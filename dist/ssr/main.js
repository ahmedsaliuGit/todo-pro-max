/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@remix-run/router/dist/router.js":
/*!*******************************************************!*\
  !*** ./node_modules/@remix-run/router/dist/router.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbortedDeferredError": () => (/* binding */ AbortedDeferredError),
/* harmony export */   "Action": () => (/* binding */ Action),
/* harmony export */   "ErrorResponse": () => (/* binding */ ErrorResponse),
/* harmony export */   "IDLE_BLOCKER": () => (/* binding */ IDLE_BLOCKER),
/* harmony export */   "IDLE_FETCHER": () => (/* binding */ IDLE_FETCHER),
/* harmony export */   "IDLE_NAVIGATION": () => (/* binding */ IDLE_NAVIGATION),
/* harmony export */   "UNSAFE_DEFERRED_SYMBOL": () => (/* binding */ UNSAFE_DEFERRED_SYMBOL),
/* harmony export */   "UNSAFE_DeferredData": () => (/* binding */ DeferredData),
/* harmony export */   "UNSAFE_convertRoutesToDataRoutes": () => (/* binding */ convertRoutesToDataRoutes),
/* harmony export */   "UNSAFE_getPathContributingMatches": () => (/* binding */ getPathContributingMatches),
/* harmony export */   "createBrowserHistory": () => (/* binding */ createBrowserHistory),
/* harmony export */   "createHashHistory": () => (/* binding */ createHashHistory),
/* harmony export */   "createMemoryHistory": () => (/* binding */ createMemoryHistory),
/* harmony export */   "createPath": () => (/* binding */ createPath),
/* harmony export */   "createRouter": () => (/* binding */ createRouter),
/* harmony export */   "createStaticHandler": () => (/* binding */ createStaticHandler),
/* harmony export */   "defer": () => (/* binding */ defer),
/* harmony export */   "generatePath": () => (/* binding */ generatePath),
/* harmony export */   "getStaticContextFromError": () => (/* binding */ getStaticContextFromError),
/* harmony export */   "getToPathname": () => (/* binding */ getToPathname),
/* harmony export */   "invariant": () => (/* binding */ invariant),
/* harmony export */   "isRouteErrorResponse": () => (/* binding */ isRouteErrorResponse),
/* harmony export */   "joinPaths": () => (/* binding */ joinPaths),
/* harmony export */   "json": () => (/* binding */ json),
/* harmony export */   "matchPath": () => (/* binding */ matchPath),
/* harmony export */   "matchRoutes": () => (/* binding */ matchRoutes),
/* harmony export */   "normalizePathname": () => (/* binding */ normalizePathname),
/* harmony export */   "parsePath": () => (/* binding */ parsePath),
/* harmony export */   "redirect": () => (/* binding */ redirect),
/* harmony export */   "resolvePath": () => (/* binding */ resolvePath),
/* harmony export */   "resolveTo": () => (/* binding */ resolveTo),
/* harmony export */   "stripBasename": () => (/* binding */ stripBasename),
/* harmony export */   "warning": () => (/* binding */ warning)
/* harmony export */ });
/**
 * @remix-run/router v1.3.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

////////////////////////////////////////////////////////////////////////////////
//#region Types and Constants
////////////////////////////////////////////////////////////////////////////////

/**
 * Actions represent the type of change to a location value.
 */
var Action;
(function (Action) {
  /**
   * A POP indicates a change to an arbitrary index in the history stack, such
   * as a back or forward navigation. It does not describe the direction of the
   * navigation, only that the current index changed.
   *
   * Note: This is the default action for newly created history objects.
   */
  Action["Pop"] = "POP";
  /**
   * A PUSH indicates a new entry being added to the history stack, such as when
   * a link is clicked and a new page loads. When this happens, all subsequent
   * entries in the stack are lost.
   */

  Action["Push"] = "PUSH";
  /**
   * A REPLACE indicates the entry at the current index in the history stack
   * being replaced by a new one.
   */

  Action["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
/**
 * Memory history stores the current location in memory. It is designed for use
 * in stateful non-browser environments like tests and React Native.
 */

function createMemoryHistory(options) {
  if (options === void 0) {
    options = {};
  }
  let {
    initialEntries = ["/"],
    initialIndex,
    v5Compat = false
  } = options;
  let entries; // Declare so we can access from createMemoryLocation

  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === "string" ? null : entry.state, index === 0 ? "default" : undefined));
  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);
  let action = Action.Pop;
  let listener = null;
  function clampIndex(n) {
    return Math.min(Math.max(n, 0), entries.length - 1);
  }
  function getCurrentLocation() {
    return entries[index];
  }
  function createMemoryLocation(to, state, key) {
    if (state === void 0) {
      state = null;
    }
    let location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key);
    warning$1(location.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(to));
    return location;
  }
  function createHref(to) {
    return typeof to === "string" ? to : createPath(to);
  }
  let history = {
    get index() {
      return index;
    },
    get action() {
      return action;
    },
    get location() {
      return getCurrentLocation();
    },
    createHref,
    createURL(to) {
      return new URL(createHref(to), "http://localhost");
    },
    encodeLocation(to) {
      let path = typeof to === "string" ? parsePath(to) : to;
      return {
        pathname: path.pathname || "",
        search: path.search || "",
        hash: path.hash || ""
      };
    },
    push(to, state) {
      action = Action.Push;
      let nextLocation = createMemoryLocation(to, state);
      index += 1;
      entries.splice(index, entries.length, nextLocation);
      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation,
          delta: 1
        });
      }
    },
    replace(to, state) {
      action = Action.Replace;
      let nextLocation = createMemoryLocation(to, state);
      entries[index] = nextLocation;
      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation,
          delta: 0
        });
      }
    },
    go(delta) {
      action = Action.Pop;
      let nextIndex = clampIndex(index + delta);
      let nextLocation = entries[nextIndex];
      index = nextIndex;
      if (listener) {
        listener({
          action,
          location: nextLocation,
          delta
        });
      }
    },
    listen(fn) {
      listener = fn;
      return () => {
        listener = null;
      };
    }
  };
  return history;
}
/**
 * Browser history stores the location in regular URLs. This is the standard for
 * most web apps, but it requires some configuration on the server to ensure you
 * serve the same app at multiple URLs.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
 */

function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window.location;
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createBrowserHref(window, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
/**
 * Hash history stores the location in window.location.hash. This makes it ideal
 * for situations where you don't want to send the location to the server for
 * some reason, either because you do cannot configure it or the URL space is
 * reserved for something else.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory
 */

function createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createHashLocation(window, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash = ""
    } = parsePath(window.location.hash.substr(1));
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createHashHref(window, to) {
    let base = window.document.querySelector("base");
    let href = "";
    if (base && base.getAttribute("href")) {
      let url = window.location.href;
      let hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href + "#" + (typeof to === "string" ? to : createPath(to));
  }
  function validateHashLocation(location, to) {
    warning$1(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
  }
  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning$1(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);
    try {
      // Welcome to debugging history!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
/**
 * For browser-based histories, we combine the state and key into an object
 */

function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
/**
 * Creates a Location object with a unique key from the given Path
 */

function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
/**
 * Creates a string URL path from the given pathname, search, and hash components.
 */

function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
/**
 * Parses a string URL path into its separate pathname, search, and hash components.
 */

function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window.history;
  let action = Action.Pop;
  let listener = null;
  let index = getIndex(); // Index should only be null when we initialize. If not, it's because the
  // user called history.pushState or history.replaceState directly, in which
  // case we should log a warning as it will result in bugs.

  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = Action.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location); // try...catch because iOS limits us to 100 pushState calls :/

    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      // They are going to lose state here, but there is no real
      // way to warn them about it since the page will refresh...
      window.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace(to, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    // window.location.origin is "null" (the literal string value) in Firefox
    // under certain conditions, notably when serving from a local HTML file
    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297
    let base = window.location.origin !== "null" ? window.location.origin : window.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window, to);
    },
    createURL,
    encodeLocation(to) {
      // Encode a Location the same way window.location would
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace,
    go(n) {
      return globalHistory.go(n);
    }
  };
  return history;
} //#endregion

var ResultType;
(function (ResultType) {
  ResultType["data"] = "data";
  ResultType["deferred"] = "deferred";
  ResultType["redirect"] = "redirect";
  ResultType["error"] = "error";
})(ResultType || (ResultType = {}));
function isIndexRoute(route) {
  return route.index === true;
} // Walk the route tree generating unique IDs where necessary so we are working
// solely with AgnosticDataRouteObject's within the Router

function convertRoutesToDataRoutes(routes, parentPath, allIds) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  if (allIds === void 0) {
    allIds = new Set();
  }
  return routes.map((route, index) => {
    let treePath = [...parentPath, index];
    let id = typeof route.id === "string" ? route.id : treePath.join("-");
    invariant(route.index !== true || !route.children, "Cannot specify children on an index route");
    invariant(!allIds.has(id), "Found a route id collision on id \"" + id + "\".  Route " + "id's must be globally unique within Data Router usages");
    allIds.add(id);
    if (isIndexRoute(route)) {
      let indexRoute = _extends({}, route, {
        id
      });
      return indexRoute;
    } else {
      let pathOrLayoutRoute = _extends({}, route, {
        id,
        children: route.children ? convertRoutesToDataRoutes(route.children, treePath, allIds) : undefined
      });
      return pathOrLayoutRoute;
    }
  });
}
/**
 * Matches the given routes to a location and returns the match data.
 *
 * @see https://reactrouter.com/utils/match-routes
 */

function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(branches[i],
    // Incoming pathnames are generally encoded from either window.location
    // or from router.navigate, but we want to match against the unencoded
    // paths in the route definitions.  Memory router locations won't be
    // encoded here but there also shouldn't be anything to decode so this
    // should be a safe operation.  This avoids needing matchRoutes to be
    // history-aware.
    safelyDecodeURI(pathname));
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === undefined ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), "Absolute route path \"" + meta.relativePath + "\" nested under path " + ("\"" + parentPath + "\" is not valid. An absolute child route path ") + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta); // Add the children before adding this route to the array so we traverse the
    // route tree depth-first and child routes appear before their parents in
    // the "flattened" version.

    if (route.children && route.children.length > 0) {
      invariant(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      route.index !== true, "Index routes must not have child routes. Please remove " + ("all child routes from route path \"" + path + "\"."));
      flattenRoutes(route.children, branches, routesMeta, path);
    } // Routes without a path shouldn't ever match by themselves unless they are
    // index routes, so don't add them to the list of possible branches.

    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    var _route$path;

    // coarse-grain check for optional params
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
/**
 * Computes all combinations of optional path segments for a given path,
 * excluding combinations that are ambiguous and of lower priority.
 *
 * For example, `/one/:two?/three/:four?/:five?` explodes to:
 * - `/one/three`
 * - `/one/:two/three`
 * - `/one/three/:four`
 * - `/one/three/:five`
 * - `/one/:two/three/:four`
 * - `/one/:two/three/:five`
 * - `/one/three/:four/:five`
 * - `/one/:two/three/:four/:five`
 */

function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments; // Optional path segments are denoted by a trailing `?`

  let isOptional = first.endsWith("?"); // Compute the corresponding required segment: `foo?` -> `foo`

  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    // Intepret empty string as omitting an optional segment
    // `["one", "", "three"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = []; // All child paths with the prefix.  Do this for all children before the
  // optional version for all children so we get consistent ordering where the
  // parent optional aspect is preferred as required.  Otherwise, we can get
  // child sections interspersed where deeper optional segments are higher than
  // parent optional segments, where for example, /:two would explodes _earlier_
  // then /:one.  By always including the parent as required _for all children_
  // first, we avoid this issue

  result.push(...restExploded.map(subpath => subpath === "" ? required : [required, subpath].join("/"))); // Then if this is an optional value, add all child versions without

  if (isOptional) {
    result.push(...restExploded);
  } // for absolute paths, ensure `/` instead of empty segment

  return result.map(exploded => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first
  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = s => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ?
  // If two routes are siblings, we should try to match the earlier sibling
  // first. This allows people to have fine-grained control over the matching
  // behavior by simply putting routes with identical paths in the order they
  // want them tried.
  a[a.length - 1] - b[b.length - 1] :
  // Otherwise, it doesn't really make sense to rank non-siblings by index,
  // so they sort equally.
  0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match) return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
/**
 * Returns a path with params interpolated.
 *
 * @see https://reactrouter.com/utils/generate-path
 */

function generatePath(originalPath, params) {
  if (params === void 0) {
    params = {};
  }
  let path = originalPath;
  if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) {
    warning(false, "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
    path = path.replace(/\*$/, "/*");
  }
  return path.replace(/^:(\w+)(\??)/g, (_, key, optional) => {
    let param = params[key];
    if (optional === "?") {
      return param == null ? "" : param;
    }
    if (param == null) {
      invariant(false, "Missing \":" + key + "\" param");
    }
    return param;
  }).replace(/\/:(\w+)(\??)/g, (_, key, optional) => {
    let param = params[key];
    if (optional === "?") {
      return param == null ? "" : "/" + param;
    }
    if (param == null) {
      invariant(false, "Missing \":" + key + "\" param");
    }
    return "/" + param;
  }) // Remove any optional markers from optional static segments
  .replace(/\?/g, "").replace(/(\/?)\*/, (_, prefix, __, str) => {
    const star = "*";
    if (params[star] == null) {
      // If no splat was provided, trim the trailing slash _unless_ it's
      // the entire path
      return str === "/*" ? "/" : "";
    } // Apply the splat

    return "" + prefix + params[star];
  });
}
/**
 * Performs pattern matching on a URL pathname and returns information about
 * the match.
 *
 * @see https://reactrouter.com/utils/match-path
 */

function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index) => {
    // We need to compute the pathnameBase here using the raw splat value
    // instead of using params["*"] later because it will be decoded then
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
  .replace(/^\/*/, "/") // Make sure it has a leading /
  .replace(/[\\.*+^$?{}|()[\]]/g, "\\$&") // Escape special regex chars
  .replace(/\/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName);
    return "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest
    : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
  } else if (end) {
    // When matching to the end, ignore trailing slashes
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    // If our path is non-empty and contains anything beyond an initial slash,
    // then we have _some_ form of path in our regex so we should expect to
    // match only if we find the end of this path segment.  Look for an optional
    // non-captured trailing slash (to match a portion of the URL) or the end
    // of the path (if we've matched to the end).  We used to do this with a
    // word boundary but that gives false positives on routes like
    // /user-preferences since `-` counts as a word boundary.
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
  return [matcher, paramNames];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error) {
    warning(false, "The URL path \"" + value + "\" could not be decoded because it is is a " + "malformed URL segment. This is probably due to a bad percent " + ("encoding (" + error + ")."));
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning(false, "The value for the URL param \"" + paramName + "\" will not be decoded because" + (" the string \"" + value + "\" is a malformed URL segment. This is probably") + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
/**
 * @private
 */

function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  } // We want to leave trailing slash behavior in the user's control, so if they
  // specify a basename with a trailing slash, we should support it

  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    // pathname does not start with basename/
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
/**
 * @private
 */

function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);
    try {
      // Welcome to debugging @remix-run/router!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}
/**
 * Returns a resolved path object relative to the given pathname.
 *
 * @see https://reactrouter.com/utils/resolve-path
 */

function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach(segment => {
    if (segment === "..") {
      // Keep the root "" segment so the pathname starts at /
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + "a string in <Link to=\"...\"> and the router will parse it for you.";
}
/**
 * @private
 *
 * When processing relative navigation we want to ignore ancestor routes that
 * do not contribute to the path, such that index/pathless layout routes don't
 * interfere.
 *
 * For example, when moving a route element into an index route and/or a
 * pathless layout route, relative link behavior contained within should stay
 * the same.  Both of the following examples should link back to the root:
 *
 *   <Route path="/">
 *     <Route path="accounts" element={<Link to=".."}>
 *   </Route>
 *
 *   <Route path="/">
 *     <Route path="accounts">
 *       <Route element={<AccountsLayout />}>       // <-- Does not contribute
 *         <Route index element={<Link to=".."} />  // <-- Does not contribute
 *       </Route
 *     </Route>
 *   </Route>
 */

function getPathContributingMatches(matches) {
  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
}
/**
 * @private
 */

function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from; // Routing is relative to the current pathname if explicitly requested.
  //
  // If a pathname is explicitly provided in `to`, it should be relative to the
  // route context. This is explained in `Note on `<Link to>` values` in our
  // migration guide from v5 as a means of disambiguation between `to` values
  // that begin with `/` and those that do not. However, this is problematic for
  // `to` values that do not provide a pathname. `to` can simply be a search or
  // hash string, in which case we should assume that the navigation is relative
  // to the current location's pathname and *not* the route pathname.

  if (isPathRelative || toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/"); // Each leading .. segment means "go up one route" instead of "go up one
      // URL segment".  This is a key difference from how <a href> works and a
      // major reason we call this a "to" value instead of a "href".

      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    } // If there are more ".." segments than parent routes, resolve relative to
    // the root / URL.

    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from); // Ensure the pathname has a trailing slash if the original "to" had one

  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/"); // Or if this was a link to the current path which has a trailing slash

  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
/**
 * @private
 */

function getToPathname(to) {
  // Empty strings should be treated the same as / paths
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? parsePath(to).pathname : to.pathname;
}
/**
 * @private
 */

const joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");
/**
 * @private
 */

const normalizePathname = pathname => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
/**
 * @private
 */

const normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
/**
 * @private
 */

const normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
/**
 * This is a shortcut for creating `application/json` responses. Converts `data`
 * to JSON and sets the `Content-Type` header.
 */

const json = function json(data, init) {
  if (init === void 0) {
    init = {};
  }
  let responseInit = typeof init === "number" ? {
    status: init
  } : init;
  let headers = new Headers(responseInit.headers);
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json; charset=utf-8");
  }
  return new Response(JSON.stringify(data), _extends({}, responseInit, {
    headers
  }));
};
class AbortedDeferredError extends Error {}
class DeferredData {
  constructor(data, responseInit) {
    this.pendingKeysSet = new Set();
    this.subscribers = new Set();
    this.deferredKeys = [];
    invariant(data && typeof data === "object" && !Array.isArray(data), "defer() only accepts plain objects"); // Set up an AbortController + Promise we can race against to exit early
    // cancellation

    let reject;
    this.abortPromise = new Promise((_, r) => reject = r);
    this.controller = new AbortController();
    let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));
    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort);
    this.controller.signal.addEventListener("abort", onAbort);
    this.data = Object.entries(data).reduce((acc, _ref) => {
      let [key, value] = _ref;
      return Object.assign(acc, {
        [key]: this.trackPromise(key, value)
      });
    }, {});
    if (this.done) {
      // All incoming values were resolved
      this.unlistenAbortSignal();
    }
    this.init = responseInit;
  }
  trackPromise(key, value) {
    if (!(value instanceof Promise)) {
      return value;
    }
    this.deferredKeys.push(key);
    this.pendingKeysSet.add(key); // We store a little wrapper promise that will be extended with
    // _data/_error props upon resolve/reject

    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, null, data), error => this.onSettle(promise, key, error)); // Register rejection listeners to avoid uncaught promise rejections on
    // errors or aborted deferred values

    promise.catch(() => {});
    Object.defineProperty(promise, "_tracked", {
      get: () => true
    });
    return promise;
  }
  onSettle(promise, key, error, data) {
    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {
      this.unlistenAbortSignal();
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      return Promise.reject(error);
    }
    this.pendingKeysSet.delete(key);
    if (this.done) {
      // Nothing left to abort!
      this.unlistenAbortSignal();
    }
    if (error) {
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      this.emit(false, key);
      return Promise.reject(error);
    }
    Object.defineProperty(promise, "_data", {
      get: () => data
    });
    this.emit(false, key);
    return data;
  }
  emit(aborted, settledKey) {
    this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));
  }
  subscribe(fn) {
    this.subscribers.add(fn);
    return () => this.subscribers.delete(fn);
  }
  cancel() {
    this.controller.abort();
    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));
    this.emit(true);
  }
  async resolveData(signal) {
    let aborted = false;
    if (!this.done) {
      let onAbort = () => this.cancel();
      signal.addEventListener("abort", onAbort);
      aborted = await new Promise(resolve => {
        this.subscribe(aborted => {
          signal.removeEventListener("abort", onAbort);
          if (aborted || this.done) {
            resolve(aborted);
          }
        });
      });
    }
    return aborted;
  }
  get done() {
    return this.pendingKeysSet.size === 0;
  }
  get unwrappedData() {
    invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds");
    return Object.entries(this.data).reduce((acc, _ref2) => {
      let [key, value] = _ref2;
      return Object.assign(acc, {
        [key]: unwrapTrackedPromise(value)
      });
    }, {});
  }
  get pendingKeys() {
    return Array.from(this.pendingKeysSet);
  }
}
function isTrackedPromise(value) {
  return value instanceof Promise && value._tracked === true;
}
function unwrapTrackedPromise(value) {
  if (!isTrackedPromise(value)) {
    return value;
  }
  if (value._error) {
    throw value._error;
  }
  return value._data;
}
const defer = function defer(data, init) {
  if (init === void 0) {
    init = {};
  }
  let responseInit = typeof init === "number" ? {
    status: init
  } : init;
  return new DeferredData(data, responseInit);
};
/**
 * A redirect response. Sets the status code and the `Location` header.
 * Defaults to "302 Found".
 */

const redirect = function redirect(url, init) {
  if (init === void 0) {
    init = 302;
  }
  let responseInit = init;
  if (typeof responseInit === "number") {
    responseInit = {
      status: responseInit
    };
  } else if (typeof responseInit.status === "undefined") {
    responseInit.status = 302;
  }
  let headers = new Headers(responseInit.headers);
  headers.set("Location", url);
  return new Response(null, _extends({}, responseInit, {
    headers
  }));
};
/**
 * @private
 * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies
 */

class ErrorResponse {
  constructor(status, statusText, data, internal) {
    if (internal === void 0) {
      internal = false;
    }
    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;
    if (data instanceof Error) {
      this.data = data.toString();
      this.error = data;
    } else {
      this.data = data;
    }
  }
}
/**
 * Check if the given error is an ErrorResponse generated from a 4xx/5xx
 * Response thrown from an action/loader
 */

function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
const validMutationMethods = new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
const validRequestMethods = new Set(validRequestMethodsArr);
const redirectStatusCodes = new Set([301, 302, 303, 307, 308]);
const redirectPreserveMethodStatusCodes = new Set([307, 308]);
const IDLE_NAVIGATION = {
  state: "idle",
  location: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined
};
const IDLE_FETCHER = {
  state: "idle",
  data: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined
};
const IDLE_BLOCKER = {
  state: "unblocked",
  proceed: undefined,
  reset: undefined,
  location: undefined
};
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const isServer = !isBrowser; //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region createRouter
////////////////////////////////////////////////////////////////////////////////

/**
 * Create a router and listen to history POP navigations
 */

function createRouter(init) {
  invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let dataRoutes = convertRoutesToDataRoutes(init.routes); // Cleanup function for history

  let unlistenHistory = null; // Externally-provided functions to call on all state changes

  let subscribers = new Set(); // Externally-provided object to hold scroll restoration locations during routing

  let savedScrollPositions = null; // Externally-provided function to get scroll restoration keys

  let getScrollRestorationKey = null; // Externally-provided function to get current scroll position

  let getScrollPosition = null; // One-time flag to control the initial hydration scroll restoration.  Because
  // we don't get the saved positions from <ScrollRestoration /> until _after_
  // the initial render, we need to manually trigger a separate updateState to
  // send along the restoreScrollPosition
  // Set to true if we have `hydrationData` since we assume we were SSR'd and that
  // SSR did the initial scroll restoration.

  let initialScrollRestored = init.hydrationData != null;
  let initialMatches = matchRoutes(dataRoutes, init.history.location, init.basename);
  let initialErrors = null;
  if (initialMatches == null) {
    // If we do not match a user-provided-route, fall back to the root
    // to allow the error boundary to take over
    let error = getInternalRouterError(404, {
      pathname: init.history.location.pathname
    });
    let {
      matches,
      route
    } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches;
    initialErrors = {
      [route.id]: error
    };
  }
  let initialized = !initialMatches.some(m => m.route.loader) || init.hydrationData != null;
  let router;
  let state = {
    historyAction: init.history.action,
    location: init.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init.hydrationData != null ? false : null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: init.hydrationData && init.hydrationData.loaderData || {},
    actionData: init.hydrationData && init.hydrationData.actionData || null,
    errors: init.hydrationData && init.hydrationData.errors || initialErrors,
    fetchers: new Map(),
    blockers: new Map()
  }; // -- Stateful internal variables to manage navigations --
  // Current navigation in progress (to be committed in completeNavigation)

  let pendingAction = Action.Pop; // Should the current navigation prevent the scroll reset if scroll cannot
  // be restored?

  let pendingPreventScrollReset = false; // AbortController for the active navigation

  let pendingNavigationController; // We use this to avoid touching history in completeNavigation if a
  // revalidation is entirely uninterrupted

  let isUninterruptedRevalidation = false; // Use this internal flag to force revalidation of all loaders:
  //  - submissions (completed or interrupted)
  //  - useRevalidate()
  //  - X-Remix-Revalidate (from redirect)

  let isRevalidationRequired = false; // Use this internal array to capture routes that require revalidation due
  // to a cancelled deferred on action submission

  let cancelledDeferredRoutes = []; // Use this internal array to capture fetcher loads that were cancelled by an
  // action navigation and require revalidation

  let cancelledFetcherLoads = []; // AbortControllers for any in-flight fetchers

  let fetchControllers = new Map(); // Track loads based on the order in which they started

  let incrementingLoadId = 0; // Track the outstanding pending navigation data load to be compared against
  // the globally incrementing load when a fetcher load lands after a completed
  // navigation

  let pendingNavigationLoadId = -1; // Fetchers that triggered data reloads as a result of their actions

  let fetchReloadIds = new Map(); // Fetchers that triggered redirect navigations from their actions

  let fetchRedirectIds = new Set(); // Most recent href/match for fetcher.load calls for fetchers

  let fetchLoadMatches = new Map(); // Store DeferredData instances for active route matches.  When a
  // route loader returns defer() we stick one in here.  Then, when a nested
  // promise resolves we update loaderData.  If a new navigation starts we
  // cancel active deferreds for eliminated routes.

  let activeDeferreds = new Map(); // Store blocker functions in a separate Map outside of router state since
  // we don't need to update UI state if they change

  let blockerFunctions = new Map(); // Flag to ignore the next history update, so we can revert the URL change on
  // a POP navigation that was blocked by the user without touching router state

  let ignoreNextHistoryUpdate = false; // Initialize the router, all side effects should be kicked off from here.
  // Implemented as a Fluent API for ease of:
  //   let router = createRouter(init).initialize();

  function initialize() {
    // If history informs us of a POP navigation, start the navigation but do not update
    // state.  We'll update our own state once the navigation completes
    unlistenHistory = init.history.listen(_ref => {
      let {
        action: historyAction,
        location,
        delta
      } = _ref;

      // Ignore this event if it was just us resetting the URL from a
      // blocked POP navigation
      if (ignoreNextHistoryUpdate) {
        ignoreNextHistoryUpdate = false;
        return;
      }
      warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location " + "that was not created by @remix-run/router. This will fail silently in " + "production. This can happen if you are navigating outside the router " + "via `window.history.pushState`/`window.location.hash` instead of using " + "router navigation APIs.  This can also happen if you are using " + "createHashRouter and the user manually changes the URL.");
      let blockerKey = shouldBlockNavigation({
        currentLocation: state.location,
        nextLocation: location,
        historyAction
      });
      if (blockerKey && delta != null) {
        // Restore the URL to match the current UI, but don't update router state
        ignoreNextHistoryUpdate = true;
        init.history.go(delta * -1); // Put the blocker into a blocked state

        updateBlocker(blockerKey, {
          state: "blocked",
          location,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: undefined,
              reset: undefined,
              location
            }); // Re-do the same POP navigation we just blocked

            init.history.go(delta);
          },
          reset() {
            deleteBlocker(blockerKey);
            updateState({
              blockers: new Map(router.state.blockers)
            });
          }
        });
        return;
      }
      return startNavigation(historyAction, location);
    }); // Kick off initial data load if needed.  Use Pop to avoid modifying history

    if (!state.initialized) {
      startNavigation(Action.Pop, state.location);
    }
    return router;
  } // Clean up a router and it's side effects

  function dispose() {
    if (unlistenHistory) {
      unlistenHistory();
    }
    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_, key) => deleteFetcher(key));
    state.blockers.forEach((_, key) => deleteBlocker(key));
  } // Subscribe to state updates for the router

  function subscribe(fn) {
    subscribers.add(fn);
    return () => subscribers.delete(fn);
  } // Update our state and notify the calling context of the change

  function updateState(newState) {
    state = _extends({}, state, newState);
    subscribers.forEach(subscriber => subscriber(state));
  } // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION
  // and setting state.[historyAction/location/matches] to the new route.
  // - Location is a required param
  // - Navigation will always be set to IDLE_NAVIGATION
  // - Can pass any other state in newState

  function completeNavigation(location, newState) {
    var _location$state, _location$state2;

    // Deduce if we're in a loading/actionReload state:
    // - We have committed actionData in the store
    // - The current navigation was a mutation submission
    // - We're past the submitting state and into the loading state
    // - The location being loaded is not the result of a redirect
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;
    let actionData;
    if (newState.actionData) {
      if (Object.keys(newState.actionData).length > 0) {
        actionData = newState.actionData;
      } else {
        // Empty actionData -> clear prior actionData due to an action error
        actionData = null;
      }
    } else if (isActionReload) {
      // Keep the current data if we're wrapping up the action reload
      actionData = state.actionData;
    } else {
      // Clear actionData on any other completed navigations
      actionData = null;
    } // Always preserve any existing loaderData from re-used routes

    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData; // On a successful navigation we can assume we got through all blockers
    // so we can start fresh

    for (let [key] of blockerFunctions) {
      deleteBlocker(key);
    } // Always respect the user flag.  Otherwise don't reset on mutation
    // submission navigations unless they redirect

    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;
    updateState(_extends({}, newState, {
      actionData,
      loaderData,
      historyAction: pendingAction,
      location,
      initialized: true,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
      preventScrollReset,
      blockers: new Map(state.blockers)
    }));
    if (isUninterruptedRevalidation) ;else if (pendingAction === Action.Pop) ;else if (pendingAction === Action.Push) {
      init.history.push(location, location.state);
    } else if (pendingAction === Action.Replace) {
      init.history.replace(location, location.state);
    } // Reset stateful navigation vars

    pendingAction = Action.Pop;
    pendingPreventScrollReset = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    cancelledDeferredRoutes = [];
    cancelledFetcherLoads = [];
  } // Trigger a navigation event, which can either be a numerical POP or a PUSH
  // replace with an optional submission

  async function navigate(to, opts) {
    if (typeof to === "number") {
      init.history.go(to);
      return;
    }
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(to, opts);
    let currentLocation = state.location;
    let nextLocation = createLocation(state.location, path, opts && opts.state); // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded
    // URL from window.location, so we need to encode it here so the behavior
    // remains the same as POP and non-data-router usages.  new URL() does all
    // the same encoding we'd get from a history.pushState/window.location read
    // without having to touch history

    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));
    let userReplace = opts && opts.replace != null ? opts.replace : undefined;
    let historyAction = Action.Push;
    if (userReplace === true) {
      historyAction = Action.Replace;
    } else if (userReplace === false) ;else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
      // By default on submissions to the current location we REPLACE so that
      // users don't have to double-click the back button to get to the prior
      // location.  If the user redirects to a different location from the
      // action/loader this will be ignored and the redirect will be a PUSH
      historyAction = Action.Replace;
    }
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : undefined;
    let blockerKey = shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    });
    if (blockerKey) {
      // Put the blocker into a blocked state
      updateBlocker(blockerKey, {
        state: "blocked",
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, {
            state: "proceeding",
            proceed: undefined,
            reset: undefined,
            location: nextLocation
          }); // Send the same navigation through

          navigate(to, opts);
        },
        reset() {
          deleteBlocker(blockerKey);
          updateState({
            blockers: new Map(state.blockers)
          });
        }
      });
      return;
    }
    return await startNavigation(historyAction, nextLocation, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace
    });
  } // Revalidate all current loaders.  If a navigation is in progress or if this
  // is interrupted by a navigation, allow this to "succeed" by calling all
  // loaders during the next loader round

  function revalidate() {
    interruptActiveLoads();
    updateState({
      revalidation: "loading"
    }); // If we're currently submitting an action, we don't need to start a new
    // navigation, we'll just let the follow up loader execution call all loaders

    if (state.navigation.state === "submitting") {
      return;
    } // If we're currently in an idle state, start a new navigation for the current
    // action/location and mark it as uninterrupted, which will skip the history
    // update in completeNavigation

    if (state.navigation.state === "idle") {
      startNavigation(state.historyAction, state.location, {
        startUninterruptedRevalidation: true
      });
      return;
    } // Otherwise, if we're currently in a loading state, just start a new
    // navigation to the navigation.location but do not trigger an uninterrupted
    // revalidation so that history correctly updates once the navigation completes

    startNavigation(pendingAction || state.historyAction, state.navigation.location, {
      overrideNavigation: state.navigation
    });
  } // Start a navigation to the given action/location.  Can optionally provide a
  // overrideNavigation which will override the normalLoad in the case of a redirect
  // navigation

  async function startNavigation(historyAction, location, opts) {
    // Abort any in-progress navigations and start a new one. Unset any ongoing
    // uninterrupted revalidations unless told otherwise, since we want this
    // new navigation to update history normally
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true; // Save the current scroll position every time we start a new navigation,
    // and track whether we should reset scroll on completion

    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    let loadingNavigation = opts && opts.overrideNavigation;
    let matches = matchRoutes(dataRoutes, location, init.basename); // Short circuit with a 404 on the root error boundary if we match nothing

    if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(dataRoutes); // Cancel all pending deferred on 404s since we don't keep any routes

      cancelActiveDeferreds();
      completeNavigation(location, {
        matches: notFoundMatches,
        loaderData: {},
        errors: {
          [route.id]: error
        }
      });
      return;
    } // Short circuit if it's only a hash change and not a mutation submission
    // For example, on /page#hash and submit a <Form method="post"> which will
    // default to a navigation to /page

    if (isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
      completeNavigation(location, {
        matches
      });
      return;
    } // Create a controller/Request for this navigation

    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);
    let pendingActionData;
    let pendingError;
    if (opts && opts.pendingError) {
      // If we have a pendingError, it means the user attempted a GET submission
      // with binary FormData so assign here and skip to handleLoaders.  That
      // way we handle calling loaders above the boundary etc.  It's not really
      // different from an actionError in that sense.
      pendingError = {
        [findNearestBoundary(matches).route.id]: opts.pendingError
      };
    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      // Call action if we received an action submission
      let actionOutput = await handleAction(request, location, opts.submission, matches, {
        replace: opts.replace
      });
      if (actionOutput.shortCircuited) {
        return;
      }
      pendingActionData = actionOutput.pendingActionData;
      pendingError = actionOutput.pendingActionError;
      let navigation = _extends({
        state: "loading",
        location
      }, opts.submission);
      loadingNavigation = navigation; // Create a GET request for the loaders

      request = new Request(request.url, {
        signal: request.signal
      });
    } // Call loaders

    let {
      shortCircuited,
      loaderData,
      errors
    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.replace, pendingActionData, pendingError);
    if (shortCircuited) {
      return;
    } // Clean up now that the action/loaders have completed.  Don't clean up if
    // we short circuited because pendingNavigationController will have already
    // been assigned to a new controller for the next navigation

    pendingNavigationController = null;
    completeNavigation(location, _extends({
      matches
    }, pendingActionData ? {
      actionData: pendingActionData
    } : {}, {
      loaderData,
      errors
    }));
  } // Call the action matched by the leaf route for this navigation and handle
  // redirects/errors

  async function handleAction(request, location, submission, matches, opts) {
    interruptActiveLoads(); // Put us in a submitting state

    let navigation = _extends({
      state: "submitting",
      location
    }, submission);
    updateState({
      navigation
    }); // Call our action and get the result

    let result;
    let actionMatch = getTargetMatch(matches, location);
    if (!actionMatch.route.action) {
      result = {
        type: ResultType.error,
        error: getInternalRouterError(405, {
          method: request.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id
        })
      };
    } else {
      result = await callLoaderOrAction("action", request, actionMatch, matches, router.basename);
      if (request.signal.aborted) {
        return {
          shortCircuited: true
        };
      }
    }
    if (isRedirectResult(result)) {
      let replace;
      if (opts && opts.replace != null) {
        replace = opts.replace;
      } else {
        // If the user didn't explicity indicate replace behavior, replace if
        // we redirected to the exact same location we're currently at to avoid
        // double back-buttons
        replace = result.location === state.location.pathname + state.location.search;
      }
      await startRedirectNavigation(state, result, {
        submission,
        replace
      });
      return {
        shortCircuited: true
      };
    }
    if (isErrorResult(result)) {
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id); // By default, all submissions are REPLACE navigations, but if the
      // action threw an error that'll be rendered in an errorElement, we fall
      // back to PUSH so that the user can use the back button to get back to
      // the pre-submission form location to try again

      if ((opts && opts.replace) !== true) {
        pendingAction = Action.Push;
      }
      return {
        // Send back an empty object we can use to clear out any prior actionData
        pendingActionData: {},
        pendingActionError: {
          [boundaryMatch.route.id]: result.error
        }
      };
    }
    if (isDeferredResult(result)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    return {
      pendingActionData: {
        [actionMatch.route.id]: result.data
      }
    };
  } // Call all applicable loaders for the given matches, handling redirects,
  // errors, etc.

  async function handleLoaders(request, location, matches, overrideNavigation, submission, replace, pendingActionData, pendingError) {
    // Figure out the right navigation we want to use for data loading
    let loadingNavigation = overrideNavigation;
    if (!loadingNavigation) {
      let navigation = _extends({
        state: "loading",
        location,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined
      }, submission);
      loadingNavigation = navigation;
    } // If this was a redirect from an action we don't have a "submission" but
    // we have it on the loading navigation so use that if available

    let activeSubmission = submission ? submission : loadingNavigation.formMethod && loadingNavigation.formAction && loadingNavigation.formData && loadingNavigation.formEncType ? {
      formMethod: loadingNavigation.formMethod,
      formAction: loadingNavigation.formAction,
      formData: loadingNavigation.formData,
      formEncType: loadingNavigation.formEncType
    } : undefined;
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, pendingActionData, pendingError, fetchLoadMatches); // Cancel pending deferreds for no-longer-matched routes or routes we're
    // about to reload.  Note that if this is an action reload we would have
    // already cancelled all pending deferreds so this would be a no-op

    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId)); // Short circuit if we have no loaders to run

    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      completeNavigation(location, _extends({
        matches,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: pendingError || null
      }, pendingActionData ? {
        actionData: pendingActionData
      } : {}));
      return {
        shortCircuited: true
      };
    } // If this is an uninterrupted revalidation, we remain in our current idle
    // state.  If not, we need to switch to our loading state and load data,
    // preserving any new action data or existing action data (in the case of
    // a revalidation interrupting an actionReload)

    if (!isUninterruptedRevalidation) {
      revalidatingFetchers.forEach(rf => {
        let fetcher = state.fetchers.get(rf.key);
        let revalidatingFetcher = {
          state: "loading",
          data: fetcher && fetcher.data,
          formMethod: undefined,
          formAction: undefined,
          formEncType: undefined,
          formData: undefined,
          " _hasFetcherDoneAnything ": true
        };
        state.fetchers.set(rf.key, revalidatingFetcher);
      });
      let actionData = pendingActionData || state.actionData;
      updateState(_extends({
        navigation: loadingNavigation
      }, actionData ? Object.keys(actionData).length === 0 ? {
        actionData: null
      } : {
        actionData
      } : {}, revalidatingFetchers.length > 0 ? {
        fetchers: new Map(state.fetchers)
      } : {}));
    }
    pendingNavigationLoadId = ++incrementingLoadId;
    revalidatingFetchers.forEach(rf => fetchControllers.set(rf.key, pendingNavigationController));
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);
    if (request.signal.aborted) {
      return {
        shortCircuited: true
      };
    } // Clean up _after_ loaders have completed.  Don't clean up if we short
    // circuited because fetchControllers would have been aborted and
    // reassigned to new controllers for the next navigation

    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key)); // If any loaders returned a redirect Response, start a new REPLACE navigation

    let redirect = findRedirect(results);
    if (redirect) {
      await startRedirectNavigation(state, redirect, {
        replace
      });
      return {
        shortCircuited: true
      };
    } // Process and commit output from loaders

    let {
      loaderData,
      errors
    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds); // Wire up subscribers to update loaderData as promises settle

    activeDeferreds.forEach((deferredData, routeId) => {
      deferredData.subscribe(aborted => {
        // Note: No need to updateState here since the TrackedPromise on
        // loaderData is stable across resolve/reject
        // Remove this instance if we were aborted or if promises have settled
        if (aborted || deferredData.done) {
          activeDeferreds.delete(routeId);
        }
      });
    });
    markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    return _extends({
      loaderData,
      errors
    }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {
      fetchers: new Map(state.fetchers)
    } : {});
  }
  function getFetcher(key) {
    return state.fetchers.get(key) || IDLE_FETCHER;
  } // Trigger a fetcher load/submit for the given fetcher key

  function fetch(key, routeId, href, opts) {
    if (isServer) {
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. " + "You are likely calling a useFetcher() method in the body of your component. " + "Try moving it to a useEffect or a callback.");
    }
    if (fetchControllers.has(key)) abortFetcher(key);
    let matches = matchRoutes(dataRoutes, href, init.basename);
    if (!matches) {
      setFetcherError(key, routeId, getInternalRouterError(404, {
        pathname: href
      }));
      return;
    }
    let {
      path,
      submission
    } = normalizeNavigateOptions(href, opts, true);
    let match = getTargetMatch(matches, path);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    if (submission && isMutationMethod(submission.formMethod)) {
      handleFetcherAction(key, routeId, path, match, matches, submission);
      return;
    } // Store off the match so we can call it's shouldRevalidate on subsequent
    // revalidations

    fetchLoadMatches.set(key, {
      routeId,
      path,
      match,
      matches
    });
    handleFetcherLoader(key, routeId, path, match, matches, submission);
  } // Call the action for the matched fetcher.submit(), and then handle redirects,
  // errors, and revalidation

  async function handleFetcherAction(key, routeId, path, match, requestMatches, submission) {
    interruptActiveLoads();
    fetchLoadMatches.delete(key);
    if (!match.route.action) {
      let error = getInternalRouterError(405, {
        method: submission.formMethod,
        pathname: path,
        routeId: routeId
      });
      setFetcherError(key, routeId, error);
      return;
    } // Put this fetcher into it's submitting state

    let existingFetcher = state.fetchers.get(key);
    let fetcher = _extends({
      state: "submitting"
    }, submission, {
      data: existingFetcher && existingFetcher.data,
      " _hasFetcherDoneAnything ": true
    });
    state.fetchers.set(key, fetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    }); // Call the action for the fetcher

    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);
    fetchControllers.set(key, abortController);
    let actionResult = await callLoaderOrAction("action", fetchRequest, match, requestMatches, router.basename);
    if (fetchRequest.signal.aborted) {
      // We can delete this so long as we weren't aborted by ou our own fetcher
      // re-submit which would have put _new_ controller is in fetchControllers
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      return;
    }
    if (isRedirectResult(actionResult)) {
      fetchControllers.delete(key);
      fetchRedirectIds.add(key);
      let loadingFetcher = _extends({
        state: "loading"
      }, submission, {
        data: undefined,
        " _hasFetcherDoneAnything ": true
      });
      state.fetchers.set(key, loadingFetcher);
      updateState({
        fetchers: new Map(state.fetchers)
      });
      return startRedirectNavigation(state, actionResult, {
        isFetchActionRedirect: true
      });
    } // Process any non-redirect errors thrown

    if (isErrorResult(actionResult)) {
      setFetcherError(key, routeId, actionResult.error);
      return;
    }
    if (isDeferredResult(actionResult)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    } // Start the data load for current matches, or the next location if we're
    // in the middle of a navigation

    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);
    let matches = state.navigation.state !== "idle" ? matchRoutes(dataRoutes, state.navigation.location, init.basename) : state.matches;
    invariant(matches, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let loadFetcher = _extends({
      state: "loading",
      data: actionResult.data
    }, submission, {
      " _hasFetcherDoneAnything ": true
    });
    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, {
      [match.route.id]: actionResult.data
    }, undefined,
    // No need to send through errors since we short circuit above
    fetchLoadMatches); // Put all revalidating fetchers into the loading state, except for the
    // current fetcher which we want to keep in it's current loading state which
    // contains it's action submission info + action data

    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {
      let staleKey = rf.key;
      let existingFetcher = state.fetchers.get(staleKey);
      let revalidatingFetcher = {
        state: "loading",
        data: existingFetcher && existingFetcher.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true
      };
      state.fetchers.set(staleKey, revalidatingFetcher);
      fetchControllers.set(staleKey, abortController);
    });
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
    if (abortController.signal.aborted) {
      return;
    }
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));
    let redirect = findRedirect(results);
    if (redirect) {
      return startRedirectNavigation(state, redirect);
    } // Process and commit output from loaders

    let {
      loaderData,
      errors
    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);
    let doneFetcher = {
      state: "idle",
      data: actionResult.data,
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      " _hasFetcherDoneAnything ": true
    };
    state.fetchers.set(key, doneFetcher);
    let didAbortFetchLoads = abortStaleFetchLoads(loadId); // If we are currently in a navigation loading state and this fetcher is
    // more recent than the navigation, we want the newer data so abort the
    // navigation and complete it with the fetcher data

    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
      invariant(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();
      completeNavigation(state.navigation.location, {
        matches,
        loaderData,
        errors,
        fetchers: new Map(state.fetchers)
      });
    } else {
      // otherwise just update with the fetcher data, preserving any existing
      // loaderData for loaders that did not need to reload.  We have to
      // manually merge here since we aren't going through completeNavigation
      updateState(_extends({
        errors,
        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors)
      }, didAbortFetchLoads ? {
        fetchers: new Map(state.fetchers)
      } : {}));
      isRevalidationRequired = false;
    }
  } // Call the matched loader for fetcher.load(), handling redirects, errors, etc.

  async function handleFetcherLoader(key, routeId, path, match, matches, submission) {
    let existingFetcher = state.fetchers.get(key); // Put this fetcher into it's loading state

    let loadingFetcher = _extends({
      state: "loading",
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined
    }, submission, {
      data: existingFetcher && existingFetcher.data,
      " _hasFetcherDoneAnything ": true
    });
    state.fetchers.set(key, loadingFetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    }); // Call the loader for this fetcher route match

    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);
    fetchControllers.set(key, abortController);
    let result = await callLoaderOrAction("loader", fetchRequest, match, matches, router.basename); // Deferred isn't supported for fetcher loads, await everything and treat it
    // as a normal load.  resolveDeferredData will return undefined if this
    // fetcher gets aborted, so we just leave result untouched and short circuit
    // below if that happens

    if (isDeferredResult(result)) {
      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;
    } // We can delete this so long as we weren't aborted by ou our own fetcher
    // re-load which would have put _new_ controller is in fetchControllers

    if (fetchControllers.get(key) === abortController) {
      fetchControllers.delete(key);
    }
    if (fetchRequest.signal.aborted) {
      return;
    } // If the loader threw a redirect Response, start a new REPLACE navigation

    if (isRedirectResult(result)) {
      await startRedirectNavigation(state, result);
      return;
    } // Process any non-redirect errors thrown

    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, routeId);
      state.fetchers.delete(key); // TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -
      // do we need to behave any differently with our non-redirect errors?
      // What if it was a non-redirect Response?

      updateState({
        fetchers: new Map(state.fetchers),
        errors: {
          [boundaryMatch.route.id]: result.error
        }
      });
      return;
    }
    invariant(!isDeferredResult(result), "Unhandled fetcher deferred data"); // Put the fetcher back into an idle state

    let doneFetcher = {
      state: "idle",
      data: result.data,
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      " _hasFetcherDoneAnything ": true
    };
    state.fetchers.set(key, doneFetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    });
  }
  /**
   * Utility function to handle redirects returned from an action or loader.
   * Normally, a redirect "replaces" the navigation that triggered it.  So, for
   * example:
   *
   *  - user is on /a
   *  - user clicks a link to /b
   *  - loader for /b redirects to /c
   *
   * In a non-JS app the browser would track the in-flight navigation to /b and
   * then replace it with /c when it encountered the redirect response.  In
   * the end it would only ever update the URL bar with /c.
   *
   * In client-side routing using pushState/replaceState, we aim to emulate
   * this behavior and we also do not update history until the end of the
   * navigation (including processed redirects).  This means that we never
   * actually touch history until we've processed redirects, so we just use
   * the history action from the original navigation (PUSH or REPLACE).
   */

  async function startRedirectNavigation(state, redirect, _temp) {
    var _window;
    let {
      submission,
      replace,
      isFetchActionRedirect
    } = _temp === void 0 ? {} : _temp;
    if (redirect.revalidate) {
      isRevalidationRequired = true;
    }
    let redirectLocation = createLocation(state.location, redirect.location,
    // TODO: This can be removed once we get rid of useTransition in Remix v2
    _extends({
      _isRedirect: true
    }, isFetchActionRedirect ? {
      _isFetchActionRedirect: true
    } : {}));
    invariant(redirectLocation, "Expected a location on the redirect navigation"); // Check if this an absolute external redirect that goes to a new origin

    if (ABSOLUTE_URL_REGEX.test(redirect.location) && isBrowser && typeof ((_window = window) == null ? void 0 : _window.location) !== "undefined") {
      let newOrigin = init.history.createURL(redirect.location).origin;
      if (window.location.origin !== newOrigin) {
        if (replace) {
          window.location.replace(redirect.location);
        } else {
          window.location.assign(redirect.location);
        }
        return;
      }
    } // There's no need to abort on redirects, since we don't detect the
    // redirect until the action/loaders have settled

    pendingNavigationController = null;
    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push; // Use the incoming submission if provided, fallback on the active one in
    // state.navigation

    let {
      formMethod,
      formAction,
      formEncType,
      formData
    } = state.navigation;
    if (!submission && formMethod && formAction && formData && formEncType) {
      submission = {
        formMethod,
        formAction,
        formEncType,
        formData
      };
    } // If this was a 307/308 submission we want to preserve the HTTP method and
    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the
    // redirected location

    if (redirectPreserveMethodStatusCodes.has(redirect.status) && submission && isMutationMethod(submission.formMethod)) {
      await startNavigation(redirectHistoryAction, redirectLocation, {
        submission: _extends({}, submission, {
          formAction: redirect.location
        }),
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    } else {
      // Otherwise, we kick off a new loading navigation, preserving the
      // submission info for the duration of this navigation
      await startNavigation(redirectHistoryAction, redirectLocation, {
        overrideNavigation: {
          state: "loading",
          location: redirectLocation,
          formMethod: submission ? submission.formMethod : undefined,
          formAction: submission ? submission.formAction : undefined,
          formEncType: submission ? submission.formEncType : undefined,
          formData: submission ? submission.formData : undefined
        },
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    }
  }
  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {
    // Call all navigation loaders and revalidating fetcher loaders in parallel,
    // then slice off the results into separate arrays so we can handle them
    // accordingly
    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, router.basename)), ...fetchersToLoad.map(f => callLoaderOrAction("loader", createClientSideRequest(init.history, f.path, request.signal), f.match, f.matches, router.basename))]);
    let loaderResults = results.slice(0, matchesToLoad.length);
    let fetcherResults = results.slice(matchesToLoad.length);
    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, request.signal, false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(f => f.match), fetcherResults, request.signal, true)]);
    return {
      results,
      loaderResults,
      fetcherResults
    };
  }
  function interruptActiveLoads() {
    // Every interruption triggers a revalidation
    isRevalidationRequired = true; // Cancel pending route-level deferreds and mark cancelled routes for
    // revalidation

    cancelledDeferredRoutes.push(...cancelActiveDeferreds()); // Abort in-flight fetcher loads

    fetchLoadMatches.forEach((_, key) => {
      if (fetchControllers.has(key)) {
        cancelledFetcherLoads.push(key);
        abortFetcher(key);
      }
    });
  }
  function setFetcherError(key, routeId, error) {
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState({
      errors: {
        [boundaryMatch.route.id]: error
      },
      fetchers: new Map(state.fetchers)
    });
  }
  function deleteFetcher(key) {
    if (fetchControllers.has(key)) abortFetcher(key);
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    state.fetchers.delete(key);
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant(controller, "Expected fetch controller: " + key);
    controller.abort();
    fetchControllers.delete(key);
  }
  function markFetchersDone(keys) {
    for (let key of keys) {
      let fetcher = getFetcher(key);
      let doneFetcher = {
        state: "idle",
        data: fetcher.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true
      };
      state.fetchers.set(key, doneFetcher);
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [];
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant(fetcher, "Expected fetcher: " + key);
      if (fetcher.state === "loading") {
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
      }
    }
    markFetchersDone(doneKeys);
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds) {
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, "Expected fetcher: " + key);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
  }
  function getBlocker(key, fn) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    if (blockerFunctions.get(key) !== fn) {
      blockerFunctions.set(key, fn);
    }
    return blocker;
  }
  function deleteBlocker(key) {
    state.blockers.delete(key);
    blockerFunctions.delete(key);
  } // Utility function to update blockers, ensuring valid state transitions

  function updateBlocker(key, newBlocker) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER; // Poor mans state machine :)
    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM

    invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
    state.blockers.set(key, newBlocker);
    updateState({
      blockers: new Map(state.blockers)
    });
  }
  function shouldBlockNavigation(_ref2) {
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = _ref2;
    if (blockerFunctions.size === 0) {
      return;
    } // We ony support a single active blocker at the moment since we don't have
    // any compelling use cases for multi-blocker yet

    if (blockerFunctions.size > 1) {
      warning(false, "A router only supports one blocker at a time");
    }
    let entries = Array.from(blockerFunctions.entries());
    let [blockerKey, blockerFunction] = entries[entries.length - 1];
    let blocker = state.blockers.get(blockerKey);
    if (blocker && blocker.state === "proceeding") {
      // If the blocker is currently proceeding, we don't need to re-check
      // it and can let this navigation continue
      return;
    } // At this point, we know we're unblocked/blocked so we need to check the
    // user-provided blocker function

    if (blockerFunction({
      currentLocation,
      nextLocation,
      historyAction
    })) {
      return blockerKey;
    }
  }
  function cancelActiveDeferreds(predicate) {
    let cancelledRouteIds = [];
    activeDeferreds.forEach((dfd, routeId) => {
      if (!predicate || predicate(routeId)) {
        // Cancel the deferred - but do not remove from activeDeferreds here -
        // we rely on the subscribers to do that so our tests can assert proper
        // cleanup via _internalActiveDeferreds
        dfd.cancel();
        cancelledRouteIds.push(routeId);
        activeDeferreds.delete(routeId);
      }
    });
    return cancelledRouteIds;
  } // Opt in to capturing and reporting scroll positions during navigations,
  // used by the <ScrollRestoration> component

  function enableScrollRestoration(positions, getPosition, getKey) {
    savedScrollPositions = positions;
    getScrollPosition = getPosition;
    getScrollRestorationKey = getKey || (location => location.key); // Perform initial hydration scroll restoration, since we miss the boat on
    // the initial updateState() because we've not yet rendered <ScrollRestoration/>
    // and therefore have no savedScrollPositions available

    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = true;
      let y = getSavedScrollPosition(state.location, state.matches);
      if (y != null) {
        updateState({
          restoreScrollPosition: y
        });
      }
    }
    return () => {
      savedScrollPositions = null;
      getScrollPosition = null;
      getScrollRestorationKey = null;
    };
  }
  function saveScrollPosition(location, matches) {
    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {
      let userMatches = matches.map(m => createUseMatchesMatch(m, state.loaderData));
      let key = getScrollRestorationKey(location, userMatches) || location.key;
      savedScrollPositions[key] = getScrollPosition();
    }
  }
  function getSavedScrollPosition(location, matches) {
    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {
      let userMatches = matches.map(m => createUseMatchesMatch(m, state.loaderData));
      let key = getScrollRestorationKey(location, userMatches) || location.key;
      let y = savedScrollPositions[key];
      if (typeof y === "number") {
        return y;
      }
    }
    return null;
  }
  router = {
    get basename() {
      return init.basename;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    initialize,
    subscribe,
    enableScrollRestoration,
    navigate,
    fetch,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: to => init.history.createHref(to),
    encodeLocation: to => init.history.encodeLocation(to),
    getFetcher,
    deleteFetcher,
    dispose,
    getBlocker,
    deleteBlocker,
    _internalFetchControllers: fetchControllers,
    _internalActiveDeferreds: activeDeferreds
  };
  return router;
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region createStaticHandler
////////////////////////////////////////////////////////////////////////////////

const UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");
function createStaticHandler(routes, opts) {
  invariant(routes.length > 0, "You must provide a non-empty routes array to createStaticHandler");
  let dataRoutes = convertRoutesToDataRoutes(routes);
  let basename = (opts ? opts.basename : null) || "/";
  /**
   * The query() method is intended for document requests, in which we want to
   * call an optional action and potentially multiple loaders for all nested
   * routes.  It returns a StaticHandlerContext object, which is very similar
   * to the router state (location, loaderData, actionData, errors, etc.) and
   * also adds SSR-specific information such as the statusCode and headers
   * from action/loaders Responses.
   *
   * It _should_ never throw and should report all errors through the
   * returned context.errors object, properly associating errors to their error
   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be
   * used to emulate React error boundaries during SSr by performing a second
   * pass only down to the boundaryId.
   *
   * The one exception where we do not return a StaticHandlerContext is when a
   * redirect response is returned or thrown from any action/loader.  We
   * propagate that out and return the raw Response so the HTTP server can
   * return it directly.
   */

  async function query(request, _temp2) {
    let {
      requestContext
    } = _temp2 === void 0 ? {} : _temp2;
    let url = new URL(request.url);
    let method = request.method.toLowerCase();
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename); // SSR supports HEAD requests while SPA doesn't

    if (!isValidMethod(method) && method !== "head") {
      let error = getInternalRouterError(405, {
        method
      });
      let {
        matches: methodNotAllowedMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: methodNotAllowedMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    } else if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: notFoundMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    let result = await queryImpl(request, location, matches, requestContext);
    if (isResponse(result)) {
      return result;
    } // When returning StaticHandlerContext, we patch back in the location here
    // since we need it for React Context.  But this helps keep our submit and
    // loadRouteData operating on a Request instead of a Location

    return _extends({
      location,
      basename
    }, result);
  }
  /**
   * The queryRoute() method is intended for targeted route requests, either
   * for fetch ?_data requests or resource route requests.  In this case, we
   * are only ever calling a single action or loader, and we are returning the
   * returned value directly.  In most cases, this will be a Response returned
   * from the action/loader, but it may be a primitive or other value as well -
   * and in such cases the calling context should handle that accordingly.
   *
   * We do respect the throw/return differentiation, so if an action/loader
   * throws, then this method will throw the value.  This is important so we
   * can do proper boundary identification in Remix where a thrown Response
   * must go to the Catch Boundary but a returned Response is happy-path.
   *
   * One thing to note is that any Router-initiated Errors that make sense
   * to associate with a status code will be thrown as an ErrorResponse
   * instance which include the raw Error, such that the calling context can
   * serialize the error as they see fit while including the proper response
   * code.  Examples here are 404 and 405 errors that occur prior to reaching
   * any user-defined loaders.
   */

  async function queryRoute(request, _temp3) {
    let {
      routeId,
      requestContext
    } = _temp3 === void 0 ? {} : _temp3;
    let url = new URL(request.url);
    let method = request.method.toLowerCase();
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename); // SSR supports HEAD requests while SPA doesn't

    if (!isValidMethod(method) && method !== "head" && method !== "options") {
      throw getInternalRouterError(405, {
        method
      });
    } else if (!matches) {
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }
    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);
    if (routeId && !match) {
      throw getInternalRouterError(403, {
        pathname: location.pathname,
        routeId
      });
    } else if (!match) {
      // This should never hit I don't think?
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }
    let result = await queryImpl(request, location, matches, requestContext, match);
    if (isResponse(result)) {
      return result;
    }
    let error = result.errors ? Object.values(result.errors)[0] : undefined;
    if (error !== undefined) {
      // If we got back result.errors, that means the loader/action threw
      // _something_ that wasn't a Response, but it's not guaranteed/required
      // to be an `instanceof Error` either, so we have to use throw here to
      // preserve the "error" state outside of queryImpl.
      throw error;
    } // Pick off the right state value to return

    if (result.actionData) {
      return Object.values(result.actionData)[0];
    }
    if (result.loaderData) {
      var _result$activeDeferre;
      let data = Object.values(result.loaderData)[0];
      if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {
        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];
      }
      return data;
    }
    return undefined;
  }
  async function queryImpl(request, location, matches, requestContext, routeMatch) {
    invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");
    try {
      if (isMutationMethod(request.method.toLowerCase())) {
        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);
        return result;
      }
      let result = await loadRouteData(request, matches, requestContext, routeMatch);
      return isResponse(result) ? result : _extends({}, result, {
        actionData: null,
        actionHeaders: {}
      });
    } catch (e) {
      // If the user threw/returned a Response in callLoaderOrAction, we throw
      // it to bail out and then return or throw here based on whether the user
      // returned or threw
      if (isQueryRouteResponse(e)) {
        if (e.type === ResultType.error && !isRedirectResponse(e.response)) {
          throw e.response;
        }
        return e.response;
      } // Redirects are always returned since they don't propagate to catch
      // boundaries

      if (isRedirectResponse(e)) {
        return e;
      }
      throw e;
    }
  }
  async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {
    let result;
    if (!actionMatch.route.action) {
      let error = getInternalRouterError(405, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: actionMatch.route.id
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: ResultType.error,
        error
      };
    } else {
      result = await callLoaderOrAction("action", request, actionMatch, matches, basename, true, isRouteRequest, requestContext);
      if (request.signal.aborted) {
        let method = isRouteRequest ? "queryRoute" : "query";
        throw new Error(method + "() call aborted");
      }
    }
    if (isRedirectResult(result)) {
      // Uhhhh - this should never happen, we should always throw these from
      // callLoaderOrAction, but the type narrowing here keeps TS happy and we
      // can get back on the "throw all redirect responses" train here should
      // this ever happen :/
      throw new Response(null, {
        status: result.status,
        headers: {
          Location: result.location
        }
      });
    }
    if (isDeferredResult(result)) {
      let error = getInternalRouterError(400, {
        type: "defer-action"
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: ResultType.error,
        error
      };
    }
    if (isRouteRequest) {
      // Note: This should only be non-Response values if we get here, since
      // isRouteRequest should throw any Response received in callLoaderOrAction
      if (isErrorResult(result)) {
        throw result.error;
      }
      return {
        matches: [actionMatch],
        loaderData: {},
        actionData: {
          [actionMatch.route.id]: result.data
        },
        errors: null,
        // Note: statusCode + headers are unused here since queryRoute will
        // return the raw Response or value
        statusCode: 200,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    if (isErrorResult(result)) {
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      let context = await loadRouteData(request, matches, requestContext, undefined, {
        [boundaryMatch.route.id]: result.error
      }); // action status codes take precedence over loader status codes

      return _extends({}, context, {
        statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,
        actionData: null,
        actionHeaders: _extends({}, result.headers ? {
          [actionMatch.route.id]: result.headers
        } : {})
      });
    } // Create a GET request for the loaders

    let loaderRequest = new Request(request.url, {
      headers: request.headers,
      redirect: request.redirect,
      signal: request.signal
    });
    let context = await loadRouteData(loaderRequest, matches, requestContext);
    return _extends({}, context, result.statusCode ? {
      statusCode: result.statusCode
    } : {}, {
      actionData: {
        [actionMatch.route.id]: result.data
      },
      actionHeaders: _extends({}, result.headers ? {
        [actionMatch.route.id]: result.headers
      } : {})
    });
  }
  async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {
    let isRouteRequest = routeMatch != null; // Short circuit if we have no loaders to run (queryRoute())

    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader)) {
      throw getInternalRouterError(400, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: routeMatch == null ? void 0 : routeMatch.route.id
      });
    }
    let requestMatches = routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);
    let matchesToLoad = requestMatches.filter(m => m.route.loader); // Short circuit if we have no loaders to run (query())

    if (matchesToLoad.length === 0) {
      return {
        matches,
        // Add a null for all matched routes for proper revalidation on the client
        loaderData: matches.reduce((acc, m) => Object.assign(acc, {
          [m.route.id]: null
        }), {}),
        errors: pendingActionError || null,
        statusCode: 200,
        loaderHeaders: {},
        activeDeferreds: null
      };
    }
    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, basename, true, isRouteRequest, requestContext))]);
    if (request.signal.aborted) {
      let method = isRouteRequest ? "queryRoute" : "query";
      throw new Error(method + "() call aborted");
    } // Process and commit output from loaders

    let activeDeferreds = new Map();
    let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds); // Add a null for any non-loader matches for proper revalidation on the client

    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));
    matches.forEach(match => {
      if (!executedLoaders.has(match.route.id)) {
        context.loaderData[match.route.id] = null;
      }
    });
    return _extends({}, context, {
      matches,
      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null
    });
  }
  return {
    dataRoutes,
    query,
    queryRoute
  };
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Helpers
////////////////////////////////////////////////////////////////////////////////

/**
 * Given an existing StaticHandlerContext and an error thrown at render time,
 * provide an updated StaticHandlerContext suitable for a second SSR render
 */

function getStaticContextFromError(routes, context, error) {
  let newContext = _extends({}, context, {
    statusCode: 500,
    errors: {
      [context._deepestRenderedBoundaryId || routes[0].id]: error
    }
  });
  return newContext;
}
function isSubmissionNavigation(opts) {
  return opts != null && "formData" in opts;
} // Normalize navigation options by converting formMethod=GET formData objects to
// URLSearchParams so they behave identically to links with query params

function normalizeNavigateOptions(to, opts, isFetcher) {
  if (isFetcher === void 0) {
    isFetcher = false;
  }
  let path = typeof to === "string" ? to : createPath(to); // Return location verbatim on non-submission navigations

  if (!opts || !isSubmissionNavigation(opts)) {
    return {
      path
    };
  }
  if (opts.formMethod && !isValidMethod(opts.formMethod)) {
    return {
      path,
      error: getInternalRouterError(405, {
        method: opts.formMethod
      })
    };
  } // Create a Submission on non-GET navigations

  let submission;
  if (opts.formData) {
    submission = {
      formMethod: opts.formMethod || "get",
      formAction: stripHashFromPath(path),
      formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
      formData: opts.formData
    };
    if (isMutationMethod(submission.formMethod)) {
      return {
        path,
        submission
      };
    }
  } // Flatten submission onto URLSearchParams for GET submissions

  let parsedPath = parsePath(path);
  let searchParams = convertFormDataToSearchParams(opts.formData); // Since fetcher GET submissions only run a single loader (as opposed to
  // navigation GET submissions which run all loaders), we need to preserve
  // any incoming ?index params

  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
    searchParams.append("index", "");
  }
  parsedPath.search = "?" + searchParams;
  return {
    path: createPath(parsedPath),
    submission
  };
} // Filter out all routes below any caught error as they aren't going to
// render so we don't need to load them

function getLoaderMatchesUntilBoundary(matches, boundaryId) {
  let boundaryMatches = matches;
  if (boundaryId) {
    let index = matches.findIndex(m => m.route.id === boundaryId);
    if (index >= 0) {
      boundaryMatches = matches.slice(0, index);
    }
  }
  return boundaryMatches;
}
function getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, pendingActionData, pendingError, fetchLoadMatches) {
  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;
  let currentUrl = history.createURL(state.location);
  let nextUrl = history.createURL(location);
  let defaultShouldRevalidate =
  // Forced revalidation due to submission, useRevalidate, or X-Remix-Revalidate
  isRevalidationRequired ||
  // Clicked the same link, resubmitted a GET form
  currentUrl.toString() === nextUrl.toString() ||
  // Search params affect all loaders
  currentUrl.search !== nextUrl.search; // Pick navigation matches that are net-new or qualify for revalidation

  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;
  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);
  let navigationMatches = boundaryMatches.filter((match, index) => {
    if (match.route.loader == null) {
      return false;
    } // Always call the loader on new route instances and pending defer cancellations

    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {
      return true;
    } // This is the default implementation for when we revalidate.  If the route
    // provides it's own implementation, then we give them full control but
    // provide this value so they can leverage it if needed after they check
    // their own specific use cases

    let currentRouteMatch = state.matches[index];
    let nextRouteMatch = match;
    return shouldRevalidateLoader(match, _extends({
      currentUrl,
      currentParams: currentRouteMatch.params,
      nextUrl,
      nextParams: nextRouteMatch.params
    }, submission, {
      actionResult,
      defaultShouldRevalidate: defaultShouldRevalidate || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
    }));
  }); // Pick fetcher.loads that need to be revalidated

  let revalidatingFetchers = [];
  fetchLoadMatches && fetchLoadMatches.forEach((f, key) => {
    if (!matches.some(m => m.route.id === f.routeId)) {
      // This fetcher is not going to be present in the subsequent render so
      // there's no need to revalidate it
      return;
    } else if (cancelledFetcherLoads.includes(key)) {
      // This fetcher was cancelled from a prior action submission - force reload
      revalidatingFetchers.push(_extends({
        key
      }, f));
    } else {
      // Revalidating fetchers are decoupled from the route matches since they
      // hit a static href, so they _always_ check shouldRevalidate and the
      // default is strictly if a revalidation is explicitly required (action
      // submissions, useRevalidator, X-Remix-Revalidate).
      let shouldRevalidate = shouldRevalidateLoader(f.match, _extends({
        currentUrl,
        currentParams: state.matches[state.matches.length - 1].params,
        nextUrl,
        nextParams: matches[matches.length - 1].params
      }, submission, {
        actionResult,
        defaultShouldRevalidate
      }));
      if (shouldRevalidate) {
        revalidatingFetchers.push(_extends({
          key
        }, f));
      }
    }
  });
  return [navigationMatches, revalidatingFetchers];
}
function isNewLoader(currentLoaderData, currentMatch, match) {
  let isNew =
  // [a] -> [a, b]
  !currentMatch ||
  // [a, b] -> [a, c]
  match.route.id !== currentMatch.route.id; // Handle the case that we don't have data for a re-used route, potentially
  // from a prior error or from a cancelled pending deferred

  let isMissingData = currentLoaderData[match.route.id] === undefined; // Always load if this is a net-new route or we don't yet have data

  return isNew || isMissingData;
}
function isNewRouteInstance(currentMatch, match) {
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match.pathname ||
    // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
  );
}
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg);
    if (typeof routeChoice === "boolean") {
      return routeChoice;
    }
  }
  return arg.defaultShouldRevalidate;
}
async function callLoaderOrAction(type, request, match, matches, basename, isStaticRequest, isRouteRequest, requestContext) {
  if (basename === void 0) {
    basename = "/";
  }
  if (isStaticRequest === void 0) {
    isStaticRequest = false;
  }
  if (isRouteRequest === void 0) {
    isRouteRequest = false;
  }
  let resultType;
  let result; // Setup a promise we can race against so that abort signals short circuit

  let reject;
  let abortPromise = new Promise((_, r) => reject = r);
  let onReject = () => reject();
  request.signal.addEventListener("abort", onReject);
  try {
    let handler = match.route[type];
    invariant(handler, "Could not find the " + type + " to run on the \"" + match.route.id + "\" route");
    result = await Promise.race([handler({
      request,
      params: match.params,
      context: requestContext
    }), abortPromise]);
    invariant(result !== undefined, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ("\"" + match.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
  } catch (e) {
    resultType = ResultType.error;
    result = e;
  } finally {
    request.signal.removeEventListener("abort", onReject);
  }
  if (isResponse(result)) {
    let status = result.status; // Process redirects

    if (redirectStatusCodes.has(status)) {
      let location = result.headers.get("Location");
      invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header"); // Support relative routing in internal redirects

      if (!ABSOLUTE_URL_REGEX.test(location)) {
        let activeMatches = matches.slice(0, matches.indexOf(match) + 1);
        let routePathnames = getPathContributingMatches(activeMatches).map(match => match.pathnameBase);
        let resolvedLocation = resolveTo(location, routePathnames, new URL(request.url).pathname);
        invariant(createPath(resolvedLocation), "Unable to resolve redirect location: " + location); // Prepend the basename to the redirect location if we have one

        if (basename) {
          let path = resolvedLocation.pathname;
          resolvedLocation.pathname = path === "/" ? basename : joinPaths([basename, path]);
        }
        location = createPath(resolvedLocation);
      } else if (!isStaticRequest) {
        // Strip off the protocol+origin for same-origin absolute redirects.
        // If this is a static reques, we can let it go back to the browser
        // as-is
        let currentUrl = new URL(request.url);
        let url = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location);
        if (url.origin === currentUrl.origin) {
          location = url.pathname + url.search + url.hash;
        }
      } // Don't process redirects in the router during static requests requests.
      // Instead, throw the Response and let the server handle it with an HTTP
      // redirect.  We also update the Location header in place in this flow so
      // basename and relative routing is taken into account

      if (isStaticRequest) {
        result.headers.set("Location", location);
        throw result;
      }
      return {
        type: ResultType.redirect,
        status,
        location,
        revalidate: result.headers.get("X-Remix-Revalidate") !== null
      };
    } // For SSR single-route requests, we want to hand Responses back directly
    // without unwrapping.  We do this with the QueryRouteResponse wrapper
    // interface so we can know whether it was returned or thrown

    if (isRouteRequest) {
      // eslint-disable-next-line no-throw-literal
      throw {
        type: resultType || ResultType.data,
        response: result
      };
    }
    let data;
    let contentType = result.headers.get("Content-Type"); // Check between word boundaries instead of startsWith() due to the last
    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type

    if (contentType && /\bapplication\/json\b/.test(contentType)) {
      data = await result.json();
    } else {
      data = await result.text();
    }
    if (resultType === ResultType.error) {
      return {
        type: resultType,
        error: new ErrorResponse(status, result.statusText, data),
        headers: result.headers
      };
    }
    return {
      type: ResultType.data,
      data,
      statusCode: result.status,
      headers: result.headers
    };
  }
  if (resultType === ResultType.error) {
    return {
      type: resultType,
      error: result
    };
  }
  if (result instanceof DeferredData) {
    return {
      type: ResultType.deferred,
      deferredData: result
    };
  }
  return {
    type: ResultType.data,
    data: result
  };
} // Utility method for creating the Request instances for loaders/actions during
// client-side navigations and fetches.  During SSR we will always have a
// Request instance from the static handler (query/queryRoute)

function createClientSideRequest(history, location, signal, submission) {
  let url = history.createURL(stripHashFromPath(location)).toString();
  let init = {
    signal
  };
  if (submission && isMutationMethod(submission.formMethod)) {
    let {
      formMethod,
      formEncType,
      formData
    } = submission;
    init.method = formMethod.toUpperCase();
    init.body = formEncType === "application/x-www-form-urlencoded" ? convertFormDataToSearchParams(formData) : formData;
  } // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)

  return new Request(url, init);
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key, value] of formData.entries()) {
    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs
    searchParams.append(key, value instanceof File ? value.name : value);
  }
  return searchParams;
}
function processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {
  // Fill in loaderData/errors from our loaders
  let loaderData = {};
  let errors = null;
  let statusCode;
  let foundError = false;
  let loaderHeaders = {}; // Process loader results into state.loaderData/state.errors

  results.forEach((result, index) => {
    let id = matchesToLoad[index].route.id;
    invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
    if (isErrorResult(result)) {
      // Look upwards from the matched route for the closest ancestor
      // error boundary, defaulting to the root match
      let boundaryMatch = findNearestBoundary(matches, id);
      let error = result.error; // If we have a pending action error, we report it at the highest-route
      // that throws a loader error, and then clear it out to indicate that
      // it was consumed

      if (pendingError) {
        error = Object.values(pendingError)[0];
        pendingError = undefined;
      }
      errors = errors || {}; // Prefer higher error values if lower errors bubble to the same boundary

      if (errors[boundaryMatch.route.id] == null) {
        errors[boundaryMatch.route.id] = error;
      } // Clear our any prior loaderData for the throwing route

      loaderData[id] = undefined; // Once we find our first (highest) error, we set the status code and
      // prevent deeper status codes from overriding

      if (!foundError) {
        foundError = true;
        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    } else {
      if (isDeferredResult(result)) {
        activeDeferreds.set(id, result.deferredData);
        loaderData[id] = result.deferredData.data;
      } else {
        loaderData[id] = result.data;
      } // Error status codes always override success status codes, but if all
      // loaders are successful we take the deepest status code.

      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
        statusCode = result.statusCode;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    }
  }); // If we didn't consume the pending action error (i.e., all loaders
  // resolved), then consume it here.  Also clear out any loaderData for the
  // throwing route

  if (pendingError) {
    errors = pendingError;
    loaderData[Object.keys(pendingError)[0]] = undefined;
  }
  return {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
function processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {
  let {
    loaderData,
    errors
  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds); // Process results from our revalidating fetchers

  for (let index = 0; index < revalidatingFetchers.length; index++) {
    let {
      key,
      match
    } = revalidatingFetchers[index];
    invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, "Did not find corresponding fetcher result");
    let result = fetcherResults[index]; // Process fetcher non-redirect errors

    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, match.route.id);
      if (!(errors && errors[boundaryMatch.route.id])) {
        errors = _extends({}, errors, {
          [boundaryMatch.route.id]: result.error
        });
      }
      state.fetchers.delete(key);
    } else if (isRedirectResult(result)) {
      // Should never get here, redirects should get processed above, but we
      // keep this to type narrow to a success result in the else
      invariant(false, "Unhandled fetcher revalidation redirect");
    } else if (isDeferredResult(result)) {
      // Should never get here, deferred data should be awaited for fetchers
      // in resolveDeferredResults
      invariant(false, "Unhandled fetcher deferred data");
    } else {
      let doneFetcher = {
        state: "idle",
        data: result.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true
      };
      state.fetchers.set(key, doneFetcher);
    }
  }
  return {
    loaderData,
    errors
  };
}
function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
  let mergedLoaderData = _extends({}, newLoaderData);
  for (let match of matches) {
    let id = match.route.id;
    if (newLoaderData.hasOwnProperty(id)) {
      if (newLoaderData[id] !== undefined) {
        mergedLoaderData[id] = newLoaderData[id];
      }
    } else if (loaderData[id] !== undefined) {
      mergedLoaderData[id] = loaderData[id];
    }
    if (errors && errors.hasOwnProperty(id)) {
      // Don't keep any loader data below the boundary
      break;
    }
  }
  return mergedLoaderData;
} // Find the nearest error boundary, looking upwards from the leaf route (or the
// route specified by routeId) for the closest ancestor error boundary,
// defaulting to the root match

function findNearestBoundary(matches, routeId) {
  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];
  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];
}
function getShortCircuitMatches(routes) {
  // Prefer a root layout route if present, otherwise shim in a route object
  let route = routes.find(r => r.index || !r.path || r.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route
    }],
    route
  };
}
function getInternalRouterError(status, _temp4) {
  let {
    pathname,
    routeId,
    method,
    type
  } = _temp4 === void 0 ? {} : _temp4;
  let statusText = "Unknown Server Error";
  let errorMessage = "Unknown @remix-run/router error";
  if (status === 400) {
    statusText = "Bad Request";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method + " request to \"" + pathname + "\" but " + ("did not provide a `loader` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    } else if (type === "defer-action") {
      errorMessage = "defer() is not supported in actions";
    }
  } else if (status === 403) {
    statusText = "Forbidden";
    errorMessage = "Route \"" + routeId + "\" does not match URL \"" + pathname + "\"";
  } else if (status === 404) {
    statusText = "Not Found";
    errorMessage = "No route matches URL \"" + pathname + "\"";
  } else if (status === 405) {
    statusText = "Method Not Allowed";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method.toUpperCase() + " request to \"" + pathname + "\" but " + ("did not provide an `action` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    } else if (method) {
      errorMessage = "Invalid request method \"" + method.toUpperCase() + "\"";
    }
  }
  return new ErrorResponse(status || 500, statusText, new Error(errorMessage), true);
} // Find any returned redirect errors, starting from the lowest match

function findRedirect(results) {
  for (let i = results.length - 1; i >= 0; i--) {
    let result = results[i];
    if (isRedirectResult(result)) {
      return result;
    }
  }
}
function stripHashFromPath(path) {
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return createPath(_extends({}, parsedPath, {
    hash: ""
  }));
}
function isHashChangeOnly(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash !== b.hash;
}
function isDeferredResult(result) {
  return result.type === ResultType.deferred;
}
function isErrorResult(result) {
  return result.type === ResultType.error;
}
function isRedirectResult(result) {
  return (result && result.type) === ResultType.redirect;
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
function isRedirectResponse(result) {
  if (!isResponse(result)) {
    return false;
  }
  let status = result.status;
  let location = result.headers.get("Location");
  return status >= 300 && status <= 399 && location != null;
}
function isQueryRouteResponse(obj) {
  return obj && isResponse(obj.response) && (obj.type === ResultType.data || ResultType.error);
}
function isValidMethod(method) {
  return validRequestMethods.has(method);
}
function isMutationMethod(method) {
  return validMutationMethods.has(method);
}
async function resolveDeferredResults(currentMatches, matchesToLoad, results, signal, isFetcher, currentLoaderData) {
  for (let index = 0; index < results.length; index++) {
    let result = results[index];
    let match = matchesToLoad[index];
    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);
    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;
    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {
      // Note: we do not have to touch activeDeferreds here since we race them
      // against the signal in resolveDeferredData and they'll get aborted
      // there if needed
      await resolveDeferredData(result, signal, isFetcher).then(result => {
        if (result) {
          results[index] = result || results[index];
        }
      });
    }
  }
}
async function resolveDeferredData(result, signal, unwrap) {
  if (unwrap === void 0) {
    unwrap = false;
  }
  let aborted = await result.deferredData.resolveData(signal);
  if (aborted) {
    return;
  }
  if (unwrap) {
    try {
      return {
        type: ResultType.data,
        data: result.deferredData.unwrappedData
      };
    } catch (e) {
      // Handle any TrackedPromise._error values encountered while unwrapping
      return {
        type: ResultType.error,
        error: e
      };
    }
  }
  return {
    type: ResultType.data,
    data: result.deferredData.data
  };
}
function hasNakedIndexQuery(search) {
  return new URLSearchParams(search).getAll("index").some(v => v === "");
} // Note: This should match the format exported by useMatches, so if you change
// this please also change that :)  Eventually we'll DRY this up

function createUseMatchesMatch(match, loaderData) {
  let {
    route,
    pathname,
    params
  } = match;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
function getTargetMatch(matches, location) {
  let search = typeof location === "string" ? parsePath(location).search : location.search;
  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
    // Return the leaf index route when index is present
    return matches[matches.length - 1];
  } // Otherwise grab the deepest "path contributing" match (ignoring index and
  // pathless layout routes)

  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
} //#endregion



/***/ }),

/***/ "./node_modules/react-router-dom/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-router-dom/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbortedDeferredError": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError),
/* harmony export */   "Await": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Await),
/* harmony export */   "BrowserRouter": () => (/* binding */ BrowserRouter),
/* harmony export */   "Form": () => (/* binding */ Form),
/* harmony export */   "HashRouter": () => (/* binding */ HashRouter),
/* harmony export */   "Link": () => (/* binding */ Link),
/* harmony export */   "MemoryRouter": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.MemoryRouter),
/* harmony export */   "NavLink": () => (/* binding */ NavLink),
/* harmony export */   "Navigate": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Navigate),
/* harmony export */   "NavigationType": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Action),
/* harmony export */   "Outlet": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Outlet),
/* harmony export */   "Route": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Route),
/* harmony export */   "Router": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Router),
/* harmony export */   "RouterProvider": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.RouterProvider),
/* harmony export */   "Routes": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Routes),
/* harmony export */   "ScrollRestoration": () => (/* binding */ ScrollRestoration),
/* harmony export */   "UNSAFE_DataRouterContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterContext),
/* harmony export */   "UNSAFE_DataRouterStateContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext),
/* harmony export */   "UNSAFE_LocationContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_LocationContext),
/* harmony export */   "UNSAFE_NavigationContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext),
/* harmony export */   "UNSAFE_RouteContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_RouteContext),
/* harmony export */   "UNSAFE_enhanceManualRouteObjects": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_enhanceManualRouteObjects),
/* harmony export */   "UNSAFE_useScrollRestoration": () => (/* binding */ useScrollRestoration),
/* harmony export */   "createBrowserRouter": () => (/* binding */ createBrowserRouter),
/* harmony export */   "createHashRouter": () => (/* binding */ createHashRouter),
/* harmony export */   "createMemoryRouter": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createMemoryRouter),
/* harmony export */   "createPath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.createPath),
/* harmony export */   "createRoutesFromChildren": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createRoutesFromChildren),
/* harmony export */   "createRoutesFromElements": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createRoutesFromElements),
/* harmony export */   "createSearchParams": () => (/* binding */ createSearchParams),
/* harmony export */   "defer": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.defer),
/* harmony export */   "generatePath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.generatePath),
/* harmony export */   "isRouteErrorResponse": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse),
/* harmony export */   "json": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.json),
/* harmony export */   "matchPath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.matchPath),
/* harmony export */   "matchRoutes": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes),
/* harmony export */   "parsePath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.parsePath),
/* harmony export */   "redirect": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.redirect),
/* harmony export */   "renderMatches": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.renderMatches),
/* harmony export */   "resolvePath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.resolvePath),
/* harmony export */   "unstable_HistoryRouter": () => (/* binding */ HistoryRouter),
/* harmony export */   "unstable_useBlocker": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.unstable_useBlocker),
/* harmony export */   "unstable_usePrompt": () => (/* binding */ usePrompt),
/* harmony export */   "useActionData": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useActionData),
/* harmony export */   "useAsyncError": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useAsyncError),
/* harmony export */   "useAsyncValue": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useAsyncValue),
/* harmony export */   "useBeforeUnload": () => (/* binding */ useBeforeUnload),
/* harmony export */   "useFetcher": () => (/* binding */ useFetcher),
/* harmony export */   "useFetchers": () => (/* binding */ useFetchers),
/* harmony export */   "useFormAction": () => (/* binding */ useFormAction),
/* harmony export */   "useHref": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useHref),
/* harmony export */   "useInRouterContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useInRouterContext),
/* harmony export */   "useLinkClickHandler": () => (/* binding */ useLinkClickHandler),
/* harmony export */   "useLoaderData": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useLoaderData),
/* harmony export */   "useLocation": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation),
/* harmony export */   "useMatch": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useMatch),
/* harmony export */   "useMatches": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useMatches),
/* harmony export */   "useNavigate": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigate),
/* harmony export */   "useNavigation": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigation),
/* harmony export */   "useNavigationType": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigationType),
/* harmony export */   "useOutlet": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useOutlet),
/* harmony export */   "useOutletContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useOutletContext),
/* harmony export */   "useParams": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useParams),
/* harmony export */   "useResolvedPath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath),
/* harmony export */   "useRevalidator": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRevalidator),
/* harmony export */   "useRouteError": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRouteError),
/* harmony export */   "useRouteLoaderData": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRouteLoaderData),
/* harmony export */   "useRoutes": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRoutes),
/* harmony export */   "useSearchParams": () => (/* binding */ useSearchParams),
/* harmony export */   "useSubmit": () => (/* binding */ useSubmit)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router */ "./node_modules/react-router/dist/index.js");
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @remix-run/router */ "./node_modules/@remix-run/router/dist/router.js");
/**
 * React Router DOM v6.8.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */




function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
const defaultMethod = "get";
const defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && (
  // Ignore everything but left clicks
  !target || target === "_self") &&
  // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event) // Ignore clicks with modifier keys
  ;
}
/**
 * Creates a URLSearchParams object using the given initializer.
 *
 * This is identical to `new URLSearchParams(init)` except it also
 * supports arrays as values in the object form of the initializer
 * instead of just strings. This is convenient when you need multiple
 * values for a given key, but don't want to use an array initializer.
 *
 * For example, instead of:
 *
 *   let searchParams = new URLSearchParams([
 *     ['sort', 'name'],
 *     ['sort', 'price']
 *   ]);
 *
 * you can do:
 *
 *   let searchParams = createSearchParams({
 *     sort: ['name', 'price']
 *   });
 */

function createSearchParams(init) {
  if (init === void 0) {
    init = "";
  }
  return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {
    let value = init[key];
    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);
  }, []));
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
  let searchParams = createSearchParams(locationSearch);
  if (defaultSearchParams) {
    for (let key of defaultSearchParams.keys()) {
      if (!searchParams.has(key)) {
        defaultSearchParams.getAll(key).forEach(value => {
          searchParams.append(key, value);
        });
      }
    }
  }
  return searchParams;
}
function getFormSubmissionInfo(target, defaultAction, options) {
  let method;
  let action;
  let encType;
  let formData;
  if (isFormElement(target)) {
    let submissionTrigger = options.submissionTrigger;
    method = options.method || target.getAttribute("method") || defaultMethod;
    action = options.action || target.getAttribute("action") || defaultAction;
    encType = options.encType || target.getAttribute("enctype") || defaultEncType;
    formData = new FormData(target);
    if (submissionTrigger && submissionTrigger.name) {
      formData.append(submissionTrigger.name, submissionTrigger.value);
    }
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error("Cannot submit a <button> or <input type=\"submit\"> without a <form>");
    } // <button>/<input type="submit"> may override attributes of <form>

    method = options.method || target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    action = options.action || target.getAttribute("formaction") || form.getAttribute("action") || defaultAction;
    encType = options.encType || target.getAttribute("formenctype") || form.getAttribute("enctype") || defaultEncType;
    formData = new FormData(form); // Include name + value from a <button>, appending in case the button name
    // matches an existing input name

    if (target.name) {
      formData.append(target.name, target.value);
    }
  } else if (isHtmlElement(target)) {
    throw new Error("Cannot submit element that is not <form>, <button>, or " + "<input type=\"submit|image\">");
  } else {
    method = options.method || defaultMethod;
    action = options.action || defaultAction;
    encType = options.encType || defaultEncType;
    if (target instanceof FormData) {
      formData = target;
    } else {
      formData = new FormData();
      if (target instanceof URLSearchParams) {
        for (let [name, value] of target) {
          formData.append(name, value);
        }
      } else if (target != null) {
        for (let name of Object.keys(target)) {
          formData.append(name, target[name]);
        }
      }
    }
  }
  let {
    protocol,
    host
  } = window.location;
  let url = new URL(action, protocol + "//" + host);
  return {
    url,
    method: method.toLowerCase(),
    encType,
    formData
  };
}
const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"],
  _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"],
  _excluded3 = ["reloadDocument", "replace", "method", "action", "onSubmit", "fetcherKey", "routeId", "relative", "preventScrollReset"];
//#region Routers
////////////////////////////////////////////////////////////////////////////////

function createBrowserRouter(routes, opts) {
  return (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createRouter)({
    basename: opts == null ? void 0 : opts.basename,
    history: (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createBrowserHistory)({
      window: opts == null ? void 0 : opts.window
    }),
    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
    routes: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_enhanceManualRouteObjects)(routes)
  }).initialize();
}
function createHashRouter(routes, opts) {
  return (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createRouter)({
    basename: opts == null ? void 0 : opts.basename,
    history: (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createHashHistory)({
      window: opts == null ? void 0 : opts.window
    }),
    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
    routes: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_enhanceManualRouteObjects)(routes)
  }).initialize();
}
function parseHydrationData() {
  var _window;
  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
  if (state && state.errors) {
    state = _extends({}, state, {
      errors: deserializeErrors(state.errors)
    });
  }
  return state;
}
function deserializeErrors(errors) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    // Hey you!  If you change this, please change the corresponding logic in
    // serializeErrors in react-router-dom/server.tsx :)
    if (val && val.__type === "RouteErrorResponse") {
      serialized[key] = new react_router__WEBPACK_IMPORTED_MODULE_1__.ErrorResponse(val.status, val.statusText, val.data, val.internal === true);
    } else if (val && val.__type === "Error") {
      let error = new Error(val.message); // Wipe away the client-side stack trace.  Nothing to fill it in with
      // because we don't serialize SSR stack traces for security reasons

      error.stack = "";
      serialized[key] = error;
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}
/**
 * A `<Router>` for use in web browsers. Provides the cleanest URLs.
 */

function BrowserRouter(_ref) {
  let {
    basename,
    children,
    window
  } = _ref;
  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  if (historyRef.current == null) {
    historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createBrowserHistory)({
      window,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
/**
 * A `<Router>` for use in web browsers. Stores the location in the hash
 * portion of the URL so it is not sent to the server.
 */

function HashRouter(_ref2) {
  let {
    basename,
    children,
    window
  } = _ref2;
  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  if (historyRef.current == null) {
    historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createHashHistory)({
      window,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
/**
 * A `<Router>` that accepts a pre-instantiated history object. It's important
 * to note that using your own history object is highly discouraged and may add
 * two versions of the history library to your bundles unless you use the same
 * version of the history library that React Router uses internally.
 */

function HistoryRouter(_ref3) {
  let {
    basename,
    children,
    history
  } = _ref3;
  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
if (true) {
  HistoryRouter.displayName = "unstable_HistoryRouter";
}
const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
/**
 * The public API for rendering a history-aware <a>.
 */

const Link = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function LinkWithRef(_ref4, ref) {
  let {
      onClick,
      relative,
      reloadDocument,
      replace,
      state,
      target,
      to,
      preventScrollReset
    } = _ref4,
    rest = _objectWithoutPropertiesLoose(_ref4, _excluded);

  // Rendered into <a href> for absolute URLs
  let absoluteHref;
  let isExternal = false;
  if (isBrowser && typeof to === "string" && /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i.test(to)) {
    absoluteHref = to;
    let currentUrl = new URL(window.location.href);
    let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
    if (targetUrl.origin === currentUrl.origin) {
      // Strip the protocol/origin for same-origin absolute URLs
      to = targetUrl.pathname + targetUrl.search + targetUrl.hash;
    } else {
      isExternal = true;
    }
  } // Rendered into <a href> for relative URLs

  let href = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useHref)(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event) {
    if (onClick) onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return /*#__PURE__*/(
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", _extends({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick,
      ref: ref,
      target: target
    }))
  );
});
if (true) {
  Link.displayName = "Link";
}
/**
 * A <Link> wrapper that knows if it's "active" or not.
 */

const NavLink = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function NavLinkWithRef(_ref5, ref) {
  let {
      "aria-current": ariaCurrentProp = "page",
      caseSensitive = false,
      className: classNameProp = "",
      end = false,
      style: styleProp,
      to,
      children
    } = _ref5,
    rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);
  let path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(to, {
    relative: rest.relative
  });
  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();
  let routerState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext);
  let {
    navigator
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext);
  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let ariaCurrent = isActive ? ariaCurrentProp : undefined;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive,
      isPending
    });
  } else {
    // If the className prop is not a function, we use a default `active`
    // class for <NavLink />s that are active. In v5 `active` was the default
    // value for `activeClassName`, but we are removing that API and can still
    // use the old default behavior for a cleaner upgrade path and keep the
    // simple styling rules working as they currently do.
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp({
    isActive,
    isPending
  }) : styleProp;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Link, _extends({}, rest, {
    "aria-current": ariaCurrent,
    className: className,
    ref: ref,
    style: style,
    to: to
  }), typeof children === "function" ? children({
    isActive,
    isPending
  }) : children);
});
if (true) {
  NavLink.displayName = "NavLink";
}
/**
 * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except
 * that the interaction with the server is with `fetch` instead of new document
 * requests, allowing components to add nicer UX to the page as the form is
 * submitted and returns with data.
 */

const Form = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FormImpl, _extends({}, props, {
    ref: ref
  }));
});
if (true) {
  Form.displayName = "Form";
}
const FormImpl = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((_ref6, forwardedRef) => {
  let {
      reloadDocument,
      replace,
      method = defaultMethod,
      action,
      onSubmit,
      fetcherKey,
      routeId,
      relative,
      preventScrollReset
    } = _ref6,
    props = _objectWithoutPropertiesLoose(_ref6, _excluded3);
  let submit = useSubmitImpl(fetcherKey, routeId);
  let formMethod = method.toLowerCase() === "get" ? "get" : "post";
  let formAction = useFormAction(action, {
    relative
  });
  let submitHandler = event => {
    onSubmit && onSubmit(event);
    if (event.defaultPrevented) return;
    event.preventDefault();
    let submitter = event.nativeEvent.submitter;
    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
    submit(submitter || event.currentTarget, {
      method: submitMethod,
      replace,
      relative,
      preventScrollReset
    });
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("form", _extends({
    ref: forwardedRef,
    method: formMethod,
    action: formAction,
    onSubmit: reloadDocument ? onSubmit : submitHandler
  }, props));
});
if (true) {
  FormImpl.displayName = "FormImpl";
}
/**
 * This component will emulate the browser's scroll restoration on location
 * changes.
 */

function ScrollRestoration(_ref7) {
  let {
    getKey,
    storageKey
  } = _ref7;
  useScrollRestoration({
    getKey,
    storageKey
  });
  return null;
}
if (true) {
  ScrollRestoration.displayName = "ScrollRestoration";
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Hooks
////////////////////////////////////////////////////////////////////////////////

var DataRouterHook;
(function (DataRouterHook) {
  DataRouterHook["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook["UseSubmitImpl"] = "useSubmitImpl";
  DataRouterHook["UseFetcher"] = "useFetcher";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function (DataRouterStateHook) {
  DataRouterStateHook["UseFetchers"] = "useFetchers";
  DataRouterStateHook["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function getDataRouterConsoleError(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function useDataRouterContext(hookName) {
  let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterContext);
  !ctx ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext);
  !state ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;
  return state;
}
/**
 * Handles the click behavior for router `<Link>` components. This is useful if
 * you need to create custom `<Link>` components with the same click behavior we
 * use in our exported `<Link>`.
 */

function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp;
  let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigate)();
  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();
  let path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(to, {
    relative
  });
  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of
      // a push, so do the same here unless the replace prop is explicitly set

      let replace = replaceProp !== undefined ? replaceProp : (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createPath)(location) === (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createPath)(path);
      navigate(to, {
        replace,
        state,
        preventScrollReset,
        relative
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative]);
}
/**
 * A convenient wrapper for reading and writing search parameters via the
 * URLSearchParams interface.
 */

function useSearchParams(defaultInit) {
   true ? warning(typeof URLSearchParams !== "undefined", "You cannot use the `useSearchParams` hook in a browser that does not " + "support the URLSearchParams API. If you need to support Internet " + "Explorer 11, we recommend you load a polyfill such as " + "https://github.com/ungap/url-search-params\n\n" + "If you're unsure how to load polyfills, we recommend you check out " + "https://polyfill.io/v3/ which provides some recommendations about how " + "to load polyfills only for users that need them, instead of for every " + "user.") : 0;
  let defaultSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(createSearchParams(defaultInit));
  let hasSetSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();
  let searchParams = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() =>
  // Only merge in the defaults if we haven't yet called setSearchParams.
  // Once we call that we want those to take precedence, otherwise you can't
  // remove a param with setSearchParams({}) if it has an initial value
  getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);
  let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigate)();
  let setSearchParams = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((nextInit, navigateOptions) => {
    const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
    hasSetSearchParamsRef.current = true;
    navigate("?" + newSearchParams, navigateOptions);
  }, [navigate, searchParams]);
  return [searchParams, setSearchParams];
}
/**
 * Returns a function that may be used to programmatically submit a form (or
 * some arbitrary data) to the server.
 */

function useSubmit() {
  return useSubmitImpl();
}
function useSubmitImpl(fetcherKey, routeId) {
  let {
    router
  } = useDataRouterContext(DataRouterHook.UseSubmitImpl);
  let defaultAction = useFormAction();
  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (target, options) {
    if (options === void 0) {
      options = {};
    }
    if (typeof document === "undefined") {
      throw new Error("You are calling submit during the server render. " + "Try calling submit within a `useEffect` or callback instead.");
    }
    let {
      method,
      encType,
      formData,
      url
    } = getFormSubmissionInfo(target, defaultAction, options);
    let href = url.pathname + url.search;
    let opts = {
      replace: options.replace,
      preventScrollReset: options.preventScrollReset,
      formData,
      formMethod: method,
      formEncType: encType
    };
    if (fetcherKey) {
      !(routeId != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, "No routeId available for useFetcher()") : 0 : void 0;
      router.fetch(fetcherKey, routeId, href, opts);
    } else {
      router.navigate(href, opts);
    }
  }, [defaultAction, router, fetcherKey, routeId]);
}
function useFormAction(action, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    basename
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext);
  let routeContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_RouteContext);
  !routeContext ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, "useFormAction must be used inside a RouteContext") : 0 : void 0;
  let [match] = routeContext.matches.slice(-1); // Shallow clone path so we can modify it below, otherwise we modify the
  // object referenced by useMemo inside useResolvedPath

  let path = _extends({}, (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(action ? action : ".", {
    relative
  })); // Previously we set the default action to ".". The problem with this is that
  // `useResolvedPath(".")` excludes search params and the hash of the resolved
  // URL. This is the intended behavior of when "." is specifically provided as
  // the form action, but inconsistent w/ browsers when the action is omitted.
  // https://github.com/remix-run/remix/issues/927

  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();
  if (action == null) {
    // Safe to write to these directly here since if action was undefined, we
    // would have called useResolvedPath(".") which will never include a search
    // or hash
    path.search = location.search;
    path.hash = location.hash; // When grabbing search params from the URL, remove the automatically
    // inserted ?index param so we match the useResolvedPath search behavior
    // which would not include ?index

    if (match.route.index) {
      let params = new URLSearchParams(path.search);
      params.delete("index");
      path.search = params.toString() ? "?" + params.toString() : "";
    }
  }
  if ((!action || action === ".") && match.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  } // If we're operating within a basename, prepend it to the pathname prior
  // to creating the form action.  If this is a root navigation, then just use
  // the raw basename which allows the basename to have full control over the
  // presence of a trailing slash on root actions

  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : (0,react_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([basename, path.pathname]);
  }
  return (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createPath)(path);
}
function createFetcherForm(fetcherKey, routeId) {
  let FetcherForm = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FormImpl, _extends({}, props, {
      ref: ref,
      fetcherKey: fetcherKey,
      routeId: routeId
    }));
  });
  if (true) {
    FetcherForm.displayName = "fetcher.Form";
  }
  return FetcherForm;
}
let fetcherId = 0;
/**
 * Interacts with route loaders and actions without causing a navigation. Great
 * for any interaction that stays on the same page.
 */

function useFetcher() {
  var _route$matches;
  let {
    router
  } = useDataRouterContext(DataRouterHook.UseFetcher);
  let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_RouteContext);
  !route ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, "useFetcher must be used inside a RouteContext") : 0 : void 0;
  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;
  !(routeId != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, "useFetcher can only be used on routes that contain a unique \"id\"") : 0 : void 0;
  let [fetcherKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => String(++fetcherId));
  let [Form] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {
    !routeId ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, "No routeId available for fetcher.Form()") : 0 : void 0;
    return createFetcherForm(fetcherKey, routeId);
  });
  let [load] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => href => {
    !router ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, "No router available for fetcher.load()") : 0 : void 0;
    !routeId ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, "No routeId available for fetcher.load()") : 0 : void 0;
    router.fetch(fetcherKey, routeId, href);
  });
  let submit = useSubmitImpl(fetcherKey, routeId);
  let fetcher = router.getFetcher(fetcherKey);
  let fetcherWithComponents = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => _extends({
    Form,
    submit,
    load
  }, fetcher), [fetcher, Form, submit, load]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    // Is this busted when the React team gets real weird and calls effects
    // twice on mount?  We really just need to garbage collect here when this
    // fetcher is no longer around.
    return () => {
      if (!router) {
        console.warn("No fetcher available to clean up from useFetcher()");
        return;
      }
      router.deleteFetcher(fetcherKey);
    };
  }, [router, fetcherKey]);
  return fetcherWithComponents;
}
/**
 * Provides all fetchers currently on the page. Useful for layouts and parent
 * routes that need to provide pending/optimistic UI regarding the fetch.
 */

function useFetchers() {
  let state = useDataRouterState(DataRouterStateHook.UseFetchers);
  return [...state.fetchers.values()];
}
const SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
let savedScrollPositions = {};
/**
 * When rendered inside a RouterProvider, will restore scroll positions on navigations
 */

function useScrollRestoration(_temp3) {
  let {
    getKey,
    storageKey
  } = _temp3 === void 0 ? {} : _temp3;
  let {
    router
  } = useDataRouterContext(DataRouterHook.UseScrollRestoration);
  let {
    restoreScrollPosition,
    preventScrollReset
  } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);
  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();
  let matches = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useMatches)();
  let navigation = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigation)(); // Trigger manual scroll restoration while we're active

  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    window.history.scrollRestoration = "manual";
    return () => {
      window.history.scrollRestoration = "auto";
    };
  }, []); // Save positions on pagehide

  usePageHide(react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    if (navigation.state === "idle") {
      let key = (getKey ? getKey(location, matches) : null) || location.key;
      savedScrollPositions[key] = window.scrollY;
    }
    sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
    window.history.scrollRestoration = "auto";
  }, [storageKey, getKey, navigation.state, location, matches])); // Read in any saved scroll locations

  if (typeof document !== "undefined") {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
      try {
        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);
        if (sessionPositions) {
          savedScrollPositions = JSON.parse(sessionPositions);
        }
      } catch (e) {// no-op, use default empty object
      }
    }, [storageKey]); // Enable scroll restoration in the router
    // eslint-disable-next-line react-hooks/rules-of-hooks

    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKey);
      return () => disableScrollRestoration && disableScrollRestoration();
    }, [router, getKey]); // Restore scrolling when state.restoreScrollPosition changes
    // eslint-disable-next-line react-hooks/rules-of-hooks

    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
      // Explicit false means don't do anything (used for submissions)
      if (restoreScrollPosition === false) {
        return;
      } // been here before, scroll to it

      if (typeof restoreScrollPosition === "number") {
        window.scrollTo(0, restoreScrollPosition);
        return;
      } // try to scroll to the hash

      if (location.hash) {
        let el = document.getElementById(location.hash.slice(1));
        if (el) {
          el.scrollIntoView();
          return;
        }
      } // Don't reset if this navigation opted out

      if (preventScrollReset === true) {
        return;
      } // otherwise go to the top on new locations

      window.scrollTo(0, 0);
    }, [location, restoreScrollPosition, preventScrollReset]);
  }
}
/**
 * Setup a callback to be fired on the window's `beforeunload` event. This is
 * useful for saving some data to `window.localStorage` just before the page
 * refreshes.
 *
 * Note: The `callback` argument should be a function created with
 * `React.useCallback()`.
 */

function useBeforeUnload(callback, options) {
  let {
    capture
  } = options || {};
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : undefined;
    window.addEventListener("beforeunload", callback, opts);
    return () => {
      window.removeEventListener("beforeunload", callback, opts);
    };
  }, [callback, capture]);
}
/**
 * Setup a callback to be fired on the window's `pagehide` event. This is
 * useful for saving some data to `window.localStorage` just before the page
 * refreshes.  This event is better supported than beforeunload across browsers.
 *
 * Note: The `callback` argument should be a function created with
 * `React.useCallback()`.
 */

function usePageHide(callback, options) {
  let {
    capture
  } = options || {};
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : undefined;
    window.addEventListener("pagehide", callback, opts);
    return () => {
      window.removeEventListener("pagehide", callback, opts);
    };
  }, [callback, capture]);
}
/**
 * Wrapper around useBlocker to show a window.confirm prompt to users instead
 * of building a custom UI with useBlocker.
 *
 * Warning: This has *a lot of rough edges* and behaves very differently (and
 * very incorrectly in some cases) across browsers if user click addition
 * back/forward navigations while the confirm is open.  Use at your own risk.
 */

function usePrompt(_ref8) {
  let {
    when,
    message
  } = _ref8;
  let blocker = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.unstable_useBlocker)(when);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (blocker.state === "blocked" && !when) {
      blocker.reset();
    }
  }, [blocker, when]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (blocker.state === "blocked") {
      let proceed = window.confirm(message);
      if (proceed) {
        setTimeout(blocker.proceed, 0);
      } else {
        blocker.reset();
      }
    }
  }, [blocker, message]);
}
////////////////////////////////////////////////////////////////////////////////
//#region Utils
////////////////////////////////////////////////////////////////////////////////

function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);
    try {
      // Welcome to debugging React Router!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
} //#endregion



/***/ }),

/***/ "./node_modules/react-router-dom/server.js":
/*!*************************************************!*\
  !*** ./node_modules/react-router-dom/server.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var React = __webpack_require__(/*! react */ "react");
var router = __webpack_require__(/*! @remix-run/router */ "./node_modules/@remix-run/router/dist/router.js");
var reactRouterDom = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router-dom/dist/index.js");
function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}
var React__namespace = /*#__PURE__*/_interopNamespace(React);

/**
 * A <Router> that may not navigate to any other location. This is useful
 * on the server where there is no stateful UI.
 */

function StaticRouter(_ref) {
  let {
    basename,
    children,
    location: locationProp = "/"
  } = _ref;
  if (typeof locationProp === "string") {
    locationProp = reactRouterDom.parsePath(locationProp);
  }
  let action = router.Action.Pop;
  let location = {
    pathname: locationProp.pathname || "/",
    search: locationProp.search || "",
    hash: locationProp.hash || "",
    state: locationProp.state || null,
    key: locationProp.key || "default"
  };
  let staticNavigator = getStatelessNavigator();
  return /*#__PURE__*/React__namespace.createElement(reactRouterDom.Router, {
    basename: basename,
    children: children,
    location: location,
    navigationType: action,
    navigator: staticNavigator,
    static: true
  });
}
/**
 * A Data Router that may not navigate to any other location. This is useful
 * on the server where there is no stateful UI.
 */

function StaticRouterProvider(_ref2) {
  let {
    context,
    router: router$1,
    hydrate = true,
    nonce
  } = _ref2;
  !(router$1 && context) ?  true ? router.invariant(false, "You must provide `router` and `context` to <StaticRouterProvider>") : 0 : void 0;
  let dataRouterContext = {
    router: router$1,
    navigator: getStatelessNavigator(),
    static: true,
    staticContext: context,
    basename: context.basename || "/"
  };
  let hydrateScript = "";
  if (hydrate !== false) {
    let data = {
      loaderData: context.loaderData,
      actionData: context.actionData,
      errors: serializeErrors(context.errors)
    }; // Use JSON.parse here instead of embedding a raw JS object here to speed
    // up parsing on the client.  Dual-stringify is needed to ensure all quotes
    // are properly escaped in the resulting string.  See:
    //   https://v8.dev/blog/cost-of-javascript-2019#json

    let json = JSON.stringify(JSON.stringify(data));
    hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;
  }
  return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(reactRouterDom.UNSAFE_DataRouterContext.Provider, {
    value: dataRouterContext
  }, /*#__PURE__*/React__namespace.createElement(reactRouterDom.UNSAFE_DataRouterStateContext.Provider, {
    value: dataRouterContext.router.state
  }, /*#__PURE__*/React__namespace.createElement(reactRouterDom.Router, {
    basename: dataRouterContext.basename,
    location: dataRouterContext.router.state.location,
    navigationType: dataRouterContext.router.state.historyAction,
    navigator: dataRouterContext.navigator
  }, /*#__PURE__*/React__namespace.createElement(reactRouterDom.Routes, null)))), hydrateScript ? /*#__PURE__*/React__namespace.createElement("script", {
    suppressHydrationWarning: true,
    nonce: nonce,
    dangerouslySetInnerHTML: {
      __html: hydrateScript
    }
  }) : null);
}
function serializeErrors(errors) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    // Hey you!  If you change this, please change the corresponding logic in
    // deserializeErrors in react-router-dom/index.tsx :)
    if (router.isRouteErrorResponse(val)) {
      serialized[key] = {
        ...val,
        __type: "RouteErrorResponse"
      };
    } else if (val instanceof Error) {
      // Do not serialize stack traces from SSR for security reasons
      serialized[key] = {
        message: val.message,
        __type: "Error"
      };
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}
function getStatelessNavigator() {
  return {
    createHref,
    encodeLocation,
    push(to) {
      throw new Error(`You cannot use navigator.push() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\`navigate(${JSON.stringify(to)})\` somewhere in your app.`);
    },
    replace(to) {
      throw new Error(`You cannot use navigator.replace() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere ` + `in your app.`);
    },
    go(delta) {
      throw new Error(`You cannot use navigator.go() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\`navigate(${delta})\` somewhere in your app.`);
    },
    back() {
      throw new Error(`You cannot use navigator.back() on the server because it is a stateless ` + `environment.`);
    },
    forward() {
      throw new Error(`You cannot use navigator.forward() on the server because it is a stateless ` + `environment.`);
    }
  };
} // Temporary manifest generation - we should optimize this by combining the
// tree-walks between convertRoutesToDataRoutes, enhanceManualRouteObjects,
// and generateManifest.
// Also look into getting rid of `route as AgnosticDataRouteObject` down below?

function generateManifest(routes) {
  let manifest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();
  routes.forEach(route => {
    manifest.set(route.id, route);
    if (route.children) {
      generateManifest(route.children, manifest);
    }
  });
  return manifest;
}
function createStaticRouter(routes, context) {
  let dataRoutes = router.UNSAFE_convertRoutesToDataRoutes(reactRouterDom.UNSAFE_enhanceManualRouteObjects(routes));
  let manifest = generateManifest(dataRoutes); // Because our context matches may be from a framework-agnostic set of
  // routes passed to createStaticHandler(), we update them here with our
  // newly created/enhanced data routes

  let matches = context.matches.map(match => {
    let route = manifest.get(match.route.id) || match.route;
    return {
      ...match,
      route: route
    };
  });
  let msg = method => `You cannot use router.${method}() on the server because it is a stateless environment`;
  return {
    get basename() {
      return context.basename;
    },
    get state() {
      return {
        historyAction: router.Action.Pop,
        location: context.location,
        matches,
        loaderData: context.loaderData,
        actionData: context.actionData,
        errors: context.errors,
        initialized: true,
        navigation: router.IDLE_NAVIGATION,
        restoreScrollPosition: null,
        preventScrollReset: false,
        revalidation: "idle",
        fetchers: new Map(),
        blockers: new Map()
      };
    },
    get routes() {
      return dataRoutes;
    },
    initialize() {
      throw msg("initialize");
    },
    subscribe() {
      throw msg("subscribe");
    },
    enableScrollRestoration() {
      throw msg("enableScrollRestoration");
    },
    navigate() {
      throw msg("navigate");
    },
    fetch() {
      throw msg("fetch");
    },
    revalidate() {
      throw msg("revalidate");
    },
    createHref,
    encodeLocation,
    getFetcher() {
      return router.IDLE_FETCHER;
    },
    deleteFetcher() {
      throw msg("deleteFetcher");
    },
    dispose() {
      throw msg("dispose");
    },
    getBlocker() {
      throw msg("getBlocker");
    },
    deleteBlocker() {
      throw msg("deleteBlocker");
    },
    _internalFetchControllers: new Map(),
    _internalActiveDeferreds: new Map()
  };
}
function createHref(to) {
  return typeof to === "string" ? to : reactRouterDom.createPath(to);
}
function encodeLocation(to) {
  // Locations should already be encoded on the server, so just return as-is
  let path = typeof to === "string" ? reactRouterDom.parsePath(to) : to;
  return {
    pathname: path.pathname || "",
    search: path.search || "",
    hash: path.hash || ""
  };
}
exports.StaticRouter = StaticRouter;
exports.StaticRouterProvider = StaticRouterProvider;
exports.createStaticRouter = createStaticRouter;

/***/ }),

/***/ "./node_modules/react-router/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/react-router/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbortedDeferredError": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.AbortedDeferredError),
/* harmony export */   "Await": () => (/* binding */ Await),
/* harmony export */   "MemoryRouter": () => (/* binding */ MemoryRouter),
/* harmony export */   "Navigate": () => (/* binding */ Navigate),
/* harmony export */   "NavigationType": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.Action),
/* harmony export */   "Outlet": () => (/* binding */ Outlet),
/* harmony export */   "Route": () => (/* binding */ Route),
/* harmony export */   "Router": () => (/* binding */ Router),
/* harmony export */   "RouterProvider": () => (/* binding */ RouterProvider),
/* harmony export */   "Routes": () => (/* binding */ Routes),
/* harmony export */   "UNSAFE_DataRouterContext": () => (/* binding */ DataRouterContext),
/* harmony export */   "UNSAFE_DataRouterStateContext": () => (/* binding */ DataRouterStateContext),
/* harmony export */   "UNSAFE_LocationContext": () => (/* binding */ LocationContext),
/* harmony export */   "UNSAFE_NavigationContext": () => (/* binding */ NavigationContext),
/* harmony export */   "UNSAFE_RouteContext": () => (/* binding */ RouteContext),
/* harmony export */   "UNSAFE_enhanceManualRouteObjects": () => (/* binding */ enhanceManualRouteObjects),
/* harmony export */   "createMemoryRouter": () => (/* binding */ createMemoryRouter),
/* harmony export */   "createPath": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.createPath),
/* harmony export */   "createRoutesFromChildren": () => (/* binding */ createRoutesFromChildren),
/* harmony export */   "createRoutesFromElements": () => (/* binding */ createRoutesFromChildren),
/* harmony export */   "defer": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.defer),
/* harmony export */   "generatePath": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.generatePath),
/* harmony export */   "isRouteErrorResponse": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.isRouteErrorResponse),
/* harmony export */   "json": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.json),
/* harmony export */   "matchPath": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.matchPath),
/* harmony export */   "matchRoutes": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.matchRoutes),
/* harmony export */   "parsePath": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.parsePath),
/* harmony export */   "redirect": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.redirect),
/* harmony export */   "renderMatches": () => (/* binding */ renderMatches),
/* harmony export */   "resolvePath": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.resolvePath),
/* harmony export */   "unstable_useBlocker": () => (/* binding */ useBlocker),
/* harmony export */   "useActionData": () => (/* binding */ useActionData),
/* harmony export */   "useAsyncError": () => (/* binding */ useAsyncError),
/* harmony export */   "useAsyncValue": () => (/* binding */ useAsyncValue),
/* harmony export */   "useHref": () => (/* binding */ useHref),
/* harmony export */   "useInRouterContext": () => (/* binding */ useInRouterContext),
/* harmony export */   "useLoaderData": () => (/* binding */ useLoaderData),
/* harmony export */   "useLocation": () => (/* binding */ useLocation),
/* harmony export */   "useMatch": () => (/* binding */ useMatch),
/* harmony export */   "useMatches": () => (/* binding */ useMatches),
/* harmony export */   "useNavigate": () => (/* binding */ useNavigate),
/* harmony export */   "useNavigation": () => (/* binding */ useNavigation),
/* harmony export */   "useNavigationType": () => (/* binding */ useNavigationType),
/* harmony export */   "useOutlet": () => (/* binding */ useOutlet),
/* harmony export */   "useOutletContext": () => (/* binding */ useOutletContext),
/* harmony export */   "useParams": () => (/* binding */ useParams),
/* harmony export */   "useResolvedPath": () => (/* binding */ useResolvedPath),
/* harmony export */   "useRevalidator": () => (/* binding */ useRevalidator),
/* harmony export */   "useRouteError": () => (/* binding */ useRouteError),
/* harmony export */   "useRouteLoaderData": () => (/* binding */ useRouteLoaderData),
/* harmony export */   "useRoutes": () => (/* binding */ useRoutes)
/* harmony export */ });
/* harmony import */ var _remix_run_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @remix-run/router */ "./node_modules/@remix-run/router/dist/router.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/**
 * React Router v6.8.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */



function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */

function isPolyfill(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

const is = typeof Object.is === "function" ? Object.is : isPolyfill; // Intentionally not using named imports because Rollup uses dynamic
// dispatch for CommonJS interop named imports.

const {
  useState,
  useEffect,
  useLayoutEffect,
  useDebugValue
} = react__WEBPACK_IMPORTED_MODULE_1__;
let didWarnOld18Alpha = false;
let didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works
// because of a very particular set of implementation details and assumptions
// -- change any one of them and it will break. The most important assumption
// is that updates are always synchronous, because concurrent rendering is
// only available in versions of React that also have a built-in
// useSyncExternalStore API. And we only use this shim when the built-in API
// does not exist.
//
// Do not assume that the clever hacks used by this hook also work in general.
// The point of this shim is to replace the need for hacks by other libraries.

function useSyncExternalStore$2(subscribe, getSnapshot,
// Note: The shim does not use getServerSnapshot, because pre-18 versions of
// React do not expose a way to check if we're hydrating. So users of the shim
// will need to track that themselves and return the correct value
// from `getSnapshot`.
getServerSnapshot) {
  if (true) {
    if (!didWarnOld18Alpha) {
      if ("startTransition" in react__WEBPACK_IMPORTED_MODULE_1__) {
        didWarnOld18Alpha = true;
        console.error("You are using an outdated, pre-release alpha of React 18 that " + "does not support useSyncExternalStore. The " + "use-sync-external-store shim will not work correctly. Upgrade " + "to a newer pre-release.");
      }
    }
  } // Read the current snapshot from the store on every render. Again, this
  // breaks the rules of React, and only works here because of specific
  // implementation details, most importantly that updates are
  // always synchronous.

  const value = getSnapshot();
  if (true) {
    if (!didWarnUncachedGetSnapshot) {
      const cachedValue = getSnapshot();
      if (!is(value, cachedValue)) {
        console.error("The result of getSnapshot should be cached to avoid an infinite loop");
        didWarnUncachedGetSnapshot = true;
      }
    }
  } // Because updates are synchronous, we don't queue them. Instead we force a
  // re-render whenever the subscribed state changes by updating an some
  // arbitrary useState hook. Then, during render, we call getSnapshot to read
  // the current value.
  //
  // Because we don't actually use the state returned by the useState hook, we
  // can save a bit of memory by storing other stuff in that slot.
  //
  // To implement the early bailout, we need to track some things on a mutable
  // object. Usually, we would put that in a useRef hook, but we can stash it in
  // our useState hook instead.
  //
  // To force a re-render, we call forceUpdate({inst}). That works because the
  // new object always fails an equality check.

  const [{
    inst
  }, forceUpdate] = useState({
    inst: {
      value,
      getSnapshot
    }
  }); // Track the latest getSnapshot function with a ref. This needs to be updated
  // in the layout phase so we can access it during the tearing check that
  // happens on subscribe.

  useLayoutEffect(() => {
    inst.value = value;
    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the
    // commit phase if there was an interleaved mutation. In concurrent mode
    // this can happen all the time, but even in synchronous mode, an earlier
    // effect may have mutated the store.

    if (checkIfSnapshotChanged(inst)) {
      // Force a re-render.
      forceUpdate({
        inst
      });
    } // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [subscribe, value, getSnapshot]);
  useEffect(() => {
    // Check for changes right before subscribing. Subsequent changes will be
    // detected in the subscription handler.
    if (checkIfSnapshotChanged(inst)) {
      // Force a re-render.
      forceUpdate({
        inst
      });
    }
    const handleStoreChange = () => {
      // TODO: Because there is no cross-renderer API for batching updates, it's
      // up to the consumer of this library to wrap their subscription event
      // with unstable_batchedUpdates. Should we try to detect when this isn't
      // the case and print a warning in development?
      // The store changed. Check if the snapshot changed since the last time we
      // read from the store.
      if (checkIfSnapshotChanged(inst)) {
        // Force a re-render.
        forceUpdate({
          inst
        });
      }
    }; // Subscribe to the store and return a clean-up function.

    return subscribe(handleStoreChange); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [subscribe]);
  useDebugValue(value);
  return value;
}
function checkIfSnapshotChanged(inst) {
  const latestGetSnapshot = inst.getSnapshot;
  const prevValue = inst.value;
  try {
    const nextValue = latestGetSnapshot();
    return !is(prevValue, nextValue);
  } catch (error) {
    return true;
  }
}

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */
function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
  // Note: The shim does not use getServerSnapshot, because pre-18 versions of
  // React do not expose a way to check if we're hydrating. So users of the shim
  // will need to track that themselves and return the correct value
  // from `getSnapshot`.
  return getSnapshot();
}

/**
 * Inlined into the react-router repo since use-sync-external-store does not
 * provide a UMD-compatible package, so we need this to be able to distribute
 * UMD react-router bundles
 */
const canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const isServerEnvironment = !canUseDOM;
const shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
const useSyncExternalStore = "useSyncExternalStore" in react__WEBPACK_IMPORTED_MODULE_1__ ? (module => module.useSyncExternalStore)(react__WEBPACK_IMPORTED_MODULE_1__) : shim;
const DataRouterContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);
if (true) {
  DataRouterContext.displayName = "DataRouter";
}
const DataRouterStateContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);
if (true) {
  DataRouterStateContext.displayName = "DataRouterState";
}
const AwaitContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);
if (true) {
  AwaitContext.displayName = "Await";
}
const NavigationContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);
if (true) {
  NavigationContext.displayName = "Navigation";
}
const LocationContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);
if (true) {
  LocationContext.displayName = "Location";
}
const RouteContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createContext({
  outlet: null,
  matches: []
});
if (true) {
  RouteContext.displayName = "Route";
}
const RouteErrorContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);
if (true) {
  RouteErrorContext.displayName = "RouteError";
}

/**
 * Returns the full href for the given "to" value. This is useful for building
 * custom links that are also accessible and preserve right-click behavior.
 *
 * @see https://reactrouter.com/hooks/use-href
 */

function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false,
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useHref() may be used only in the context of a <Router> component.") : 0 : void 0;
  let {
    basename,
    navigator
  } = react__WEBPACK_IMPORTED_MODULE_1__.useContext(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname; // If we're operating within a basename, prepend it to the pathname prior
  // to creating the href.  If this is a root navigation, then just use the raw
  // basename which allows the basename to have full control over the presence
  // of a trailing slash on root links

  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.joinPaths)([basename, pathname]);
  }
  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
/**
 * Returns true if this component is a descendant of a <Router>.
 *
 * @see https://reactrouter.com/hooks/use-in-router-context
 */

function useInRouterContext() {
  return react__WEBPACK_IMPORTED_MODULE_1__.useContext(LocationContext) != null;
}
/**
 * Returns the current location object, which represents the current URL in web
 * browsers.
 *
 * Note: If you're using this it may mean you're doing some of your own
 * "routing" in your app, and we'd like to know what your use case is. We may
 * be able to provide something higher-level to better suit your needs.
 *
 * @see https://reactrouter.com/hooks/use-location
 */

function useLocation() {
  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false,
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useLocation() may be used only in the context of a <Router> component.") : 0 : void 0;
  return react__WEBPACK_IMPORTED_MODULE_1__.useContext(LocationContext).location;
}
/**
 * Returns the current navigation action which describes how the router came to
 * the current location, either by a pop, push, or replace on the history stack.
 *
 * @see https://reactrouter.com/hooks/use-navigation-type
 */

function useNavigationType() {
  return react__WEBPACK_IMPORTED_MODULE_1__.useContext(LocationContext).navigationType;
}
/**
 * Returns a PathMatch object if the given pattern matches the current URL.
 * This is useful for components that need to know "active" state, e.g.
 * <NavLink>.
 *
 * @see https://reactrouter.com/hooks/use-match
 */

function useMatch(pattern) {
  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false,
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useMatch() may be used only in the context of a <Router> component.") : 0 : void 0;
  let {
    pathname
  } = useLocation();
  return react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.matchPath)(pattern, pathname), [pathname, pattern]);
}
/**
 * The interface for the navigate() function returned from useNavigate().
 */

/**
 * Returns an imperative method for changing the location. Used by <Link>s, but
 * may also be used by other elements to change the location.
 *
 * @see https://reactrouter.com/hooks/use-navigate
 */
function useNavigate() {
  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false,
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useNavigate() may be used only in the context of a <Router> component.") : 0 : void 0;
  let {
    basename,
    navigator
  } = react__WEBPACK_IMPORTED_MODULE_1__.useContext(NavigationContext);
  let {
    matches
  } = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.UNSAFE_getPathContributingMatches)(matches).map(match => match.pathnameBase));
  let activeRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(false);
  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
    activeRef.current = true;
  });
  let navigate = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(function (to, options) {
    if (options === void 0) {
      options = {};
    }
     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.warning)(activeRef.current, "You should call navigate() in a React.useEffect(), not when " + "your component is first rendered.") : 0;
    if (!activeRef.current) return;
    if (typeof to === "number") {
      navigator.go(to);
      return;
    }
    let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path"); // If we're operating within a basename, prepend it to the pathname prior
    // to handing off to history.  If this is a root navigation, then we
    // navigate to the raw basename which allows the basename to have full
    // control over the presence of a trailing slash on root links

    if (basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.joinPaths)([basename, path.pathname]);
    }
    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);
  }, [basename, navigator, routePathnamesJson, locationPathname]);
  return navigate;
}
const OutletContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);
/**
 * Returns the context (if provided) for the child route at this level of the route
 * hierarchy.
 * @see https://reactrouter.com/hooks/use-outlet-context
 */

function useOutletContext() {
  return react__WEBPACK_IMPORTED_MODULE_1__.useContext(OutletContext);
}
/**
 * Returns the element for the child route at this level of the route
 * hierarchy. Used internally by <Outlet> to render child routes.
 *
 * @see https://reactrouter.com/hooks/use-outlet
 */

function useOutlet(context) {
  let outlet = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext).outlet;
  if (outlet) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(OutletContext.Provider, {
      value: context
    }, outlet);
  }
  return outlet;
}
/**
 * Returns an object of key/value pairs of the dynamic params from the current
 * URL that were matched by the route path.
 *
 * @see https://reactrouter.com/hooks/use-params
 */

function useParams() {
  let {
    matches
  } = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
/**
 * Resolves the pathname of the given `to` value against the current location.
 *
 * @see https://reactrouter.com/hooks/use-resolved-path
 */

function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    matches
  } = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.UNSAFE_getPathContributingMatches)(matches).map(match => match.pathnameBase));
  return react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
/**
 * Returns the element of the route that matched the current location, prepared
 * with the correct context to render the remainder of the route tree. Route
 * elements in the tree must render an <Outlet> to render their child route's
 * element.
 *
 * @see https://reactrouter.com/hooks/use-routes
 */

function useRoutes(routes, locationArg) {
  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false,
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useRoutes() may be used only in the context of a <Router> component.") : 0 : void 0;
  let {
    navigator
  } = react__WEBPACK_IMPORTED_MODULE_1__.useContext(NavigationContext);
  let dataRouterStateContext = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DataRouterStateContext);
  let {
    matches: parentMatches
  } = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  if (true) {
    // You won't get a warning about 2 different <Routes> under a <Route>
    // without a trailing *, but this is a best-effort warning anyway since we
    // cannot even give the warning unless they land at the parent route.
    //
    // Example:
    //
    // <Routes>
    //   {/* This route path MUST end with /* because otherwise
    //       it will never match /blog/post/123 */}
    //   <Route path="blog" element={<Blog />} />
    //   <Route path="blog/feed" element={<BlogFeed />} />
    // </Routes>
    //
    // function Blog() {
    //   return (
    //     <Routes>
    //       <Route path="post/:id" element={<Post />} />
    //     </Routes>
    //   );
    // }
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ("\"" + parentPathname + "\" (under <Route path=\"" + parentPath + "\">) but the ") + "parent route path has no trailing \"*\". This means if you navigate " + "deeper, the parent won't match anymore and therefore the child " + "routes will never render.\n\n" + ("Please change the parent <Route path=\"" + parentPath + "\"> to <Route ") + ("path=\"" + (parentPath === "/" ? "*" : parentPath + "/*") + "\">."));
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.parsePath)(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, " + "the location pathname must begin with the portion of the URL pathname that was " + ("matched by all parent routes. The current pathname base is \"" + parentPathnameBase + "\" ") + ("but pathname \"" + parsedLocationArg.pathname + "\" was given in the `location` prop.")) : 0 : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.matchRoutes)(routes, {
    pathname: remainingPathname
  });
  if (true) {
     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.warning)(parentRoute || matches != null, "No routes matched location \"" + location.pathname + location.search + location.hash + "\" ") : 0;
     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.warning)(matches == null || matches[matches.length - 1].route.element !== undefined, "Matched leaf route at location \"" + location.pathname + location.search + location.hash + "\" does not have an element. " + "This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.") : 0;
  }
  let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.joinPaths)([parentPathnameBase,
    // Re-encode pathnames that were decoded inside matchRoutes
    navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.joinPaths)([parentPathnameBase,
    // Re-encode pathnames that were decoded inside matchRoutes
    navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])
  })), parentMatches, dataRouterStateContext || undefined); // When a user passes in a `locationArg`, the associated routes need to
  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`
  // to use the scoped location instead of the global location.

  if (locationArg && renderedMatches) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(LocationContext.Provider, {
      value: {
        location: _extends({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorElement() {
  let error = useRouteError();
  let message = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.isRouteErrorResponse)(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  if (true) {
    devInfo = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("p", null, "\uD83D\uDCBF Hey developer \uD83D\uDC4B"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own\xA0", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("code", {
      style: codeStyles
    }, "errorElement"), " props on\xA0", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("code", {
      style: codeStyles
    }, "<Route>")));
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("h2", null, "Unexpected Application Error!"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
class RenderErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_1__.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error: error
    };
  }
  static getDerivedStateFromProps(props, state) {
    // When we get into an error state, the user will likely click "back" to the
    // previous page that didn't have an error. Because this wraps the entire
    // application, that will have no effect--the error page continues to display.
    // This gives us a mechanism to recover from the error when the location changes.
    //
    // Whether we're in an error state or not, we update the location in state
    // so that when we are in an error state, it gets reset when a new location
    // comes in and the user recovers from the error.
    if (state.location !== props.location) {
      return {
        error: props.error,
        location: props.location
      };
    } // If we're not changing locations, preserve the location but still surface
    // any new errors that may come through. We retain the existing error, we do
    // this because the error provided from the app state may be cleared without
    // the location changing.

    return {
      error: props.error || state.error,
      location: state.location
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match,
    children
  } = _ref;
  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DataRouterContext); // Track how deep we got in our render pass to emulate SSR componentDidCatch
  // in a DataStaticRouter

  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && match.route.errorElement) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null) {
    if (dataRouterState != null && dataRouterState.errors) {
      // Don't bail if we have data router errors so we can render them in the
      // boundary.  Use the pre-matched (or shimmed) matches
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches; // If we have data errors, trim matches to the highest error boundary

  let errors = dataRouterState == null ? void 0 : dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]));
    !(errorIndex >= 0) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, "Could not find a matching route for the current errors: " + errors) : 0 : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match, index) => {
    let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null; // Only data routers handle errors

    let errorElement = dataRouterState ? match.route.errorElement || /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(DefaultErrorElement, null) : null;
    let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));
    let getChildren = () => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(RenderedRoute, {
      match: match,
      routeContext: {
        outlet,
        matches
      }
    }, error ? errorElement : match.route.element !== undefined ? match.route.element : outlet); // Only wrap in an error boundary within data router usages when we have an
    // errorElement on this route.  Otherwise let it bubble up to an ancestor
    // errorElement

    return dataRouterState && (match.route.errorElement || index === 0) ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      component: errorElement,
      error: error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook;
(function (DataRouterHook) {
  DataRouterHook["UseBlocker"] = "useBlocker";
  DataRouterHook["UseRevalidator"] = "useRevalidator";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function (DataRouterStateHook) {
  DataRouterStateHook["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook["UseActionData"] = "useActionData";
  DataRouterStateHook["UseRouteError"] = "useRouteError";
  DataRouterStateHook["UseNavigation"] = "useNavigation";
  DataRouterStateHook["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook["UseMatches"] = "useMatches";
  DataRouterStateHook["UseRevalidator"] = "useRevalidator";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function getDataRouterConsoleError(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function useDataRouterContext(hookName) {
  let ctx = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DataRouterContext);
  !ctx ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DataRouterStateContext);
  !state ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext);
  !route ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, hookName + " can only be used on routes that contain a unique \"id\"") : 0 : void 0;
  return thisRoute.route.id;
}
/**
 * Returns the current navigation, defaulting to an "idle" navigation when
 * no navigation is in progress
 */

function useNavigation() {
  let state = useDataRouterState(DataRouterStateHook.UseNavigation);
  return state.navigation;
}
/**
 * Returns a revalidate function for manually triggering revalidation, as well
 * as the current state of any manual revalidations
 */

function useRevalidator() {
  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);
  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);
  return {
    revalidate: dataRouterContext.router.revalidate,
    state: state.revalidation
  };
}
/**
 * Returns the active route matches, useful for accessing loaderData for
 * parent/child routes or the route "handle" property
 */

function useMatches() {
  let {
    matches,
    loaderData
  } = useDataRouterState(DataRouterStateHook.UseMatches);
  return react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => matches.map(match => {
    let {
      pathname,
      params
    } = match; // Note: This structure matches that created by createUseMatchesMatch
    // in the @remix-run/router , so if you change this please also change
    // that :)  Eventually we'll DRY this up

    return {
      id: match.route.id,
      pathname,
      params,
      data: loaderData[match.route.id],
      handle: match.route.handle
    };
  }), [matches, loaderData]);
}
/**
 * Returns the loader data for the nearest ancestor Route loader
 */

function useLoaderData() {
  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);
  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);
  if (state.errors && state.errors[routeId] != null) {
    console.error("You cannot `useLoaderData` in an errorElement (routeId: " + routeId + ")");
    return undefined;
  }
  return state.loaderData[routeId];
}
/**
 * Returns the loaderData for the given routeId
 */

function useRouteLoaderData(routeId) {
  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);
  return state.loaderData[routeId];
}
/**
 * Returns the action data for the nearest ancestor Route action
 */

function useActionData() {
  let state = useDataRouterState(DataRouterStateHook.UseActionData);
  let route = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext);
  !route ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, "useActionData must be used inside a RouteContext") : 0 : void 0;
  return Object.values((state == null ? void 0 : state.actionData) || {})[0];
}
/**
 * Returns the nearest ancestor Route error, which could be a loader/action
 * error or a render error.  This is intended to be called from your
 * errorElement to display a proper error message.
 */

function useRouteError() {
  var _state$errors;
  let error = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError); // If this was a render error, we put it in a RouteError context inside
  // of RenderErrorBoundary

  if (error) {
    return error;
  } // Otherwise look for errors from our data router state

  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
/**
 * Returns the happy-path data from the nearest ancestor <Await /> value
 */

function useAsyncValue() {
  let value = react__WEBPACK_IMPORTED_MODULE_1__.useContext(AwaitContext);
  return value == null ? void 0 : value._data;
}
/**
 * Returns the error from the nearest ancestor <Await /> value
 */

function useAsyncError() {
  let value = react__WEBPACK_IMPORTED_MODULE_1__.useContext(AwaitContext);
  return value == null ? void 0 : value._error;
}
let blockerId = 0;
/**
 * Allow the application to block navigations within the SPA and present the
 * user a confirmation dialog to confirm the navigation.  Mostly used to avoid
 * using half-filled form data.  This does not handle hard-reloads or
 * cross-origin navigations.
 */

function useBlocker(shouldBlock) {
  let {
    router
  } = useDataRouterContext(DataRouterHook.UseBlocker);
  let [blockerKey] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => String(++blockerId));
  let blockerFunction = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(args => {
    return typeof shouldBlock === "function" ? !!shouldBlock(args) : !!shouldBlock;
  }, [shouldBlock]);
  let blocker = router.getBlocker(blockerKey, blockerFunction); // Cleanup on unmount

  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => () => router.deleteBlocker(blockerKey), [router, blockerKey]);
  return blocker;
}
const alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.warning)(false, message) : 0;
  }
}

/**
 * Given a Remix Router instance, render the appropriate UI
 */
function RouterProvider(_ref) {
  let {
    fallbackElement,
    router
  } = _ref;
  // Sync router state to our component state to force re-renders
  let state = useSyncExternalStore(router.subscribe, () => router.state,
  // We have to provide this so React@18 doesn't complain during hydration,
  // but we pass our serialized hydration data into the router so state here
  // is already synced with what the server saw
  () => router.state);
  let navigator = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {
    return {
      createHref: router.createHref,
      encodeLocation: router.encodeLocation,
      go: n => router.navigate(n),
      push: (to, state, opts) => router.navigate(to, {
        state,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      }),
      replace: (to, state, opts) => router.navigate(to, {
        replace: true,
        state,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      })
    };
  }, [router]);
  let basename = router.basename || "/"; // The fragment and {null} here are important!  We need them to keep React 18's
  // useId happy when we are server-rendering since we may have a <script> here
  // containing the hydrated server-side staticContext (from StaticRouterProvider).
  // useId relies on the component tree structure to generate deterministic id's
  // so we need to ensure it remains the same on the client even though
  // we don't need the <script> tag

  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(DataRouterContext.Provider, {
    value: {
      router,
      navigator,
      static: false,
      // Do we need this?
      basename
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(DataRouterStateContext.Provider, {
    value: state
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Router, {
    basename: router.basename,
    location: router.state.location,
    navigationType: router.state.historyAction,
    navigator: navigator
  }, router.state.initialized ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Routes, null) : fallbackElement))), null);
}

/**
 * A <Router> that stores all entries in memory.
 *
 * @see https://reactrouter.com/router-components/memory-router
 */
function MemoryRouter(_ref2) {
  let {
    basename,
    children,
    initialEntries,
    initialIndex
  } = _ref2;
  let historyRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef();
  if (historyRef.current == null) {
    historyRef.current = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.createMemoryHistory)({
      initialEntries,
      initialIndex,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setState] = react__WEBPACK_IMPORTED_MODULE_1__.useState({
    action: history.action,
    location: history.location
  });
  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => history.listen(setState), [history]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}

/**
 * Changes the current location.
 *
 * Note: This API is mostly useful in React.Component subclasses that are not
 * able to use hooks. In functional components, we recommend you use the
 * `useNavigate` hook instead.
 *
 * @see https://reactrouter.com/components/navigate
 */
function Navigate(_ref3) {
  let {
    to,
    replace,
    state,
    relative
  } = _ref3;
  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false,
  // TODO: This error is probably because they somehow have 2 versions of
  // the router loaded. We can help them understand how to avoid that.
  "<Navigate> may be used only in the context of a <Router> component.") : 0 : void 0;
   true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.warning)(!react__WEBPACK_IMPORTED_MODULE_1__.useContext(NavigationContext).static, "<Navigate> must not be used on the initial render in a <StaticRouter>. " + "This is a no-op, but you should modify your code so the <Navigate> is " + "only ever rendered in response to some user interaction or state change.") : 0;
  let dataRouterState = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DataRouterStateContext);
  let navigate = useNavigate();
  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
    // Avoid kicking off multiple navigations if we're in the middle of a
    // data-router navigation, since components get re-rendered when we enter
    // a submitting/loading state
    if (dataRouterState && dataRouterState.navigation.state !== "idle") {
      return;
    }
    navigate(to, {
      replace,
      state,
      relative
    });
  });
  return null;
}

/**
 * Renders the child route's element, if there is one.
 *
 * @see https://reactrouter.com/components/outlet
 */
function Outlet(props) {
  return useOutlet(props.context);
}

/**
 * Declares an element that should be rendered at a certain URL path.
 *
 * @see https://reactrouter.com/components/route
 */
function Route(_props) {
   true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, "A <Route> is only ever to be used as the child of <Routes> element, " + "never rendered directly. Please wrap your <Route> in a <Routes>.") : 0;
}

/**
 * Provides location context for the rest of the app.
 *
 * Note: You usually won't render a <Router> directly. Instead, you'll render a
 * router that is more specific to your environment such as a <BrowserRouter>
 * in web browsers or a <StaticRouter> for server rendering.
 *
 * @see https://reactrouter.com/router-components/router
 */
function Router(_ref4) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.Action.Pop,
    navigator,
    static: staticProp = false
  } = _ref4;
  !!useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, "You cannot render a <Router> inside another <Router>." + " You should never have more than one in your app.") : 0 : void 0; // Preserve trailing slashes on basename, so we can let the user control
  // the enforcement of trailing slashes throughout the app

  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => ({
    basename,
    navigator,
    static: staticProp
  }), [basename, navigator, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.parsePath)(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let location = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {
    let trailingPathname = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.stripBasename)(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
    };
  }, [basename, pathname, search, hash, state, key]);
   true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.warning)(location != null, "<Router basename=\"" + basename + "\"> is not able to match the URL " + ("\"" + pathname + search + hash + "\" because it does not start with the ") + "basename, so the <Router> won't render anything.") : 0;
  if (location == null) {
    return null;
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(LocationContext.Provider, {
    children: children,
    value: {
      location,
      navigationType
    }
  }));
}

/**
 * A container for a nested tree of <Route> elements that renders the branch
 * that best matches the current location.
 *
 * @see https://reactrouter.com/components/routes
 */
function Routes(_ref5) {
  let {
    children,
    location
  } = _ref5;
  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DataRouterContext); // When in a DataRouterContext _without_ children, we use the router routes
  // directly.  If we have children, then we're in a descendant tree and we
  // need to use child routes.

  let routes = dataRouterContext && !children ? dataRouterContext.router.routes : createRoutesFromChildren(children);
  return useRoutes(routes, location);
}

/**
 * Component to use for rendering lazily loaded data from returning defer()
 * in a loader function
 */
function Await(_ref6) {
  let {
    children,
    errorElement,
    resolve
  } = _ref6;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(AwaitErrorBoundary, {
    resolve: resolve,
    errorElement: errorElement
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(ResolveAwait, null, children));
}
var AwaitRenderStatus;
(function (AwaitRenderStatus) {
  AwaitRenderStatus[AwaitRenderStatus["pending"] = 0] = "pending";
  AwaitRenderStatus[AwaitRenderStatus["success"] = 1] = "success";
  AwaitRenderStatus[AwaitRenderStatus["error"] = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));
const neverSettledPromise = new Promise(() => {});
class AwaitErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_1__.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: null
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("<Await> caught the following error during render", error, errorInfo);
  }
  render() {
    let {
      children,
      errorElement,
      resolve
    } = this.props;
    let promise = null;
    let status = AwaitRenderStatus.pending;
    if (!(resolve instanceof Promise)) {
      // Didn't get a promise - provide as a resolved promise
      status = AwaitRenderStatus.success;
      promise = Promise.resolve();
      Object.defineProperty(promise, "_tracked", {
        get: () => true
      });
      Object.defineProperty(promise, "_data", {
        get: () => resolve
      });
    } else if (this.state.error) {
      // Caught a render error, provide it as a rejected promise
      status = AwaitRenderStatus.error;
      let renderError = this.state.error;
      promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings

      Object.defineProperty(promise, "_tracked", {
        get: () => true
      });
      Object.defineProperty(promise, "_error", {
        get: () => renderError
      });
    } else if (resolve._tracked) {
      // Already tracked promise - check contents
      promise = resolve;
      status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;
    } else {
      // Raw (untracked) promise - track it
      status = AwaitRenderStatus.pending;
      Object.defineProperty(resolve, "_tracked", {
        get: () => true
      });
      promise = resolve.then(data => Object.defineProperty(resolve, "_data", {
        get: () => data
      }), error => Object.defineProperty(resolve, "_error", {
        get: () => error
      }));
    }
    if (status === AwaitRenderStatus.error && promise._error instanceof _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.AbortedDeferredError) {
      // Freeze the UI by throwing a never resolved promise
      throw neverSettledPromise;
    }
    if (status === AwaitRenderStatus.error && !errorElement) {
      // No errorElement, throw to the nearest route-level error boundary
      throw promise._error;
    }
    if (status === AwaitRenderStatus.error) {
      // Render via our errorElement
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(AwaitContext.Provider, {
        value: promise,
        children: errorElement
      });
    }
    if (status === AwaitRenderStatus.success) {
      // Render children with resolved value
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(AwaitContext.Provider, {
        value: promise,
        children: children
      });
    } // Throw to the suspense boundary

    throw promise;
  }
}
/**
 * @private
 * Indirection to leverage useAsyncValue for a render-prop API on <Await>
 */

function ResolveAwait(_ref7) {
  let {
    children
  } = _ref7;
  let data = useAsyncValue();
  let toRender = typeof children === "function" ? children(data) : children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, toRender);
} ///////////////////////////////////////////////////////////////////////////////
// UTILS
///////////////////////////////////////////////////////////////////////////////

/**
 * Creates a route config from a React "children" object, which is usually
 * either a `<Route>` element or an array of them. Used internally by
 * `<Routes>` to create a route config from its children.
 *
 * @see https://reactrouter.com/utils/create-routes-from-children
 */

function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  react__WEBPACK_IMPORTED_MODULE_1__.Children.forEach(children, (element, index) => {
    if (! /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.isValidElement(element)) {
      // Ignore non-elements. This allows people to more easily inline
      // conditionals in their route config.
      return;
    }
    if (element.type === react__WEBPACK_IMPORTED_MODULE_1__.Fragment) {
      // Transparently support React.Fragment and its children.
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, parentPath));
      return;
    }
    !(element.type === Route) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, "[" + (typeof element.type === "string" ? element.type : element.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : 0 : void 0;
    !(!element.props.index || !element.props.children) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, "An index route cannot have child routes.") : 0 : void 0;
    let treePath = [...parentPath, index];
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      hasErrorBoundary: element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
/**
 * Renders the result of `matchRoutes()` into a React element.
 */

function renderMatches(matches) {
  return _renderMatches(matches);
}
/**
 * @private
 * Walk the route tree and add hasErrorBoundary if it's not provided, so that
 * users providing manual route arrays can just specify errorElement
 */

function enhanceManualRouteObjects(routes) {
  return routes.map(route => {
    let routeClone = _extends({}, route);
    if (routeClone.hasErrorBoundary == null) {
      routeClone.hasErrorBoundary = routeClone.errorElement != null;
    }
    if (routeClone.children) {
      routeClone.children = enhanceManualRouteObjects(routeClone.children);
    }
    return routeClone;
  });
}
function createMemoryRouter(routes, opts) {
  return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.createRouter)({
    basename: opts == null ? void 0 : opts.basename,
    history: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.createMemoryHistory)({
      initialEntries: opts == null ? void 0 : opts.initialEntries,
      initialIndex: opts == null ? void 0 : opts.initialIndex
    }),
    hydrationData: opts == null ? void 0 : opts.hydrationData,
    routes: enhanceManualRouteObjects(routes)
  }).initialize();
} ///////////////////////////////////////////////////////////////////////////////



/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function () {
    'use strict';

    var React = __webpack_require__(/*! react */ "react");

    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types.
    var REACT_ELEMENT_TYPE = Symbol.for('react.element');
    var REACT_PORTAL_TYPE = Symbol.for('react.portal');
    var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
    var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
    var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
    var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
    var REACT_CONTEXT_TYPE = Symbol.for('react.context');
    var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
    var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
    var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
    var REACT_MEMO_TYPE = Symbol.for('react.memo');
    var REACT_LAZY_TYPE = Symbol.for('react.lazy');
    var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';
    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable !== 'object') {
        return null;
      }
      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
      if (typeof maybeIterator === 'function') {
        return maybeIterator;
      }
      return null;
    }
    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function error(format) {
      {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          printWarning('error', format, args);
        }
      }
    }
    function printWarning(level, format, args) {
      // When changing this logic, you might want to also
      // update consoleWithStackDev.www.js as well.
      {
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();
        if (stack !== '') {
          format += '%s';
          args = args.concat([stack]);
        } // eslint-disable-next-line react-internal/safe-string-coercion

        var argsWithFormat = args.map(function (item) {
          return String(item);
        }); // Careful: RN currently depends on this prefix

        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
        // breaks IE9: https://github.com/facebook/react/issues/13610
        // eslint-disable-next-line react-internal/no-production-logging

        Function.prototype.apply.call(console[level], console, argsWithFormat);
      }
    }

    // -----------------------------------------------------------------------------

    var enableScopeAPI = false; // Experimental Create Event Handle API.
    var enableCacheElement = false;
    var enableTransitionTracing = false; // No known bugs, but needs performance testing

    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
    // stuff. Intended to enable React core members to more easily debug scheduling
    // issues in DEV builds.

    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

    var REACT_MODULE_REFERENCE;
    {
      REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
    }
    function isValidElementType(type) {
      if (typeof type === 'string' || typeof type === 'function') {
        return true;
      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).

      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
        return true;
      }
      if (typeof type === 'object' && type !== null) {
        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||
        // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
          return true;
        }
      }
      return false;
    }
    function getWrappedName(outerType, innerType, wrapperName) {
      var displayName = outerType.displayName;
      if (displayName) {
        return displayName;
      }
      var functionName = innerType.displayName || innerType.name || '';
      return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
    } // Keep in sync with react-reconciler/getComponentNameFromFiber

    function getContextName(type) {
      return type.displayName || 'Context';
    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.

    function getComponentNameFromType(type) {
      if (type == null) {
        // Host root, text node or just invalid type.
        return null;
      }
      {
        if (typeof type.tag === 'number') {
          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
        }
      }
      if (typeof type === 'function') {
        return type.displayName || type.name || null;
      }
      if (typeof type === 'string') {
        return type;
      }
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return 'Fragment';
        case REACT_PORTAL_TYPE:
          return 'Portal';
        case REACT_PROFILER_TYPE:
          return 'Profiler';
        case REACT_STRICT_MODE_TYPE:
          return 'StrictMode';
        case REACT_SUSPENSE_TYPE:
          return 'Suspense';
        case REACT_SUSPENSE_LIST_TYPE:
          return 'SuspenseList';
      }
      if (typeof type === 'object') {
        switch (type.$$typeof) {
          case REACT_CONTEXT_TYPE:
            var context = type;
            return getContextName(context) + '.Consumer';
          case REACT_PROVIDER_TYPE:
            var provider = type;
            return getContextName(provider._context) + '.Provider';
          case REACT_FORWARD_REF_TYPE:
            return getWrappedName(type, type.render, 'ForwardRef');
          case REACT_MEMO_TYPE:
            var outerName = type.displayName || null;
            if (outerName !== null) {
              return outerName;
            }
            return getComponentNameFromType(type.type) || 'Memo';
          case REACT_LAZY_TYPE:
            {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }

          // eslint-disable-next-line no-fallthrough
        }
      }

      return null;
    }
    var assign = Object.assign;

    // Helpers to patch console.logs to avoid logging during side-effect free
    // replaying on render function. This currently only patches the object
    // lazily which won't cover if the log function was extracted eagerly.
    // We could also eagerly patch the method.
    var disabledDepth = 0;
    var prevLog;
    var prevInfo;
    var prevWarn;
    var prevError;
    var prevGroup;
    var prevGroupCollapsed;
    var prevGroupEnd;
    function disabledLog() {}
    disabledLog.__reactDisabledLog = true;
    function disableLogs() {
      {
        if (disabledDepth === 0) {
          /* eslint-disable react-internal/no-production-logging */
          prevLog = console.log;
          prevInfo = console.info;
          prevWarn = console.warn;
          prevError = console.error;
          prevGroup = console.group;
          prevGroupCollapsed = console.groupCollapsed;
          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

          var props = {
            configurable: true,
            enumerable: true,
            value: disabledLog,
            writable: true
          }; // $FlowFixMe Flow thinks console is immutable.

          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
          /* eslint-enable react-internal/no-production-logging */
        }

        disabledDepth++;
      }
    }
    function reenableLogs() {
      {
        disabledDepth--;
        if (disabledDepth === 0) {
          /* eslint-disable react-internal/no-production-logging */
          var props = {
            configurable: true,
            enumerable: true,
            writable: true
          }; // $FlowFixMe Flow thinks console is immutable.

          Object.defineProperties(console, {
            log: assign({}, props, {
              value: prevLog
            }),
            info: assign({}, props, {
              value: prevInfo
            }),
            warn: assign({}, props, {
              value: prevWarn
            }),
            error: assign({}, props, {
              value: prevError
            }),
            group: assign({}, props, {
              value: prevGroup
            }),
            groupCollapsed: assign({}, props, {
              value: prevGroupCollapsed
            }),
            groupEnd: assign({}, props, {
              value: prevGroupEnd
            })
          });
          /* eslint-enable react-internal/no-production-logging */
        }

        if (disabledDepth < 0) {
          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
        }
      }
    }
    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
    var prefix;
    function describeBuiltInComponentFrame(name, source, ownerFn) {
      {
        if (prefix === undefined) {
          // Extract the VM specific prefix used by each line.
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || '';
          }
        } // We use the prefix to ensure our stacks line up with native stack frames.

        return '\n' + prefix + name;
      }
    }
    var reentry = false;
    var componentFrameCache;
    {
      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
      componentFrameCache = new PossiblyWeakMap();
    }
    function describeNativeComponentFrame(fn, construct) {
      // If something asked for a stack inside a fake render, it should get ignored.
      if (!fn || reentry) {
        return '';
      }
      {
        var frame = componentFrameCache.get(fn);
        if (frame !== undefined) {
          return frame;
        }
      }
      var control;
      reentry = true;
      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

      Error.prepareStackTrace = undefined;
      var previousDispatcher;
      {
        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
        // for warnings.

        ReactCurrentDispatcher.current = null;
        disableLogs();
      }
      try {
        // This should throw.
        if (construct) {
          // Something should be setting the props in the constructor.
          var Fake = function () {
            throw Error();
          }; // $FlowFixMe

          Object.defineProperty(Fake.prototype, 'props', {
            set: function () {
              // We use a throwing setter instead of frozen or non-writable props
              // because that won't throw in a non-strict mode function.
              throw Error();
            }
          });
          if (typeof Reflect === 'object' && Reflect.construct) {
            // We construct a different control for this case to include any extra
            // frames added by the construct call.
            try {
              Reflect.construct(Fake, []);
            } catch (x) {
              control = x;
            }
            Reflect.construct(fn, [], Fake);
          } else {
            try {
              Fake.call();
            } catch (x) {
              control = x;
            }
            fn.call(Fake.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (x) {
            control = x;
          }
          fn();
        }
      } catch (sample) {
        // This is inlined manually because closure doesn't do it for us.
        if (sample && control && typeof sample.stack === 'string') {
          // This extracts the first frame from the sample that isn't also in the control.
          // Skipping one frame that we assume is the frame that calls the two.
          var sampleLines = sample.stack.split('\n');
          var controlLines = control.stack.split('\n');
          var s = sampleLines.length - 1;
          var c = controlLines.length - 1;
          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
            // We expect at least one stack frame to be shared.
            // Typically this will be the root most one. However, stack frames may be
            // cut off due to maximum stack limits. In this case, one maybe cut off
            // earlier than the other. We assume that the sample is longer or the same
            // and there for cut off earlier. So we should find the root most frame in
            // the sample somewhere in the control.
            c--;
          }
          for (; s >= 1 && c >= 0; s--, c--) {
            // Next we find the first one that isn't the same which should be the
            // frame that called our sample function and the control.
            if (sampleLines[s] !== controlLines[c]) {
              // In V8, the first line is describing the message but other VMs don't.
              // If we're about to return the first line, and the control is also on the same
              // line, that's a pretty good indicator that our sample threw at same line as
              // the control. I.e. before we entered the sample frame. So we ignore this result.
              // This can happen if you passed a class to function component, or non-function.
              if (s !== 1 || c !== 1) {
                do {
                  s--;
                  c--; // We may still have similar intermediate frames from the construct call.
                  // The next one that isn't the same should be our match though.

                  if (c < 0 || sampleLines[s] !== controlLines[c]) {
                    // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                    var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
                    // but we have a user-provided "displayName"
                    // splice it in to make the stack more readable.

                    if (fn.displayName && _frame.includes('<anonymous>')) {
                      _frame = _frame.replace('<anonymous>', fn.displayName);
                    }
                    {
                      if (typeof fn === 'function') {
                        componentFrameCache.set(fn, _frame);
                      }
                    } // Return the line we found.

                    return _frame;
                  }
                } while (s >= 1 && c >= 0);
              }
              break;
            }
          }
        }
      } finally {
        reentry = false;
        {
          ReactCurrentDispatcher.current = previousDispatcher;
          reenableLogs();
        }
        Error.prepareStackTrace = previousPrepareStackTrace;
      } // Fallback to just using the name if we couldn't make it throw.

      var name = fn ? fn.displayName || fn.name : '';
      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
      {
        if (typeof fn === 'function') {
          componentFrameCache.set(fn, syntheticFrame);
        }
      }
      return syntheticFrame;
    }
    function describeFunctionComponentFrame(fn, source, ownerFn) {
      {
        return describeNativeComponentFrame(fn, false);
      }
    }
    function shouldConstruct(Component) {
      var prototype = Component.prototype;
      return !!(prototype && prototype.isReactComponent);
    }
    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
      if (type == null) {
        return '';
      }
      if (typeof type === 'function') {
        {
          return describeNativeComponentFrame(type, shouldConstruct(type));
        }
      }
      if (typeof type === 'string') {
        return describeBuiltInComponentFrame(type);
      }
      switch (type) {
        case REACT_SUSPENSE_TYPE:
          return describeBuiltInComponentFrame('Suspense');
        case REACT_SUSPENSE_LIST_TYPE:
          return describeBuiltInComponentFrame('SuspenseList');
      }
      if (typeof type === 'object') {
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            return describeFunctionComponentFrame(type.render);
          case REACT_MEMO_TYPE:
            // Memo may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
          case REACT_LAZY_TYPE:
            {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                // Lazy may contain any component type so we recursively resolve it.
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {}
            }
        }
      }
      return '';
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var loggedTypeFailures = {};
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement(element) {
      {
        if (element) {
          var owner = element._owner;
          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame.setExtraStackFrame(stack);
        } else {
          ReactDebugCurrentFrame.setExtraStackFrame(null);
        }
      }
    }
    function checkPropTypes(typeSpecs, values, location, componentName, element) {
      {
        // $FlowFixMe This is okay but Flow doesn't know it.
        var has = Function.call.bind(hasOwnProperty);
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
            // fail the render phase where it didn't fail before. So we log it.
            // After these have been cleaned up, we'll let them throw.

            try {
              // This is intentionally an invariant that gets caught. It's the same
              // behavior as without this statement except with a better message.
              if (typeof typeSpecs[typeSpecName] !== 'function') {
                // eslint-disable-next-line react-internal/prod-error-codes
                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                err.name = 'Invariant Violation';
                throw err;
              }
              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
            } catch (ex) {
              error$1 = ex;
            }
            if (error$1 && !(error$1 instanceof Error)) {
              setCurrentlyValidatingElement(element);
              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);
              setCurrentlyValidatingElement(null);
            }
            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
              // Only monitor this failure once because there tends to be a lot of the
              // same error.
              loggedTypeFailures[error$1.message] = true;
              setCurrentlyValidatingElement(element);
              error('Failed %s type: %s', location, error$1.message);
              setCurrentlyValidatingElement(null);
            }
          }
        }
      }
    }
    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

    function isArray(a) {
      return isArrayImpl(a);
    }

    /*
     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
     *
     * The functions in this module will throw an easier-to-understand,
     * easier-to-debug exception with a clear errors message message explaining the
     * problem. (Instead of a confusing exception thrown inside the implementation
     * of the `value` object).
     */
    // $FlowFixMe only called in DEV, so void return is not possible.
    function typeName(value) {
      {
        // toStringTag is needed for namespaced types like Temporal.Instant
        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
        return type;
      }
    } // $FlowFixMe only called in DEV, so void return is not possible.

    function willCoercionThrow(value) {
      {
        try {
          testStringCoercion(value);
          return false;
        } catch (e) {
          return true;
        }
      }
    }
    function testStringCoercion(value) {
      // If you ended up here by following an exception call stack, here's what's
      // happened: you supplied an object or symbol value to React (as a prop, key,
      // DOM attribute, CSS property, string ref, etc.) and when React tried to
      // coerce it to a string using `'' + value`, an exception was thrown.
      //
      // The most common types that will cause this exception are `Symbol` instances
      // and Temporal objects like `Temporal.Instant`. But any object that has a
      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
      // exception. (Library authors do this to prevent users from using built-in
      // numeric operators like `+` or comparison operators like `>=` because custom
      // methods are needed to perform accurate arithmetic or comparison.)
      //
      // To fix the problem, coerce this object or symbol value to a string before
      // passing it to React. The most reliable way is usually `String(value)`.
      //
      // To find which value is throwing, check the browser or debugger console.
      // Before this exception was thrown, there should be `console.error` output
      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
      // problem and how that type was used: key, atrribute, input value prop, etc.
      // In most cases, this console output also shows the component and its
      // ancestor components where the exception happened.
      //
      // eslint-disable-next-line react-internal/safe-string-coercion
      return '' + value;
    }
    function checkKeyStringCoercion(value) {
      {
        if (willCoercionThrow(value)) {
          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
        }
      }
    }

    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };
    var specialPropKeyWarningShown;
    var specialPropRefWarningShown;
    var didWarnAboutStringRefs;
    {
      didWarnAboutStringRefs = {};
    }
    function hasValidRef(config) {
      {
        if (hasOwnProperty.call(config, 'ref')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.ref !== undefined;
    }
    function hasValidKey(config) {
      {
        if (hasOwnProperty.call(config, 'key')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.key !== undefined;
    }
    function warnIfStringRefCannotBeAutoConverted(config, self) {
      {
        if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
          if (!didWarnAboutStringRefs[componentName]) {
            error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
            didWarnAboutStringRefs[componentName] = true;
          }
        }
      }
    }
    function defineKeyPropWarningGetter(props, displayName) {
      {
        var warnAboutAccessingKey = function () {
          if (!specialPropKeyWarningShown) {
            specialPropKeyWarningShown = true;
            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
          }
        };
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, 'key', {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
    }
    function defineRefPropWarningGetter(props, displayName) {
      {
        var warnAboutAccessingRef = function () {
          if (!specialPropRefWarningShown) {
            specialPropRefWarningShown = true;
            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
          }
        };
        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, 'ref', {
          get: warnAboutAccessingRef,
          configurable: true
        });
      }
    }
    /**
     * Factory method to create a new React element. This no longer adheres to
     * the class pattern, so do not use new to call it. Also, instanceof check
     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
     * if something is a React Element.
     *
     * @param {*} type
     * @param {*} props
     * @param {*} key
     * @param {string|object} ref
     * @param {*} owner
     * @param {*} self A *temporary* helper to detect places where `this` is
     * different from the `owner` when React.createElement is called, so that we
     * can warn. We want to get rid of owner and replace string `ref`s with arrow
     * functions, and as long as `this` and owner are the same, there will be no
     * change in behavior.
     * @param {*} source An annotation object (added by a transpiler or otherwise)
     * indicating filename, line number, and/or other information.
     * @internal
     */

    var ReactElement = function (type, key, ref, self, source, owner, props) {
      var element = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: REACT_ELEMENT_TYPE,
        // Built-in properties that belong on the element
        type: type,
        key: key,
        ref: ref,
        props: props,
        // Record the component responsible for creating this element.
        _owner: owner
      };
      {
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.

        Object.defineProperty(element._store, 'validated', {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        }); // self and source are DEV only properties.

        Object.defineProperty(element, '_self', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        }); // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.

        Object.defineProperty(element, '_source', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });
        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }
      return element;
    };
    /**
     * https://github.com/reactjs/rfcs/pull/107
     * @param {*} type
     * @param {object} props
     * @param {string} key
     */

    function jsxDEV(type, config, maybeKey, source, self) {
      {
        var propName; // Reserved names are extracted

        var props = {};
        var key = null;
        var ref = null; // Currently, key can be spread in as a prop. This causes a potential
        // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
        // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
        // but as an intermediary step, we will use jsxDEV for everything except
        // <div {...props} key="Hi" />, because we aren't currently able to tell if
        // key is explicitly declared to be undefined or not.

        if (maybeKey !== undefined) {
          {
            checkKeyStringCoercion(maybeKey);
          }
          key = '' + maybeKey;
        }
        if (hasValidKey(config)) {
          {
            checkKeyStringCoercion(config.key);
          }
          key = '' + config.key;
        }
        if (hasValidRef(config)) {
          ref = config.ref;
          warnIfStringRefCannotBeAutoConverted(config, self);
        } // Remaining properties are added to a new props object

        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        } // Resolve default props

        if (type && type.defaultProps) {
          var defaultProps = type.defaultProps;
          for (propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
        }
        if (key || ref) {
          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
          if (key) {
            defineKeyPropWarningGetter(props, displayName);
          }
          if (ref) {
            defineRefPropWarningGetter(props, displayName);
          }
        }
        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
      }
    }
    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement$1(element) {
      {
        if (element) {
          var owner = element._owner;
          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else {
          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
        }
      }
    }
    var propTypesMisspellWarningShown;
    {
      propTypesMisspellWarningShown = false;
    }
    /**
     * Verifies the object is a ReactElement.
     * See https://reactjs.org/docs/react-api.html#isvalidelement
     * @param {?object} object
     * @return {boolean} True if `object` is a ReactElement.
     * @final
     */

    function isValidElement(object) {
      {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
    }
    function getDeclarationErrorAddendum() {
      {
        if (ReactCurrentOwner$1.current) {
          var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
          if (name) {
            return '\n\nCheck the render method of `' + name + '`.';
          }
        }
        return '';
      }
    }
    function getSourceInfoErrorAddendum(source) {
      {
        if (source !== undefined) {
          var fileName = source.fileName.replace(/^.*[\\\/]/, '');
          var lineNumber = source.lineNumber;
          return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
        }
        return '';
      }
    }
    /**
     * Warn if there's no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */

    var ownerHasKeyUseWarning = {};
    function getCurrentComponentErrorInfo(parentType) {
      {
        var info = getDeclarationErrorAddendum();
        if (!info) {
          var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
          if (parentName) {
            info = "\n\nCheck the top-level render call using <" + parentName + ">.";
          }
        }
        return info;
      }
    }
    /**
     * Warn if the element doesn't have an explicit key assigned to it.
     * This element is in an array. The array could grow and shrink or be
     * reordered. All children that haven't already been validated are required to
     * have a "key" property assigned to it. Error statuses are cached so a warning
     * will only be shown once.
     *
     * @internal
     * @param {ReactElement} element Element that requires a key.
     * @param {*} parentType element's parent's type.
     */

    function validateExplicitKey(element, parentType) {
      {
        if (!element._store || element._store.validated || element.key != null) {
          return;
        }
        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
          return;
        }
        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
        // property, it may be the creator of the child that's responsible for
        // assigning it a key.

        var childOwner = '';
        if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
          // Give the component that originally created this child.
          childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
        }
        setCurrentlyValidatingElement$1(element);
        error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
        setCurrentlyValidatingElement$1(null);
      }
    }
    /**
     * Ensure that every element either is passed in a static location, in an
     * array with an explicit keys property defined, or in an object literal
     * with valid key property.
     *
     * @internal
     * @param {ReactNode} node Statically passed child of any type.
     * @param {*} parentType node's parent's type.
     */

    function validateChildKeys(node, parentType) {
      {
        if (typeof node !== 'object') {
          return;
        }
        if (isArray(node)) {
          for (var i = 0; i < node.length; i++) {
            var child = node[i];
            if (isValidElement(child)) {
              validateExplicitKey(child, parentType);
            }
          }
        } else if (isValidElement(node)) {
          // This element was passed in a valid location.
          if (node._store) {
            node._store.validated = true;
          }
        } else if (node) {
          var iteratorFn = getIteratorFn(node);
          if (typeof iteratorFn === 'function') {
            // Entry iterators used to provide implicit keys,
            // but now we print a separate warning for them later.
            if (iteratorFn !== node.entries) {
              var iterator = iteratorFn.call(node);
              var step;
              while (!(step = iterator.next()).done) {
                if (isValidElement(step.value)) {
                  validateExplicitKey(step.value, parentType);
                }
              }
            }
          }
        }
      }
    }
    /**
     * Given an element, validate that its props follow the propTypes definition,
     * provided by the type.
     *
     * @param {ReactElement} element
     */

    function validatePropTypes(element) {
      {
        var type = element.type;
        if (type === null || type === undefined || typeof type === 'string') {
          return;
        }
        var propTypes;
        if (typeof type === 'function') {
          propTypes = type.propTypes;
        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE ||
        // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        type.$$typeof === REACT_MEMO_TYPE)) {
          propTypes = type.propTypes;
        } else {
          return;
        }
        if (propTypes) {
          // Intentionally inside to avoid triggering lazy initializers:
          var name = getComponentNameFromType(type);
          checkPropTypes(propTypes, element.props, 'prop', name, element);
        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

          var _name = getComponentNameFromType(type);
          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
        }
        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
        }
      }
    }
    /**
     * Given a fragment, validate that it can only be provided with fragment props
     * @param {ReactElement} fragment
     */

    function validateFragmentProps(fragment) {
      {
        var keys = Object.keys(fragment.props);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (key !== 'children' && key !== 'key') {
            setCurrentlyValidatingElement$1(fragment);
            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
            setCurrentlyValidatingElement$1(null);
            break;
          }
        }
        if (fragment.ref !== null) {
          setCurrentlyValidatingElement$1(fragment);
          error('Invalid attribute `ref` supplied to `React.Fragment`.');
          setCurrentlyValidatingElement$1(null);
        }
      }
    }
    function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
      {
        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
        // succeed and there will likely be errors in render.

        if (!validType) {
          var info = '';
          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
            info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
          }
          var sourceInfo = getSourceInfoErrorAddendum(source);
          if (sourceInfo) {
            info += sourceInfo;
          } else {
            info += getDeclarationErrorAddendum();
          }
          var typeString;
          if (type === null) {
            typeString = 'null';
          } else if (isArray(type)) {
            typeString = 'array';
          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
            typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
            info = ' Did you accidentally export a JSX literal instead of a component?';
          } else {
            typeString = typeof type;
          }
          error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
        }
        var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
        // TODO: Drop this when these are no longer allowed as the type argument.

        if (element == null) {
          return element;
        } // Skip key warning if the type isn't valid since our key validation logic
        // doesn't expect a non-string/function type and can throw confusing errors.
        // We don't want exception behavior to differ between dev and prod.
        // (Rendering will throw with a helpful message and as soon as the type is
        // fixed, the key warnings will appear.)

        if (validType) {
          var children = props.children;
          if (children !== undefined) {
            if (isStaticChildren) {
              if (isArray(children)) {
                for (var i = 0; i < children.length; i++) {
                  validateChildKeys(children[i], type);
                }
                if (Object.freeze) {
                  Object.freeze(children);
                }
              } else {
                error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
              }
            } else {
              validateChildKeys(children, type);
            }
          }
        }
        if (type === REACT_FRAGMENT_TYPE) {
          validateFragmentProps(element);
        } else {
          validatePropTypes(element);
        }
        return element;
      }
    } // These two functions exist to still get child warnings in dev
    // even with the prod transform. This means that jsxDEV is purely
    // opt-in behavior for better messages but that we won't stop
    // giving you warnings if you use production apis.

    function jsxWithValidationStatic(type, props, key) {
      {
        return jsxWithValidation(type, props, key, true);
      }
    }
    function jsxWithValidationDynamic(type, props, key) {
      {
        return jsxWithValidation(type, props, key, false);
      }
    }
    var jsx = jsxWithValidationDynamic; // we may want to special case jsxs internally to take advantage of static children.
    // for now we can ship identical prod functions

    var jsxs = jsxWithValidationStatic;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsx = jsx;
    exports.jsxs = jsxs;
  })();
}

/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ "./node_modules/react/cjs/react-jsx-runtime.development.js");
}

/***/ }),

/***/ "./src/_partials/Header/Header.module.scss":
/*!*************************************************!*\
  !*** ./src/_partials/Header/Header.module.scss ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"Header":"YYMraRsm_j1dUiyvELk3","HeaderTitle":"l1mTSl5BzOI7kzFmUQOa"});

/***/ }),

/***/ "./src/_partials/Header/HeaderLink/HeaderLink.module.scss":
/*!****************************************************************!*\
  !*** ./src/_partials/Header/HeaderLink/HeaderLink.module.scss ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"HeaderLink":"CIA1ZLvkHTD6pXZ3XHbc"});

/***/ }),

/***/ "./src/components/PageLayout/PageLayout.module.scss":
/*!**********************************************************!*\
  !*** ./src/components/PageLayout/PageLayout.module.scss ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"TodoList":"bukwXY7YX_6aNlwg8qyk"});

/***/ }),

/***/ "./src/containers/StatsContainer/StatsContainer.module.scss":
/*!******************************************************************!*\
  !*** ./src/containers/StatsContainer/StatsContainer.module.scss ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"StatsBoardContainer":"c_P8Lfs8ymTpKOjI7yR4","Title":"kOBmsFb8V06Yau9x_6wd","StatsBoard":"s1hDgEAlsben1xz2lnQe","BoardTitle":"N2oKcaZVRXqnBIBF9O9V"});

/***/ }),

/***/ "./src/styles/_base.scss":
/*!*******************************!*\
  !*** ./src/styles/_base.scss ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/App.tsx":
/*!*********************!*\
  !*** ./src/App.tsx ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _styles_base_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles/_base.scss */ "./src/styles/_base.scss");
/* harmony import */ var _partials_Header_Header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_partials/Header/Header */ "./src/_partials/Header/Header.tsx");
/* harmony import */ var _hoc_useAppState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hoc/useAppState */ "./src/hoc/useAppState.tsx");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/dist/index.js");
/* harmony import */ var _hoc_withSuspense__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hoc/withSuspense */ "./src/hoc/withSuspense.tsx");
/* harmony import */ var _components_PageLayout_PageLayout__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/PageLayout/PageLayout */ "./src/components/PageLayout/PageLayout.tsx");
/* harmony import */ var _containers_StatsContainer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./containers/StatsContainer */ "./src/containers/StatsContainer/index.tsx");








var AsyncTodoContainer = (0,_hoc_withSuspense__WEBPACK_IMPORTED_MODULE_4__.withSuspense)(function () { return __webpack_require__.e(/*! import() */ "src_containers_TodoContainer_index_tsx").then(__webpack_require__.bind(__webpack_require__, /*! ./containers/TodoContainer */ "./src/containers/TodoContainer/index.tsx")); });
var AsyncEditTodoItem = (0,_hoc_withSuspense__WEBPACK_IMPORTED_MODULE_4__.withSuspense)(function () { return __webpack_require__.e(/*! import() */ "src_containers_TodoContainer_EditTodoItem_index_tsx").then(__webpack_require__.bind(__webpack_require__, /*! ./containers/TodoContainer/EditTodoItem */ "./src/containers/TodoContainer/EditTodoItem/index.tsx")); });
var AsyncStatsContainer = (0,_hoc_withSuspense__WEBPACK_IMPORTED_MODULE_4__.withSuspense)(function () { return Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./containers/StatsContainer */ "./src/containers/StatsContainer/index.tsx")); });
var AsyncAboutContainer = (0,_hoc_withSuspense__WEBPACK_IMPORTED_MODULE_4__.withSuspense)(function () { return Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_react-markdown_lib_react-markdown_js"), __webpack_require__.e("src_containers_AboutContainer_index_tsx")]).then(__webpack_require__.bind(__webpack_require__, /*! ./containers/AboutContainer */ "./src/containers/AboutContainer/index.tsx")); });
function App() {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_hoc_useAppState__WEBPACK_IMPORTED_MODULE_3__.AppStateProvider, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_partials_Header_Header__WEBPACK_IMPORTED_MODULE_2__["default"], {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_PageLayout_PageLayout__WEBPACK_IMPORTED_MODULE_5__.PageLayout, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_router_dom__WEBPACK_IMPORTED_MODULE_7__.Routes, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_router_dom__WEBPACK_IMPORTED_MODULE_7__.Route, { path: "/", element: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [AsyncTodoContainer, AsyncEditTodoItem] }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_router_dom__WEBPACK_IMPORTED_MODULE_7__.Route, { path: "/stats", element: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_containers_StatsContainer__WEBPACK_IMPORTED_MODULE_6__["default"], {}) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_router_dom__WEBPACK_IMPORTED_MODULE_7__.Route, { path: "/about", element: AsyncAboutContainer })] }) })] }) }));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (App);


/***/ }),

/***/ "./src/_partials/Header/Header.tsx":
/*!*****************************************!*\
  !*** ./src/_partials/Header/Header.tsx ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _Header_module_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Header.module.scss */ "./src/_partials/Header/Header.module.scss");
/* harmony import */ var _HeaderLink_HeaderLink__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HeaderLink/HeaderLink */ "./src/_partials/Header/HeaderLink/HeaderLink.tsx");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};



var Header = function () {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("header", __assign({ className: _Header_module_scss__WEBPACK_IMPORTED_MODULE_1__["default"].Header }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("h1", __assign({ className: _Header_module_scss__WEBPACK_IMPORTED_MODULE_1__["default"].HeaderTitle }, { children: "Todo Pro Max App" })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("nav", __assign({ className: "m-auto" }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_HeaderLink_HeaderLink__WEBPACK_IMPORTED_MODULE_2__["default"], __assign({ url: "/" }, { children: "Home" })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_HeaderLink_HeaderLink__WEBPACK_IMPORTED_MODULE_2__["default"], __assign({ url: "/stats" }, { children: "Stats" })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_HeaderLink_HeaderLink__WEBPACK_IMPORTED_MODULE_2__["default"], __assign({ url: "/about" }, { children: "About" }))] }))] })));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Header);


/***/ }),

/***/ "./src/_partials/Header/HeaderLink/HeaderLink.tsx":
/*!********************************************************!*\
  !*** ./src/_partials/Header/HeaderLink/HeaderLink.tsx ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router-dom/dist/index.js");
/* harmony import */ var _HeaderLink_module_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HeaderLink.module.scss */ "./src/_partials/Header/HeaderLink/HeaderLink.module.scss");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};



var HeaderLink = function (_a) {
    var url = _a.url, children = _a.children;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_router_dom__WEBPACK_IMPORTED_MODULE_2__.Link, __assign({ to: "".concat(url), className: _HeaderLink_module_scss__WEBPACK_IMPORTED_MODULE_1__["default"].HeaderLink + " mr-2 mr-2" }, { children: children })));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HeaderLink);


/***/ }),

/***/ "./src/adapters/HttpAdapter.ts":
/*!*************************************!*\
  !*** ./src/adapters/HttpAdapter.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HttpAdapter": () => (/* binding */ HttpAdapter)
/* harmony export */ });
var HttpAdapter = /** @class */ (function () {
    function HttpAdapter(_a) {
        var baseUrl = _a.baseUrl;
        this.baseUrl = baseUrl;
    }
    HttpAdapter.prototype.get = function (url, params) {
        if (params === void 0) { params = { query: {} }; }
        var query = Object.keys((params === null || params === void 0 ? void 0 : params.query) || {})
            .map(function (key) { var _a; return "".concat(key, "=").concat((_a = Object.getOwnPropertyDescriptor(params.query, key)) === null || _a === void 0 ? void 0 : _a.value); })
            .join("&");
        return fetch(this.baseUrl + url + "?" + query).then(function (response) {
            return response.json();
        });
    };
    HttpAdapter.prototype.post = function (url, data) {
        return fetch(this.baseUrl + url, {
            method: "POST",
            body: JSON.stringify(data),
            headers: {
                "Content-Type": "application/json",
            },
        }).then(function (response) { return response.json(); });
    };
    HttpAdapter.prototype.patch = function (url, data) {
        return fetch(this.baseUrl + url, {
            method: "PATCH",
            body: JSON.stringify(data),
            headers: {
                "Content-Type": "application/json",
            },
        }).then(function (response) { return response.json(); });
    };
    HttpAdapter.prototype.delete = function (url, data) {
        return fetch(this.baseUrl + url, {
            method: "DELETE",
            body: JSON.stringify(data),
            headers: {
                "Content-Type": "application/json",
            },
        }).then(function (response) { return response.json(); });
    };
    return HttpAdapter;
}());



/***/ }),

/***/ "./src/components/PageLayout/PageLayout.tsx":
/*!**************************************************!*\
  !*** ./src/components/PageLayout/PageLayout.tsx ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PageLayout": () => (/* binding */ PageLayout)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _PageLayout_module_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PageLayout.module.scss */ "./src/components/PageLayout/PageLayout.module.scss");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};


var PageLayout = function (_a) {
    var children = _a.children;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", __assign({ className: _PageLayout_module_scss__WEBPACK_IMPORTED_MODULE_1__["default"].TodoList + " mr-auto ml-auto" }, { children: children })));
};


/***/ }),

/***/ "./src/containers/StatsContainer/StatsContainer.tsx":
/*!**********************************************************!*\
  !*** ./src/containers/StatsContainer/StatsContainer.tsx ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StatsContainer": () => (/* binding */ StatsContainer)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _StatsContainer_module_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StatsContainer.module.scss */ "./src/containers/StatsContainer/StatsContainer.module.scss");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};



var StatsContainer = function (_a) {
    var todoService = _a.todoService;
    var _b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]), todos = _b[0], setTodos = _b[1];
    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
        todoService.getAllTodos().then(function (todos) {
            setTodos(todos);
        });
    }, []);
    var doneTodos = todos.filter(function (_a) {
        var isDone = _a.isDone;
        return isDone;
    });
    var notDoneTodos = todos.filter(function (_a) {
        var isDone = _a.isDone;
        return !isDone;
    });
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("h2", __assign({ className: _StatsContainer_module_scss__WEBPACK_IMPORTED_MODULE_2__["default"].Title }, { children: "Stats" })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", __assign({ className: _StatsContainer_module_scss__WEBPACK_IMPORTED_MODULE_2__["default"].StatsBoardContainer }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", __assign({ className: _StatsContainer_module_scss__WEBPACK_IMPORTED_MODULE_2__["default"].StatsBoard }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("h3", __assign({ className: _StatsContainer_module_scss__WEBPACK_IMPORTED_MODULE_2__["default"].StatsTitle }, { children: ["Done Todo (", doneTodos.length, ")"] })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("ul", { children: doneTodos.map(function (todo) { return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("li", { children: todo.task }, todo.id)); }) })] })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", __assign({ className: _StatsContainer_module_scss__WEBPACK_IMPORTED_MODULE_2__["default"].StatsBoard }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("h3", __assign({ className: _StatsContainer_module_scss__WEBPACK_IMPORTED_MODULE_2__["default"].StatsTitle }, { children: ["Not Done (", notDoneTodos.length, ")"] })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("ul", { children: notDoneTodos.map(function (todo) { return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("li", { children: todo.task }, todo.id)); }) })] }))] }))] }));
};


/***/ }),

/***/ "./src/containers/StatsContainer/index.tsx":
/*!*************************************************!*\
  !*** ./src/containers/StatsContainer/index.tsx ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dependencies__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dependencies */ "./src/dependencies.ts");
/* harmony import */ var _hoc_withDependencies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../hoc/withDependencies */ "./src/hoc/withDependencies.tsx");
/* harmony import */ var _StatsContainer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StatsContainer */ "./src/containers/StatsContainer/StatsContainer.tsx");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_hoc_withDependencies__WEBPACK_IMPORTED_MODULE_1__.withDependency)(_StatsContainer__WEBPACK_IMPORTED_MODULE_2__.StatsContainer, {
    todoService: _dependencies__WEBPACK_IMPORTED_MODULE_0__.dependencies.TodoService,
}));


/***/ }),

/***/ "./src/dependencies.ts":
/*!*****************************!*\
  !*** ./src/dependencies.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "container": () => (/* binding */ container),
/* harmony export */   "dependencies": () => (/* binding */ dependencies)
/* harmony export */ });
/* harmony import */ var _adapters_HttpAdapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapters/HttpAdapter */ "./src/adapters/HttpAdapter.ts");
/* harmony import */ var _services_Todo_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./services/Todo.service */ "./src/services/Todo.service.ts");


var DependencyContainer = /** @class */ (function () {
    function DependencyContainer() {
        this._dependency = {};
    }
    DependencyContainer.prototype.add = function (key, dependency) {
        Object.defineProperty(this._dependency, key, {
            value: dependency,
        });
    };
    DependencyContainer.prototype.get = function (key) {
        var _a;
        return (_a = Object.getOwnPropertyDescriptor(this._dependency, key)) === null || _a === void 0 ? void 0 : _a.value;
    };
    return DependencyContainer;
}());
var httpAdapter = new _adapters_HttpAdapter__WEBPACK_IMPORTED_MODULE_0__.HttpAdapter({ baseUrl: "http://localhost:3001" });
var todoService = new _services_Todo_service__WEBPACK_IMPORTED_MODULE_1__.TodoService(httpAdapter);
var dependencies = {
    TodoService: Symbol("TodoService"),
};
var container = new DependencyContainer();
container.add(dependencies.TodoService, todoService);



/***/ }),

/***/ "./src/hoc/useAppState.tsx":
/*!*********************************!*\
  !*** ./src/hoc/useAppState.tsx ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AppSate": () => (/* binding */ AppSate),
/* harmony export */   "AppStateProvider": () => (/* binding */ AppStateProvider),
/* harmony export */   "useAppState": () => (/* binding */ useAppState)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};


var AppSate = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({
    appState: { editTodoId: -1, isDrawerOpen: false },
    setAppState: function () { },
});
var useAppState = function () { return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AppSate); };
var AppStateProvider = function (_a) {
    var children = _a.children;
    var _b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({
        editTodoId: -1,
        isDrawerOpen: false,
    }), appState = _b[0], setAppState = _b[1];
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AppSate.Provider, __assign({ value: { appState: appState, setAppState: setAppState } }, { children: children })));
};


/***/ }),

/***/ "./src/hoc/withDependencies.tsx":
/*!**************************************!*\
  !*** ./src/hoc/withDependencies.tsx ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "withDependency": () => (/* binding */ withDependency)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _dependencies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dependencies */ "./src/dependencies.ts");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};


var withDependency = function (Component, dependencies) {
    var resolvedDependencies = {};
    Object.keys(dependencies).forEach(function (propName) {
        var _a;
        var dependencyKey = (_a = Object.getOwnPropertyDescriptor(dependencies, propName)) === null || _a === void 0 ? void 0 : _a.value;
        var dependency = _dependencies__WEBPACK_IMPORTED_MODULE_1__.container.get(dependencyKey);
        Object.defineProperty(resolvedDependencies, propName, {
            value: dependency,
            enumerable: true,
        });
    });
    return function (props) { return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Component, __assign({}, props, resolvedDependencies))); };
};


/***/ }),

/***/ "./src/hoc/withSuspense.tsx":
/*!**********************************!*\
  !*** ./src/hoc/withSuspense.tsx ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "withSuspense": () => (/* binding */ withSuspense)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};


var Loading = function () { return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { children: "Loading..." }); };
var withSuspense = function (ComponentImportCallback) {
    var AsyncComponent = react__WEBPACK_IMPORTED_MODULE_1___default().lazy(ComponentImportCallback);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react__WEBPACK_IMPORTED_MODULE_1__.Suspense, __assign({ fallback: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Loading, {}) }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AsyncComponent, {}) })));
};


/***/ }),

/***/ "./src/services/Todo.service.ts":
/*!**************************************!*\
  !*** ./src/services/Todo.service.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TodoService": () => (/* binding */ TodoService)
/* harmony export */ });
var TodoService = /** @class */ (function () {
    function TodoService(httpAdapter) {
        this.http = httpAdapter;
    }
    TodoService.prototype.getTodo = function (todoId) {
        return this.http.get("/todos/" + todoId);
    };
    TodoService.prototype.getAllTodos = function (params) {
        return this.http.get("/todos", params);
    };
    TodoService.prototype.addTodo = function (task) {
        return this.http.post("/todos", { todo: task });
    };
    TodoService.prototype.updateTodo = function (todoId, task) {
        return this.http.patch("/todos/" + todoId, task);
    };
    TodoService.prototype.deleteTodo = function (todoId) {
        return this.http.delete("/todos", { id: todoId });
    };
    return TodoService;
}());



/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

module.exports = require("react");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "process":
/*!**************************!*\
  !*** external "process" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("process");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".css";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/css loading */
/******/ 	(() => {
/******/ 		if (typeof document === "undefined") return;
/******/ 		var createStylesheet = (chunkId, fullhref, oldTag, resolve, reject) => {
/******/ 			var linkTag = document.createElement("link");
/******/ 		
/******/ 			linkTag.rel = "stylesheet";
/******/ 			linkTag.type = "text/css";
/******/ 			var onLinkComplete = (event) => {
/******/ 				// avoid mem leaks.
/******/ 				linkTag.onerror = linkTag.onload = null;
/******/ 				if (event.type === 'load') {
/******/ 					resolve();
/******/ 				} else {
/******/ 					var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 					var realHref = event && event.target && event.target.href || fullhref;
/******/ 					var err = new Error("Loading CSS chunk " + chunkId + " failed.\n(" + realHref + ")");
/******/ 					err.code = "CSS_CHUNK_LOAD_FAILED";
/******/ 					err.type = errorType;
/******/ 					err.request = realHref;
/******/ 					linkTag.parentNode.removeChild(linkTag)
/******/ 					reject(err);
/******/ 				}
/******/ 			}
/******/ 			linkTag.onerror = linkTag.onload = onLinkComplete;
/******/ 			linkTag.href = fullhref;
/******/ 		
/******/ 			if (oldTag) {
/******/ 				oldTag.parentNode.insertBefore(linkTag, oldTag.nextSibling);
/******/ 			} else {
/******/ 				document.head.appendChild(linkTag);
/******/ 			}
/******/ 			return linkTag;
/******/ 		};
/******/ 		var findStylesheet = (href, fullhref) => {
/******/ 			var existingLinkTags = document.getElementsByTagName("link");
/******/ 			for(var i = 0; i < existingLinkTags.length; i++) {
/******/ 				var tag = existingLinkTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");
/******/ 				if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return tag;
/******/ 			}
/******/ 			var existingStyleTags = document.getElementsByTagName("style");
/******/ 			for(var i = 0; i < existingStyleTags.length; i++) {
/******/ 				var tag = existingStyleTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href");
/******/ 				if(dataHref === href || dataHref === fullhref) return tag;
/******/ 			}
/******/ 		};
/******/ 		var loadStylesheet = (chunkId) => {
/******/ 			return new Promise((resolve, reject) => {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				if(findStylesheet(href, fullhref)) return resolve();
/******/ 				createStylesheet(chunkId, fullhref, null, resolve, reject);
/******/ 			});
/******/ 		}
/******/ 		// object to store loaded CSS chunks
/******/ 		var installedCssChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.miniCss = (chunkId, promises) => {
/******/ 			var cssChunks = {"src_containers_TodoContainer_index_tsx":1,"src_containers_TodoContainer_EditTodoItem_index_tsx":1};
/******/ 			if(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);
/******/ 			else if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {
/******/ 				promises.push(installedCssChunks[chunkId] = loadStylesheet(chunkId).then(() => {
/******/ 					installedCssChunks[chunkId] = 0;
/******/ 				}, (e) => {
/******/ 					delete installedCssChunks[chunkId];
/******/ 					throw e;
/******/ 				}));
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no hmr
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/require chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "loaded", otherwise not loaded yet
/******/ 		var installedChunks = {
/******/ 			"main": 1
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		var installChunk = (chunk) => {
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 1;
/******/ 		
/******/ 		};
/******/ 		
/******/ 		// require() chunk loading for javascript
/******/ 		__webpack_require__.f.require = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					installChunk(require("./" + __webpack_require__.u(chunkId)));
/******/ 				} else installedChunks[chunkId] = 1;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no external install chunk
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!****************************!*\
  !*** ./src/ssr/SsrApp.tsx ***!
  \****************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SsrApp": () => (/* binding */ SsrApp)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../App */ "./src/App.tsx");
/* harmony import */ var react_router_dom_server__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router-dom/server */ "./node_modules/react-router-dom/server.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};



var SsrApp = function (pathname) {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_router_dom_server__WEBPACK_IMPORTED_MODULE_2__.StaticRouter, __assign({ location: pathname }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_App__WEBPACK_IMPORTED_MODULE_1__["default"], {}) })));
};

})();

module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsSUFBSTtXQUNKO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGdCQUFnQiw2QkFBNkI7V0FDN0M7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGdCQUFnQiw4QkFBOEI7V0FDOUM7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEVBQUU7V0FDRjtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0Esa0JBQWtCO1dBQ2xCO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTs7V0FFQTs7Ozs7V0N4RUE7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsZ0JBQWdCLHFCQUFxQjtXQUNyQzs7V0FFQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGFBQWE7V0FDYjtXQUNBLElBQUk7V0FDSjtXQUNBOztXQUVBOztXQUVBOztXQUVBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JDQSxnQkFBZ0IsU0FBSSxJQUFJLFNBQUk7QUFDNUI7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dEO0FBQ3ZCO0FBQzhCO0FBQ2hEO0FBQ1AsWUFBWSxzREFBSSxDQUFDLGlFQUFZLGFBQWEsb0JBQW9CLElBQUksVUFBVSxzREFBSSxDQUFDLDRDQUFHLElBQUksR0FBRztBQUMzRiIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8tcHJvLW1heC8uLi9oaXN0b3J5LnRzIiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uLi91dGlscy50cyIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvLi4vcm91dGVyLnRzIiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uLi9kb20udHMiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4uL2luZGV4LnRzeCIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4uL2xpYi91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3VzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbUNsaWVudC50cyIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvLi4vbGliL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vdXNlU3luY0V4dGVybmFsU3RvcmVTaGltU2VydmVyLnRzIiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uLi9saWIvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS9pbmRleC50cyIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvLi4vbGliL2NvbnRleHQudHMiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4uL2xpYi9ob29rcy50c3giLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4uL2xpYi9jb21wb25lbnRzLnRzeCIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvLi4vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4vc3JjL19wYXJ0aWFscy9IZWFkZXIvSGVhZGVyLm1vZHVsZS5zY3NzPzNkZWUiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4vc3JjL19wYXJ0aWFscy9IZWFkZXIvSGVhZGVyTGluay9IZWFkZXJMaW5rLm1vZHVsZS5zY3NzP2EzYjIiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4vc3JjL2NvbXBvbmVudHMvUGFnZUxheW91dC9QYWdlTGF5b3V0Lm1vZHVsZS5zY3NzPzNhZTIiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4vc3JjL2NvbnRhaW5lcnMvU3RhdHNDb250YWluZXIvU3RhdHNDb250YWluZXIubW9kdWxlLnNjc3M/MWRlOSIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvLi9zcmMvc3R5bGVzL19iYXNlLnNjc3M/MTQyMSIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvLi9zcmMvQXBwLnRzeCIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvLi9zcmMvX3BhcnRpYWxzL0hlYWRlci9IZWFkZXIudHN4Iiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uL3NyYy9fcGFydGlhbHMvSGVhZGVyL0hlYWRlckxpbmsvSGVhZGVyTGluay50c3giLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4vc3JjL2FkYXB0ZXJzL0h0dHBBZGFwdGVyLnRzIiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uL3NyYy9jb21wb25lbnRzL1BhZ2VMYXlvdXQvUGFnZUxheW91dC50c3giLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4vc3JjL2NvbnRhaW5lcnMvU3RhdHNDb250YWluZXIvU3RhdHNDb250YWluZXIudHN4Iiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uL3NyYy9jb250YWluZXJzL1N0YXRzQ29udGFpbmVyL2luZGV4LnRzeCIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvLi9zcmMvZGVwZW5kZW5jaWVzLnRzIiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uL3NyYy9ob2MvdXNlQXBwU3RhdGUudHN4Iiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uL3NyYy9ob2Mvd2l0aERlcGVuZGVuY2llcy50c3giLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4vc3JjL2hvYy93aXRoU3VzcGVuc2UudHN4Iiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uL3NyYy9zZXJ2aWNlcy9Ub2RvLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4L2V4dGVybmFsIGNvbW1vbmpzMiBcInJlYWN0XCIiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4L2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJvc1wiIiwid2VicGFjazovL3RvZG8tcHJvLW1heC9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwicGF0aFwiIiwid2VicGFjazovL3RvZG8tcHJvLW1heC9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwicHJvY2Vzc1wiIiwid2VicGFjazovL3RvZG8tcHJvLW1heC9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwidHR5XCIiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4L2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJ1cmxcIiIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInV0aWxcIiIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4L3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3RvZG8tcHJvLW1heC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4L3dlYnBhY2svcnVudGltZS9lbnN1cmUgY2h1bmsiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4L3dlYnBhY2svcnVudGltZS9nZXQgamF2YXNjcmlwdCBjaHVuayBmaWxlbmFtZSIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvd2VicGFjay9ydW50aW1lL2dldCBtaW5pLWNzcyBjaHVuayBmaWxlbmFtZSIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvd2VicGFjay9ydW50aW1lL3B1YmxpY1BhdGgiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4L3dlYnBhY2svcnVudGltZS9jc3MgbG9hZGluZyIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvd2VicGFjay9ydW50aW1lL3JlcXVpcmUgY2h1bmsgbG9hZGluZyIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvLi9zcmMvc3NyL1NzckFwcC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBUeXBlcyBhbmQgQ29uc3RhbnRzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEFjdGlvbnMgcmVwcmVzZW50IHRoZSB0eXBlIG9mIGNoYW5nZSB0byBhIGxvY2F0aW9uIHZhbHVlLlxuICovXG5leHBvcnQgZW51bSBBY3Rpb24ge1xuICAvKipcbiAgICogQSBQT1AgaW5kaWNhdGVzIGEgY2hhbmdlIHRvIGFuIGFyYml0cmFyeSBpbmRleCBpbiB0aGUgaGlzdG9yeSBzdGFjaywgc3VjaFxuICAgKiBhcyBhIGJhY2sgb3IgZm9yd2FyZCBuYXZpZ2F0aW9uLiBJdCBkb2VzIG5vdCBkZXNjcmliZSB0aGUgZGlyZWN0aW9uIG9mIHRoZVxuICAgKiBuYXZpZ2F0aW9uLCBvbmx5IHRoYXQgdGhlIGN1cnJlbnQgaW5kZXggY2hhbmdlZC5cbiAgICpcbiAgICogTm90ZTogVGhpcyBpcyB0aGUgZGVmYXVsdCBhY3Rpb24gZm9yIG5ld2x5IGNyZWF0ZWQgaGlzdG9yeSBvYmplY3RzLlxuICAgKi9cbiAgUG9wID0gXCJQT1BcIixcblxuICAvKipcbiAgICogQSBQVVNIIGluZGljYXRlcyBhIG5ldyBlbnRyeSBiZWluZyBhZGRlZCB0byB0aGUgaGlzdG9yeSBzdGFjaywgc3VjaCBhcyB3aGVuXG4gICAqIGEgbGluayBpcyBjbGlja2VkIGFuZCBhIG5ldyBwYWdlIGxvYWRzLiBXaGVuIHRoaXMgaGFwcGVucywgYWxsIHN1YnNlcXVlbnRcbiAgICogZW50cmllcyBpbiB0aGUgc3RhY2sgYXJlIGxvc3QuXG4gICAqL1xuICBQdXNoID0gXCJQVVNIXCIsXG5cbiAgLyoqXG4gICAqIEEgUkVQTEFDRSBpbmRpY2F0ZXMgdGhlIGVudHJ5IGF0IHRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrXG4gICAqIGJlaW5nIHJlcGxhY2VkIGJ5IGEgbmV3IG9uZS5cbiAgICovXG4gIFJlcGxhY2UgPSBcIlJFUExBQ0VcIixcbn1cblxuLyoqXG4gKiBUaGUgcGF0aG5hbWUsIHNlYXJjaCwgYW5kIGhhc2ggdmFsdWVzIG9mIGEgVVJMLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhdGgge1xuICAvKipcbiAgICogQSBVUkwgcGF0aG5hbWUsIGJlZ2lubmluZyB3aXRoIGEgLy5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgVVJMIHNlYXJjaCBzdHJpbmcsIGJlZ2lubmluZyB3aXRoIGEgPy5cbiAgICovXG4gIHNlYXJjaDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIFVSTCBmcmFnbWVudCBpZGVudGlmaWVyLCBiZWdpbm5pbmcgd2l0aCBhICMuXG4gICAqL1xuICBoYXNoOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQW4gZW50cnkgaW4gYSBoaXN0b3J5IHN0YWNrLiBBIGxvY2F0aW9uIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICogVVJMIHBhdGgsIGFzIHdlbGwgYXMgcG9zc2libHkgc29tZSBhcmJpdHJhcnkgc3RhdGUgYW5kIGEga2V5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIExvY2F0aW9uIGV4dGVuZHMgUGF0aCB7XG4gIC8qKlxuICAgKiBBIHZhbHVlIG9mIGFyYml0cmFyeSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxvY2F0aW9uLlxuICAgKi9cbiAgc3RhdGU6IGFueTtcblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxvY2F0aW9uLiBNYXkgYmUgdXNlZCB0byBzYWZlbHkgc3RvcmVcbiAgICogYW5kIHJldHJpZXZlIGRhdGEgaW4gc29tZSBvdGhlciBzdG9yYWdlIEFQSSwgbGlrZSBgbG9jYWxTdG9yYWdlYC5cbiAgICpcbiAgICogTm90ZTogVGhpcyB2YWx1ZSBpcyBhbHdheXMgXCJkZWZhdWx0XCIgb24gdGhlIGluaXRpYWwgbG9jYXRpb24uXG4gICAqL1xuICBrZXk6IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIGNoYW5nZSB0byB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGRhdGUge1xuICAvKipcbiAgICogVGhlIGFjdGlvbiB0aGF0IHRyaWdnZXJlZCB0aGUgY2hhbmdlLlxuICAgKi9cbiAgYWN0aW9uOiBBY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSBuZXcgbG9jYXRpb24uXG4gICAqL1xuICBsb2NhdGlvbjogTG9jYXRpb247XG5cbiAgLyoqXG4gICAqIFRoZSBkZWx0YSBiZXR3ZWVuIHRoaXMgbG9jYXRpb24gYW5kIHRoZSBmb3JtZXIgbG9jYXRpb24gaW4gdGhlIGhpc3Rvcnkgc3RhY2tcbiAgICovXG4gIGRlbHRhOiBudW1iZXIgfCBudWxsO1xufVxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBub3RpZmljYXRpb25zIGFib3V0IGxvY2F0aW9uIGNoYW5nZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdGVuZXIge1xuICAodXBkYXRlOiBVcGRhdGUpOiB2b2lkO1xufVxuXG4vKipcbiAqIERlc2NyaWJlcyBhIGxvY2F0aW9uIHRoYXQgaXMgdGhlIGRlc3RpbmF0aW9uIG9mIHNvbWUgbmF2aWdhdGlvbiwgZWl0aGVyIHZpYVxuICogYGhpc3RvcnkucHVzaGAgb3IgYGhpc3RvcnkucmVwbGFjZWAuIE1heSBiZSBlaXRoZXIgYSBVUkwgb3IgdGhlIHBpZWNlcyBvZiBhXG4gKiBVUkwgcGF0aC5cbiAqL1xuZXhwb3J0IHR5cGUgVG8gPSBzdHJpbmcgfCBQYXJ0aWFsPFBhdGg+O1xuXG4vKipcbiAqIEEgaGlzdG9yeSBpcyBhbiBpbnRlcmZhY2UgdG8gdGhlIG5hdmlnYXRpb24gc3RhY2suIFRoZSBoaXN0b3J5IHNlcnZlcyBhcyB0aGVcbiAqIHNvdXJjZSBvZiB0cnV0aCBmb3IgdGhlIGN1cnJlbnQgbG9jYXRpb24sIGFzIHdlbGwgYXMgcHJvdmlkZXMgYSBzZXQgb2ZcbiAqIG1ldGhvZHMgdGhhdCBtYXkgYmUgdXNlZCB0byBjaGFuZ2UgaXQuXG4gKlxuICogSXQgaXMgc2ltaWxhciB0byB0aGUgRE9NJ3MgYHdpbmRvdy5oaXN0b3J5YCBvYmplY3QsIGJ1dCB3aXRoIGEgc21hbGxlciwgbW9yZVxuICogZm9jdXNlZCBBUEkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeSB7XG4gIC8qKlxuICAgKiBUaGUgbGFzdCBhY3Rpb24gdGhhdCBtb2RpZmllZCB0aGUgY3VycmVudCBsb2NhdGlvbi4gVGhpcyB3aWxsIGFsd2F5cyBiZVxuICAgKiBBY3Rpb24uUG9wIHdoZW4gYSBoaXN0b3J5IGluc3RhbmNlIGlzIGZpcnN0IGNyZWF0ZWQuIFRoaXMgdmFsdWUgaXMgbXV0YWJsZS5cbiAgICovXG4gIHJlYWRvbmx5IGFjdGlvbjogQWN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBsb2NhdGlvbi4gVGhpcyB2YWx1ZSBpcyBtdXRhYmxlLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246IExvY2F0aW9uO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmFsaWQgaHJlZiBmb3IgdGhlIGdpdmVuIGB0b2AgdmFsdWUgdGhhdCBtYXkgYmUgdXNlZCBhc1xuICAgKiB0aGUgdmFsdWUgb2YgYW4gPGEgaHJlZj4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAcGFyYW0gdG8gLSBUaGUgZGVzdGluYXRpb24gVVJMXG4gICAqL1xuICBjcmVhdGVIcmVmKHRvOiBUbyk6IHN0cmluZztcblxuICAvKipcbiAgICogUmV0dXJucyBhIFVSTCBmb3IgdGhlIGdpdmVuIGB0b2AgdmFsdWVcbiAgICpcbiAgICogQHBhcmFtIHRvIC0gVGhlIGRlc3RpbmF0aW9uIFVSTFxuICAgKi9cbiAgY3JlYXRlVVJMKHRvOiBUbyk6IFVSTDtcblxuICAvKipcbiAgICogRW5jb2RlIGEgbG9jYXRpb24gdGhlIHNhbWUgd2F5IHdpbmRvdy5oaXN0b3J5IHdvdWxkIGRvIChuby1vcCBmb3IgbWVtb3J5XG4gICAqIGhpc3RvcnkpIHNvIHdlIGVuc3VyZSBvdXIgUFVTSC9SRVBMQUNFIG5hdmlnYXRpb25zIGZvciBkYXRhIHJvdXRlcnNcbiAgICogYmVoYXZlIHRoZSBzYW1lIGFzIFBPUFxuICAgKlxuICAgKiBAcGFyYW0gdG8gVW5lbmNvZGVkIHBhdGhcbiAgICovXG4gIGVuY29kZUxvY2F0aW9uKHRvOiBUbyk6IFBhdGg7XG5cbiAgLyoqXG4gICAqIFB1c2hlcyBhIG5ldyBsb2NhdGlvbiBvbnRvIHRoZSBoaXN0b3J5IHN0YWNrLCBpbmNyZWFzaW5nIGl0cyBsZW5ndGggYnkgb25lLlxuICAgKiBJZiB0aGVyZSB3ZXJlIGFueSBlbnRyaWVzIGluIHRoZSBzdGFjayBhZnRlciB0aGUgY3VycmVudCBvbmUsIHRoZXkgYXJlXG4gICAqIGxvc3QuXG4gICAqXG4gICAqIEBwYXJhbSB0byAtIFRoZSBuZXcgVVJMXG4gICAqIEBwYXJhbSBzdGF0ZSAtIERhdGEgdG8gYXNzb2NpYXRlIHdpdGggdGhlIG5ldyBsb2NhdGlvblxuICAgKi9cbiAgcHVzaCh0bzogVG8sIHN0YXRlPzogYW55KTogdm9pZDtcblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gdGhlIGhpc3Rvcnkgc3RhY2sgd2l0aCBhIG5ldyBvbmUuICBUaGVcbiAgICogbG9jYXRpb24gdGhhdCB3YXMgcmVwbGFjZWQgd2lsbCBubyBsb25nZXIgYmUgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gdG8gLSBUaGUgbmV3IFVSTFxuICAgKiBAcGFyYW0gc3RhdGUgLSBEYXRhIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBuZXcgbG9jYXRpb25cbiAgICovXG4gIHJlcGxhY2UodG86IFRvLCBzdGF0ZT86IGFueSk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlcyBgbmAgZW50cmllcyBiYWNrd2FyZC9mb3J3YXJkIGluIHRoZSBoaXN0b3J5IHN0YWNrIHJlbGF0aXZlIHRvIHRoZVxuICAgKiBjdXJyZW50IGluZGV4LiBGb3IgZXhhbXBsZSwgYSBcImJhY2tcIiBuYXZpZ2F0aW9uIHdvdWxkIHVzZSBnbygtMSkuXG4gICAqXG4gICAqIEBwYXJhbSBkZWx0YSAtIFRoZSBkZWx0YSBpbiB0aGUgc3RhY2sgaW5kZXhcbiAgICovXG4gIGdvKGRlbHRhOiBudW1iZXIpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBTZXRzIHVwIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgKiBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgbG9jYXRpb24gY2hhbmdlc1xuICAgKiBAcmV0dXJucyB1bmxpc3RlbiAtIEEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBzdG9wIGxpc3RlbmluZ1xuICAgKi9cbiAgbGlzdGVuKGxpc3RlbmVyOiBMaXN0ZW5lcik6ICgpID0+IHZvaWQ7XG59XG5cbnR5cGUgSGlzdG9yeVN0YXRlID0ge1xuICB1c3I6IGFueTtcbiAga2V5Pzogc3RyaW5nO1xuICBpZHg6IG51bWJlcjtcbn07XG5cbmNvbnN0IFBvcFN0YXRlRXZlbnRUeXBlID0gXCJwb3BzdGF0ZVwiO1xuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gTWVtb3J5IEhpc3Rvcnlcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQSB1c2VyLXN1cHBsaWVkIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBhIGxvY2F0aW9uLiBVc2VkIHdoZW4gcHJvdmlkaW5nXG4gKiBlbnRyaWVzIHRvIGBjcmVhdGVNZW1vcnlIaXN0b3J5YCB2aWEgaXRzIGBpbml0aWFsRW50cmllc2Agb3B0aW9uLlxuICovXG5leHBvcnQgdHlwZSBJbml0aWFsRW50cnkgPSBzdHJpbmcgfCBQYXJ0aWFsPExvY2F0aW9uPjtcblxuZXhwb3J0IHR5cGUgTWVtb3J5SGlzdG9yeU9wdGlvbnMgPSB7XG4gIGluaXRpYWxFbnRyaWVzPzogSW5pdGlhbEVudHJ5W107XG4gIGluaXRpYWxJbmRleD86IG51bWJlcjtcbiAgdjVDb21wYXQ/OiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBBIG1lbW9yeSBoaXN0b3J5IHN0b3JlcyBsb2NhdGlvbnMgaW4gbWVtb3J5LiBUaGlzIGlzIHVzZWZ1bCBpbiBzdGF0ZWZ1bFxuICogZW52aXJvbm1lbnRzIHdoZXJlIHRoZXJlIGlzIG5vIHdlYiBicm93c2VyLCBzdWNoIGFzIG5vZGUgdGVzdHMgb3IgUmVhY3RcbiAqIE5hdGl2ZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZW1vcnlIaXN0b3J5IGV4dGVuZHMgSGlzdG9yeSB7XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBpbmRleCBpbiB0aGUgaGlzdG9yeSBzdGFjay5cbiAgICovXG4gIHJlYWRvbmx5IGluZGV4OiBudW1iZXI7XG59XG5cbi8qKlxuICogTWVtb3J5IGhpc3Rvcnkgc3RvcmVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIG1lbW9yeS4gSXQgaXMgZGVzaWduZWQgZm9yIHVzZVxuICogaW4gc3RhdGVmdWwgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzIGxpa2UgdGVzdHMgYW5kIFJlYWN0IE5hdGl2ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkoXG4gIG9wdGlvbnM6IE1lbW9yeUhpc3RvcnlPcHRpb25zID0ge31cbik6IE1lbW9yeUhpc3Rvcnkge1xuICBsZXQgeyBpbml0aWFsRW50cmllcyA9IFtcIi9cIl0sIGluaXRpYWxJbmRleCwgdjVDb21wYXQgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgbGV0IGVudHJpZXM6IExvY2F0aW9uW107IC8vIERlY2xhcmUgc28gd2UgY2FuIGFjY2VzcyBmcm9tIGNyZWF0ZU1lbW9yeUxvY2F0aW9uXG4gIGVudHJpZXMgPSBpbml0aWFsRW50cmllcy5tYXAoKGVudHJ5LCBpbmRleCkgPT5cbiAgICBjcmVhdGVNZW1vcnlMb2NhdGlvbihcbiAgICAgIGVudHJ5LFxuICAgICAgdHlwZW9mIGVudHJ5ID09PSBcInN0cmluZ1wiID8gbnVsbCA6IGVudHJ5LnN0YXRlLFxuICAgICAgaW5kZXggPT09IDAgPyBcImRlZmF1bHRcIiA6IHVuZGVmaW5lZFxuICAgIClcbiAgKTtcbiAgbGV0IGluZGV4ID0gY2xhbXBJbmRleChcbiAgICBpbml0aWFsSW5kZXggPT0gbnVsbCA/IGVudHJpZXMubGVuZ3RoIC0gMSA6IGluaXRpYWxJbmRleFxuICApO1xuICBsZXQgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgbGV0IGxpc3RlbmVyOiBMaXN0ZW5lciB8IG51bGwgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGNsYW1wSW5kZXgobjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgMCksIGVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCk6IExvY2F0aW9uIHtcbiAgICByZXR1cm4gZW50cmllc1tpbmRleF07XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlTWVtb3J5TG9jYXRpb24oXG4gICAgdG86IFRvLFxuICAgIHN0YXRlOiBhbnkgPSBudWxsLFxuICAgIGtleT86IHN0cmluZ1xuICApOiBMb2NhdGlvbiB7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXG4gICAgICBlbnRyaWVzID8gZ2V0Q3VycmVudExvY2F0aW9uKCkucGF0aG5hbWUgOiBcIi9cIixcbiAgICAgIHRvLFxuICAgICAgc3RhdGUsXG4gICAgICBrZXlcbiAgICApO1xuICAgIHdhcm5pbmcoXG4gICAgICBsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09IFwiL1wiLFxuICAgICAgYHJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBtZW1vcnkgaGlzdG9yeTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgdG9cbiAgICAgICl9YFxuICAgICk7XG4gICAgcmV0dXJuIGxvY2F0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZih0bzogVG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5OiBNZW1vcnlIaXN0b3J5ID0ge1xuICAgIGdldCBpbmRleCgpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuICAgIGdldCBhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH0sXG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIGdldEN1cnJlbnRMb2NhdGlvbigpO1xuICAgIH0sXG4gICAgY3JlYXRlSHJlZixcbiAgICBjcmVhdGVVUkwodG8pIHtcbiAgICAgIHJldHVybiBuZXcgVVJMKGNyZWF0ZUhyZWYodG8pLCBcImh0dHA6Ly9sb2NhbGhvc3RcIik7XG4gICAgfSxcbiAgICBlbmNvZGVMb2NhdGlvbih0bzogVG8pIHtcbiAgICAgIGxldCBwYXRoID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHBhdGgucGF0aG5hbWUgfHwgXCJcIixcbiAgICAgICAgc2VhcmNoOiBwYXRoLnNlYXJjaCB8fCBcIlwiLFxuICAgICAgICBoYXNoOiBwYXRoLmhhc2ggfHwgXCJcIixcbiAgICAgIH07XG4gICAgfSxcbiAgICBwdXNoKHRvLCBzdGF0ZSkge1xuICAgICAgYWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlKTtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgZW50cmllcy5sZW5ndGgsIG5leHRMb2NhdGlvbik7XG4gICAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sIGRlbHRhOiAxIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVwbGFjZSh0bywgc3RhdGUpIHtcbiAgICAgIGFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XG4gICAgICBlbnRyaWVzW2luZGV4XSA9IG5leHRMb2NhdGlvbjtcbiAgICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IG5leHRMb2NhdGlvbiwgZGVsdGE6IDAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnbyhkZWx0YSkge1xuICAgICAgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgICAgIGxldCBuZXh0SW5kZXggPSBjbGFtcEluZGV4KGluZGV4ICsgZGVsdGEpO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGVudHJpZXNbbmV4dEluZGV4XTtcbiAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbmV4dExvY2F0aW9uLCBkZWx0YSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpc3RlbihmbjogTGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyID0gZm47XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBCcm93c2VyIEhpc3Rvcnlcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQSBicm93c2VyIGhpc3Rvcnkgc3RvcmVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHJlZ3VsYXIgVVJMcyBpbiBhIHdlYlxuICogYnJvd3NlciBlbnZpcm9ubWVudC4gVGhpcyBpcyB0aGUgc3RhbmRhcmQgZm9yIG1vc3Qgd2ViIGFwcHMgYW5kIHByb3ZpZGVzIHRoZVxuICogY2xlYW5lc3QgVVJMcyB0aGUgYnJvd3NlcidzIGFkZHJlc3MgYmFyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjYnJvd3Nlcmhpc3RvcnlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCcm93c2VySGlzdG9yeSBleHRlbmRzIFVybEhpc3Rvcnkge31cblxuZXhwb3J0IHR5cGUgQnJvd3Nlckhpc3RvcnlPcHRpb25zID0gVXJsSGlzdG9yeU9wdGlvbnM7XG5cbi8qKlxuICogQnJvd3NlciBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gcmVndWxhciBVUkxzLiBUaGlzIGlzIHRoZSBzdGFuZGFyZCBmb3JcbiAqIG1vc3Qgd2ViIGFwcHMsIGJ1dCBpdCByZXF1aXJlcyBzb21lIGNvbmZpZ3VyYXRpb24gb24gdGhlIHNlcnZlciB0byBlbnN1cmUgeW91XG4gKiBzZXJ2ZSB0aGUgc2FtZSBhcHAgYXQgbXVsdGlwbGUgVVJMcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZWJyb3dzZXJoaXN0b3J5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeShcbiAgb3B0aW9uczogQnJvd3Nlckhpc3RvcnlPcHRpb25zID0ge31cbik6IEJyb3dzZXJIaXN0b3J5IHtcbiAgZnVuY3Rpb24gY3JlYXRlQnJvd3NlckxvY2F0aW9uKFxuICAgIHdpbmRvdzogV2luZG93LFxuICAgIGdsb2JhbEhpc3Rvcnk6IFdpbmRvd1tcImhpc3RvcnlcIl1cbiAgKSB7XG4gICAgbGV0IHsgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9ID0gd2luZG93LmxvY2F0aW9uO1xuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihcbiAgICAgIFwiXCIsXG4gICAgICB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSxcbiAgICAgIC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuICAgICAgKGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS51c3IpIHx8IG51bGwsXG4gICAgICAoZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLmtleSkgfHwgXCJkZWZhdWx0XCJcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQnJvd3NlckhyZWYod2luZG93OiBXaW5kb3csIHRvOiBUbykge1xuICAgIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICB9XG5cbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShcbiAgICBjcmVhdGVCcm93c2VyTG9jYXRpb24sXG4gICAgY3JlYXRlQnJvd3NlckhyZWYsXG4gICAgbnVsbCxcbiAgICBvcHRpb25zXG4gICk7XG59XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBIYXNoIEhpc3Rvcnlcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQSBoYXNoIGhpc3Rvcnkgc3RvcmVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHRoZSBmcmFnbWVudCBpZGVudGlmaWVyIHBvcnRpb25cbiAqIG9mIHRoZSBVUkwgaW4gYSB3ZWIgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAqXG4gKiBUaGlzIGlzIGlkZWFsIGZvciBhcHBzIHRoYXQgZG8gbm90IGNvbnRyb2wgdGhlIHNlcnZlciBmb3Igc29tZSByZWFzb25cbiAqIChiZWNhdXNlIHRoZSBmcmFnbWVudCBpZGVudGlmaWVyIGlzIG5ldmVyIHNlbnQgdG8gdGhlIHNlcnZlciksIGluY2x1ZGluZyBzb21lXG4gKiBzaGFyZWQgaG9zdGluZyBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgcHJvdmlkZSBmaW5lLWdyYWluZWQgY29udHJvbHMgb3ZlclxuICogd2hpY2ggcGFnZXMgYXJlIHNlcnZlZCBhdCB3aGljaCBVUkxzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjaGFzaGhpc3RvcnlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIYXNoSGlzdG9yeSBleHRlbmRzIFVybEhpc3Rvcnkge31cblxuZXhwb3J0IHR5cGUgSGFzaEhpc3RvcnlPcHRpb25zID0gVXJsSGlzdG9yeU9wdGlvbnM7XG5cbi8qKlxuICogSGFzaCBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gd2luZG93LmxvY2F0aW9uLmhhc2guIFRoaXMgbWFrZXMgaXQgaWRlYWxcbiAqIGZvciBzaXR1YXRpb25zIHdoZXJlIHlvdSBkb24ndCB3YW50IHRvIHNlbmQgdGhlIGxvY2F0aW9uIHRvIHRoZSBzZXJ2ZXIgZm9yXG4gKiBzb21lIHJlYXNvbiwgZWl0aGVyIGJlY2F1c2UgeW91IGRvIGNhbm5vdCBjb25maWd1cmUgaXQgb3IgdGhlIFVSTCBzcGFjZSBpc1xuICogcmVzZXJ2ZWQgZm9yIHNvbWV0aGluZyBlbHNlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjY3JlYXRlaGFzaGhpc3RvcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KFxuICBvcHRpb25zOiBIYXNoSGlzdG9yeU9wdGlvbnMgPSB7fVxuKTogSGFzaEhpc3Rvcnkge1xuICBmdW5jdGlvbiBjcmVhdGVIYXNoTG9jYXRpb24oXG4gICAgd2luZG93OiBXaW5kb3csXG4gICAgZ2xvYmFsSGlzdG9yeTogV2luZG93W1wiaGlzdG9yeVwiXVxuICApIHtcbiAgICBsZXQge1xuICAgICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgICBoYXNoID0gXCJcIixcbiAgICB9ID0gcGFyc2VQYXRoKHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cigxKSk7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKFxuICAgICAgXCJcIixcbiAgICAgIHsgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9LFxuICAgICAgLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXG4gICAgICAoZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLnVzcikgfHwgbnVsbCxcbiAgICAgIChnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUua2V5KSB8fCBcImRlZmF1bHRcIlxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIYXNoSHJlZih3aW5kb3c6IFdpbmRvdywgdG86IFRvKSB7XG4gICAgbGV0IGJhc2UgPSB3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImJhc2VcIik7XG4gICAgbGV0IGhyZWYgPSBcIlwiO1xuXG4gICAgaWYgKGJhc2UgJiYgYmFzZS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpKSB7XG4gICAgICBsZXQgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICBsZXQgaGFzaEluZGV4ID0gdXJsLmluZGV4T2YoXCIjXCIpO1xuICAgICAgaHJlZiA9IGhhc2hJbmRleCA9PT0gLTEgPyB1cmwgOiB1cmwuc2xpY2UoMCwgaGFzaEluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHJlZiArIFwiI1wiICsgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0bykpO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVIYXNoTG9jYXRpb24obG9jYXRpb246IExvY2F0aW9uLCB0bzogVG8pIHtcbiAgICB3YXJuaW5nKFxuICAgICAgbG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSBcIi9cIixcbiAgICAgIGByZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gaGFzaCBoaXN0b3J5LnB1c2goJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgdG9cbiAgICAgICl9KWBcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShcbiAgICBjcmVhdGVIYXNoTG9jYXRpb24sXG4gICAgY3JlYXRlSGFzaEhyZWYsXG4gICAgdmFsaWRhdGVIYXNoTG9jYXRpb24sXG4gICAgb3B0aW9uc1xuICApO1xufVxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gVVRJTFNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFyaWFudCh2YWx1ZTogYm9vbGVhbiwgbWVzc2FnZT86IHN0cmluZyk6IGFzc2VydHMgdmFsdWU7XG5leHBvcnQgZnVuY3Rpb24gaW52YXJpYW50PFQ+KFxuICB2YWx1ZTogVCB8IG51bGwgfCB1bmRlZmluZWQsXG4gIG1lc3NhZ2U/OiBzdHJpbmdcbik6IGFzc2VydHMgdmFsdWUgaXMgVDtcbmV4cG9ydCBmdW5jdGlvbiBpbnZhcmlhbnQodmFsdWU6IGFueSwgbWVzc2FnZT86IHN0cmluZykge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuaW5nKGNvbmQ6IGFueSwgbWVzc2FnZTogc3RyaW5nKSB7XG4gIGlmICghY29uZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gV2VsY29tZSB0byBkZWJ1Z2dpbmcgaGlzdG9yeSFcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHlvdSBjYW4gbW9yZSBlYXNpbHlcbiAgICAgIC8vIGZpbmQgdGhlIHNvdXJjZSBmb3IgYSB3YXJuaW5nIHRoYXQgYXBwZWFycyBpbiB0aGUgY29uc29sZSBieVxuICAgICAgLy8gZW5hYmxpbmcgXCJwYXVzZSBvbiBleGNlcHRpb25zXCIgaW4geW91ciBKYXZhU2NyaXB0IGRlYnVnZ2VyLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOCk7XG59XG5cbi8qKlxuICogRm9yIGJyb3dzZXItYmFzZWQgaGlzdG9yaWVzLCB3ZSBjb21iaW5lIHRoZSBzdGF0ZSBhbmQga2V5IGludG8gYW4gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbjogTG9jYXRpb24sIGluZGV4OiBudW1iZXIpOiBIaXN0b3J5U3RhdGUge1xuICByZXR1cm4ge1xuICAgIHVzcjogbG9jYXRpb24uc3RhdGUsXG4gICAga2V5OiBsb2NhdGlvbi5rZXksXG4gICAgaWR4OiBpbmRleCxcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgTG9jYXRpb24gb2JqZWN0IHdpdGggYSB1bmlxdWUga2V5IGZyb20gdGhlIGdpdmVuIFBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKFxuICBjdXJyZW50OiBzdHJpbmcgfCBMb2NhdGlvbixcbiAgdG86IFRvLFxuICBzdGF0ZTogYW55ID0gbnVsbCxcbiAga2V5Pzogc3RyaW5nXG4pOiBSZWFkb25seTxMb2NhdGlvbj4ge1xuICBsZXQgbG9jYXRpb246IFJlYWRvbmx5PExvY2F0aW9uPiA9IHtcbiAgICBwYXRobmFtZTogdHlwZW9mIGN1cnJlbnQgPT09IFwic3RyaW5nXCIgPyBjdXJyZW50IDogY3VycmVudC5wYXRobmFtZSxcbiAgICBzZWFyY2g6IFwiXCIsXG4gICAgaGFzaDogXCJcIixcbiAgICAuLi4odHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvKSxcbiAgICBzdGF0ZSxcbiAgICAvLyBUT0RPOiBUaGlzIGNvdWxkIGJlIGNsZWFuZWQgdXAuICBwdXNoL3JlcGxhY2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgdGFrZVxuICAgIC8vIGZ1bGwgTG9jYXRpb25zIG5vdyBhbmQgYXZvaWQgdGhlIG5lZWQgdG8gcnVuIHRocm91Z2ggdGhpcyBmbG93IGF0IGFsbFxuICAgIC8vIEJ1dCB0aGF0J3MgYSBwcmV0dHkgYmlnIHJlZmFjdG9yIHRvIHRoZSBjdXJyZW50IHRlc3Qgc3VpdGUgc28gZ29pbmcgdG9cbiAgICAvLyBrZWVwIGFzIGlzIGZvciB0aGUgdGltZSBiZWluZyBhbmQganVzdCBsZXQgYW55IGluY29taW5nIGtleXMgdGFrZSBwcmVjZWRlbmNlXG4gICAga2V5OiAodG8gJiYgKHRvIGFzIExvY2F0aW9uKS5rZXkpIHx8IGtleSB8fCBjcmVhdGVLZXkoKSxcbiAgfTtcbiAgcmV0dXJuIGxvY2F0aW9uO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgVVJMIHBhdGggZnJvbSB0aGUgZ2l2ZW4gcGF0aG5hbWUsIHNlYXJjaCwgYW5kIGhhc2ggY29tcG9uZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBhdGgoe1xuICBwYXRobmFtZSA9IFwiL1wiLFxuICBzZWFyY2ggPSBcIlwiLFxuICBoYXNoID0gXCJcIixcbn06IFBhcnRpYWw8UGF0aD4pIHtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09IFwiP1wiKVxuICAgIHBhdGhuYW1lICs9IHNlYXJjaC5jaGFyQXQoMCkgPT09IFwiP1wiID8gc2VhcmNoIDogXCI/XCIgKyBzZWFyY2g7XG4gIGlmIChoYXNoICYmIGhhc2ggIT09IFwiI1wiKVxuICAgIHBhdGhuYW1lICs9IGhhc2guY2hhckF0KDApID09PSBcIiNcIiA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG4gIHJldHVybiBwYXRobmFtZTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSBzdHJpbmcgVVJMIHBhdGggaW50byBpdHMgc2VwYXJhdGUgcGF0aG5hbWUsIHNlYXJjaCwgYW5kIGhhc2ggY29tcG9uZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoOiBzdHJpbmcpOiBQYXJ0aWFsPFBhdGg+IHtcbiAgbGV0IHBhcnNlZFBhdGg6IFBhcnRpYWw8UGF0aD4gPSB7fTtcblxuICBpZiAocGF0aCkge1xuICAgIGxldCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpO1xuICAgIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgICAgcGFyc2VkUGF0aC5oYXNoID0gcGF0aC5zdWJzdHIoaGFzaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICAgIH1cblxuICAgIGxldCBzZWFyY2hJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKHNlYXJjaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguc2VhcmNoID0gcGF0aC5zdWJzdHIoc2VhcmNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHNlYXJjaEluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAocGF0aCkge1xuICAgICAgcGFyc2VkUGF0aC5wYXRobmFtZSA9IHBhdGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnNlZFBhdGg7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXJsSGlzdG9yeSBleHRlbmRzIEhpc3Rvcnkge31cblxuZXhwb3J0IHR5cGUgVXJsSGlzdG9yeU9wdGlvbnMgPSB7XG4gIHdpbmRvdz86IFdpbmRvdztcbiAgdjVDb21wYXQ/OiBib29sZWFuO1xufTtcblxuZnVuY3Rpb24gZ2V0VXJsQmFzZWRIaXN0b3J5KFxuICBnZXRMb2NhdGlvbjogKHdpbmRvdzogV2luZG93LCBnbG9iYWxIaXN0b3J5OiBXaW5kb3dbXCJoaXN0b3J5XCJdKSA9PiBMb2NhdGlvbixcbiAgY3JlYXRlSHJlZjogKHdpbmRvdzogV2luZG93LCB0bzogVG8pID0+IHN0cmluZyxcbiAgdmFsaWRhdGVMb2NhdGlvbjogKChsb2NhdGlvbjogTG9jYXRpb24sIHRvOiBUbykgPT4gdm9pZCkgfCBudWxsLFxuICBvcHRpb25zOiBVcmxIaXN0b3J5T3B0aW9ucyA9IHt9XG4pOiBVcmxIaXN0b3J5IHtcbiAgbGV0IHsgd2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXchLCB2NUNvbXBhdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBsZXQgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICBsZXQgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgbGV0IGxpc3RlbmVyOiBMaXN0ZW5lciB8IG51bGwgPSBudWxsO1xuXG4gIGxldCBpbmRleCA9IGdldEluZGV4KCkhO1xuICAvLyBJbmRleCBzaG91bGQgb25seSBiZSBudWxsIHdoZW4gd2UgaW5pdGlhbGl6ZS4gSWYgbm90LCBpdCdzIGJlY2F1c2UgdGhlXG4gIC8vIHVzZXIgY2FsbGVkIGhpc3RvcnkucHVzaFN0YXRlIG9yIGhpc3RvcnkucmVwbGFjZVN0YXRlIGRpcmVjdGx5LCBpbiB3aGljaFxuICAvLyBjYXNlIHdlIHNob3VsZCBsb2cgYSB3YXJuaW5nIGFzIGl0IHdpbGwgcmVzdWx0IGluIGJ1Z3MuXG4gIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgaW5kZXggPSAwO1xuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHsgLi4uZ2xvYmFsSGlzdG9yeS5zdGF0ZSwgaWR4OiBpbmRleCB9LCBcIlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEluZGV4KCk6IG51bWJlciB7XG4gICAgbGV0IHN0YXRlID0gZ2xvYmFsSGlzdG9yeS5zdGF0ZSB8fCB7IGlkeDogbnVsbCB9O1xuICAgIHJldHVybiBzdGF0ZS5pZHg7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQb3AoKSB7XG4gICAgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgICBsZXQgbmV4dEluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgICBsZXQgZGVsdGEgPSBuZXh0SW5kZXggPT0gbnVsbCA/IG51bGwgOiBuZXh0SW5kZXggLSBpbmRleDtcbiAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbiwgZGVsdGEgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHVzaCh0bzogVG8sIHN0YXRlPzogYW55KSB7XG4gICAgYWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oaGlzdG9yeS5sb2NhdGlvbiwgdG8sIHN0YXRlKTtcbiAgICBpZiAodmFsaWRhdGVMb2NhdGlvbikgdmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbiwgdG8pO1xuXG4gICAgaW5kZXggPSBnZXRJbmRleCgpICsgMTtcbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCk7XG4gICAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbik7XG5cbiAgICAvLyB0cnkuLi5jYXRjaCBiZWNhdXNlIGlPUyBsaW1pdHMgdXMgdG8gMTAwIHB1c2hTdGF0ZSBjYWxscyA6L1xuICAgIHRyeSB7XG4gICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsIFwiXCIsIHVybCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFRoZXkgYXJlIGdvaW5nIHRvIGxvc2Ugc3RhdGUgaGVyZSwgYnV0IHRoZXJlIGlzIG5vIHJlYWxcbiAgICAgIC8vIHdheSB0byB3YXJuIHRoZW0gYWJvdXQgaXQgc2luY2UgdGhlIHBhZ2Ugd2lsbCByZWZyZXNoLi4uXG4gICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgfVxuXG4gICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sIGRlbHRhOiAxIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UodG86IFRvLCBzdGF0ZT86IGFueSkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGhpc3RvcnkubG9jYXRpb24sIHRvLCBzdGF0ZSk7XG4gICAgaWYgKHZhbGlkYXRlTG9jYXRpb24pIHZhbGlkYXRlTG9jYXRpb24obG9jYXRpb24sIHRvKTtcblxuICAgIGluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCk7XG4gICAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCBcIlwiLCB1cmwpO1xuXG4gICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sIGRlbHRhOiAwIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVSTCh0bzogVG8pOiBVUkwge1xuICAgIC8vIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gaXMgXCJudWxsXCIgKHRoZSBsaXRlcmFsIHN0cmluZyB2YWx1ZSkgaW4gRmlyZWZveFxuICAgIC8vIHVuZGVyIGNlcnRhaW4gY29uZGl0aW9ucywgbm90YWJseSB3aGVuIHNlcnZpbmcgZnJvbSBhIGxvY2FsIEhUTUwgZmlsZVxuICAgIC8vIFNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04NzgyOTdcbiAgICBsZXQgYmFzZSA9XG4gICAgICB3aW5kb3cubG9jYXRpb24ub3JpZ2luICE9PSBcIm51bGxcIlxuICAgICAgICA/IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICAgICAgOiB3aW5kb3cubG9jYXRpb24uaHJlZjtcblxuICAgIGxldCBocmVmID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBiYXNlLFxuICAgICAgYE5vIHdpbmRvdy5sb2NhdGlvbi4ob3JpZ2lufGhyZWYpIGF2YWlsYWJsZSB0byBjcmVhdGUgVVJMIGZvciBocmVmOiAke2hyZWZ9YFxuICAgICk7XG4gICAgcmV0dXJuIG5ldyBVUkwoaHJlZiwgYmFzZSk7XG4gIH1cblxuICBsZXQgaGlzdG9yeTogSGlzdG9yeSA9IHtcbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBnZXRMb2NhdGlvbih3aW5kb3csIGdsb2JhbEhpc3RvcnkpO1xuICAgIH0sXG4gICAgbGlzdGVuKGZuOiBMaXN0ZW5lcikge1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgaGlzdG9yeSBvbmx5IGFjY2VwdHMgb25lIGFjdGl2ZSBsaXN0ZW5lclwiKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgbGlzdGVuZXIgPSBmbjtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudFR5cGUsIGhhbmRsZVBvcCk7XG4gICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmKHRvKSB7XG4gICAgICByZXR1cm4gY3JlYXRlSHJlZih3aW5kb3csIHRvKTtcbiAgICB9LFxuICAgIGNyZWF0ZVVSTCxcbiAgICBlbmNvZGVMb2NhdGlvbih0bykge1xuICAgICAgLy8gRW5jb2RlIGEgTG9jYXRpb24gdGhlIHNhbWUgd2F5IHdpbmRvdy5sb2NhdGlvbiB3b3VsZFxuICAgICAgbGV0IHVybCA9IGNyZWF0ZVVSTCh0byk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRobmFtZTogdXJsLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2g6IHVybC5zZWFyY2gsXG4gICAgICAgIGhhc2g6IHVybC5oYXNoLFxuICAgICAgfTtcbiAgICB9LFxuICAgIHB1c2gsXG4gICAgcmVwbGFjZSxcbiAgICBnbyhuKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufVxuXG4vLyNlbmRyZWdpb25cbiIsImltcG9ydCB0eXBlIHsgTG9jYXRpb24sIFBhdGgsIFRvIH0gZnJvbSBcIi4vaGlzdG9yeVwiO1xuaW1wb3J0IHsgaW52YXJpYW50LCBwYXJzZVBhdGggfSBmcm9tIFwiLi9oaXN0b3J5XCI7XG5cbi8qKlxuICogTWFwIG9mIHJvdXRlSWQgLT4gZGF0YSByZXR1cm5lZCBmcm9tIGEgbG9hZGVyL2FjdGlvbi9lcnJvclxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlRGF0YSB7XG4gIFtyb3V0ZUlkOiBzdHJpbmddOiBhbnk7XG59XG5cbmV4cG9ydCBlbnVtIFJlc3VsdFR5cGUge1xuICBkYXRhID0gXCJkYXRhXCIsXG4gIGRlZmVycmVkID0gXCJkZWZlcnJlZFwiLFxuICByZWRpcmVjdCA9IFwicmVkaXJlY3RcIixcbiAgZXJyb3IgPSBcImVycm9yXCIsXG59XG5cbi8qKlxuICogU3VjY2Vzc2Z1bCByZXN1bHQgZnJvbSBhIGxvYWRlciBvciBhY3Rpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdWNjZXNzUmVzdWx0IHtcbiAgdHlwZTogUmVzdWx0VHlwZS5kYXRhO1xuICBkYXRhOiBhbnk7XG4gIHN0YXR1c0NvZGU/OiBudW1iZXI7XG4gIGhlYWRlcnM/OiBIZWFkZXJzO1xufVxuXG4vKipcbiAqIFN1Y2Nlc3NmdWwgZGVmZXIoKSByZXN1bHQgZnJvbSBhIGxvYWRlciBvciBhY3Rpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZWZlcnJlZFJlc3VsdCB7XG4gIHR5cGU6IFJlc3VsdFR5cGUuZGVmZXJyZWQ7XG4gIGRlZmVycmVkRGF0YTogRGVmZXJyZWREYXRhO1xuICBzdGF0dXNDb2RlPzogbnVtYmVyO1xuICBoZWFkZXJzPzogSGVhZGVycztcbn1cblxuLyoqXG4gKiBSZWRpcmVjdCByZXN1bHQgZnJvbSBhIGxvYWRlciBvciBhY3Rpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWRpcmVjdFJlc3VsdCB7XG4gIHR5cGU6IFJlc3VsdFR5cGUucmVkaXJlY3Q7XG4gIHN0YXR1czogbnVtYmVyO1xuICBsb2NhdGlvbjogc3RyaW5nO1xuICByZXZhbGlkYXRlOiBib29sZWFuO1xufVxuXG4vKipcbiAqIFVuc3VjY2Vzc2Z1bCByZXN1bHQgZnJvbSBhIGxvYWRlciBvciBhY3Rpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFcnJvclJlc3VsdCB7XG4gIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3I7XG4gIGVycm9yOiBhbnk7XG4gIGhlYWRlcnM/OiBIZWFkZXJzO1xufVxuXG4vKipcbiAqIFJlc3VsdCBmcm9tIGEgbG9hZGVyIG9yIGFjdGlvbiAtIHBvdGVudGlhbGx5IHN1Y2Nlc3NmdWwgb3IgdW5zdWNjZXNzZnVsXG4gKi9cbmV4cG9ydCB0eXBlIERhdGFSZXN1bHQgPVxuICB8IFN1Y2Nlc3NSZXN1bHRcbiAgfCBEZWZlcnJlZFJlc3VsdFxuICB8IFJlZGlyZWN0UmVzdWx0XG4gIHwgRXJyb3JSZXN1bHQ7XG5cbmV4cG9ydCB0eXBlIE11dGF0aW9uRm9ybU1ldGhvZCA9IFwicG9zdFwiIHwgXCJwdXRcIiB8IFwicGF0Y2hcIiB8IFwiZGVsZXRlXCI7XG5leHBvcnQgdHlwZSBGb3JtTWV0aG9kID0gXCJnZXRcIiB8IE11dGF0aW9uRm9ybU1ldGhvZDtcblxuZXhwb3J0IHR5cGUgRm9ybUVuY1R5cGUgPVxuICB8IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAgfCBcIm11bHRpcGFydC9mb3JtLWRhdGFcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogSW50ZXJuYWwgaW50ZXJmYWNlIHRvIHBhc3MgYXJvdW5kIGZvciBhY3Rpb24gc3VibWlzc2lvbnMsIG5vdCBpbnRlbmRlZCBmb3JcbiAqIGV4dGVybmFsIGNvbnN1bXB0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3VibWlzc2lvbiB7XG4gIGZvcm1NZXRob2Q6IEZvcm1NZXRob2Q7XG4gIGZvcm1BY3Rpb246IHN0cmluZztcbiAgZm9ybUVuY1R5cGU6IEZvcm1FbmNUeXBlO1xuICBmb3JtRGF0YTogRm9ybURhdGE7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEFyZ3VtZW50cyBwYXNzZWQgdG8gcm91dGUgbG9hZGVyL2FjdGlvbiBmdW5jdGlvbnMuICBTYW1lIGZvciBub3cgYnV0IHdlIGtlZXBcbiAqIHRoaXMgYXMgYSBwcml2YXRlIGltcGxlbWVudGF0aW9uIGRldGFpbCBpbiBjYXNlIHRoZXkgZGl2ZXJnZSBpbiB0aGUgZnV0dXJlLlxuICovXG5pbnRlcmZhY2UgRGF0YUZ1bmN0aW9uQXJncyB7XG4gIHJlcXVlc3Q6IFJlcXVlc3Q7XG4gIHBhcmFtczogUGFyYW1zO1xuICBjb250ZXh0PzogYW55O1xufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBwYXNzZWQgdG8gbG9hZGVyIGZ1bmN0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlckZ1bmN0aW9uQXJncyBleHRlbmRzIERhdGFGdW5jdGlvbkFyZ3Mge31cblxuLyoqXG4gKiBBcmd1bWVudHMgcGFzc2VkIHRvIGFjdGlvbiBmdW5jdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25GdW5jdGlvbkFyZ3MgZXh0ZW5kcyBEYXRhRnVuY3Rpb25BcmdzIHt9XG5cbi8qKlxuICogUm91dGUgbG9hZGVyIGZ1bmN0aW9uIHNpZ25hdHVyZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlckZ1bmN0aW9uIHtcbiAgKGFyZ3M6IExvYWRlckZ1bmN0aW9uQXJncyk6IFByb21pc2U8UmVzcG9uc2U+IHwgUmVzcG9uc2UgfCBQcm9taXNlPGFueT4gfCBhbnk7XG59XG5cbi8qKlxuICogUm91dGUgYWN0aW9uIGZ1bmN0aW9uIHNpZ25hdHVyZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkZ1bmN0aW9uIHtcbiAgKGFyZ3M6IEFjdGlvbkZ1bmN0aW9uQXJncyk6IFByb21pc2U8UmVzcG9uc2U+IHwgUmVzcG9uc2UgfCBQcm9taXNlPGFueT4gfCBhbnk7XG59XG5cbi8qKlxuICogUm91dGUgc2hvdWxkUmV2YWxpZGF0ZSBmdW5jdGlvbiBzaWduYXR1cmUuICBUaGlzIHJ1bnMgYWZ0ZXIgYW55IHN1Ym1pc3Npb25cbiAqIChuYXZpZ2F0aW9uIG9yIGZldGNoZXIpLCBzbyB3ZSBmbGF0dGVuIHRoZSBuYXZpZ2F0aW9uL2ZldGNoZXIgc3VibWlzc2lvblxuICogb250byB0aGUgYXJndW1lbnRzLiAgSXQgc2hvdWxkbid0IG1hdHRlciB3aGV0aGVyIGl0IGNhbWUgZnJvbSBhIG5hdmlnYXRpb25cbiAqIG9yIGEgZmV0Y2hlciwgd2hhdCByZWFsbHkgbWF0dGVycyBpcyB0aGUgVVJMcyBhbmQgdGhlIGZvcm1EYXRhIHNpbmNlIGxvYWRlcnNcbiAqIGhhdmUgdG8gcmUtcnVuIGJhc2VkIG9uIHRoZSBkYXRhIG1vZGVscyB0aGF0IHdlcmUgcG90ZW50aWFsbHkgbXV0YXRlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb24ge1xuICAoYXJnczoge1xuICAgIGN1cnJlbnRVcmw6IFVSTDtcbiAgICBjdXJyZW50UGFyYW1zOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW1wicGFyYW1zXCJdO1xuICAgIG5leHRVcmw6IFVSTDtcbiAgICBuZXh0UGFyYW1zOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW1wicGFyYW1zXCJdO1xuICAgIGZvcm1NZXRob2Q/OiBTdWJtaXNzaW9uW1wiZm9ybU1ldGhvZFwiXTtcbiAgICBmb3JtQWN0aW9uPzogU3VibWlzc2lvbltcImZvcm1BY3Rpb25cIl07XG4gICAgZm9ybUVuY1R5cGU/OiBTdWJtaXNzaW9uW1wiZm9ybUVuY1R5cGVcIl07XG4gICAgZm9ybURhdGE/OiBTdWJtaXNzaW9uW1wiZm9ybURhdGFcIl07XG4gICAgYWN0aW9uUmVzdWx0PzogRGF0YVJlc3VsdDtcbiAgICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTogYm9vbGVhbjtcbiAgfSk6IGJvb2xlYW47XG59XG5cbi8qKlxuICogQmFzZSBSb3V0ZU9iamVjdCB3aXRoIGNvbW1vbiBwcm9wcyBzaGFyZWQgYnkgYWxsIHR5cGVzIG9mIHJvdXRlc1xuICovXG50eXBlIEFnbm9zdGljQmFzZVJvdXRlT2JqZWN0ID0ge1xuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgcGF0aD86IHN0cmluZztcbiAgaWQ/OiBzdHJpbmc7XG4gIGxvYWRlcj86IExvYWRlckZ1bmN0aW9uO1xuICBhY3Rpb24/OiBBY3Rpb25GdW5jdGlvbjtcbiAgaGFzRXJyb3JCb3VuZGFyeT86IGJvb2xlYW47XG4gIHNob3VsZFJldmFsaWRhdGU/OiBTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb247XG4gIGhhbmRsZT86IGFueTtcbn07XG5cbi8qKlxuICogSW5kZXggcm91dGVzIG11c3Qgbm90IGhhdmUgY2hpbGRyZW5cbiAqL1xuZXhwb3J0IHR5cGUgQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0ID0gQWdub3N0aWNCYXNlUm91dGVPYmplY3QgJiB7XG4gIGNoaWxkcmVuPzogdW5kZWZpbmVkO1xuICBpbmRleDogdHJ1ZTtcbn07XG5cbi8qKlxuICogTm9uLWluZGV4IHJvdXRlcyBtYXkgaGF2ZSBjaGlsZHJlbiwgYnV0IGNhbm5vdCBoYXZlIGluZGV4XG4gKi9cbmV4cG9ydCB0eXBlIEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdCA9IEFnbm9zdGljQmFzZVJvdXRlT2JqZWN0ICYge1xuICBjaGlsZHJlbj86IEFnbm9zdGljUm91dGVPYmplY3RbXTtcbiAgaW5kZXg/OiBmYWxzZTtcbn07XG5cbi8qKlxuICogQSByb3V0ZSBvYmplY3QgcmVwcmVzZW50cyBhIGxvZ2ljYWwgcm91dGUsIHdpdGggKG9wdGlvbmFsbHkpIGl0cyBjaGlsZFxuICogcm91dGVzIG9yZ2FuaXplZCBpbiBhIHRyZWUtbGlrZSBzdHJ1Y3R1cmUuXG4gKi9cbmV4cG9ydCB0eXBlIEFnbm9zdGljUm91dGVPYmplY3QgPVxuICB8IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdFxuICB8IEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdDtcblxuZXhwb3J0IHR5cGUgQWdub3N0aWNEYXRhSW5kZXhSb3V0ZU9iamVjdCA9IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdCAmIHtcbiAgaWQ6IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIEFnbm9zdGljRGF0YU5vbkluZGV4Um91dGVPYmplY3QgPSBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3QgJiB7XG4gIGNoaWxkcmVuPzogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXTtcbiAgaWQ6IHN0cmluZztcbn07XG5cbi8qKlxuICogQSBkYXRhIHJvdXRlIG9iamVjdCwgd2hpY2ggaXMganVzdCBhIFJvdXRlT2JqZWN0IHdpdGggYSByZXF1aXJlZCB1bmlxdWUgSURcbiAqL1xuZXhwb3J0IHR5cGUgQWdub3N0aWNEYXRhUm91dGVPYmplY3QgPVxuICB8IEFnbm9zdGljRGF0YUluZGV4Um91dGVPYmplY3RcbiAgfCBBZ25vc3RpY0RhdGFOb25JbmRleFJvdXRlT2JqZWN0O1xuXG4vLyBSZWN1cnNpdmUgaGVscGVyIGZvciBmaW5kaW5nIHBhdGggcGFyYW1ldGVycyBpbiB0aGUgYWJzZW5jZSBvZiB3aWxkY2FyZHNcbnR5cGUgX1BhdGhQYXJhbTxQYXRoIGV4dGVuZHMgc3RyaW5nPiA9XG4gIC8vIHNwbGl0IHBhdGggaW50byBpbmRpdmlkdWFsIHBhdGggc2VnbWVudHNcbiAgUGF0aCBleHRlbmRzIGAke2luZmVyIEx9LyR7aW5mZXIgUn1gXG4gICAgPyBfUGF0aFBhcmFtPEw+IHwgX1BhdGhQYXJhbTxSPlxuICAgIDogLy8gZmluZCBwYXJhbXMgYWZ0ZXIgYDpgXG4gICAgUGF0aCBleHRlbmRzIGA6JHtpbmZlciBQYXJhbX1gXG4gICAgPyBQYXJhbSBleHRlbmRzIGAke2luZmVyIE9wdGlvbmFsfT9gXG4gICAgICA/IE9wdGlvbmFsXG4gICAgICA6IFBhcmFtXG4gICAgOiAvLyBvdGhlcndpc2UsIHRoZXJlIGFyZW4ndCBhbnkgcGFyYW1zIHByZXNlbnRcbiAgICAgIG5ldmVyO1xuXG4vKipcbiAqIEV4YW1wbGVzOlxuICogXCIvYS9iLypcIiAtPiBcIipcIlxuICogXCI6YVwiIC0+IFwiYVwiXG4gKiBcIi9hLzpiXCIgLT4gXCJiXCJcbiAqIFwiL2EvYmxhaGJsYWhibGFoOmJcIiAtPiBcImJcIlxuICogXCIvOmEvOmJcIiAtPiBcImFcIiB8IFwiYlwiXG4gKiBcIi86YS9iLzpjLypcIiAtPiBcImFcIiB8IFwiY1wiIHwgXCIqXCJcbiAqL1xudHlwZSBQYXRoUGFyYW08UGF0aCBleHRlbmRzIHN0cmluZz4gPVxuICAvLyBjaGVjayBpZiBwYXRoIGlzIGp1c3QgYSB3aWxkY2FyZFxuICBQYXRoIGV4dGVuZHMgXCIqXCJcbiAgICA/IFwiKlwiXG4gICAgOiAvLyBsb29rIGZvciB3aWxkY2FyZCBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoXG4gICAgUGF0aCBleHRlbmRzIGAke2luZmVyIFJlc3R9LypgXG4gICAgPyBcIipcIiB8IF9QYXRoUGFyYW08UmVzdD5cbiAgICA6IC8vIGxvb2sgZm9yIHBhcmFtcyBpbiB0aGUgYWJzZW5jZSBvZiB3aWxkY2FyZHNcbiAgICAgIF9QYXRoUGFyYW08UGF0aD47XG5cbi8vIEF0dGVtcHQgdG8gcGFyc2UgdGhlIGdpdmVuIHN0cmluZyBzZWdtZW50LiBJZiBpdCBmYWlscywgdGhlbiBqdXN0IHJldHVybiB0aGVcbi8vIHBsYWluIHN0cmluZyB0eXBlIGFzIGEgZGVmYXVsdCBmYWxsYmFjay4gT3RoZXJ3aXNlIHJldHVybiB0aGUgdW5pb24gb2YgdGhlXG4vLyBwYXJzZWQgc3RyaW5nIGxpdGVyYWxzIHRoYXQgd2VyZSByZWZlcmVuY2VkIGFzIGR5bmFtaWMgc2VnbWVudHMgaW4gdGhlIHJvdXRlLlxuZXhwb3J0IHR5cGUgUGFyYW1QYXJzZUtleTxTZWdtZW50IGV4dGVuZHMgc3RyaW5nPiA9XG4gIC8vIGlmIGNvdWxkIG5vdCBmaW5kIHBhdGggcGFyYW1zLCBmYWxsYmFjayB0byBgc3RyaW5nYFxuICBbUGF0aFBhcmFtPFNlZ21lbnQ+XSBleHRlbmRzIFtuZXZlcl0gPyBzdHJpbmcgOiBQYXRoUGFyYW08U2VnbWVudD47XG5cbi8qKlxuICogVGhlIHBhcmFtZXRlcnMgdGhhdCB3ZXJlIHBhcnNlZCBmcm9tIHRoZSBVUkwgcGF0aC5cbiAqL1xuZXhwb3J0IHR5cGUgUGFyYW1zPEtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4gPSB7XG4gIHJlYWRvbmx5IFtrZXkgaW4gS2V5XTogc3RyaW5nIHwgdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBBIFJvdXRlTWF0Y2ggY29udGFpbnMgaW5mbyBhYm91dCBob3cgYSByb3V0ZSBtYXRjaGVkIGEgVVJMLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFnbm9zdGljUm91dGVNYXRjaDxcbiAgUGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsXG4gIFJvdXRlT2JqZWN0VHlwZSBleHRlbmRzIEFnbm9zdGljUm91dGVPYmplY3QgPSBBZ25vc3RpY1JvdXRlT2JqZWN0XG4+IHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIGR5bmFtaWMgcGFyYW1ldGVycyBpbiB0aGUgVVJMLlxuICAgKi9cbiAgcGFyYW1zOiBQYXJhbXM8UGFyYW1LZXk+O1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZCBiZWZvcmUgY2hpbGQgcm91dGVzLlxuICAgKi9cbiAgcGF0aG5hbWVCYXNlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcm91dGUgb2JqZWN0IHRoYXQgd2FzIHVzZWQgdG8gbWF0Y2guXG4gICAqL1xuICByb3V0ZTogUm91dGVPYmplY3RUeXBlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hcbiAgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlTWF0Y2g8c3RyaW5nLCBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdD4ge31cblxuZnVuY3Rpb24gaXNJbmRleFJvdXRlKFxuICByb3V0ZTogQWdub3N0aWNSb3V0ZU9iamVjdFxuKTogcm91dGUgaXMgQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0IHtcbiAgcmV0dXJuIHJvdXRlLmluZGV4ID09PSB0cnVlO1xufVxuXG4vLyBXYWxrIHRoZSByb3V0ZSB0cmVlIGdlbmVyYXRpbmcgdW5pcXVlIElEcyB3aGVyZSBuZWNlc3Nhcnkgc28gd2UgYXJlIHdvcmtpbmdcbi8vIHNvbGVseSB3aXRoIEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0J3Mgd2l0aGluIHRoZSBSb3V0ZXJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICByb3V0ZXM6IEFnbm9zdGljUm91dGVPYmplY3RbXSxcbiAgcGFyZW50UGF0aDogbnVtYmVyW10gPSBbXSxcbiAgYWxsSWRzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQ8c3RyaW5nPigpXG4pOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdIHtcbiAgcmV0dXJuIHJvdXRlcy5tYXAoKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIGxldCB0cmVlUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBpbmRleF07XG4gICAgbGV0IGlkID0gdHlwZW9mIHJvdXRlLmlkID09PSBcInN0cmluZ1wiID8gcm91dGUuaWQgOiB0cmVlUGF0aC5qb2luKFwiLVwiKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICByb3V0ZS5pbmRleCAhPT0gdHJ1ZSB8fCAhcm91dGUuY2hpbGRyZW4sXG4gICAgICBgQ2Fubm90IHNwZWNpZnkgY2hpbGRyZW4gb24gYW4gaW5kZXggcm91dGVgXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhYWxsSWRzLmhhcyhpZCksXG4gICAgICBgRm91bmQgYSByb3V0ZSBpZCBjb2xsaXNpb24gb24gaWQgXCIke2lkfVwiLiAgUm91dGUgYCArXG4gICAgICAgIFwiaWQncyBtdXN0IGJlIGdsb2JhbGx5IHVuaXF1ZSB3aXRoaW4gRGF0YSBSb3V0ZXIgdXNhZ2VzXCJcbiAgICApO1xuICAgIGFsbElkcy5hZGQoaWQpO1xuXG4gICAgaWYgKGlzSW5kZXhSb3V0ZShyb3V0ZSkpIHtcbiAgICAgIGxldCBpbmRleFJvdXRlOiBBZ25vc3RpY0RhdGFJbmRleFJvdXRlT2JqZWN0ID0geyAuLi5yb3V0ZSwgaWQgfTtcbiAgICAgIHJldHVybiBpbmRleFJvdXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGF0aE9yTGF5b3V0Um91dGU6IEFnbm9zdGljRGF0YU5vbkluZGV4Um91dGVPYmplY3QgPSB7XG4gICAgICAgIC4uLnJvdXRlLFxuICAgICAgICBpZCxcbiAgICAgICAgY2hpbGRyZW46IHJvdXRlLmNoaWxkcmVuXG4gICAgICAgICAgPyBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlLmNoaWxkcmVuLCB0cmVlUGF0aCwgYWxsSWRzKVxuICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICAgIHJldHVybiBwYXRoT3JMYXlvdXRSb3V0ZTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIE1hdGNoZXMgdGhlIGdpdmVuIHJvdXRlcyB0byBhIGxvY2F0aW9uIGFuZCByZXR1cm5zIHRoZSBtYXRjaCBkYXRhLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvbWF0Y2gtcm91dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFJvdXRlczxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4oXG4gIHJvdXRlczogUm91dGVPYmplY3RUeXBlW10sXG4gIGxvY2F0aW9uQXJnOiBQYXJ0aWFsPExvY2F0aW9uPiB8IHN0cmluZyxcbiAgYmFzZW5hbWUgPSBcIi9cIlxuKTogQWdub3N0aWNSb3V0ZU1hdGNoPHN0cmluZywgUm91dGVPYmplY3RUeXBlPltdIHwgbnVsbCB7XG4gIGxldCBsb2NhdGlvbiA9XG4gICAgdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuXG4gIGxldCBwYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCIsIGJhc2VuYW1lKTtcblxuICBpZiAocGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IGJyYW5jaGVzID0gZmxhdHRlblJvdXRlcyhyb3V0ZXMpO1xuICByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcyk7XG5cbiAgbGV0IG1hdGNoZXMgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgbWF0Y2hlcyA9PSBudWxsICYmIGkgPCBicmFuY2hlcy5sZW5ndGg7ICsraSkge1xuICAgIG1hdGNoZXMgPSBtYXRjaFJvdXRlQnJhbmNoPHN0cmluZywgUm91dGVPYmplY3RUeXBlPihcbiAgICAgIGJyYW5jaGVzW2ldLFxuICAgICAgLy8gSW5jb21pbmcgcGF0aG5hbWVzIGFyZSBnZW5lcmFsbHkgZW5jb2RlZCBmcm9tIGVpdGhlciB3aW5kb3cubG9jYXRpb25cbiAgICAgIC8vIG9yIGZyb20gcm91dGVyLm5hdmlnYXRlLCBidXQgd2Ugd2FudCB0byBtYXRjaCBhZ2FpbnN0IHRoZSB1bmVuY29kZWRcbiAgICAgIC8vIHBhdGhzIGluIHRoZSByb3V0ZSBkZWZpbml0aW9ucy4gIE1lbW9yeSByb3V0ZXIgbG9jYXRpb25zIHdvbid0IGJlXG4gICAgICAvLyBlbmNvZGVkIGhlcmUgYnV0IHRoZXJlIGFsc28gc2hvdWxkbid0IGJlIGFueXRoaW5nIHRvIGRlY29kZSBzbyB0aGlzXG4gICAgICAvLyBzaG91bGQgYmUgYSBzYWZlIG9wZXJhdGlvbi4gIFRoaXMgYXZvaWRzIG5lZWRpbmcgbWF0Y2hSb3V0ZXMgdG8gYmVcbiAgICAgIC8vIGhpc3RvcnktYXdhcmUuXG4gICAgICBzYWZlbHlEZWNvZGVVUkkocGF0aG5hbWUpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG5pbnRlcmZhY2UgUm91dGVNZXRhPFxuICBSb3V0ZU9iamVjdFR5cGUgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0ID0gQWdub3N0aWNSb3V0ZU9iamVjdFxuPiB7XG4gIHJlbGF0aXZlUGF0aDogc3RyaW5nO1xuICBjYXNlU2Vuc2l0aXZlOiBib29sZWFuO1xuICBjaGlsZHJlbkluZGV4OiBudW1iZXI7XG4gIHJvdXRlOiBSb3V0ZU9iamVjdFR5cGU7XG59XG5cbmludGVyZmFjZSBSb3V0ZUJyYW5jaDxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4ge1xuICBwYXRoOiBzdHJpbmc7XG4gIHNjb3JlOiBudW1iZXI7XG4gIHJvdXRlc01ldGE6IFJvdXRlTWV0YTxSb3V0ZU9iamVjdFR5cGU+W107XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5Sb3V0ZXM8XG4gIFJvdXRlT2JqZWN0VHlwZSBleHRlbmRzIEFnbm9zdGljUm91dGVPYmplY3QgPSBBZ25vc3RpY1JvdXRlT2JqZWN0XG4+KFxuICByb3V0ZXM6IFJvdXRlT2JqZWN0VHlwZVtdLFxuICBicmFuY2hlczogUm91dGVCcmFuY2g8Um91dGVPYmplY3RUeXBlPltdID0gW10sXG4gIHBhcmVudHNNZXRhOiBSb3V0ZU1ldGE8Um91dGVPYmplY3RUeXBlPltdID0gW10sXG4gIHBhcmVudFBhdGggPSBcIlwiXG4pOiBSb3V0ZUJyYW5jaDxSb3V0ZU9iamVjdFR5cGU+W10ge1xuICBsZXQgZmxhdHRlblJvdXRlID0gKFxuICAgIHJvdXRlOiBSb3V0ZU9iamVjdFR5cGUsXG4gICAgaW5kZXg6IG51bWJlcixcbiAgICByZWxhdGl2ZVBhdGg/OiBzdHJpbmdcbiAgKSA9PiB7XG4gICAgbGV0IG1ldGE6IFJvdXRlTWV0YTxSb3V0ZU9iamVjdFR5cGU+ID0ge1xuICAgICAgcmVsYXRpdmVQYXRoOlxuICAgICAgICByZWxhdGl2ZVBhdGggPT09IHVuZGVmaW5lZCA/IHJvdXRlLnBhdGggfHwgXCJcIiA6IHJlbGF0aXZlUGF0aCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09IHRydWUsXG4gICAgICBjaGlsZHJlbkluZGV4OiBpbmRleCxcbiAgICAgIHJvdXRlLFxuICAgIH07XG5cbiAgICBpZiAobWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgbWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChwYXJlbnRQYXRoKSxcbiAgICAgICAgYEFic29sdXRlIHJvdXRlIHBhdGggXCIke21ldGEucmVsYXRpdmVQYXRofVwiIG5lc3RlZCB1bmRlciBwYXRoIGAgK1xuICAgICAgICAgIGBcIiR7cGFyZW50UGF0aH1cIiBpcyBub3QgdmFsaWQuIEFuIGFic29sdXRlIGNoaWxkIHJvdXRlIHBhdGggYCArXG4gICAgICAgICAgYG11c3Qgc3RhcnQgd2l0aCB0aGUgY29tYmluZWQgcGF0aCBvZiBhbGwgaXRzIHBhcmVudCByb3V0ZXMuYFxuICAgICAgKTtcblxuICAgICAgbWV0YS5yZWxhdGl2ZVBhdGggPSBtZXRhLnJlbGF0aXZlUGF0aC5zbGljZShwYXJlbnRQYXRoLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgbGV0IHBhdGggPSBqb2luUGF0aHMoW3BhcmVudFBhdGgsIG1ldGEucmVsYXRpdmVQYXRoXSk7XG4gICAgbGV0IHJvdXRlc01ldGEgPSBwYXJlbnRzTWV0YS5jb25jYXQobWV0YSk7XG5cbiAgICAvLyBBZGQgdGhlIGNoaWxkcmVuIGJlZm9yZSBhZGRpbmcgdGhpcyByb3V0ZSB0byB0aGUgYXJyYXkgc28gd2UgdHJhdmVyc2UgdGhlXG4gICAgLy8gcm91dGUgdHJlZSBkZXB0aC1maXJzdCBhbmQgY2hpbGQgcm91dGVzIGFwcGVhciBiZWZvcmUgdGhlaXIgcGFyZW50cyBpblxuICAgIC8vIHRoZSBcImZsYXR0ZW5lZFwiIHZlcnNpb24uXG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuICYmIHJvdXRlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgLy8gT3VyIHR5cGVzIGtub3cgYmV0dGVyLCBidXQgcnVudGltZSBKUyBtYXkgbm90IVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHJvdXRlLmluZGV4ICE9PSB0cnVlLFxuICAgICAgICBgSW5kZXggcm91dGVzIG11c3Qgbm90IGhhdmUgY2hpbGQgcm91dGVzLiBQbGVhc2UgcmVtb3ZlIGAgK1xuICAgICAgICAgIGBhbGwgY2hpbGQgcm91dGVzIGZyb20gcm91dGUgcGF0aCBcIiR7cGF0aH1cIi5gXG4gICAgICApO1xuXG4gICAgICBmbGF0dGVuUm91dGVzKHJvdXRlLmNoaWxkcmVuLCBicmFuY2hlcywgcm91dGVzTWV0YSwgcGF0aCk7XG4gICAgfVxuXG4gICAgLy8gUm91dGVzIHdpdGhvdXQgYSBwYXRoIHNob3VsZG4ndCBldmVyIG1hdGNoIGJ5IHRoZW1zZWx2ZXMgdW5sZXNzIHRoZXkgYXJlXG4gICAgLy8gaW5kZXggcm91dGVzLCBzbyBkb24ndCBhZGQgdGhlbSB0byB0aGUgbGlzdCBvZiBwb3NzaWJsZSBicmFuY2hlcy5cbiAgICBpZiAocm91dGUucGF0aCA9PSBudWxsICYmICFyb3V0ZS5pbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJyYW5jaGVzLnB1c2goe1xuICAgICAgcGF0aCxcbiAgICAgIHNjb3JlOiBjb21wdXRlU2NvcmUocGF0aCwgcm91dGUuaW5kZXgpLFxuICAgICAgcm91dGVzTWV0YSxcbiAgICB9KTtcbiAgfTtcbiAgcm91dGVzLmZvckVhY2goKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIC8vIGNvYXJzZS1ncmFpbiBjaGVjayBmb3Igb3B0aW9uYWwgcGFyYW1zXG4gICAgaWYgKHJvdXRlLnBhdGggPT09IFwiXCIgfHwgIXJvdXRlLnBhdGg/LmluY2x1ZGVzKFwiP1wiKSkge1xuICAgICAgZmxhdHRlblJvdXRlKHJvdXRlLCBpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGV4cGxvZGVkIG9mIGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHJvdXRlLnBhdGgpKSB7XG4gICAgICAgIGZsYXR0ZW5Sb3V0ZShyb3V0ZSwgaW5kZXgsIGV4cGxvZGVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBicmFuY2hlcztcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhbGwgY29tYmluYXRpb25zIG9mIG9wdGlvbmFsIHBhdGggc2VnbWVudHMgZm9yIGEgZ2l2ZW4gcGF0aCxcbiAqIGV4Y2x1ZGluZyBjb21iaW5hdGlvbnMgdGhhdCBhcmUgYW1iaWd1b3VzIGFuZCBvZiBsb3dlciBwcmlvcml0eS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgYC9vbmUvOnR3bz8vdGhyZWUvOmZvdXI/LzpmaXZlP2AgZXhwbG9kZXMgdG86XG4gKiAtIGAvb25lL3RocmVlYFxuICogLSBgL29uZS86dHdvL3RocmVlYFxuICogLSBgL29uZS90aHJlZS86Zm91cmBcbiAqIC0gYC9vbmUvdGhyZWUvOmZpdmVgXG4gKiAtIGAvb25lLzp0d28vdGhyZWUvOmZvdXJgXG4gKiAtIGAvb25lLzp0d28vdGhyZWUvOmZpdmVgXG4gKiAtIGAvb25lL3RocmVlLzpmb3VyLzpmaXZlYFxuICogLSBgL29uZS86dHdvL3RocmVlLzpmb3VyLzpmaXZlYFxuICovXG5mdW5jdGlvbiBleHBsb2RlT3B0aW9uYWxTZWdtZW50cyhwYXRoOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG5cbiAgbGV0IFtmaXJzdCwgLi4ucmVzdF0gPSBzZWdtZW50cztcblxuICAvLyBPcHRpb25hbCBwYXRoIHNlZ21lbnRzIGFyZSBkZW5vdGVkIGJ5IGEgdHJhaWxpbmcgYD9gXG4gIGxldCBpc09wdGlvbmFsID0gZmlyc3QuZW5kc1dpdGgoXCI/XCIpO1xuICAvLyBDb21wdXRlIHRoZSBjb3JyZXNwb25kaW5nIHJlcXVpcmVkIHNlZ21lbnQ6IGBmb28/YCAtPiBgZm9vYFxuICBsZXQgcmVxdWlyZWQgPSBmaXJzdC5yZXBsYWNlKC9cXD8kLywgXCJcIik7XG5cbiAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSW50ZXByZXQgZW1wdHkgc3RyaW5nIGFzIG9taXR0aW5nIGFuIG9wdGlvbmFsIHNlZ21lbnRcbiAgICAvLyBgW1wib25lXCIsIFwiXCIsIFwidGhyZWVcIl1gIGNvcnJlc3BvbmRzIHRvIG9taXR0aW5nIGA6dHdvYCBmcm9tIGAvb25lLzp0d28/L3RocmVlYCAtPiBgL29uZS90aHJlZWBcbiAgICByZXR1cm4gaXNPcHRpb25hbCA/IFtyZXF1aXJlZCwgXCJcIl0gOiBbcmVxdWlyZWRdO1xuICB9XG5cbiAgbGV0IHJlc3RFeHBsb2RlZCA9IGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHJlc3Quam9pbihcIi9cIikpO1xuXG4gIGxldCByZXN1bHQ6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gQWxsIGNoaWxkIHBhdGhzIHdpdGggdGhlIHByZWZpeC4gIERvIHRoaXMgZm9yIGFsbCBjaGlsZHJlbiBiZWZvcmUgdGhlXG4gIC8vIG9wdGlvbmFsIHZlcnNpb24gZm9yIGFsbCBjaGlsZHJlbiBzbyB3ZSBnZXQgY29uc2lzdGVudCBvcmRlcmluZyB3aGVyZSB0aGVcbiAgLy8gcGFyZW50IG9wdGlvbmFsIGFzcGVjdCBpcyBwcmVmZXJyZWQgYXMgcmVxdWlyZWQuICBPdGhlcndpc2UsIHdlIGNhbiBnZXRcbiAgLy8gY2hpbGQgc2VjdGlvbnMgaW50ZXJzcGVyc2VkIHdoZXJlIGRlZXBlciBvcHRpb25hbCBzZWdtZW50cyBhcmUgaGlnaGVyIHRoYW5cbiAgLy8gcGFyZW50IG9wdGlvbmFsIHNlZ21lbnRzLCB3aGVyZSBmb3IgZXhhbXBsZSwgLzp0d28gd291bGQgZXhwbG9kZXMgX2VhcmxpZXJfXG4gIC8vIHRoZW4gLzpvbmUuICBCeSBhbHdheXMgaW5jbHVkaW5nIHRoZSBwYXJlbnQgYXMgcmVxdWlyZWQgX2ZvciBhbGwgY2hpbGRyZW5fXG4gIC8vIGZpcnN0LCB3ZSBhdm9pZCB0aGlzIGlzc3VlXG4gIHJlc3VsdC5wdXNoKFxuICAgIC4uLnJlc3RFeHBsb2RlZC5tYXAoKHN1YnBhdGgpID0+XG4gICAgICBzdWJwYXRoID09PSBcIlwiID8gcmVxdWlyZWQgOiBbcmVxdWlyZWQsIHN1YnBhdGhdLmpvaW4oXCIvXCIpXG4gICAgKVxuICApO1xuXG4gIC8vIFRoZW4gaWYgdGhpcyBpcyBhbiBvcHRpb25hbCB2YWx1ZSwgYWRkIGFsbCBjaGlsZCB2ZXJzaW9ucyB3aXRob3V0XG4gIGlmIChpc09wdGlvbmFsKSB7XG4gICAgcmVzdWx0LnB1c2goLi4ucmVzdEV4cGxvZGVkKTtcbiAgfVxuXG4gIC8vIGZvciBhYnNvbHV0ZSBwYXRocywgZW5zdXJlIGAvYCBpbnN0ZWFkIG9mIGVtcHR5IHNlZ21lbnRcbiAgcmV0dXJuIHJlc3VsdC5tYXAoKGV4cGxvZGVkKSA9PlxuICAgIHBhdGguc3RhcnRzV2l0aChcIi9cIikgJiYgZXhwbG9kZWQgPT09IFwiXCIgPyBcIi9cIiA6IGV4cGxvZGVkXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJhbmtSb3V0ZUJyYW5jaGVzKGJyYW5jaGVzOiBSb3V0ZUJyYW5jaFtdKTogdm9pZCB7XG4gIGJyYW5jaGVzLnNvcnQoKGEsIGIpID0+XG4gICAgYS5zY29yZSAhPT0gYi5zY29yZVxuICAgICAgPyBiLnNjb3JlIC0gYS5zY29yZSAvLyBIaWdoZXIgc2NvcmUgZmlyc3RcbiAgICAgIDogY29tcGFyZUluZGV4ZXMoXG4gICAgICAgICAgYS5yb3V0ZXNNZXRhLm1hcCgobWV0YSkgPT4gbWV0YS5jaGlsZHJlbkluZGV4KSxcbiAgICAgICAgICBiLnJvdXRlc01ldGEubWFwKChtZXRhKSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpXG4gICAgICAgIClcbiAgKTtcbn1cblxuY29uc3QgcGFyYW1SZSA9IC9eOlxcdyskLztcbmNvbnN0IGR5bmFtaWNTZWdtZW50VmFsdWUgPSAzO1xuY29uc3QgaW5kZXhSb3V0ZVZhbHVlID0gMjtcbmNvbnN0IGVtcHR5U2VnbWVudFZhbHVlID0gMTtcbmNvbnN0IHN0YXRpY1NlZ21lbnRWYWx1ZSA9IDEwO1xuY29uc3Qgc3BsYXRQZW5hbHR5ID0gLTI7XG5jb25zdCBpc1NwbGF0ID0gKHM6IHN0cmluZykgPT4gcyA9PT0gXCIqXCI7XG5cbmZ1bmN0aW9uIGNvbXB1dGVTY29yZShwYXRoOiBzdHJpbmcsIGluZGV4OiBib29sZWFuIHwgdW5kZWZpbmVkKTogbnVtYmVyIHtcbiAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGxldCBpbml0aWFsU2NvcmUgPSBzZWdtZW50cy5sZW5ndGg7XG4gIGlmIChzZWdtZW50cy5zb21lKGlzU3BsYXQpKSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IHNwbGF0UGVuYWx0eTtcbiAgfVxuXG4gIGlmIChpbmRleCkge1xuICAgIGluaXRpYWxTY29yZSArPSBpbmRleFJvdXRlVmFsdWU7XG4gIH1cblxuICByZXR1cm4gc2VnbWVudHNcbiAgICAuZmlsdGVyKChzKSA9PiAhaXNTcGxhdChzKSlcbiAgICAucmVkdWNlKFxuICAgICAgKHNjb3JlLCBzZWdtZW50KSA9PlxuICAgICAgICBzY29yZSArXG4gICAgICAgIChwYXJhbVJlLnRlc3Qoc2VnbWVudClcbiAgICAgICAgICA/IGR5bmFtaWNTZWdtZW50VmFsdWVcbiAgICAgICAgICA6IHNlZ21lbnQgPT09IFwiXCJcbiAgICAgICAgICA/IGVtcHR5U2VnbWVudFZhbHVlXG4gICAgICAgICAgOiBzdGF0aWNTZWdtZW50VmFsdWUpLFxuICAgICAgaW5pdGlhbFNjb3JlXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUluZGV4ZXMoYTogbnVtYmVyW10sIGI6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgbGV0IHNpYmxpbmdzID1cbiAgICBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5zbGljZSgwLCAtMSkuZXZlcnkoKG4sIGkpID0+IG4gPT09IGJbaV0pO1xuXG4gIHJldHVybiBzaWJsaW5nc1xuICAgID8gLy8gSWYgdHdvIHJvdXRlcyBhcmUgc2libGluZ3MsIHdlIHNob3VsZCB0cnkgdG8gbWF0Y2ggdGhlIGVhcmxpZXIgc2libGluZ1xuICAgICAgLy8gZmlyc3QuIFRoaXMgYWxsb3dzIHBlb3BsZSB0byBoYXZlIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXIgdGhlIG1hdGNoaW5nXG4gICAgICAvLyBiZWhhdmlvciBieSBzaW1wbHkgcHV0dGluZyByb3V0ZXMgd2l0aCBpZGVudGljYWwgcGF0aHMgaW4gdGhlIG9yZGVyIHRoZXlcbiAgICAgIC8vIHdhbnQgdGhlbSB0cmllZC5cbiAgICAgIGFbYS5sZW5ndGggLSAxXSAtIGJbYi5sZW5ndGggLSAxXVxuICAgIDogLy8gT3RoZXJ3aXNlLCBpdCBkb2Vzbid0IHJlYWxseSBtYWtlIHNlbnNlIHRvIHJhbmsgbm9uLXNpYmxpbmdzIGJ5IGluZGV4LFxuICAgICAgLy8gc28gdGhleSBzb3J0IGVxdWFsbHkuXG4gICAgICAwO1xufVxuXG5mdW5jdGlvbiBtYXRjaFJvdXRlQnJhbmNoPFxuICBQYXJhbUtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4oXG4gIGJyYW5jaDogUm91dGVCcmFuY2g8Um91dGVPYmplY3RUeXBlPixcbiAgcGF0aG5hbWU6IHN0cmluZ1xuKTogQWdub3N0aWNSb3V0ZU1hdGNoPFBhcmFtS2V5LCBSb3V0ZU9iamVjdFR5cGU+W10gfCBudWxsIHtcbiAgbGV0IHsgcm91dGVzTWV0YSB9ID0gYnJhbmNoO1xuXG4gIGxldCBtYXRjaGVkUGFyYW1zID0ge307XG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBcIi9cIjtcbiAgbGV0IG1hdGNoZXM6IEFnbm9zdGljUm91dGVNYXRjaDxQYXJhbUtleSwgUm91dGVPYmplY3RUeXBlPltdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVzTWV0YS5sZW5ndGg7ICsraSkge1xuICAgIGxldCBtZXRhID0gcm91dGVzTWV0YVtpXTtcbiAgICBsZXQgZW5kID0gaSA9PT0gcm91dGVzTWV0YS5sZW5ndGggLSAxO1xuICAgIGxldCByZW1haW5pbmdQYXRobmFtZSA9XG4gICAgICBtYXRjaGVkUGF0aG5hbWUgPT09IFwiL1wiXG4gICAgICAgID8gcGF0aG5hbWVcbiAgICAgICAgOiBwYXRobmFtZS5zbGljZShtYXRjaGVkUGF0aG5hbWUubGVuZ3RoKSB8fCBcIi9cIjtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaFBhdGgoXG4gICAgICB7IHBhdGg6IG1ldGEucmVsYXRpdmVQYXRoLCBjYXNlU2Vuc2l0aXZlOiBtZXRhLmNhc2VTZW5zaXRpdmUsIGVuZCB9LFxuICAgICAgcmVtYWluaW5nUGF0aG5hbWVcbiAgICApO1xuXG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgICBPYmplY3QuYXNzaWduKG1hdGNoZWRQYXJhbXMsIG1hdGNoLnBhcmFtcyk7XG5cbiAgICBsZXQgcm91dGUgPSBtZXRhLnJvdXRlO1xuXG4gICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgIC8vIFRPRE86IENhbiB0aGlzIGFzIGJlIGF2b2lkZWQ/XG4gICAgICBwYXJhbXM6IG1hdGNoZWRQYXJhbXMgYXMgUGFyYW1zPFBhcmFtS2V5PixcbiAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgIHBhdGhuYW1lQmFzZTogbm9ybWFsaXplUGF0aG5hbWUoXG4gICAgICAgIGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKVxuICAgICAgKSxcbiAgICAgIHJvdXRlLFxuICAgIH0pO1xuXG4gICAgaWYgKG1hdGNoLnBhdGhuYW1lQmFzZSAhPT0gXCIvXCIpIHtcbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcGF0aCB3aXRoIHBhcmFtcyBpbnRlcnBvbGF0ZWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9nZW5lcmF0ZS1wYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVBhdGg8UGF0aCBleHRlbmRzIHN0cmluZz4oXG4gIG9yaWdpbmFsUGF0aDogUGF0aCxcbiAgcGFyYW1zOiB7XG4gICAgW2tleSBpbiBQYXRoUGFyYW08UGF0aD5dOiBzdHJpbmcgfCBudWxsO1xuICB9ID0ge30gYXMgYW55XG4pOiBzdHJpbmcge1xuICBsZXQgcGF0aCA9IG9yaWdpbmFsUGF0aDtcbiAgaWYgKHBhdGguZW5kc1dpdGgoXCIqXCIpICYmIHBhdGggIT09IFwiKlwiICYmICFwYXRoLmVuZHNXaXRoKFwiLypcIikpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICBgUm91dGUgcGF0aCBcIiR7cGF0aH1cIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBgICtcbiAgICAgICAgYFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiIGJlY2F1c2UgdGhlIFxcYCpcXGAgY2hhcmFjdGVyIG11c3QgYCArXG4gICAgICAgIGBhbHdheXMgZm9sbG93IGEgXFxgL1xcYCBpbiB0aGUgcGF0dGVybi4gVG8gZ2V0IHJpZCBvZiB0aGlzIHdhcm5pbmcsIGAgK1xuICAgICAgICBgcGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIi5gXG4gICAgKTtcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKSBhcyBQYXRoO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBwYXRoXG4gICAgICAucmVwbGFjZShcbiAgICAgICAgL146KFxcdyspKFxcPz8pL2csXG4gICAgICAgIChfLCBrZXk6IFBhdGhQYXJhbTxQYXRoPiwgb3B0aW9uYWw6IHN0cmluZyB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICAgIGxldCBwYXJhbSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgIGlmIChvcHRpb25hbCA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbSA9PSBudWxsID8gXCJcIiA6IHBhcmFtO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyYW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgaW52YXJpYW50KGZhbHNlLCBgTWlzc2luZyBcIjoke2tleX1cIiBwYXJhbWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIC5yZXBsYWNlKFxuICAgICAgICAvXFwvOihcXHcrKShcXD8/KS9nLFxuICAgICAgICAoXywga2V5OiBQYXRoUGFyYW08UGF0aD4sIG9wdGlvbmFsOiBzdHJpbmcgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICBsZXQgcGFyYW0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICBpZiAob3B0aW9uYWwgPT09IFwiP1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW0gPT0gbnVsbCA/IFwiXCIgOiBgLyR7cGFyYW19YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcmFtID09IG51bGwpIHtcbiAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgYE1pc3NpbmcgXCI6JHtrZXl9XCIgcGFyYW1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGAvJHtwYXJhbX1gO1xuICAgICAgICB9XG4gICAgICApXG4gICAgICAvLyBSZW1vdmUgYW55IG9wdGlvbmFsIG1hcmtlcnMgZnJvbSBvcHRpb25hbCBzdGF0aWMgc2VnbWVudHNcbiAgICAgIC5yZXBsYWNlKC9cXD8vZywgXCJcIilcbiAgICAgIC5yZXBsYWNlKC8oXFwvPylcXCovLCAoXywgcHJlZml4LCBfXywgc3RyKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXIgPSBcIipcIiBhcyBQYXRoUGFyYW08UGF0aD47XG5cbiAgICAgICAgaWYgKHBhcmFtc1tzdGFyXSA9PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgbm8gc3BsYXQgd2FzIHByb3ZpZGVkLCB0cmltIHRoZSB0cmFpbGluZyBzbGFzaCBfdW5sZXNzXyBpdCdzXG4gICAgICAgICAgLy8gdGhlIGVudGlyZSBwYXRoXG4gICAgICAgICAgcmV0dXJuIHN0ciA9PT0gXCIvKlwiID8gXCIvXCIgOiBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgdGhlIHNwbGF0XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9JHtwYXJhbXNbc3Rhcl19YDtcbiAgICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogQSBQYXRoUGF0dGVybiBpcyB1c2VkIHRvIG1hdGNoIG9uIHNvbWUgcG9ydGlvbiBvZiBhIFVSTCBwYXRobmFtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXRoUGF0dGVybjxQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiB7XG4gIC8qKlxuICAgKiBBIHN0cmluZyB0byBtYXRjaCBhZ2FpbnN0IGEgVVJMIHBhdGhuYW1lLiBNYXkgY29udGFpbiBgOmlkYC1zdHlsZSBzZWdtZW50c1xuICAgKiB0byBpbmRpY2F0ZSBwbGFjZWhvbGRlcnMgZm9yIGR5bmFtaWMgcGFyYW1ldGVycy4gTWF5IGFsc28gZW5kIHdpdGggYC8qYCB0b1xuICAgKiBpbmRpY2F0ZSBtYXRjaGluZyB0aGUgcmVzdCBvZiB0aGUgVVJMIHBhdGhuYW1lLlxuICAgKi9cbiAgcGF0aDogUGF0aDtcbiAgLyoqXG4gICAqIFNob3VsZCBiZSBgdHJ1ZWAgaWYgdGhlIHN0YXRpYyBwb3J0aW9ucyBvZiB0aGUgYHBhdGhgIHNob3VsZCBiZSBtYXRjaGVkIGluXG4gICAqIHRoZSBzYW1lIGNhc2UuXG4gICAqL1xuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFNob3VsZCBiZSBgdHJ1ZWAgaWYgdGhpcyBwYXR0ZXJuIHNob3VsZCBtYXRjaCB0aGUgZW50aXJlIFVSTCBwYXRobmFtZS5cbiAgICovXG4gIGVuZD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQSBQYXRoTWF0Y2ggY29udGFpbnMgaW5mbyBhYm91dCBob3cgYSBQYXRoUGF0dGVybiBtYXRjaGVkIG9uIGEgVVJMIHBhdGhuYW1lLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhdGhNYXRjaDxQYXJhbUtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4ge1xuICAvKipcbiAgICogVGhlIG5hbWVzIGFuZCB2YWx1ZXMgb2YgZHluYW1pYyBwYXJhbWV0ZXJzIGluIHRoZSBVUkwuXG4gICAqL1xuICBwYXJhbXM6IFBhcmFtczxQYXJhbUtleT47XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkIGJlZm9yZSBjaGlsZCByb3V0ZXMuXG4gICAqL1xuICBwYXRobmFtZUJhc2U6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwYXR0ZXJuIHRoYXQgd2FzIHVzZWQgdG8gbWF0Y2guXG4gICAqL1xuICBwYXR0ZXJuOiBQYXRoUGF0dGVybjtcbn1cblxudHlwZSBNdXRhYmxlPFQ+ID0ge1xuICAtcmVhZG9ubHkgW1AgaW4ga2V5b2YgVF06IFRbUF07XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIHBhdHRlcm4gbWF0Y2hpbmcgb24gYSBVUkwgcGF0aG5hbWUgYW5kIHJldHVybnMgaW5mb3JtYXRpb24gYWJvdXRcbiAqIHRoZSBtYXRjaC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL21hdGNoLXBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoUGF0aDxcbiAgUGFyYW1LZXkgZXh0ZW5kcyBQYXJhbVBhcnNlS2V5PFBhdGg+LFxuICBQYXRoIGV4dGVuZHMgc3RyaW5nXG4+KFxuICBwYXR0ZXJuOiBQYXRoUGF0dGVybjxQYXRoPiB8IFBhdGgsXG4gIHBhdGhuYW1lOiBzdHJpbmdcbik6IFBhdGhNYXRjaDxQYXJhbUtleT4gfCBudWxsIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgcGF0dGVybiA9IHsgcGF0aDogcGF0dGVybiwgY2FzZVNlbnNpdGl2ZTogZmFsc2UsIGVuZDogdHJ1ZSB9O1xuICB9XG5cbiAgbGV0IFttYXRjaGVyLCBwYXJhbU5hbWVzXSA9IGNvbXBpbGVQYXRoKFxuICAgIHBhdHRlcm4ucGF0aCxcbiAgICBwYXR0ZXJuLmNhc2VTZW5zaXRpdmUsXG4gICAgcGF0dGVybi5lbmRcbiAgKTtcblxuICBsZXQgbWF0Y2ggPSBwYXRobmFtZS5tYXRjaChtYXRjaGVyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IG1hdGNoWzBdO1xuICBsZXQgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgbGV0IGNhcHR1cmVHcm91cHMgPSBtYXRjaC5zbGljZSgxKTtcbiAgbGV0IHBhcmFtczogUGFyYW1zID0gcGFyYW1OYW1lcy5yZWR1Y2U8TXV0YWJsZTxQYXJhbXM+PihcbiAgICAobWVtbywgcGFyYW1OYW1lLCBpbmRleCkgPT4ge1xuICAgICAgLy8gV2UgbmVlZCB0byBjb21wdXRlIHRoZSBwYXRobmFtZUJhc2UgaGVyZSB1c2luZyB0aGUgcmF3IHNwbGF0IHZhbHVlXG4gICAgICAvLyBpbnN0ZWFkIG9mIHVzaW5nIHBhcmFtc1tcIipcIl0gbGF0ZXIgYmVjYXVzZSBpdCB3aWxsIGJlIGRlY29kZWQgdGhlblxuICAgICAgaWYgKHBhcmFtTmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgICAgbGV0IHNwbGF0VmFsdWUgPSBjYXB0dXJlR3JvdXBzW2luZGV4XSB8fCBcIlwiO1xuICAgICAgICBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWVcbiAgICAgICAgICAuc2xpY2UoMCwgbWF0Y2hlZFBhdGhuYW1lLmxlbmd0aCAtIHNwbGF0VmFsdWUubGVuZ3RoKVxuICAgICAgICAgIC5yZXBsYWNlKC8oLilcXC8rJC8sIFwiJDFcIik7XG4gICAgICB9XG5cbiAgICAgIG1lbW9bcGFyYW1OYW1lXSA9IHNhZmVseURlY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIixcbiAgICAgICAgcGFyYW1OYW1lXG4gICAgICApO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSxcbiAgICB7fVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaGVkUGF0aG5hbWUsXG4gICAgcGF0aG5hbWVCYXNlLFxuICAgIHBhdHRlcm4sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVQYXRoKFxuICBwYXRoOiBzdHJpbmcsXG4gIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSxcbiAgZW5kID0gdHJ1ZVxuKTogW1JlZ0V4cCwgc3RyaW5nW11dIHtcbiAgd2FybmluZyhcbiAgICBwYXRoID09PSBcIipcIiB8fCAhcGF0aC5lbmRzV2l0aChcIipcIikgfHwgcGF0aC5lbmRzV2l0aChcIi8qXCIpLFxuICAgIGBSb3V0ZSBwYXRoIFwiJHtwYXRofVwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIGAgK1xuICAgICAgYFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiIGJlY2F1c2UgdGhlIFxcYCpcXGAgY2hhcmFjdGVyIG11c3QgYCArXG4gICAgICBgYWx3YXlzIGZvbGxvdyBhIFxcYC9cXGAgaW4gdGhlIHBhdHRlcm4uIFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCBgICtcbiAgICAgIGBwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiLmBcbiAgKTtcblxuICBsZXQgcGFyYW1OYW1lczogc3RyaW5nW10gPSBbXTtcbiAgbGV0IHJlZ2V4cFNvdXJjZSA9XG4gICAgXCJeXCIgK1xuICAgIHBhdGhcbiAgICAgIC5yZXBsYWNlKC9cXC8qXFwqPyQvLCBcIlwiKSAvLyBJZ25vcmUgdHJhaWxpbmcgLyBhbmQgLyosIHdlJ2xsIGhhbmRsZSBpdCBiZWxvd1xuICAgICAgLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpIC8vIE1ha2Ugc3VyZSBpdCBoYXMgYSBsZWFkaW5nIC9cbiAgICAgIC5yZXBsYWNlKC9bXFxcXC4qK14kP3t9fCgpW1xcXV0vZywgXCJcXFxcJCZcIikgLy8gRXNjYXBlIHNwZWNpYWwgcmVnZXggY2hhcnNcbiAgICAgIC5yZXBsYWNlKC9cXC86KFxcdyspL2csIChfOiBzdHJpbmcsIHBhcmFtTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHBhcmFtTmFtZXMucHVzaChwYXJhbU5hbWUpO1xuICAgICAgICByZXR1cm4gXCIvKFteXFxcXC9dKylcIjtcbiAgICAgIH0pO1xuXG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgIHBhcmFtTmFtZXMucHVzaChcIipcIik7XG4gICAgcmVnZXhwU291cmNlICs9XG4gICAgICBwYXRoID09PSBcIipcIiB8fCBwYXRoID09PSBcIi8qXCJcbiAgICAgICAgPyBcIiguKikkXCIgLy8gQWxyZWFkeSBtYXRjaGVkIHRoZSBpbml0aWFsIC8sIGp1c3QgbWF0Y2ggdGhlIHJlc3RcbiAgICAgICAgOiBcIig/OlxcXFwvKC4rKXxcXFxcLyopJFwiOyAvLyBEb24ndCBpbmNsdWRlIHRoZSAvIGluIHBhcmFtc1tcIipcIl1cbiAgfSBlbHNlIGlmIChlbmQpIHtcbiAgICAvLyBXaGVuIG1hdGNoaW5nIHRvIHRoZSBlbmQsIGlnbm9yZSB0cmFpbGluZyBzbGFzaGVzXG4gICAgcmVnZXhwU291cmNlICs9IFwiXFxcXC8qJFwiO1xuICB9IGVsc2UgaWYgKHBhdGggIT09IFwiXCIgJiYgcGF0aCAhPT0gXCIvXCIpIHtcbiAgICAvLyBJZiBvdXIgcGF0aCBpcyBub24tZW1wdHkgYW5kIGNvbnRhaW5zIGFueXRoaW5nIGJleW9uZCBhbiBpbml0aWFsIHNsYXNoLFxuICAgIC8vIHRoZW4gd2UgaGF2ZSBfc29tZV8gZm9ybSBvZiBwYXRoIGluIG91ciByZWdleCBzbyB3ZSBzaG91bGQgZXhwZWN0IHRvXG4gICAgLy8gbWF0Y2ggb25seSBpZiB3ZSBmaW5kIHRoZSBlbmQgb2YgdGhpcyBwYXRoIHNlZ21lbnQuICBMb29rIGZvciBhbiBvcHRpb25hbFxuICAgIC8vIG5vbi1jYXB0dXJlZCB0cmFpbGluZyBzbGFzaCAodG8gbWF0Y2ggYSBwb3J0aW9uIG9mIHRoZSBVUkwpIG9yIHRoZSBlbmRcbiAgICAvLyBvZiB0aGUgcGF0aCAoaWYgd2UndmUgbWF0Y2hlZCB0byB0aGUgZW5kKS4gIFdlIHVzZWQgdG8gZG8gdGhpcyB3aXRoIGFcbiAgICAvLyB3b3JkIGJvdW5kYXJ5IGJ1dCB0aGF0IGdpdmVzIGZhbHNlIHBvc2l0aXZlcyBvbiByb3V0ZXMgbGlrZVxuICAgIC8vIC91c2VyLXByZWZlcmVuY2VzIHNpbmNlIGAtYCBjb3VudHMgYXMgYSB3b3JkIGJvdW5kYXJ5LlxuICAgIHJlZ2V4cFNvdXJjZSArPSBcIig/Oig/PVxcXFwvfCQpKVwiO1xuICB9IGVsc2Uge1xuICAgIC8vIE5vdGhpbmcgdG8gbWF0Y2ggZm9yIFwiXCIgb3IgXCIvXCJcbiAgfVxuXG4gIGxldCBtYXRjaGVyID0gbmV3IFJlZ0V4cChyZWdleHBTb3VyY2UsIGNhc2VTZW5zaXRpdmUgPyB1bmRlZmluZWQgOiBcImlcIik7XG5cbiAgcmV0dXJuIFttYXRjaGVyLCBwYXJhbU5hbWVzXTtcbn1cblxuZnVuY3Rpb24gc2FmZWx5RGVjb2RlVVJJKHZhbHVlOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICBgVGhlIFVSTCBwYXRoIFwiJHt2YWx1ZX1cIiBjb3VsZCBub3QgYmUgZGVjb2RlZCBiZWNhdXNlIGl0IGlzIGlzIGEgYCArXG4gICAgICAgIGBtYWxmb3JtZWQgVVJMIHNlZ21lbnQuIFRoaXMgaXMgcHJvYmFibHkgZHVlIHRvIGEgYmFkIHBlcmNlbnQgYCArXG4gICAgICAgIGBlbmNvZGluZyAoJHtlcnJvcn0pLmBcbiAgICApO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseURlY29kZVVSSUNvbXBvbmVudCh2YWx1ZTogc3RyaW5nLCBwYXJhbU5hbWU6IHN0cmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBUaGUgdmFsdWUgZm9yIHRoZSBVUkwgcGFyYW0gXCIke3BhcmFtTmFtZX1cIiB3aWxsIG5vdCBiZSBkZWNvZGVkIGJlY2F1c2VgICtcbiAgICAgICAgYCB0aGUgc3RyaW5nIFwiJHt2YWx1ZX1cIiBpcyBhIG1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseWAgK1xuICAgICAgICBgIGR1ZSB0byBhIGJhZCBwZXJjZW50IGVuY29kaW5nICgke2Vycm9yfSkuYFxuICAgICk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShcbiAgcGF0aG5hbWU6IHN0cmluZyxcbiAgYmFzZW5hbWU6IHN0cmluZ1xuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmIChiYXNlbmFtZSA9PT0gXCIvXCIpIHJldHVybiBwYXRobmFtZTtcblxuICBpZiAoIXBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChiYXNlbmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gV2Ugd2FudCB0byBsZWF2ZSB0cmFpbGluZyBzbGFzaCBiZWhhdmlvciBpbiB0aGUgdXNlcidzIGNvbnRyb2wsIHNvIGlmIHRoZXlcbiAgLy8gc3BlY2lmeSBhIGJhc2VuYW1lIHdpdGggYSB0cmFpbGluZyBzbGFzaCwgd2Ugc2hvdWxkIHN1cHBvcnQgaXRcbiAgbGV0IHN0YXJ0SW5kZXggPSBiYXNlbmFtZS5lbmRzV2l0aChcIi9cIilcbiAgICA/IGJhc2VuYW1lLmxlbmd0aCAtIDFcbiAgICA6IGJhc2VuYW1lLmxlbmd0aDtcbiAgbGV0IG5leHRDaGFyID0gcGF0aG5hbWUuY2hhckF0KHN0YXJ0SW5kZXgpO1xuICBpZiAobmV4dENoYXIgJiYgbmV4dENoYXIgIT09IFwiL1wiKSB7XG4gICAgLy8gcGF0aG5hbWUgZG9lcyBub3Qgc3RhcnQgd2l0aCBiYXNlbmFtZS9cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBwYXRobmFtZS5zbGljZShzdGFydEluZGV4KSB8fCBcIi9cIjtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gd2FybmluZyhjb25kOiBhbnksIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoIWNvbmQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlbGNvbWUgdG8gZGVidWdnaW5nIEByZW1peC1ydW4vcm91dGVyIVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28geW91IGNhbiBtb3JlIGVhc2lseVxuICAgICAgLy8gZmluZCB0aGUgc291cmNlIGZvciBhIHdhcm5pbmcgdGhhdCBhcHBlYXJzIGluIHRoZSBjb25zb2xlIGJ5XG4gICAgICAvLyBlbmFibGluZyBcInBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIEphdmFTY3JpcHQgZGVidWdnZXIuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJlc29sdmVkIHBhdGggb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBnaXZlbiBwYXRobmFtZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL3Jlc29sdmUtcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVBhdGgodG86IFRvLCBmcm9tUGF0aG5hbWUgPSBcIi9cIik6IFBhdGgge1xuICBsZXQge1xuICAgIHBhdGhuYW1lOiB0b1BhdGhuYW1lLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCIsXG4gIH0gPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG87XG5cbiAgbGV0IHBhdGhuYW1lID0gdG9QYXRobmFtZVxuICAgID8gdG9QYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKVxuICAgICAgPyB0b1BhdGhuYW1lXG4gICAgICA6IHJlc29sdmVQYXRobmFtZSh0b1BhdGhuYW1lLCBmcm9tUGF0aG5hbWUpXG4gICAgOiBmcm9tUGF0aG5hbWU7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2g6IG5vcm1hbGl6ZVNlYXJjaChzZWFyY2gpLFxuICAgIGhhc2g6IG5vcm1hbGl6ZUhhc2goaGFzaCksXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZShyZWxhdGl2ZVBhdGg6IHN0cmluZywgZnJvbVBhdGhuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgc2VnbWVudHMgPSBmcm9tUGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gIGxldCByZWxhdGl2ZVNlZ21lbnRzID0gcmVsYXRpdmVQYXRoLnNwbGl0KFwiL1wiKTtcblxuICByZWxhdGl2ZVNlZ21lbnRzLmZvckVhY2goKHNlZ21lbnQpID0+IHtcbiAgICBpZiAoc2VnbWVudCA9PT0gXCIuLlwiKSB7XG4gICAgICAvLyBLZWVwIHRoZSByb290IFwiXCIgc2VnbWVudCBzbyB0aGUgcGF0aG5hbWUgc3RhcnRzIGF0IC9cbiAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAxKSBzZWdtZW50cy5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgIT09IFwiLlwiKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA+IDEgPyBzZWdtZW50cy5qb2luKFwiL1wiKSA6IFwiL1wiO1xufVxuXG5mdW5jdGlvbiBnZXRJbnZhbGlkUGF0aEVycm9yKFxuICBjaGFyOiBzdHJpbmcsXG4gIGZpZWxkOiBzdHJpbmcsXG4gIGRlc3Q6IHN0cmluZyxcbiAgcGF0aDogUGFydGlhbDxQYXRoPlxuKSB7XG4gIHJldHVybiAoXG4gICAgYENhbm5vdCBpbmNsdWRlIGEgJyR7Y2hhcn0nIGNoYXJhY3RlciBpbiBhIG1hbnVhbGx5IHNwZWNpZmllZCBgICtcbiAgICBgXFxgdG8uJHtmaWVsZH1cXGAgZmllbGQgWyR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICBwYXRoXG4gICAgKX1dLiAgUGxlYXNlIHNlcGFyYXRlIGl0IG91dCB0byB0aGUgYCArXG4gICAgYFxcYHRvLiR7ZGVzdH1cXGAgZmllbGQuIEFsdGVybmF0aXZlbHkgeW91IG1heSBwcm92aWRlIHRoZSBmdWxsIHBhdGggYXMgYCArXG4gICAgYGEgc3RyaW5nIGluIDxMaW5rIHRvPVwiLi4uXCI+IGFuZCB0aGUgcm91dGVyIHdpbGwgcGFyc2UgaXQgZm9yIHlvdS5gXG4gICk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBXaGVuIHByb2Nlc3NpbmcgcmVsYXRpdmUgbmF2aWdhdGlvbiB3ZSB3YW50IHRvIGlnbm9yZSBhbmNlc3RvciByb3V0ZXMgdGhhdFxuICogZG8gbm90IGNvbnRyaWJ1dGUgdG8gdGhlIHBhdGgsIHN1Y2ggdGhhdCBpbmRleC9wYXRobGVzcyBsYXlvdXQgcm91dGVzIGRvbid0XG4gKiBpbnRlcmZlcmUuXG4gKlxuICogRm9yIGV4YW1wbGUsIHdoZW4gbW92aW5nIGEgcm91dGUgZWxlbWVudCBpbnRvIGFuIGluZGV4IHJvdXRlIGFuZC9vciBhXG4gKiBwYXRobGVzcyBsYXlvdXQgcm91dGUsIHJlbGF0aXZlIGxpbmsgYmVoYXZpb3IgY29udGFpbmVkIHdpdGhpbiBzaG91bGQgc3RheVxuICogdGhlIHNhbWUuICBCb3RoIG9mIHRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgc2hvdWxkIGxpbmsgYmFjayB0byB0aGUgcm9vdDpcbiAqXG4gKiAgIDxSb3V0ZSBwYXRoPVwiL1wiPlxuICogICAgIDxSb3V0ZSBwYXRoPVwiYWNjb3VudHNcIiBlbGVtZW50PXs8TGluayB0bz1cIi4uXCJ9PlxuICogICA8L1JvdXRlPlxuICpcbiAqICAgPFJvdXRlIHBhdGg9XCIvXCI+XG4gKiAgICAgPFJvdXRlIHBhdGg9XCJhY2NvdW50c1wiPlxuICogICAgICAgPFJvdXRlIGVsZW1lbnQ9ezxBY2NvdW50c0xheW91dCAvPn0+ICAgICAgIC8vIDwtLSBEb2VzIG5vdCBjb250cmlidXRlXG4gKiAgICAgICAgIDxSb3V0ZSBpbmRleCBlbGVtZW50PXs8TGluayB0bz1cIi4uXCJ9IC8+ICAvLyA8LS0gRG9lcyBub3QgY29udHJpYnV0ZVxuICogICAgICAgPC9Sb3V0ZVxuICogICAgIDwvUm91dGU+XG4gKiAgIDwvUm91dGU+XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlczxcbiAgVCBleHRlbmRzIEFnbm9zdGljUm91dGVNYXRjaCA9IEFnbm9zdGljUm91dGVNYXRjaFxuPihtYXRjaGVzOiBUW10pIHtcbiAgcmV0dXJuIG1hdGNoZXMuZmlsdGVyKFxuICAgIChtYXRjaCwgaW5kZXgpID0+XG4gICAgICBpbmRleCA9PT0gMCB8fCAobWF0Y2gucm91dGUucGF0aCAmJiBtYXRjaC5yb3V0ZS5wYXRoLmxlbmd0aCA+IDApXG4gICk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVUbyhcbiAgdG9Bcmc6IFRvLFxuICByb3V0ZVBhdGhuYW1lczogc3RyaW5nW10sXG4gIGxvY2F0aW9uUGF0aG5hbWU6IHN0cmluZyxcbiAgaXNQYXRoUmVsYXRpdmUgPSBmYWxzZVxuKTogUGF0aCB7XG4gIGxldCB0bzogUGFydGlhbDxQYXRoPjtcbiAgaWYgKHR5cGVvZiB0b0FyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRvID0gcGFyc2VQYXRoKHRvQXJnKTtcbiAgfSBlbHNlIHtcbiAgICB0byA9IHsgLi4udG9BcmcgfTtcblxuICAgIGludmFyaWFudChcbiAgICAgICF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCI/XCIpLFxuICAgICAgZ2V0SW52YWxpZFBhdGhFcnJvcihcIj9cIiwgXCJwYXRobmFtZVwiLCBcInNlYXJjaFwiLCB0bylcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCIjXCIpLFxuICAgICAgZ2V0SW52YWxpZFBhdGhFcnJvcihcIiNcIiwgXCJwYXRobmFtZVwiLCBcImhhc2hcIiwgdG8pXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhdG8uc2VhcmNoIHx8ICF0by5zZWFyY2guaW5jbHVkZXMoXCIjXCIpLFxuICAgICAgZ2V0SW52YWxpZFBhdGhFcnJvcihcIiNcIiwgXCJzZWFyY2hcIiwgXCJoYXNoXCIsIHRvKVxuICAgICk7XG4gIH1cblxuICBsZXQgaXNFbXB0eVBhdGggPSB0b0FyZyA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIjtcbiAgbGV0IHRvUGF0aG5hbWUgPSBpc0VtcHR5UGF0aCA/IFwiL1wiIDogdG8ucGF0aG5hbWU7XG5cbiAgbGV0IGZyb206IHN0cmluZztcblxuICAvLyBSb3V0aW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBhdGhuYW1lIGlmIGV4cGxpY2l0bHkgcmVxdWVzdGVkLlxuICAvL1xuICAvLyBJZiBhIHBhdGhuYW1lIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQgaW4gYHRvYCwgaXQgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZVxuICAvLyByb3V0ZSBjb250ZXh0LiBUaGlzIGlzIGV4cGxhaW5lZCBpbiBgTm90ZSBvbiBgPExpbmsgdG8+YCB2YWx1ZXNgIGluIG91clxuICAvLyBtaWdyYXRpb24gZ3VpZGUgZnJvbSB2NSBhcyBhIG1lYW5zIG9mIGRpc2FtYmlndWF0aW9uIGJldHdlZW4gYHRvYCB2YWx1ZXNcbiAgLy8gdGhhdCBiZWdpbiB3aXRoIGAvYCBhbmQgdGhvc2UgdGhhdCBkbyBub3QuIEhvd2V2ZXIsIHRoaXMgaXMgcHJvYmxlbWF0aWMgZm9yXG4gIC8vIGB0b2AgdmFsdWVzIHRoYXQgZG8gbm90IHByb3ZpZGUgYSBwYXRobmFtZS4gYHRvYCBjYW4gc2ltcGx5IGJlIGEgc2VhcmNoIG9yXG4gIC8vIGhhc2ggc3RyaW5nLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBhc3N1bWUgdGhhdCB0aGUgbmF2aWdhdGlvbiBpcyByZWxhdGl2ZVxuICAvLyB0byB0aGUgY3VycmVudCBsb2NhdGlvbidzIHBhdGhuYW1lIGFuZCAqbm90KiB0aGUgcm91dGUgcGF0aG5hbWUuXG4gIGlmIChpc1BhdGhSZWxhdGl2ZSB8fCB0b1BhdGhuYW1lID09IG51bGwpIHtcbiAgICBmcm9tID0gbG9jYXRpb25QYXRobmFtZTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcm91dGVQYXRobmFtZUluZGV4ID0gcm91dGVQYXRobmFtZXMubGVuZ3RoIC0gMTtcblxuICAgIGlmICh0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuLlwiKSkge1xuICAgICAgbGV0IHRvU2VnbWVudHMgPSB0b1BhdGhuYW1lLnNwbGl0KFwiL1wiKTtcblxuICAgICAgLy8gRWFjaCBsZWFkaW5nIC4uIHNlZ21lbnQgbWVhbnMgXCJnbyB1cCBvbmUgcm91dGVcIiBpbnN0ZWFkIG9mIFwiZ28gdXAgb25lXG4gICAgICAvLyBVUkwgc2VnbWVudFwiLiAgVGhpcyBpcyBhIGtleSBkaWZmZXJlbmNlIGZyb20gaG93IDxhIGhyZWY+IHdvcmtzIGFuZCBhXG4gICAgICAvLyBtYWpvciByZWFzb24gd2UgY2FsbCB0aGlzIGEgXCJ0b1wiIHZhbHVlIGluc3RlYWQgb2YgYSBcImhyZWZcIi5cbiAgICAgIHdoaWxlICh0b1NlZ21lbnRzWzBdID09PSBcIi4uXCIpIHtcbiAgICAgICAgdG9TZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICByb3V0ZVBhdGhuYW1lSW5kZXggLT0gMTtcbiAgICAgIH1cblxuICAgICAgdG8ucGF0aG5hbWUgPSB0b1NlZ21lbnRzLmpvaW4oXCIvXCIpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIFwiLi5cIiBzZWdtZW50cyB0aGFuIHBhcmVudCByb3V0ZXMsIHJlc29sdmUgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgcm9vdCAvIFVSTC5cbiAgICBmcm9tID0gcm91dGVQYXRobmFtZUluZGV4ID49IDAgPyByb3V0ZVBhdGhuYW1lc1tyb3V0ZVBhdGhuYW1lSW5kZXhdIDogXCIvXCI7XG4gIH1cblxuICBsZXQgcGF0aCA9IHJlc29sdmVQYXRoKHRvLCBmcm9tKTtcblxuICAvLyBFbnN1cmUgdGhlIHBhdGhuYW1lIGhhcyBhIHRyYWlsaW5nIHNsYXNoIGlmIHRoZSBvcmlnaW5hbCBcInRvXCIgaGFkIG9uZVxuICBsZXQgaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoID1cbiAgICB0b1BhdGhuYW1lICYmIHRvUGF0aG5hbWUgIT09IFwiL1wiICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICAvLyBPciBpZiB0aGlzIHdhcyBhIGxpbmsgdG8gdGhlIGN1cnJlbnQgcGF0aCB3aGljaCBoYXMgYSB0cmFpbGluZyBzbGFzaFxuICBsZXQgaGFzQ3VycmVudFRyYWlsaW5nU2xhc2ggPVxuICAgIChpc0VtcHR5UGF0aCB8fCB0b1BhdGhuYW1lID09PSBcIi5cIikgJiYgbG9jYXRpb25QYXRobmFtZS5lbmRzV2l0aChcIi9cIik7XG4gIGlmIChcbiAgICAhcGF0aC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikgJiZcbiAgICAoaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoIHx8IGhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoKVxuICApIHtcbiAgICBwYXRoLnBhdGhuYW1lICs9IFwiL1wiO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRvUGF0aG5hbWUodG86IFRvKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgLy8gRW1wdHkgc3RyaW5ncyBzaG91bGQgYmUgdHJlYXRlZCB0aGUgc2FtZSBhcyAvIHBhdGhzXG4gIHJldHVybiB0byA9PT0gXCJcIiB8fCAodG8gYXMgUGF0aCkucGF0aG5hbWUgPT09IFwiXCJcbiAgICA/IFwiL1wiXG4gICAgOiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCJcbiAgICA/IHBhcnNlUGF0aCh0bykucGF0aG5hbWVcbiAgICA6IHRvLnBhdGhuYW1lO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBqb2luUGF0aHMgPSAocGF0aHM6IHN0cmluZ1tdKTogc3RyaW5nID0+XG4gIHBhdGhzLmpvaW4oXCIvXCIpLnJlcGxhY2UoL1xcL1xcLysvZywgXCIvXCIpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVQYXRobmFtZSA9IChwYXRobmFtZTogc3RyaW5nKTogc3RyaW5nID0+XG4gIHBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikucmVwbGFjZSgvXlxcLyovLCBcIi9cIik7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVNlYXJjaCA9IChzZWFyY2g6IHN0cmluZyk6IHN0cmluZyA9PlxuICAhc2VhcmNoIHx8IHNlYXJjaCA9PT0gXCI/XCJcbiAgICA/IFwiXCJcbiAgICA6IHNlYXJjaC5zdGFydHNXaXRoKFwiP1wiKVxuICAgID8gc2VhcmNoXG4gICAgOiBcIj9cIiArIHNlYXJjaDtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplSGFzaCA9IChoYXNoOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgIWhhc2ggfHwgaGFzaCA9PT0gXCIjXCIgPyBcIlwiIDogaGFzaC5zdGFydHNXaXRoKFwiI1wiKSA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG5cbmV4cG9ydCB0eXBlIEpzb25GdW5jdGlvbiA9IDxEYXRhPihcbiAgZGF0YTogRGF0YSxcbiAgaW5pdD86IG51bWJlciB8IFJlc3BvbnNlSW5pdFxuKSA9PiBSZXNwb25zZTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIGNyZWF0aW5nIGBhcHBsaWNhdGlvbi9qc29uYCByZXNwb25zZXMuIENvbnZlcnRzIGBkYXRhYFxuICogdG8gSlNPTiBhbmQgc2V0cyB0aGUgYENvbnRlbnQtVHlwZWAgaGVhZGVyLlxuICovXG5leHBvcnQgY29uc3QganNvbjogSnNvbkZ1bmN0aW9uID0gKGRhdGEsIGluaXQgPSB7fSkgPT4ge1xuICBsZXQgcmVzcG9uc2VJbml0ID0gdHlwZW9mIGluaXQgPT09IFwibnVtYmVyXCIgPyB7IHN0YXR1czogaW5pdCB9IDogaW5pdDtcblxuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcbiAgaWYgKCFoZWFkZXJzLmhhcyhcIkNvbnRlbnQtVHlwZVwiKSkge1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSksIHtcbiAgICAuLi5yZXNwb25zZUluaXQsXG4gICAgaGVhZGVycyxcbiAgfSk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYWNrZWRQcm9taXNlIGV4dGVuZHMgUHJvbWlzZTxhbnk+IHtcbiAgX3RyYWNrZWQ/OiBib29sZWFuO1xuICBfZGF0YT86IGFueTtcbiAgX2Vycm9yPzogYW55O1xufVxuXG5leHBvcnQgY2xhc3MgQWJvcnRlZERlZmVycmVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5leHBvcnQgY2xhc3MgRGVmZXJyZWREYXRhIHtcbiAgcHJpdmF0ZSBwZW5kaW5nS2V5c1NldDogU2V0PHN0cmluZz4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgcHJpdmF0ZSBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXI7XG4gIHByaXZhdGUgYWJvcnRQcm9taXNlOiBQcm9taXNlPHZvaWQ+O1xuICBwcml2YXRlIHVubGlzdGVuQWJvcnRTaWduYWw6ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgc3Vic2NyaWJlcnM6IFNldDwoYWJvcnRlZDogYm9vbGVhbiwgc2V0dGxlZEtleT86IHN0cmluZykgPT4gdm9pZD4gPVxuICAgIG5ldyBTZXQoKTtcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIGluaXQ/OiBSZXNwb25zZUluaXQ7XG4gIGRlZmVycmVkS2V5czogc3RyaW5nW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwgcmVzcG9uc2VJbml0PzogUmVzcG9uc2VJbml0KSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShkYXRhKSxcbiAgICAgIFwiZGVmZXIoKSBvbmx5IGFjY2VwdHMgcGxhaW4gb2JqZWN0c1wiXG4gICAgKTtcblxuICAgIC8vIFNldCB1cCBhbiBBYm9ydENvbnRyb2xsZXIgKyBQcm9taXNlIHdlIGNhbiByYWNlIGFnYWluc3QgdG8gZXhpdCBlYXJseVxuICAgIC8vIGNhbmNlbGxhdGlvblxuICAgIGxldCByZWplY3Q6IChlOiBBYm9ydGVkRGVmZXJyZWRFcnJvcikgPT4gdm9pZDtcbiAgICB0aGlzLmFib3J0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByKSA9PiAocmVqZWN0ID0gcikpO1xuICAgIHRoaXMuY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgb25BYm9ydCA9ICgpID0+XG4gICAgICByZWplY3QobmV3IEFib3J0ZWREZWZlcnJlZEVycm9yKFwiRGVmZXJyZWQgZGF0YSBhYm9ydGVkXCIpKTtcbiAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwgPSAoKSA9PlxuICAgICAgdGhpcy5jb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgdGhpcy5jb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG5cbiAgICB0aGlzLmRhdGEgPSBPYmplY3QuZW50cmllcyhkYXRhKS5yZWR1Y2UoXG4gICAgICAoYWNjLCBba2V5LCB2YWx1ZV0pID0+XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWNjLCB7XG4gICAgICAgICAgW2tleV06IHRoaXMudHJhY2tQcm9taXNlKGtleSwgdmFsdWUpLFxuICAgICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcblxuICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgIC8vIEFsbCBpbmNvbWluZyB2YWx1ZXMgd2VyZSByZXNvbHZlZFxuICAgICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsKCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0ID0gcmVzcG9uc2VJbml0O1xuICB9XG5cbiAgcHJpdmF0ZSB0cmFja1Byb21pc2UoXG4gICAga2V5OiBzdHJpbmcsXG4gICAgdmFsdWU6IFByb21pc2U8dW5rbm93bj4gfCB1bmtub3duXG4gICk6IFRyYWNrZWRQcm9taXNlIHwgdW5rbm93biB7XG4gICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMuZGVmZXJyZWRLZXlzLnB1c2goa2V5KTtcbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0LmFkZChrZXkpO1xuXG4gICAgLy8gV2Ugc3RvcmUgYSBsaXR0bGUgd3JhcHBlciBwcm9taXNlIHRoYXQgd2lsbCBiZSBleHRlbmRlZCB3aXRoXG4gICAgLy8gX2RhdGEvX2Vycm9yIHByb3BzIHVwb24gcmVzb2x2ZS9yZWplY3RcbiAgICBsZXQgcHJvbWlzZTogVHJhY2tlZFByb21pc2UgPSBQcm9taXNlLnJhY2UoW3ZhbHVlLCB0aGlzLmFib3J0UHJvbWlzZV0pLnRoZW4oXG4gICAgICAoZGF0YSkgPT4gdGhpcy5vblNldHRsZShwcm9taXNlLCBrZXksIG51bGwsIGRhdGEgYXMgdW5rbm93biksXG4gICAgICAoZXJyb3IpID0+IHRoaXMub25TZXR0bGUocHJvbWlzZSwga2V5LCBlcnJvciBhcyB1bmtub3duKVxuICAgICk7XG5cbiAgICAvLyBSZWdpc3RlciByZWplY3Rpb24gbGlzdGVuZXJzIHRvIGF2b2lkIHVuY2F1Z2h0IHByb21pc2UgcmVqZWN0aW9ucyBvblxuICAgIC8vIGVycm9ycyBvciBhYm9ydGVkIGRlZmVycmVkIHZhbHVlc1xuICAgIHByb21pc2UuY2F0Y2goKCkgPT4ge30pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwgeyBnZXQ6ICgpID0+IHRydWUgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBwcml2YXRlIG9uU2V0dGxlKFxuICAgIHByb21pc2U6IFRyYWNrZWRQcm9taXNlLFxuICAgIGtleTogc3RyaW5nLFxuICAgIGVycm9yOiB1bmtub3duLFxuICAgIGRhdGE/OiB1bmtub3duXG4gICk6IHVua25vd24ge1xuICAgIGlmIChcbiAgICAgIHRoaXMuY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCAmJlxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBBYm9ydGVkRGVmZXJyZWRFcnJvclxuICAgICkge1xuICAgICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsKCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwgeyBnZXQ6ICgpID0+IGVycm9yIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0LmRlbGV0ZShrZXkpO1xuXG4gICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgLy8gTm90aGluZyBsZWZ0IHRvIGFib3J0IVxuICAgICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsKCk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwgeyBnZXQ6ICgpID0+IGVycm9yIH0pO1xuICAgICAgdGhpcy5lbWl0KGZhbHNlLCBrZXkpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZGF0YVwiLCB7IGdldDogKCkgPT4gZGF0YSB9KTtcbiAgICB0aGlzLmVtaXQoZmFsc2UsIGtleSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBwcml2YXRlIGVtaXQoYWJvcnRlZDogYm9vbGVhbiwgc2V0dGxlZEtleT86IHN0cmluZykge1xuICAgIHRoaXMuc3Vic2NyaWJlcnMuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4gc3Vic2NyaWJlcihhYm9ydGVkLCBzZXR0bGVkS2V5KSk7XG4gIH1cblxuICBzdWJzY3JpYmUoZm46IChhYm9ydGVkOiBib29sZWFuLCBzZXR0bGVkS2V5Pzogc3RyaW5nKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5hZGQoZm4pO1xuICAgIHJldHVybiAoKSA9PiB0aGlzLnN1YnNjcmliZXJzLmRlbGV0ZShmbik7XG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgdGhpcy5wZW5kaW5nS2V5c1NldC5mb3JFYWNoKCh2LCBrKSA9PiB0aGlzLnBlbmRpbmdLZXlzU2V0LmRlbGV0ZShrKSk7XG4gICAgdGhpcy5lbWl0KHRydWUpO1xuICB9XG5cbiAgYXN5bmMgcmVzb2x2ZURhdGEoc2lnbmFsOiBBYm9ydFNpZ25hbCkge1xuICAgIGxldCBhYm9ydGVkID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmRvbmUpIHtcbiAgICAgIGxldCBvbkFib3J0ID0gKCkgPT4gdGhpcy5jYW5jZWwoKTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICBhYm9ydGVkID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoKGFib3J0ZWQpID0+IHtcbiAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgICAgICAgIGlmIChhYm9ydGVkIHx8IHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShhYm9ydGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhYm9ydGVkO1xuICB9XG5cbiAgZ2V0IGRvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ0tleXNTZXQuc2l6ZSA9PT0gMDtcbiAgfVxuXG4gIGdldCB1bndyYXBwZWREYXRhKCkge1xuICAgIGludmFyaWFudChcbiAgICAgIHRoaXMuZGF0YSAhPT0gbnVsbCAmJiB0aGlzLmRvbmUsXG4gICAgICBcIkNhbiBvbmx5IHVud3JhcCBkYXRhIG9uIGluaXRpYWxpemVkIGFuZCBzZXR0bGVkIGRlZmVycmVkc1wiXG4gICAgKTtcblxuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLmRhdGEpLnJlZHVjZShcbiAgICAgIChhY2MsIFtrZXksIHZhbHVlXSkgPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihhY2MsIHtcbiAgICAgICAgICBba2V5XTogdW53cmFwVHJhY2tlZFByb21pc2UodmFsdWUpLFxuICAgICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcbiAgfVxuXG4gIGdldCBwZW5kaW5nS2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnBlbmRpbmdLZXlzU2V0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1RyYWNrZWRQcm9taXNlKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBUcmFja2VkUHJvbWlzZSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlICYmICh2YWx1ZSBhcyBUcmFja2VkUHJvbWlzZSkuX3RyYWNrZWQgPT09IHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwVHJhY2tlZFByb21pc2UodmFsdWU6IGFueSkge1xuICBpZiAoIWlzVHJhY2tlZFByb21pc2UodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHZhbHVlLl9lcnJvcikge1xuICAgIHRocm93IHZhbHVlLl9lcnJvcjtcbiAgfVxuICByZXR1cm4gdmFsdWUuX2RhdGE7XG59XG5cbmV4cG9ydCB0eXBlIERlZmVyRnVuY3Rpb24gPSAoXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBpbml0PzogbnVtYmVyIHwgUmVzcG9uc2VJbml0XG4pID0+IERlZmVycmVkRGF0YTtcblxuZXhwb3J0IGNvbnN0IGRlZmVyOiBEZWZlckZ1bmN0aW9uID0gKGRhdGEsIGluaXQgPSB7fSkgPT4ge1xuICBsZXQgcmVzcG9uc2VJbml0ID0gdHlwZW9mIGluaXQgPT09IFwibnVtYmVyXCIgPyB7IHN0YXR1czogaW5pdCB9IDogaW5pdDtcblxuICByZXR1cm4gbmV3IERlZmVycmVkRGF0YShkYXRhLCByZXNwb25zZUluaXQpO1xufTtcblxuZXhwb3J0IHR5cGUgUmVkaXJlY3RGdW5jdGlvbiA9IChcbiAgdXJsOiBzdHJpbmcsXG4gIGluaXQ/OiBudW1iZXIgfCBSZXNwb25zZUluaXRcbikgPT4gUmVzcG9uc2U7XG5cbi8qKlxuICogQSByZWRpcmVjdCByZXNwb25zZS4gU2V0cyB0aGUgc3RhdHVzIGNvZGUgYW5kIHRoZSBgTG9jYXRpb25gIGhlYWRlci5cbiAqIERlZmF1bHRzIHRvIFwiMzAyIEZvdW5kXCIuXG4gKi9cbmV4cG9ydCBjb25zdCByZWRpcmVjdDogUmVkaXJlY3RGdW5jdGlvbiA9ICh1cmwsIGluaXQgPSAzMDIpID0+IHtcbiAgbGV0IHJlc3BvbnNlSW5pdCA9IGluaXQ7XG4gIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVzcG9uc2VJbml0ID0geyBzdGF0dXM6IHJlc3BvbnNlSW5pdCB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZUluaXQuc3RhdHVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmVzcG9uc2VJbml0LnN0YXR1cyA9IDMwMjtcbiAgfVxuXG4gIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2VJbml0LmhlYWRlcnMpO1xuICBoZWFkZXJzLnNldChcIkxvY2F0aW9uXCIsIHVybCk7XG5cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgLi4ucmVzcG9uc2VJbml0LFxuICAgIGhlYWRlcnMsXG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogVXRpbGl0eSBjbGFzcyB3ZSB1c2UgdG8gaG9sZCBhdXRvLXVud3JhcHBlZCA0eHgvNXh4IFJlc3BvbnNlIGJvZGllc1xuICovXG5leHBvcnQgY2xhc3MgRXJyb3JSZXNwb25zZSB7XG4gIHN0YXR1czogbnVtYmVyO1xuICBzdGF0dXNUZXh0OiBzdHJpbmc7XG4gIGRhdGE6IGFueTtcbiAgZXJyb3I/OiBFcnJvcjtcbiAgaW50ZXJuYWw6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgc3RhdHVzOiBudW1iZXIsXG4gICAgc3RhdHVzVGV4dDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIGRhdGE6IGFueSxcbiAgICBpbnRlcm5hbCA9IGZhbHNlXG4gICkge1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgXCJcIjtcbiAgICB0aGlzLmludGVybmFsID0gaW50ZXJuYWw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YS50b1N0cmluZygpO1xuICAgICAgdGhpcy5lcnJvciA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVycm9yIGlzIGFuIEVycm9yUmVzcG9uc2UgZ2VuZXJhdGVkIGZyb20gYSA0eHgvNXh4XG4gKiBSZXNwb25zZSB0aHJvd24gZnJvbSBhbiBhY3Rpb24vbG9hZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcjogYW55KTogZXJyb3IgaXMgRXJyb3JSZXNwb25zZSB7XG4gIHJldHVybiAoXG4gICAgZXJyb3IgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiBlcnJvci5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiZcbiAgICB0eXBlb2YgZXJyb3Iuc3RhdHVzVGV4dCA9PT0gXCJzdHJpbmdcIiAmJlxuICAgIHR5cGVvZiBlcnJvci5pbnRlcm5hbCA9PT0gXCJib29sZWFuXCIgJiZcbiAgICBcImRhdGFcIiBpbiBlcnJvclxuICApO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBIaXN0b3J5LCBMb2NhdGlvbiwgUGF0aCwgVG8gfSBmcm9tIFwiLi9oaXN0b3J5XCI7XG5pbXBvcnQge1xuICBBY3Rpb24gYXMgSGlzdG9yeUFjdGlvbixcbiAgY3JlYXRlTG9jYXRpb24sXG4gIGNyZWF0ZVBhdGgsXG4gIGludmFyaWFudCxcbiAgcGFyc2VQYXRoLFxufSBmcm9tIFwiLi9oaXN0b3J5XCI7XG5pbXBvcnQgdHlwZSB7XG4gIERhdGFSZXN1bHQsXG4gIEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0LFxuICBEZWZlcnJlZFJlc3VsdCxcbiAgRXJyb3JSZXN1bHQsXG4gIEZvcm1FbmNUeXBlLFxuICBGb3JtTWV0aG9kLFxuICBSZWRpcmVjdFJlc3VsdCxcbiAgUm91dGVEYXRhLFxuICBBZ25vc3RpY1JvdXRlT2JqZWN0LFxuICBTdWJtaXNzaW9uLFxuICBTdWNjZXNzUmVzdWx0LFxuICBBZ25vc3RpY1JvdXRlTWF0Y2gsXG4gIE11dGF0aW9uRm9ybU1ldGhvZCxcbiAgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uLFxufSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHtcbiAgRGVmZXJyZWREYXRhLFxuICBFcnJvclJlc3BvbnNlLFxuICBSZXN1bHRUeXBlLFxuICBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzLFxuICBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyxcbiAgaXNSb3V0ZUVycm9yUmVzcG9uc2UsXG4gIGpvaW5QYXRocyxcbiAgbWF0Y2hSb3V0ZXMsXG4gIHJlc29sdmVUbyxcbiAgd2FybmluZyxcbn0gZnJvbSBcIi4vdXRpbHNcIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBUeXBlcyBhbmQgQ29uc3RhbnRzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEEgUm91dGVyIGluc3RhbmNlIG1hbmFnZXMgYWxsIG5hdmlnYXRpb24gYW5kIGRhdGEgbG9hZGluZy9tdXRhdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXIge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFJldHVybiB0aGUgYmFzZW5hbWUgZm9yIHRoZSByb3V0ZXJcbiAgICovXG4gIGdldCBiYXNlbmFtZSgpOiBSb3V0ZXJJbml0W1wiYmFzZW5hbWVcIl07XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHJvdXRlclxuICAgKi9cbiAgZ2V0IHN0YXRlKCk6IFJvdXRlclN0YXRlO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogUmV0dXJuIHRoZSByb3V0ZXMgZm9yIHRoaXMgcm91dGVyIGluc3RhbmNlXG4gICAqL1xuICBnZXQgcm91dGVzKCk6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W107XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBJbml0aWFsaXplIHRoZSByb3V0ZXIsIGluY2x1ZGluZyBhZGRpbmcgaGlzdG9yeSBsaXN0ZW5lcnMgYW5kIGtpY2tpbmcgb2ZmXG4gICAqIGluaXRpYWwgZGF0YSBmZXRjaGVzLiAgUmV0dXJucyBhIGZ1bmN0aW9uIHRvIGNsZWFudXAgbGlzdGVuZXJzIGFuZCBhYm9ydFxuICAgKiBhbnkgaW4tcHJvZ3Jlc3MgbG9hZHNcbiAgICovXG4gIGluaXRpYWxpemUoKTogUm91dGVyO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogU3Vic2NyaWJlIHRvIHJvdXRlci5zdGF0ZSB1cGRhdGVzXG4gICAqXG4gICAqIEBwYXJhbSBmbiBmdW5jdGlvbiB0byBjYWxsIHdpdGggdGhlIG5ldyBzdGF0ZVxuICAgKi9cbiAgc3Vic2NyaWJlKGZuOiBSb3V0ZXJTdWJzY3JpYmVyKTogKCkgPT4gdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEVuYWJsZSBzY3JvbGwgcmVzdG9yYXRpb24gYmVoYXZpb3IgaW4gdGhlIHJvdXRlclxuICAgKlxuICAgKiBAcGFyYW0gc2F2ZWRTY3JvbGxQb3NpdGlvbnMgT2JqZWN0IHRoYXQgd2lsbCBtYW5hZ2UgcG9zaXRpb25zLCBpbiBjYXNlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdCdzIGJlaW5nIHJlc3RvcmVkIGZyb20gc2Vzc2lvblN0b3JhZ2VcbiAgICogQHBhcmFtIGdldFNjcm9sbFBvc2l0aW9uICAgIEZ1bmN0aW9uIHRvIGdldCB0aGUgYWN0aXZlIFkgc2Nyb2xsIHBvc2l0aW9uXG4gICAqIEBwYXJhbSBnZXRLZXkgICAgICAgICAgICAgICBGdW5jdGlvbiB0byBnZXQgdGhlIGtleSB0byB1c2UgZm9yIHJlc3RvcmF0aW9uXG4gICAqL1xuICBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbihcbiAgICBzYXZlZFNjcm9sbFBvc2l0aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgICBnZXRTY3JvbGxQb3NpdGlvbjogR2V0U2Nyb2xsUG9zaXRpb25GdW5jdGlvbixcbiAgICBnZXRLZXk/OiBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uXG4gICk6ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBOYXZpZ2F0ZSBmb3J3YXJkL2JhY2t3YXJkIGluIHRoZSBoaXN0b3J5IHN0YWNrXG4gICAqIEBwYXJhbSB0byBEZWx0YSB0byBtb3ZlIGluIHRoZSBoaXN0b3J5IHN0YWNrXG4gICAqL1xuICBuYXZpZ2F0ZSh0bzogbnVtYmVyKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogTmF2aWdhdGUgdG8gdGhlIGdpdmVuIHBhdGhcbiAgICogQHBhcmFtIHRvIFBhdGggdG8gbmF2aWdhdGUgdG9cbiAgICogQHBhcmFtIG9wdHMgTmF2aWdhdGlvbiBvcHRpb25zIChtZXRob2QsIHN1Ym1pc3Npb24sIGV0Yy4pXG4gICAqL1xuICBuYXZpZ2F0ZSh0bzogVG8sIG9wdHM/OiBSb3V0ZXJOYXZpZ2F0ZU9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogVHJpZ2dlciBhIGZldGNoZXIgbG9hZC9zdWJtaXNzaW9uXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgICAgIEZldGNoZXIga2V5XG4gICAqIEBwYXJhbSByb3V0ZUlkIFJvdXRlIHRoYXQgb3ducyB0aGUgZmV0Y2hlclxuICAgKiBAcGFyYW0gaHJlZiAgICBocmVmIHRvIGZldGNoXG4gICAqIEBwYXJhbSBvcHRzICAgIEZldGNoZXIgb3B0aW9ucywgKG1ldGhvZCwgc3VibWlzc2lvbiwgZXRjLilcbiAgICovXG4gIGZldGNoKFxuICAgIGtleTogc3RyaW5nLFxuICAgIHJvdXRlSWQ6IHN0cmluZyxcbiAgICBocmVmOiBzdHJpbmcsXG4gICAgb3B0cz86IFJvdXRlck5hdmlnYXRlT3B0aW9uc1xuICApOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogVHJpZ2dlciBhIHJldmFsaWRhdGlvbiBvZiBhbGwgY3VycmVudCByb3V0ZSBsb2FkZXJzIGFuZCBmZXRjaGVyIGxvYWRzXG4gICAqL1xuICByZXZhbGlkYXRlKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBocmVmIGZvciB0aGUgZ2l2ZW4gbG9jYXRpb25cbiAgICogQHBhcmFtIGxvY2F0aW9uXG4gICAqL1xuICBjcmVhdGVIcmVmKGxvY2F0aW9uOiBMb2NhdGlvbiB8IFVSTCk6IHN0cmluZztcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gVVJMIGVuY29kZSBhIGRlc3RpbmF0aW9uIHBhdGggYWNjb3JkaW5nIHRvIHRoZSBpbnRlcm5hbFxuICAgKiBoaXN0b3J5IGltcGxlbWVudGF0aW9uXG4gICAqIEBwYXJhbSB0b1xuICAgKi9cbiAgZW5jb2RlTG9jYXRpb24odG86IFRvKTogUGF0aDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEdldC9jcmVhdGUgYSBmZXRjaGVyIGZvciB0aGUgZ2l2ZW4ga2V5XG4gICAqIEBwYXJhbSBrZXlcbiAgICovXG4gIGdldEZldGNoZXI8VERhdGEgPSBhbnk+KGtleT86IHN0cmluZyk6IEZldGNoZXI8VERhdGE+O1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogRGVsZXRlIHRoZSBmZXRjaGVyIGZvciBhIGdpdmVuIGtleVxuICAgKiBAcGFyYW0ga2V5XG4gICAqL1xuICBkZWxldGVGZXRjaGVyKGtleT86IHN0cmluZyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBDbGVhbnVwIGxpc3RlbmVycyBhbmQgYWJvcnQgYW55IGluLXByb2dyZXNzIGxvYWRzXG4gICAqL1xuICBkaXNwb3NlKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBHZXQgYSBuYXZpZ2F0aW9uIGJsb2NrZXJcbiAgICogQHBhcmFtIGtleSBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGJsb2NrZXJcbiAgICogQHBhcmFtIGZuIFRoZSBibG9ja2VyIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBnZXRCbG9ja2VyKGtleTogc3RyaW5nLCBmbjogQmxvY2tlckZ1bmN0aW9uKTogQmxvY2tlcjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIERlbGV0ZSBhIG5hdmlnYXRpb24gYmxvY2tlclxuICAgKiBAcGFyYW0ga2V5IFRoZSBpZGVudGlmaWVyIGZvciB0aGUgYmxvY2tlclxuICAgKi9cbiAgZGVsZXRlQmxvY2tlcihrZXk6IHN0cmluZyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBJbnRlcm5hbCBmZXRjaCBBYm9ydENvbnRyb2xsZXJzIGFjY2Vzc2VkIGJ5IHVuaXQgdGVzdHNcbiAgICovXG4gIF9pbnRlcm5hbEZldGNoQ29udHJvbGxlcnM6IE1hcDxzdHJpbmcsIEFib3J0Q29udHJvbGxlcj47XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBJbnRlcm5hbCBwZW5kaW5nIERlZmVycmVkRGF0YSBpbnN0YW5jZXMgYWNjZXNzZWQgYnkgdW5pdCB0ZXN0c1xuICAgKi9cbiAgX2ludGVybmFsQWN0aXZlRGVmZXJyZWRzOiBNYXA8c3RyaW5nLCBEZWZlcnJlZERhdGE+O1xufVxuXG4vKipcbiAqIFN0YXRlIG1haW50YWluZWQgaW50ZXJuYWxseSBieSB0aGUgcm91dGVyLiAgRHVyaW5nIGEgbmF2aWdhdGlvbiwgYWxsIHN0YXRlc1xuICogcmVmbGVjdCB0aGUgdGhlIFwib2xkXCIgbG9jYXRpb24gdW5sZXNzIG90aGVyd2lzZSBub3RlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJTdGF0ZSB7XG4gIC8qKlxuICAgKiBUaGUgYWN0aW9uIG9mIHRoZSBtb3N0IHJlY2VudCBuYXZpZ2F0aW9uXG4gICAqL1xuICBoaXN0b3J5QWN0aW9uOiBIaXN0b3J5QWN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBsb2NhdGlvbiByZWZsZWN0ZWQgYnkgdGhlIHJvdXRlclxuICAgKi9cbiAgbG9jYXRpb246IExvY2F0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzZXQgb2Ygcm91dGUgbWF0Y2hlc1xuICAgKi9cbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdO1xuXG4gIC8qKlxuICAgKiBUcmFja3Mgd2hldGhlciB3ZSd2ZSBjb21wbGV0ZWQgb3VyIGluaXRpYWwgZGF0YSBsb2FkXG4gICAqL1xuICBpbml0aWFsaXplZDogYm9vbGVhbjtcblxuICAvKipcbiAgICogQ3VycmVudCBzY3JvbGwgcG9zaXRpb24gd2Ugc2hvdWxkIHN0YXJ0IGF0IGZvciBhIG5ldyB2aWV3XG4gICAqICAtIG51bWJlciAtPiBzY3JvbGwgcG9zaXRpb24gdG8gcmVzdG9yZSB0b1xuICAgKiAgLSBmYWxzZSAtPiBkbyBub3QgcmVzdG9yZSBzY3JvbGwgYXQgYWxsICh1c2VkIGR1cmluZyBzdWJtaXNzaW9ucylcbiAgICogIC0gbnVsbCAtPiBkb24ndCBoYXZlIGEgc2F2ZWQgcG9zaXRpb24sIHNjcm9sbCB0byBoYXNoIG9yIHRvcCBvZiBwYWdlXG4gICAqL1xuICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IG51bWJlciB8IGZhbHNlIHwgbnVsbDtcblxuICAvKipcbiAgICogSW5kaWNhdGUgd2hldGhlciB0aGlzIG5hdmlnYXRpb24gc2hvdWxkIHNraXAgcmVzZXR0aW5nIHRoZSBzY3JvbGwgcG9zaXRpb25cbiAgICogaWYgd2UgYXJlIHVuYWJsZSB0byByZXN0b3JlIHRoZSBzY3JvbGwgcG9zaXRpb25cbiAgICovXG4gIHByZXZlbnRTY3JvbGxSZXNldDogYm9vbGVhbjtcblxuICAvKipcbiAgICogVHJhY2tzIHRoZSBzdGF0ZSBvZiB0aGUgY3VycmVudCBuYXZpZ2F0aW9uXG4gICAqL1xuICBuYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uO1xuXG4gIC8qKlxuICAgKiBUcmFja3MgYW55IGluLXByb2dyZXNzIHJldmFsaWRhdGlvbnNcbiAgICovXG4gIHJldmFsaWRhdGlvbjogUmV2YWxpZGF0aW9uU3RhdGU7XG5cbiAgLyoqXG4gICAqIERhdGEgZnJvbSB0aGUgbG9hZGVycyBmb3IgdGhlIGN1cnJlbnQgbWF0Y2hlc1xuICAgKi9cbiAgbG9hZGVyRGF0YTogUm91dGVEYXRhO1xuXG4gIC8qKlxuICAgKiBEYXRhIGZyb20gdGhlIGFjdGlvbiBmb3IgdGhlIGN1cnJlbnQgbWF0Y2hlc1xuICAgKi9cbiAgYWN0aW9uRGF0YTogUm91dGVEYXRhIHwgbnVsbDtcblxuICAvKipcbiAgICogRXJyb3JzIGNhdWdodCBmcm9tIGxvYWRlcnMgZm9yIHRoZSBjdXJyZW50IG1hdGNoZXNcbiAgICovXG4gIGVycm9yczogUm91dGVEYXRhIHwgbnVsbDtcblxuICAvKipcbiAgICogTWFwIG9mIGN1cnJlbnQgZmV0Y2hlcnNcbiAgICovXG4gIGZldGNoZXJzOiBNYXA8c3RyaW5nLCBGZXRjaGVyPjtcblxuICAvKipcbiAgICogTWFwIG9mIGN1cnJlbnQgYmxvY2tlcnNcbiAgICovXG4gIGJsb2NrZXJzOiBNYXA8c3RyaW5nLCBCbG9ja2VyPjtcbn1cblxuLyoqXG4gKiBEYXRhIHRoYXQgY2FuIGJlIHBhc3NlZCBpbnRvIGh5ZHJhdGUgYSBSb3V0ZXIgZnJvbSBTU1JcbiAqL1xuZXhwb3J0IHR5cGUgSHlkcmF0aW9uU3RhdGUgPSBQYXJ0aWFsPFxuICBQaWNrPFJvdXRlclN0YXRlLCBcImxvYWRlckRhdGFcIiB8IFwiYWN0aW9uRGF0YVwiIHwgXCJlcnJvcnNcIj5cbj47XG5cbi8qKlxuICogSW5pdGlhbGl6YXRpb24gb3B0aW9ucyBmb3IgY3JlYXRlUm91dGVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVySW5pdCB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICByb3V0ZXM6IEFnbm9zdGljUm91dGVPYmplY3RbXTtcbiAgaGlzdG9yeTogSGlzdG9yeTtcbiAgaHlkcmF0aW9uRGF0YT86IEh5ZHJhdGlvblN0YXRlO1xufVxuXG4vKipcbiAqIFN0YXRlIHJldHVybmVkIGZyb20gYSBzZXJ2ZXItc2lkZSBxdWVyeSgpIGNhbGxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdGF0aWNIYW5kbGVyQ29udGV4dCB7XG4gIGJhc2VuYW1lOiBSb3V0ZXJbXCJiYXNlbmFtZVwiXTtcbiAgbG9jYXRpb246IFJvdXRlclN0YXRlW1wibG9jYXRpb25cIl07XG4gIG1hdGNoZXM6IFJvdXRlclN0YXRlW1wibWF0Y2hlc1wiXTtcbiAgbG9hZGVyRGF0YTogUm91dGVyU3RhdGVbXCJsb2FkZXJEYXRhXCJdO1xuICBhY3Rpb25EYXRhOiBSb3V0ZXJTdGF0ZVtcImFjdGlvbkRhdGFcIl07XG4gIGVycm9yczogUm91dGVyU3RhdGVbXCJlcnJvcnNcIl07XG4gIHN0YXR1c0NvZGU6IG51bWJlcjtcbiAgbG9hZGVySGVhZGVyczogUmVjb3JkPHN0cmluZywgSGVhZGVycz47XG4gIGFjdGlvbkhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIEhlYWRlcnM+O1xuICBhY3RpdmVEZWZlcnJlZHM6IFJlY29yZDxzdHJpbmcsIERlZmVycmVkRGF0YT4gfCBudWxsO1xuICBfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZD86IHN0cmluZyB8IG51bGw7XG59XG5cbi8qKlxuICogQSBTdGF0aWNIYW5kbGVyIGluc3RhbmNlIG1hbmFnZXMgYSBzaW5ndWxhciBTU1IgbmF2aWdhdGlvbi9mZXRjaCBldmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpY0hhbmRsZXIge1xuICBkYXRhUm91dGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdO1xuICBxdWVyeShcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIG9wdHM/OiB7IHJlcXVlc3RDb250ZXh0PzogdW5rbm93biB9XG4gICk6IFByb21pc2U8U3RhdGljSGFuZGxlckNvbnRleHQgfCBSZXNwb25zZT47XG4gIHF1ZXJ5Um91dGUoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBvcHRzPzogeyByb3V0ZUlkPzogc3RyaW5nOyByZXF1ZXN0Q29udGV4dD86IHVua25vd24gfVxuICApOiBQcm9taXNlPGFueT47XG59XG5cbi8qKlxuICogU3Vic2NyaWJlciBmdW5jdGlvbiBzaWduYXR1cmUgZm9yIGNoYW5nZXMgdG8gcm91dGVyIHN0YXRlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyU3Vic2NyaWJlciB7XG4gIChzdGF0ZTogUm91dGVyU3RhdGUpOiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgVXNlTWF0Y2hlc01hdGNoIHtcbiAgaWQ6IHN0cmluZztcbiAgcGF0aG5hbWU6IHN0cmluZztcbiAgcGFyYW1zOiBBZ25vc3RpY1JvdXRlTWF0Y2hbXCJwYXJhbXNcIl07XG4gIGRhdGE6IHVua25vd247XG4gIGhhbmRsZTogdW5rbm93bjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBzaWduYXR1cmUgZm9yIGRldGVybWluaW5nIHRoZSBrZXkgdG8gYmUgdXNlZCBpbiBzY3JvbGwgcmVzdG9yYXRpb25cbiAqIGZvciBhIGdpdmVuIGxvY2F0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvbiB7XG4gIChsb2NhdGlvbjogTG9jYXRpb24sIG1hdGNoZXM6IFVzZU1hdGNoZXNNYXRjaFtdKTogc3RyaW5nIHwgbnVsbDtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBzaWduYXR1cmUgZm9yIGRldGVybWluaW5nIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdldFNjcm9sbFBvc2l0aW9uRnVuY3Rpb24ge1xuICAoKTogbnVtYmVyO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGEgbmF2aWdhdGUoKSBjYWxsIGZvciBhIExpbmsgbmF2aWdhdGlvblxuICovXG50eXBlIExpbmtOYXZpZ2F0ZU9wdGlvbnMgPSB7XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbiAgcHJldmVudFNjcm9sbFJlc2V0PzogYm9vbGVhbjtcbn07XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYSBuYXZpZ2F0ZSgpIGNhbGwgZm9yIGEgRm9ybSBuYXZpZ2F0aW9uXG4gKi9cbnR5cGUgU3VibWlzc2lvbk5hdmlnYXRlT3B0aW9ucyA9IHtcbiAgcmVwbGFjZT86IGJvb2xlYW47XG4gIHN0YXRlPzogYW55O1xuICBwcmV2ZW50U2Nyb2xsUmVzZXQ/OiBib29sZWFuO1xuICBmb3JtTWV0aG9kPzogRm9ybU1ldGhvZDtcbiAgZm9ybUVuY1R5cGU/OiBGb3JtRW5jVHlwZTtcbiAgZm9ybURhdGE6IEZvcm1EYXRhO1xufTtcblxuLyoqXG4gKiBPcHRpb25zIHRvIHBhc3MgdG8gbmF2aWdhdGUoKSBmb3IgZWl0aGVyIGEgTGluayBvciBGb3JtIG5hdmlnYXRpb25cbiAqL1xuZXhwb3J0IHR5cGUgUm91dGVyTmF2aWdhdGVPcHRpb25zID1cbiAgfCBMaW5rTmF2aWdhdGVPcHRpb25zXG4gIHwgU3VibWlzc2lvbk5hdmlnYXRlT3B0aW9ucztcblxuLyoqXG4gKiBPcHRpb25zIHRvIHBhc3MgdG8gZmV0Y2goKVxuICovXG5leHBvcnQgdHlwZSBSb3V0ZXJGZXRjaE9wdGlvbnMgPVxuICB8IE9taXQ8TGlua05hdmlnYXRlT3B0aW9ucywgXCJyZXBsYWNlXCI+XG4gIHwgT21pdDxTdWJtaXNzaW9uTmF2aWdhdGVPcHRpb25zLCBcInJlcGxhY2VcIj47XG5cbi8qKlxuICogUG90ZW50aWFsIHN0YXRlcyBmb3Igc3RhdGUubmF2aWdhdGlvblxuICovXG5leHBvcnQgdHlwZSBOYXZpZ2F0aW9uU3RhdGVzID0ge1xuICBJZGxlOiB7XG4gICAgc3RhdGU6IFwiaWRsZVwiO1xuICAgIGxvY2F0aW9uOiB1bmRlZmluZWQ7XG4gICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkO1xuICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZDtcbiAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkO1xuICAgIGZvcm1EYXRhOiB1bmRlZmluZWQ7XG4gIH07XG4gIExvYWRpbmc6IHtcbiAgICBzdGF0ZTogXCJsb2FkaW5nXCI7XG4gICAgbG9jYXRpb246IExvY2F0aW9uO1xuICAgIGZvcm1NZXRob2Q6IEZvcm1NZXRob2QgfCB1bmRlZmluZWQ7XG4gICAgZm9ybUFjdGlvbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGZvcm1FbmNUeXBlOiBGb3JtRW5jVHlwZSB8IHVuZGVmaW5lZDtcbiAgICBmb3JtRGF0YTogRm9ybURhdGEgfCB1bmRlZmluZWQ7XG4gIH07XG4gIFN1Ym1pdHRpbmc6IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCI7XG4gICAgbG9jYXRpb246IExvY2F0aW9uO1xuICAgIGZvcm1NZXRob2Q6IEZvcm1NZXRob2Q7XG4gICAgZm9ybUFjdGlvbjogc3RyaW5nO1xuICAgIGZvcm1FbmNUeXBlOiBGb3JtRW5jVHlwZTtcbiAgICBmb3JtRGF0YTogRm9ybURhdGE7XG4gIH07XG59O1xuXG5leHBvcnQgdHlwZSBOYXZpZ2F0aW9uID0gTmF2aWdhdGlvblN0YXRlc1trZXlvZiBOYXZpZ2F0aW9uU3RhdGVzXTtcblxuZXhwb3J0IHR5cGUgUmV2YWxpZGF0aW9uU3RhdGUgPSBcImlkbGVcIiB8IFwibG9hZGluZ1wiO1xuXG4vKipcbiAqIFBvdGVudGlhbCBzdGF0ZXMgZm9yIGZldGNoZXJzXG4gKi9cbnR5cGUgRmV0Y2hlclN0YXRlczxURGF0YSA9IGFueT4gPSB7XG4gIElkbGU6IHtcbiAgICBzdGF0ZTogXCJpZGxlXCI7XG4gICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkO1xuICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZDtcbiAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkO1xuICAgIGZvcm1EYXRhOiB1bmRlZmluZWQ7XG4gICAgZGF0YTogVERhdGEgfCB1bmRlZmluZWQ7XG4gICAgXCIgX2hhc0ZldGNoZXJEb25lQW55dGhpbmcgXCI/OiBib29sZWFuO1xuICB9O1xuICBMb2FkaW5nOiB7XG4gICAgc3RhdGU6IFwibG9hZGluZ1wiO1xuICAgIGZvcm1NZXRob2Q6IEZvcm1NZXRob2QgfCB1bmRlZmluZWQ7XG4gICAgZm9ybUFjdGlvbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGZvcm1FbmNUeXBlOiBGb3JtRW5jVHlwZSB8IHVuZGVmaW5lZDtcbiAgICBmb3JtRGF0YTogRm9ybURhdGEgfCB1bmRlZmluZWQ7XG4gICAgZGF0YTogVERhdGEgfCB1bmRlZmluZWQ7XG4gICAgXCIgX2hhc0ZldGNoZXJEb25lQW55dGhpbmcgXCI/OiBib29sZWFuO1xuICB9O1xuICBTdWJtaXR0aW5nOiB7XG4gICAgc3RhdGU6IFwic3VibWl0dGluZ1wiO1xuICAgIGZvcm1NZXRob2Q6IEZvcm1NZXRob2Q7XG4gICAgZm9ybUFjdGlvbjogc3RyaW5nO1xuICAgIGZvcm1FbmNUeXBlOiBGb3JtRW5jVHlwZTtcbiAgICBmb3JtRGF0YTogRm9ybURhdGE7XG4gICAgZGF0YTogVERhdGEgfCB1bmRlZmluZWQ7XG4gICAgXCIgX2hhc0ZldGNoZXJEb25lQW55dGhpbmcgXCI/OiBib29sZWFuO1xuICB9O1xufTtcblxuZXhwb3J0IHR5cGUgRmV0Y2hlcjxURGF0YSA9IGFueT4gPVxuICBGZXRjaGVyU3RhdGVzPFREYXRhPltrZXlvZiBGZXRjaGVyU3RhdGVzPFREYXRhPl07XG5cbmludGVyZmFjZSBCbG9ja2VyQmxvY2tlZCB7XG4gIHN0YXRlOiBcImJsb2NrZWRcIjtcbiAgcmVzZXQoKTogdm9pZDtcbiAgcHJvY2VlZCgpOiB2b2lkO1xuICBsb2NhdGlvbjogTG9jYXRpb247XG59XG5cbmludGVyZmFjZSBCbG9ja2VyVW5ibG9ja2VkIHtcbiAgc3RhdGU6IFwidW5ibG9ja2VkXCI7XG4gIHJlc2V0OiB1bmRlZmluZWQ7XG4gIHByb2NlZWQ6IHVuZGVmaW5lZDtcbiAgbG9jYXRpb246IHVuZGVmaW5lZDtcbn1cblxuaW50ZXJmYWNlIEJsb2NrZXJQcm9jZWVkaW5nIHtcbiAgc3RhdGU6IFwicHJvY2VlZGluZ1wiO1xuICByZXNldDogdW5kZWZpbmVkO1xuICBwcm9jZWVkOiB1bmRlZmluZWQ7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbn1cblxuZXhwb3J0IHR5cGUgQmxvY2tlciA9IEJsb2NrZXJVbmJsb2NrZWQgfCBCbG9ja2VyQmxvY2tlZCB8IEJsb2NrZXJQcm9jZWVkaW5nO1xuXG5leHBvcnQgdHlwZSBCbG9ja2VyRnVuY3Rpb24gPSAoYXJnczoge1xuICBjdXJyZW50TG9jYXRpb246IExvY2F0aW9uO1xuICBuZXh0TG9jYXRpb246IExvY2F0aW9uO1xuICBoaXN0b3J5QWN0aW9uOiBIaXN0b3J5QWN0aW9uO1xufSkgPT4gYm9vbGVhbjtcblxuaW50ZXJmYWNlIFNob3J0Q2lyY3VpdGFibGUge1xuICAvKipcbiAgICogc3RhcnROYXZpZ2F0aW9uIGRvZXMgbm90IG5lZWQgdG8gY29tcGxldGUgdGhlIG5hdmlnYXRpb24gYmVjYXVzZSB3ZVxuICAgKiByZWRpcmVjdGVkIG9yIGdvdCBpbnRlcnJ1cHRlZFxuICAgKi9cbiAgc2hvcnRDaXJjdWl0ZWQ/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgSGFuZGxlQWN0aW9uUmVzdWx0IGV4dGVuZHMgU2hvcnRDaXJjdWl0YWJsZSB7XG4gIC8qKlxuICAgKiBFcnJvciB0aHJvd24gZnJvbSB0aGUgY3VycmVudCBhY3Rpb24sIGtleWVkIGJ5IHRoZSByb3V0ZSBjb250YWluaW5nIHRoZVxuICAgKiBlcnJvciBib3VuZGFyeSB0byByZW5kZXIgdGhlIGVycm9yLiAgVG8gYmUgY29tbWl0dGVkIHRvIHRoZSBzdGF0ZSBhZnRlclxuICAgKiBsb2FkZXJzIGhhdmUgY29tcGxldGVkXG4gICAqL1xuICBwZW5kaW5nQWN0aW9uRXJyb3I/OiBSb3V0ZURhdGE7XG4gIC8qKlxuICAgKiBEYXRhIHJldHVybmVkIGZyb20gdGhlIGN1cnJlbnQgYWN0aW9uLCBrZXllZCBieSB0aGUgcm91dGUgb3duaW5nIHRoZSBhY3Rpb24uXG4gICAqIFRvIGJlIGNvbW1pdHRlZCB0byB0aGUgc3RhdGUgYWZ0ZXIgbG9hZGVycyBoYXZlIGNvbXBsZXRlZFxuICAgKi9cbiAgcGVuZGluZ0FjdGlvbkRhdGE/OiBSb3V0ZURhdGE7XG59XG5cbmludGVyZmFjZSBIYW5kbGVMb2FkZXJzUmVzdWx0IGV4dGVuZHMgU2hvcnRDaXJjdWl0YWJsZSB7XG4gIC8qKlxuICAgKiBsb2FkZXJEYXRhIHJldHVybmVkIGZyb20gdGhlIGN1cnJlbnQgc2V0IG9mIGxvYWRlcnNcbiAgICovXG4gIGxvYWRlckRhdGE/OiBSb3V0ZXJTdGF0ZVtcImxvYWRlckRhdGFcIl07XG4gIC8qKlxuICAgKiBlcnJvcnMgdGhyb3duIGZyb20gdGhlIGN1cnJlbnQgc2V0IG9mIGxvYWRlcnNcbiAgICovXG4gIGVycm9ycz86IFJvdXRlclN0YXRlW1wiZXJyb3JzXCJdO1xufVxuXG4vKipcbiAqIENhY2hlZCBpbmZvIGZvciBhY3RpdmUgZmV0Y2hlci5sb2FkKCkgaW5zdGFuY2VzIHNvIHRoZXkgY2FuIHBhcnRpY2lwYXRlXG4gKiBpbiByZXZhbGlkYXRpb25cbiAqL1xuaW50ZXJmYWNlIEZldGNoTG9hZE1hdGNoIHtcbiAgcm91dGVJZDogc3RyaW5nO1xuICBwYXRoOiBzdHJpbmc7XG4gIG1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoO1xuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW107XG59XG5cbi8qKlxuICogSWRlbnRpZmllZCBmZXRjaGVyLmxvYWQoKSBjYWxscyB0aGF0IG5lZWQgdG8gYmUgcmV2YWxpZGF0ZWRcbiAqL1xuaW50ZXJmYWNlIFJldmFsaWRhdGluZ0ZldGNoZXIgZXh0ZW5kcyBGZXRjaExvYWRNYXRjaCB7XG4gIGtleTogc3RyaW5nO1xufVxuXG4vKipcbiAqIFdyYXBwZXIgb2JqZWN0IHRvIGFsbG93IHVzIHRvIHRocm93IGFueSByZXNwb25zZSBvdXQgZnJvbSBjYWxsTG9hZGVyT3JBY3Rpb25cbiAqIGZvciBxdWVyeVJvdXRlciB3aGlsZSBwcmVzZXJ2aW5nIHdoZXRoZXIgb3Igbm90IGl0IHdhcyB0aHJvd24gb3IgcmV0dXJuZWRcbiAqIGZyb20gdGhlIGxvYWRlci9hY3Rpb25cbiAqL1xuaW50ZXJmYWNlIFF1ZXJ5Um91dGVSZXNwb25zZSB7XG4gIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSB8IFJlc3VsdFR5cGUuZXJyb3I7XG4gIHJlc3BvbnNlOiBSZXNwb25zZTtcbn1cblxuY29uc3QgdmFsaWRNdXRhdGlvbk1ldGhvZHNBcnI6IE11dGF0aW9uRm9ybU1ldGhvZFtdID0gW1xuICBcInBvc3RcIixcbiAgXCJwdXRcIixcbiAgXCJwYXRjaFwiLFxuICBcImRlbGV0ZVwiLFxuXTtcbmNvbnN0IHZhbGlkTXV0YXRpb25NZXRob2RzID0gbmV3IFNldDxNdXRhdGlvbkZvcm1NZXRob2Q+KFxuICB2YWxpZE11dGF0aW9uTWV0aG9kc0FyclxuKTtcblxuY29uc3QgdmFsaWRSZXF1ZXN0TWV0aG9kc0FycjogRm9ybU1ldGhvZFtdID0gW1xuICBcImdldFwiLFxuICAuLi52YWxpZE11dGF0aW9uTWV0aG9kc0Fycixcbl07XG5jb25zdCB2YWxpZFJlcXVlc3RNZXRob2RzID0gbmV3IFNldDxGb3JtTWV0aG9kPih2YWxpZFJlcXVlc3RNZXRob2RzQXJyKTtcblxuY29uc3QgcmVkaXJlY3RTdGF0dXNDb2RlcyA9IG5ldyBTZXQoWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XSk7XG5jb25zdCByZWRpcmVjdFByZXNlcnZlTWV0aG9kU3RhdHVzQ29kZXMgPSBuZXcgU2V0KFszMDcsIDMwOF0pO1xuXG5leHBvcnQgY29uc3QgSURMRV9OQVZJR0FUSU9OOiBOYXZpZ2F0aW9uU3RhdGVzW1wiSWRsZVwiXSA9IHtcbiAgc3RhdGU6IFwiaWRsZVwiLFxuICBsb2NhdGlvbjogdW5kZWZpbmVkLFxuICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbn07XG5cbmV4cG9ydCBjb25zdCBJRExFX0ZFVENIRVI6IEZldGNoZXJTdGF0ZXNbXCJJZGxlXCJdID0ge1xuICBzdGF0ZTogXCJpZGxlXCIsXG4gIGRhdGE6IHVuZGVmaW5lZCxcbiAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gIGZvcm1EYXRhOiB1bmRlZmluZWQsXG59O1xuXG5leHBvcnQgY29uc3QgSURMRV9CTE9DS0VSOiBCbG9ja2VyVW5ibG9ja2VkID0ge1xuICBzdGF0ZTogXCJ1bmJsb2NrZWRcIixcbiAgcHJvY2VlZDogdW5kZWZpbmVkLFxuICByZXNldDogdW5kZWZpbmVkLFxuICBsb2NhdGlvbjogdW5kZWZpbmVkLFxufTtcblxuY29uc3QgQUJTT0xVVEVfVVJMX1JFR0VYID0gL14oPzpbYS16XVthLXowLTkrLi1dKjp8XFwvXFwvKS9pO1xuXG5jb25zdCBpc0Jyb3dzZXIgPVxuICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuY29uc3QgaXNTZXJ2ZXIgPSAhaXNCcm93c2VyO1xuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gY3JlYXRlUm91dGVyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENyZWF0ZSBhIHJvdXRlciBhbmQgbGlzdGVuIHRvIGhpc3RvcnkgUE9QIG5hdmlnYXRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSb3V0ZXIoaW5pdDogUm91dGVySW5pdCk6IFJvdXRlciB7XG4gIGludmFyaWFudChcbiAgICBpbml0LnJvdXRlcy5sZW5ndGggPiAwLFxuICAgIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlUm91dGVyXCJcbiAgKTtcblxuICBsZXQgZGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoaW5pdC5yb3V0ZXMpO1xuICAvLyBDbGVhbnVwIGZ1bmN0aW9uIGZvciBoaXN0b3J5XG4gIGxldCB1bmxpc3Rlbkhpc3Rvcnk6ICgoKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIGZ1bmN0aW9ucyB0byBjYWxsIG9uIGFsbCBzdGF0ZSBjaGFuZ2VzXG4gIGxldCBzdWJzY3JpYmVycyA9IG5ldyBTZXQ8Um91dGVyU3Vic2NyaWJlcj4oKTtcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBvYmplY3QgdG8gaG9sZCBzY3JvbGwgcmVzdG9yYXRpb24gbG9jYXRpb25zIGR1cmluZyByb3V0aW5nXG4gIGxldCBzYXZlZFNjcm9sbFBvc2l0aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB8IG51bGwgPSBudWxsO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIGZ1bmN0aW9uIHRvIGdldCBzY3JvbGwgcmVzdG9yYXRpb24ga2V5c1xuICBsZXQgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXk6IEdldFNjcm9sbFJlc3RvcmF0aW9uS2V5RnVuY3Rpb24gfCBudWxsID0gbnVsbDtcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBmdW5jdGlvbiB0byBnZXQgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cbiAgbGV0IGdldFNjcm9sbFBvc2l0aW9uOiBHZXRTY3JvbGxQb3NpdGlvbkZ1bmN0aW9uIHwgbnVsbCA9IG51bGw7XG4gIC8vIE9uZS10aW1lIGZsYWcgdG8gY29udHJvbCB0aGUgaW5pdGlhbCBoeWRyYXRpb24gc2Nyb2xsIHJlc3RvcmF0aW9uLiAgQmVjYXVzZVxuICAvLyB3ZSBkb24ndCBnZXQgdGhlIHNhdmVkIHBvc2l0aW9ucyBmcm9tIDxTY3JvbGxSZXN0b3JhdGlvbiAvPiB1bnRpbCBfYWZ0ZXJfXG4gIC8vIHRoZSBpbml0aWFsIHJlbmRlciwgd2UgbmVlZCB0byBtYW51YWxseSB0cmlnZ2VyIGEgc2VwYXJhdGUgdXBkYXRlU3RhdGUgdG9cbiAgLy8gc2VuZCBhbG9uZyB0aGUgcmVzdG9yZVNjcm9sbFBvc2l0aW9uXG4gIC8vIFNldCB0byB0cnVlIGlmIHdlIGhhdmUgYGh5ZHJhdGlvbkRhdGFgIHNpbmNlIHdlIGFzc3VtZSB3ZSB3ZXJlIFNTUidkIGFuZCB0aGF0XG4gIC8vIFNTUiBkaWQgdGhlIGluaXRpYWwgc2Nyb2xsIHJlc3RvcmF0aW9uLlxuICBsZXQgaW5pdGlhbFNjcm9sbFJlc3RvcmVkID0gaW5pdC5oeWRyYXRpb25EYXRhICE9IG51bGw7XG5cbiAgbGV0IGluaXRpYWxNYXRjaGVzID0gbWF0Y2hSb3V0ZXMoXG4gICAgZGF0YVJvdXRlcyxcbiAgICBpbml0Lmhpc3RvcnkubG9jYXRpb24sXG4gICAgaW5pdC5iYXNlbmFtZVxuICApO1xuICBsZXQgaW5pdGlhbEVycm9yczogUm91dGVEYXRhIHwgbnVsbCA9IG51bGw7XG5cbiAgaWYgKGluaXRpYWxNYXRjaGVzID09IG51bGwpIHtcbiAgICAvLyBJZiB3ZSBkbyBub3QgbWF0Y2ggYSB1c2VyLXByb3ZpZGVkLXJvdXRlLCBmYWxsIGJhY2sgdG8gdGhlIHJvb3RcbiAgICAvLyB0byBhbGxvdyB0aGUgZXJyb3IgYm91bmRhcnkgdG8gdGFrZSBvdmVyXG4gICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgIHBhdGhuYW1lOiBpbml0Lmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWUsXG4gICAgfSk7XG4gICAgbGV0IHsgbWF0Y2hlcywgcm91dGUgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgaW5pdGlhbE1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGluaXRpYWxFcnJvcnMgPSB7IFtyb3V0ZS5pZF06IGVycm9yIH07XG4gIH1cblxuICBsZXQgaW5pdGlhbGl6ZWQgPVxuICAgICFpbml0aWFsTWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmxvYWRlcikgfHwgaW5pdC5oeWRyYXRpb25EYXRhICE9IG51bGw7XG5cbiAgbGV0IHJvdXRlcjogUm91dGVyO1xuICBsZXQgc3RhdGU6IFJvdXRlclN0YXRlID0ge1xuICAgIGhpc3RvcnlBY3Rpb246IGluaXQuaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGluaXQuaGlzdG9yeS5sb2NhdGlvbixcbiAgICBtYXRjaGVzOiBpbml0aWFsTWF0Y2hlcyxcbiAgICBpbml0aWFsaXplZCxcbiAgICBuYXZpZ2F0aW9uOiBJRExFX05BVklHQVRJT04sXG4gICAgLy8gRG9uJ3QgcmVzdG9yZSBvbiBpbml0aWFsIHVwZGF0ZVN0YXRlKCkgaWYgd2Ugd2VyZSBTU1InZFxuICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogaW5pdC5oeWRyYXRpb25EYXRhICE9IG51bGwgPyBmYWxzZSA6IG51bGwsXG4gICAgcHJldmVudFNjcm9sbFJlc2V0OiBmYWxzZSxcbiAgICByZXZhbGlkYXRpb246IFwiaWRsZVwiLFxuICAgIGxvYWRlckRhdGE6IChpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmxvYWRlckRhdGEpIHx8IHt9LFxuICAgIGFjdGlvbkRhdGE6IChpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmFjdGlvbkRhdGEpIHx8IG51bGwsXG4gICAgZXJyb3JzOiAoaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5lcnJvcnMpIHx8IGluaXRpYWxFcnJvcnMsXG4gICAgZmV0Y2hlcnM6IG5ldyBNYXAoKSxcbiAgICBibG9ja2VyczogbmV3IE1hcCgpLFxuICB9O1xuXG4gIC8vIC0tIFN0YXRlZnVsIGludGVybmFsIHZhcmlhYmxlcyB0byBtYW5hZ2UgbmF2aWdhdGlvbnMgLS1cbiAgLy8gQ3VycmVudCBuYXZpZ2F0aW9uIGluIHByb2dyZXNzICh0byBiZSBjb21taXR0ZWQgaW4gY29tcGxldGVOYXZpZ2F0aW9uKVxuICBsZXQgcGVuZGluZ0FjdGlvbjogSGlzdG9yeUFjdGlvbiA9IEhpc3RvcnlBY3Rpb24uUG9wO1xuXG4gIC8vIFNob3VsZCB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIHByZXZlbnQgdGhlIHNjcm9sbCByZXNldCBpZiBzY3JvbGwgY2Fubm90XG4gIC8vIGJlIHJlc3RvcmVkP1xuICBsZXQgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IGZhbHNlO1xuXG4gIC8vIEFib3J0Q29udHJvbGxlciBmb3IgdGhlIGFjdGl2ZSBuYXZpZ2F0aW9uXG4gIGxldCBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlciB8IG51bGw7XG5cbiAgLy8gV2UgdXNlIHRoaXMgdG8gYXZvaWQgdG91Y2hpbmcgaGlzdG9yeSBpbiBjb21wbGV0ZU5hdmlnYXRpb24gaWYgYVxuICAvLyByZXZhbGlkYXRpb24gaXMgZW50aXJlbHkgdW5pbnRlcnJ1cHRlZFxuICBsZXQgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG5cbiAgLy8gVXNlIHRoaXMgaW50ZXJuYWwgZmxhZyB0byBmb3JjZSByZXZhbGlkYXRpb24gb2YgYWxsIGxvYWRlcnM6XG4gIC8vICAtIHN1Ym1pc3Npb25zIChjb21wbGV0ZWQgb3IgaW50ZXJydXB0ZWQpXG4gIC8vICAtIHVzZVJldmFsaWRhdGUoKVxuICAvLyAgLSBYLVJlbWl4LVJldmFsaWRhdGUgKGZyb20gcmVkaXJlY3QpXG4gIGxldCBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG5cbiAgLy8gVXNlIHRoaXMgaW50ZXJuYWwgYXJyYXkgdG8gY2FwdHVyZSByb3V0ZXMgdGhhdCByZXF1aXJlIHJldmFsaWRhdGlvbiBkdWVcbiAgLy8gdG8gYSBjYW5jZWxsZWQgZGVmZXJyZWQgb24gYWN0aW9uIHN1Ym1pc3Npb25cbiAgbGV0IGNhbmNlbGxlZERlZmVycmVkUm91dGVzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8vIFVzZSB0aGlzIGludGVybmFsIGFycmF5IHRvIGNhcHR1cmUgZmV0Y2hlciBsb2FkcyB0aGF0IHdlcmUgY2FuY2VsbGVkIGJ5IGFuXG4gIC8vIGFjdGlvbiBuYXZpZ2F0aW9uIGFuZCByZXF1aXJlIHJldmFsaWRhdGlvblxuICBsZXQgY2FuY2VsbGVkRmV0Y2hlckxvYWRzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8vIEFib3J0Q29udHJvbGxlcnMgZm9yIGFueSBpbi1mbGlnaHQgZmV0Y2hlcnNcbiAgbGV0IGZldGNoQ29udHJvbGxlcnMgPSBuZXcgTWFwPHN0cmluZywgQWJvcnRDb250cm9sbGVyPigpO1xuXG4gIC8vIFRyYWNrIGxvYWRzIGJhc2VkIG9uIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHN0YXJ0ZWRcbiAgbGV0IGluY3JlbWVudGluZ0xvYWRJZCA9IDA7XG5cbiAgLy8gVHJhY2sgdGhlIG91dHN0YW5kaW5nIHBlbmRpbmcgbmF2aWdhdGlvbiBkYXRhIGxvYWQgdG8gYmUgY29tcGFyZWQgYWdhaW5zdFxuICAvLyB0aGUgZ2xvYmFsbHkgaW5jcmVtZW50aW5nIGxvYWQgd2hlbiBhIGZldGNoZXIgbG9hZCBsYW5kcyBhZnRlciBhIGNvbXBsZXRlZFxuICAvLyBuYXZpZ2F0aW9uXG4gIGxldCBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA9IC0xO1xuXG4gIC8vIEZldGNoZXJzIHRoYXQgdHJpZ2dlcmVkIGRhdGEgcmVsb2FkcyBhcyBhIHJlc3VsdCBvZiB0aGVpciBhY3Rpb25zXG4gIGxldCBmZXRjaFJlbG9hZElkcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG5cbiAgLy8gRmV0Y2hlcnMgdGhhdCB0cmlnZ2VyZWQgcmVkaXJlY3QgbmF2aWdhdGlvbnMgZnJvbSB0aGVpciBhY3Rpb25zXG4gIGxldCBmZXRjaFJlZGlyZWN0SWRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgLy8gTW9zdCByZWNlbnQgaHJlZi9tYXRjaCBmb3IgZmV0Y2hlci5sb2FkIGNhbGxzIGZvciBmZXRjaGVyc1xuICBsZXQgZmV0Y2hMb2FkTWF0Y2hlcyA9IG5ldyBNYXA8c3RyaW5nLCBGZXRjaExvYWRNYXRjaD4oKTtcblxuICAvLyBTdG9yZSBEZWZlcnJlZERhdGEgaW5zdGFuY2VzIGZvciBhY3RpdmUgcm91dGUgbWF0Y2hlcy4gIFdoZW4gYVxuICAvLyByb3V0ZSBsb2FkZXIgcmV0dXJucyBkZWZlcigpIHdlIHN0aWNrIG9uZSBpbiBoZXJlLiAgVGhlbiwgd2hlbiBhIG5lc3RlZFxuICAvLyBwcm9taXNlIHJlc29sdmVzIHdlIHVwZGF0ZSBsb2FkZXJEYXRhLiAgSWYgYSBuZXcgbmF2aWdhdGlvbiBzdGFydHMgd2VcbiAgLy8gY2FuY2VsIGFjdGl2ZSBkZWZlcnJlZHMgZm9yIGVsaW1pbmF0ZWQgcm91dGVzLlxuICBsZXQgYWN0aXZlRGVmZXJyZWRzID0gbmV3IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT4oKTtcblxuICAvLyBTdG9yZSBibG9ja2VyIGZ1bmN0aW9ucyBpbiBhIHNlcGFyYXRlIE1hcCBvdXRzaWRlIG9mIHJvdXRlciBzdGF0ZSBzaW5jZVxuICAvLyB3ZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSBVSSBzdGF0ZSBpZiB0aGV5IGNoYW5nZVxuICBsZXQgYmxvY2tlckZ1bmN0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBCbG9ja2VyRnVuY3Rpb24+KCk7XG5cbiAgLy8gRmxhZyB0byBpZ25vcmUgdGhlIG5leHQgaGlzdG9yeSB1cGRhdGUsIHNvIHdlIGNhbiByZXZlcnQgdGhlIFVSTCBjaGFuZ2Ugb25cbiAgLy8gYSBQT1AgbmF2aWdhdGlvbiB0aGF0IHdhcyBibG9ja2VkIGJ5IHRoZSB1c2VyIHdpdGhvdXQgdG91Y2hpbmcgcm91dGVyIHN0YXRlXG4gIGxldCBpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSA9IGZhbHNlO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIHJvdXRlciwgYWxsIHNpZGUgZWZmZWN0cyBzaG91bGQgYmUga2lja2VkIG9mZiBmcm9tIGhlcmUuXG4gIC8vIEltcGxlbWVudGVkIGFzIGEgRmx1ZW50IEFQSSBmb3IgZWFzZSBvZjpcbiAgLy8gICBsZXQgcm91dGVyID0gY3JlYXRlUm91dGVyKGluaXQpLmluaXRpYWxpemUoKTtcbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICAvLyBJZiBoaXN0b3J5IGluZm9ybXMgdXMgb2YgYSBQT1AgbmF2aWdhdGlvbiwgc3RhcnQgdGhlIG5hdmlnYXRpb24gYnV0IGRvIG5vdCB1cGRhdGVcbiAgICAvLyBzdGF0ZS4gIFdlJ2xsIHVwZGF0ZSBvdXIgb3duIHN0YXRlIG9uY2UgdGhlIG5hdmlnYXRpb24gY29tcGxldGVzXG4gICAgdW5saXN0ZW5IaXN0b3J5ID0gaW5pdC5oaXN0b3J5Lmxpc3RlbihcbiAgICAgICh7IGFjdGlvbjogaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24sIGRlbHRhIH0pID0+IHtcbiAgICAgICAgLy8gSWdub3JlIHRoaXMgZXZlbnQgaWYgaXQgd2FzIGp1c3QgdXMgcmVzZXR0aW5nIHRoZSBVUkwgZnJvbSBhXG4gICAgICAgIC8vIGJsb2NrZWQgUE9QIG5hdmlnYXRpb25cbiAgICAgICAgaWYgKGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlKSB7XG4gICAgICAgICAgaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA9PT0gMCB8fCBkZWx0YSAhPSBudWxsLFxuICAgICAgICAgIFwiWW91IGFyZSB0cnlpbmcgdG8gdXNlIGEgYmxvY2tlciBvbiBhIFBPUCBuYXZpZ2F0aW9uIHRvIGEgbG9jYXRpb24gXCIgK1xuICAgICAgICAgICAgXCJ0aGF0IHdhcyBub3QgY3JlYXRlZCBieSBAcmVtaXgtcnVuL3JvdXRlci4gVGhpcyB3aWxsIGZhaWwgc2lsZW50bHkgaW4gXCIgK1xuICAgICAgICAgICAgXCJwcm9kdWN0aW9uLiBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IGFyZSBuYXZpZ2F0aW5nIG91dHNpZGUgdGhlIHJvdXRlciBcIiArXG4gICAgICAgICAgICBcInZpYSBgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlYC9gd2luZG93LmxvY2F0aW9uLmhhc2hgIGluc3RlYWQgb2YgdXNpbmcgXCIgK1xuICAgICAgICAgICAgXCJyb3V0ZXIgbmF2aWdhdGlvbiBBUElzLiAgVGhpcyBjYW4gYWxzbyBoYXBwZW4gaWYgeW91IGFyZSB1c2luZyBcIiArXG4gICAgICAgICAgICBcImNyZWF0ZUhhc2hSb3V0ZXIgYW5kIHRoZSB1c2VyIG1hbnVhbGx5IGNoYW5nZXMgdGhlIFVSTC5cIlxuICAgICAgICApO1xuXG4gICAgICAgIGxldCBibG9ja2VyS2V5ID0gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKHtcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgaGlzdG9yeUFjdGlvbixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGJsb2NrZXJLZXkgJiYgZGVsdGEgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIFVSTCB0byBtYXRjaCB0aGUgY3VycmVudCBVSSwgYnV0IGRvbid0IHVwZGF0ZSByb3V0ZXIgc3RhdGVcbiAgICAgICAgICBpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgaW5pdC5oaXN0b3J5LmdvKGRlbHRhICogLTEpO1xuXG4gICAgICAgICAgLy8gUHV0IHRoZSBibG9ja2VyIGludG8gYSBibG9ja2VkIHN0YXRlXG4gICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XG4gICAgICAgICAgICBzdGF0ZTogXCJibG9ja2VkXCIsXG4gICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgIHByb2NlZWQoKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSEsIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJwcm9jZWVkaW5nXCIsXG4gICAgICAgICAgICAgICAgcHJvY2VlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHJlc2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAvLyBSZS1kbyB0aGUgc2FtZSBQT1AgbmF2aWdhdGlvbiB3ZSBqdXN0IGJsb2NrZWRcbiAgICAgICAgICAgICAgaW5pdC5oaXN0b3J5LmdvKGRlbHRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgICAgZGVsZXRlQmxvY2tlcihibG9ja2VyS2V5ISk7XG4gICAgICAgICAgICAgIHVwZGF0ZVN0YXRlKHsgYmxvY2tlcnM6IG5ldyBNYXAocm91dGVyLnN0YXRlLmJsb2NrZXJzKSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXJ0TmF2aWdhdGlvbihoaXN0b3J5QWN0aW9uLCBsb2NhdGlvbik7XG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIEtpY2sgb2ZmIGluaXRpYWwgZGF0YSBsb2FkIGlmIG5lZWRlZC4gIFVzZSBQb3AgdG8gYXZvaWQgbW9kaWZ5aW5nIGhpc3RvcnlcbiAgICBpZiAoIXN0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgICBzdGFydE5hdmlnYXRpb24oSGlzdG9yeUFjdGlvbi5Qb3AsIHN0YXRlLmxvY2F0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm91dGVyO1xuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYSByb3V0ZXIgYW5kIGl0J3Mgc2lkZSBlZmZlY3RzXG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHVubGlzdGVuSGlzdG9yeSkge1xuICAgICAgdW5saXN0ZW5IaXN0b3J5KCk7XG4gICAgfVxuICAgIHN1YnNjcmliZXJzLmNsZWFyKCk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgIHN0YXRlLmZldGNoZXJzLmZvckVhY2goKF8sIGtleSkgPT4gZGVsZXRlRmV0Y2hlcihrZXkpKTtcbiAgICBzdGF0ZS5ibG9ja2Vycy5mb3JFYWNoKChfLCBrZXkpID0+IGRlbGV0ZUJsb2NrZXIoa2V5KSk7XG4gIH1cblxuICAvLyBTdWJzY3JpYmUgdG8gc3RhdGUgdXBkYXRlcyBmb3IgdGhlIHJvdXRlclxuICBmdW5jdGlvbiBzdWJzY3JpYmUoZm46IFJvdXRlclN1YnNjcmliZXIpIHtcbiAgICBzdWJzY3JpYmVycy5hZGQoZm4pO1xuICAgIHJldHVybiAoKSA9PiBzdWJzY3JpYmVycy5kZWxldGUoZm4pO1xuICB9XG5cbiAgLy8gVXBkYXRlIG91ciBzdGF0ZSBhbmQgbm90aWZ5IHRoZSBjYWxsaW5nIGNvbnRleHQgb2YgdGhlIGNoYW5nZVxuICBmdW5jdGlvbiB1cGRhdGVTdGF0ZShuZXdTdGF0ZTogUGFydGlhbDxSb3V0ZXJTdGF0ZT4pOiB2b2lkIHtcbiAgICBzdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgLi4ubmV3U3RhdGUsXG4gICAgfTtcbiAgICBzdWJzY3JpYmVycy5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiBzdWJzY3JpYmVyKHN0YXRlKSk7XG4gIH1cblxuICAvLyBDb21wbGV0ZSBhIG5hdmlnYXRpb24gcmV0dXJuaW5nIHRoZSBzdGF0ZS5uYXZpZ2F0aW9uIGJhY2sgdG8gdGhlIElETEVfTkFWSUdBVElPTlxuICAvLyBhbmQgc2V0dGluZyBzdGF0ZS5baGlzdG9yeUFjdGlvbi9sb2NhdGlvbi9tYXRjaGVzXSB0byB0aGUgbmV3IHJvdXRlLlxuICAvLyAtIExvY2F0aW9uIGlzIGEgcmVxdWlyZWQgcGFyYW1cbiAgLy8gLSBOYXZpZ2F0aW9uIHdpbGwgYWx3YXlzIGJlIHNldCB0byBJRExFX05BVklHQVRJT05cbiAgLy8gLSBDYW4gcGFzcyBhbnkgb3RoZXIgc3RhdGUgaW4gbmV3U3RhdGVcbiAgZnVuY3Rpb24gY29tcGxldGVOYXZpZ2F0aW9uKFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBuZXdTdGF0ZTogUGFydGlhbDxPbWl0PFJvdXRlclN0YXRlLCBcImFjdGlvblwiIHwgXCJsb2NhdGlvblwiIHwgXCJuYXZpZ2F0aW9uXCI+PlxuICApOiB2b2lkIHtcbiAgICAvLyBEZWR1Y2UgaWYgd2UncmUgaW4gYSBsb2FkaW5nL2FjdGlvblJlbG9hZCBzdGF0ZTpcbiAgICAvLyAtIFdlIGhhdmUgY29tbWl0dGVkIGFjdGlvbkRhdGEgaW4gdGhlIHN0b3JlXG4gICAgLy8gLSBUaGUgY3VycmVudCBuYXZpZ2F0aW9uIHdhcyBhIG11dGF0aW9uIHN1Ym1pc3Npb25cbiAgICAvLyAtIFdlJ3JlIHBhc3QgdGhlIHN1Ym1pdHRpbmcgc3RhdGUgYW5kIGludG8gdGhlIGxvYWRpbmcgc3RhdGVcbiAgICAvLyAtIFRoZSBsb2NhdGlvbiBiZWluZyBsb2FkZWQgaXMgbm90IHRoZSByZXN1bHQgb2YgYSByZWRpcmVjdFxuICAgIGxldCBpc0FjdGlvblJlbG9hZCA9XG4gICAgICBzdGF0ZS5hY3Rpb25EYXRhICE9IG51bGwgJiZcbiAgICAgIHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCAhPSBudWxsICYmXG4gICAgICBpc011dGF0aW9uTWV0aG9kKHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCkgJiZcbiAgICAgIHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmXG4gICAgICBsb2NhdGlvbi5zdGF0ZT8uX2lzUmVkaXJlY3QgIT09IHRydWU7XG5cbiAgICBsZXQgYWN0aW9uRGF0YTogUm91dGVEYXRhIHwgbnVsbDtcbiAgICBpZiAobmV3U3RhdGUuYWN0aW9uRGF0YSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKG5ld1N0YXRlLmFjdGlvbkRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYWN0aW9uRGF0YSA9IG5ld1N0YXRlLmFjdGlvbkRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFbXB0eSBhY3Rpb25EYXRhIC0+IGNsZWFyIHByaW9yIGFjdGlvbkRhdGEgZHVlIHRvIGFuIGFjdGlvbiBlcnJvclxuICAgICAgICBhY3Rpb25EYXRhID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQWN0aW9uUmVsb2FkKSB7XG4gICAgICAvLyBLZWVwIHRoZSBjdXJyZW50IGRhdGEgaWYgd2UncmUgd3JhcHBpbmcgdXAgdGhlIGFjdGlvbiByZWxvYWRcbiAgICAgIGFjdGlvbkRhdGEgPSBzdGF0ZS5hY3Rpb25EYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDbGVhciBhY3Rpb25EYXRhIG9uIGFueSBvdGhlciBjb21wbGV0ZWQgbmF2aWdhdGlvbnNcbiAgICAgIGFjdGlvbkRhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyBwcmVzZXJ2ZSBhbnkgZXhpc3RpbmcgbG9hZGVyRGF0YSBmcm9tIHJlLXVzZWQgcm91dGVzXG4gICAgbGV0IGxvYWRlckRhdGEgPSBuZXdTdGF0ZS5sb2FkZXJEYXRhXG4gICAgICA/IG1lcmdlTG9hZGVyRGF0YShcbiAgICAgICAgICBzdGF0ZS5sb2FkZXJEYXRhLFxuICAgICAgICAgIG5ld1N0YXRlLmxvYWRlckRhdGEsXG4gICAgICAgICAgbmV3U3RhdGUubWF0Y2hlcyB8fCBbXSxcbiAgICAgICAgICBuZXdTdGF0ZS5lcnJvcnNcbiAgICAgICAgKVxuICAgICAgOiBzdGF0ZS5sb2FkZXJEYXRhO1xuXG4gICAgLy8gT24gYSBzdWNjZXNzZnVsIG5hdmlnYXRpb24gd2UgY2FuIGFzc3VtZSB3ZSBnb3QgdGhyb3VnaCBhbGwgYmxvY2tlcnNcbiAgICAvLyBzbyB3ZSBjYW4gc3RhcnQgZnJlc2hcbiAgICBmb3IgKGxldCBba2V5XSBvZiBibG9ja2VyRnVuY3Rpb25zKSB7XG4gICAgICBkZWxldGVCbG9ja2VyKGtleSk7XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIHJlc3BlY3QgdGhlIHVzZXIgZmxhZy4gIE90aGVyd2lzZSBkb24ndCByZXNldCBvbiBtdXRhdGlvblxuICAgIC8vIHN1Ym1pc3Npb24gbmF2aWdhdGlvbnMgdW5sZXNzIHRoZXkgcmVkaXJlY3RcbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID1cbiAgICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWUgfHxcbiAgICAgIChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QgIT0gbnVsbCAmJlxuICAgICAgICBpc011dGF0aW9uTWV0aG9kKHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCkgJiZcbiAgICAgICAgbG9jYXRpb24uc3RhdGU/Ll9pc1JlZGlyZWN0ICE9PSB0cnVlKTtcblxuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIC4uLm5ld1N0YXRlLCAvLyBtYXRjaGVzLCBlcnJvcnMsIGZldGNoZXJzIGdvIHRocm91Z2ggYXMtaXNcbiAgICAgIGFjdGlvbkRhdGEsXG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgaGlzdG9yeUFjdGlvbjogcGVuZGluZ0FjdGlvbixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgaW5pdGlhbGl6ZWQ6IHRydWUsXG4gICAgICBuYXZpZ2F0aW9uOiBJRExFX05BVklHQVRJT04sXG4gICAgICByZXZhbGlkYXRpb246IFwiaWRsZVwiLFxuICAgICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbmV3U3RhdGUubWF0Y2hlcyB8fCBzdGF0ZS5tYXRjaGVzXG4gICAgICApLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgYmxvY2tlcnM6IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpLFxuICAgIH0pO1xuXG4gICAgaWYgKGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikge1xuICAgICAgLy8gSWYgdGhpcyB3YXMgYW4gdW5pbnRlcnJ1cHRlZCByZXZhbGlkYXRpb24gdGhlbiBkbyBub3QgdG91Y2ggaGlzdG9yeVxuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gSGlzdG9yeUFjdGlvbi5Qb3ApIHtcbiAgICAgIC8vIERvIG5vdGhpbmcgZm9yIFBPUCAtIFVSTCBoYXMgYWxyZWFkeSBiZWVuIHVwZGF0ZWRcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEhpc3RvcnlBY3Rpb24uUHVzaCkge1xuICAgICAgaW5pdC5oaXN0b3J5LnB1c2gobG9jYXRpb24sIGxvY2F0aW9uLnN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEhpc3RvcnlBY3Rpb24uUmVwbGFjZSkge1xuICAgICAgaW5pdC5oaXN0b3J5LnJlcGxhY2UobG9jYXRpb24sIGxvY2F0aW9uLnN0YXRlKTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBzdGF0ZWZ1bCBuYXZpZ2F0aW9uIHZhcnNcbiAgICBwZW5kaW5nQWN0aW9uID0gSGlzdG9yeUFjdGlvbi5Qb3A7XG4gICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IGZhbHNlO1xuICAgIGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IGZhbHNlO1xuICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcyA9IFtdO1xuICAgIGNhbmNlbGxlZEZldGNoZXJMb2FkcyA9IFtdO1xuICB9XG5cbiAgLy8gVHJpZ2dlciBhIG5hdmlnYXRpb24gZXZlbnQsIHdoaWNoIGNhbiBlaXRoZXIgYmUgYSBudW1lcmljYWwgUE9QIG9yIGEgUFVTSFxuICAvLyByZXBsYWNlIHdpdGggYW4gb3B0aW9uYWwgc3VibWlzc2lvblxuICBhc3luYyBmdW5jdGlvbiBuYXZpZ2F0ZShcbiAgICB0bzogbnVtYmVyIHwgVG8sXG4gICAgb3B0cz86IFJvdXRlck5hdmlnYXRlT3B0aW9uc1xuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpbml0Lmhpc3RvcnkuZ28odG8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB7IHBhdGgsIHN1Ym1pc3Npb24sIGVycm9yIH0gPSBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnModG8sIG9wdHMpO1xuXG4gICAgbGV0IGN1cnJlbnRMb2NhdGlvbiA9IHN0YXRlLmxvY2F0aW9uO1xuICAgIGxldCBuZXh0TG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihzdGF0ZS5sb2NhdGlvbiwgcGF0aCwgb3B0cyAmJiBvcHRzLnN0YXRlKTtcblxuICAgIC8vIFdoZW4gdXNpbmcgbmF2aWdhdGUgYXMgYSBQVVNIL1JFUExBQ0Ugd2UgYXJlbid0IHJlYWRpbmcgYW4gYWxyZWFkeS1lbmNvZGVkXG4gICAgLy8gVVJMIGZyb20gd2luZG93LmxvY2F0aW9uLCBzbyB3ZSBuZWVkIHRvIGVuY29kZSBpdCBoZXJlIHNvIHRoZSBiZWhhdmlvclxuICAgIC8vIHJlbWFpbnMgdGhlIHNhbWUgYXMgUE9QIGFuZCBub24tZGF0YS1yb3V0ZXIgdXNhZ2VzLiAgbmV3IFVSTCgpIGRvZXMgYWxsXG4gICAgLy8gdGhlIHNhbWUgZW5jb2Rpbmcgd2UnZCBnZXQgZnJvbSBhIGhpc3RvcnkucHVzaFN0YXRlL3dpbmRvdy5sb2NhdGlvbiByZWFkXG4gICAgLy8gd2l0aG91dCBoYXZpbmcgdG8gdG91Y2ggaGlzdG9yeVxuICAgIG5leHRMb2NhdGlvbiA9IHtcbiAgICAgIC4uLm5leHRMb2NhdGlvbixcbiAgICAgIC4uLmluaXQuaGlzdG9yeS5lbmNvZGVMb2NhdGlvbihuZXh0TG9jYXRpb24pLFxuICAgIH07XG5cbiAgICBsZXQgdXNlclJlcGxhY2UgPSBvcHRzICYmIG9wdHMucmVwbGFjZSAhPSBudWxsID8gb3B0cy5yZXBsYWNlIDogdW5kZWZpbmVkO1xuXG4gICAgbGV0IGhpc3RvcnlBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlB1c2g7XG5cbiAgICBpZiAodXNlclJlcGxhY2UgPT09IHRydWUpIHtcbiAgICAgIGhpc3RvcnlBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlJlcGxhY2U7XG4gICAgfSBlbHNlIGlmICh1c2VyUmVwbGFjZSA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIG5vLW9wXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHN1Ym1pc3Npb24gIT0gbnVsbCAmJlxuICAgICAgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpICYmXG4gICAgICBzdWJtaXNzaW9uLmZvcm1BY3Rpb24gPT09IHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lICsgc3RhdGUubG9jYXRpb24uc2VhcmNoXG4gICAgKSB7XG4gICAgICAvLyBCeSBkZWZhdWx0IG9uIHN1Ym1pc3Npb25zIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uIHdlIFJFUExBQ0Ugc28gdGhhdFxuICAgICAgLy8gdXNlcnMgZG9uJ3QgaGF2ZSB0byBkb3VibGUtY2xpY2sgdGhlIGJhY2sgYnV0dG9uIHRvIGdldCB0byB0aGUgcHJpb3JcbiAgICAgIC8vIGxvY2F0aW9uLiAgSWYgdGhlIHVzZXIgcmVkaXJlY3RzIHRvIGEgZGlmZmVyZW50IGxvY2F0aW9uIGZyb20gdGhlXG4gICAgICAvLyBhY3Rpb24vbG9hZGVyIHRoaXMgd2lsbCBiZSBpZ25vcmVkIGFuZCB0aGUgcmVkaXJlY3Qgd2lsbCBiZSBhIFBVU0hcbiAgICAgIGhpc3RvcnlBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlJlcGxhY2U7XG4gICAgfVxuXG4gICAgbGV0IHByZXZlbnRTY3JvbGxSZXNldCA9XG4gICAgICBvcHRzICYmIFwicHJldmVudFNjcm9sbFJlc2V0XCIgaW4gb3B0c1xuICAgICAgICA/IG9wdHMucHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgbGV0IGJsb2NrZXJLZXkgPSBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgICAgY3VycmVudExvY2F0aW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgaGlzdG9yeUFjdGlvbixcbiAgICB9KTtcbiAgICBpZiAoYmxvY2tlcktleSkge1xuICAgICAgLy8gUHV0IHRoZSBibG9ja2VyIGludG8gYSBibG9ja2VkIHN0YXRlXG4gICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgc3RhdGU6IFwiYmxvY2tlZFwiLFxuICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICBwcm9jZWVkKCkge1xuICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSEsIHtcbiAgICAgICAgICAgIHN0YXRlOiBcInByb2NlZWRpbmdcIixcbiAgICAgICAgICAgIHByb2NlZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlc2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIFNlbmQgdGhlIHNhbWUgbmF2aWdhdGlvbiB0aHJvdWdoXG4gICAgICAgICAgbmF2aWdhdGUodG8sIG9wdHMpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICBkZWxldGVCbG9ja2VyKGJsb2NrZXJLZXkhKTtcbiAgICAgICAgICB1cGRhdGVTdGF0ZSh7IGJsb2NrZXJzOiBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKSB9KTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbmV4dExvY2F0aW9uLCB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgLy8gU2VuZCB0aHJvdWdoIHRoZSBmb3JtRGF0YSBzZXJpYWxpemF0aW9uIGVycm9yIGlmIHdlIGhhdmUgb25lIHNvIHdlIGNhblxuICAgICAgLy8gcmVuZGVyIGF0IHRoZSByaWdodCBlcnJvciBib3VuZGFyeSBhZnRlciB3ZSBtYXRjaCByb3V0ZXNcbiAgICAgIHBlbmRpbmdFcnJvcjogZXJyb3IsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZXBsYWNlOiBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFJldmFsaWRhdGUgYWxsIGN1cnJlbnQgbG9hZGVycy4gIElmIGEgbmF2aWdhdGlvbiBpcyBpbiBwcm9ncmVzcyBvciBpZiB0aGlzXG4gIC8vIGlzIGludGVycnVwdGVkIGJ5IGEgbmF2aWdhdGlvbiwgYWxsb3cgdGhpcyB0byBcInN1Y2NlZWRcIiBieSBjYWxsaW5nIGFsbFxuICAvLyBsb2FkZXJzIGR1cmluZyB0aGUgbmV4dCBsb2FkZXIgcm91bmRcbiAgZnVuY3Rpb24gcmV2YWxpZGF0ZSgpIHtcbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIHVwZGF0ZVN0YXRlKHsgcmV2YWxpZGF0aW9uOiBcImxvYWRpbmdcIiB9KTtcblxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBzdWJtaXR0aW5nIGFuIGFjdGlvbiwgd2UgZG9uJ3QgbmVlZCB0byBzdGFydCBhIG5ld1xuICAgIC8vIG5hdmlnYXRpb24sIHdlJ2xsIGp1c3QgbGV0IHRoZSBmb2xsb3cgdXAgbG9hZGVyIGV4ZWN1dGlvbiBjYWxsIGFsbCBsb2FkZXJzXG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwic3VibWl0dGluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGluIGFuIGlkbGUgc3RhdGUsIHN0YXJ0IGEgbmV3IG5hdmlnYXRpb24gZm9yIHRoZSBjdXJyZW50XG4gICAgLy8gYWN0aW9uL2xvY2F0aW9uIGFuZCBtYXJrIGl0IGFzIHVuaW50ZXJydXB0ZWQsIHdoaWNoIHdpbGwgc2tpcCB0aGUgaGlzdG9yeVxuICAgIC8vIHVwZGF0ZSBpbiBjb21wbGV0ZU5hdmlnYXRpb25cbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihzdGF0ZS5oaXN0b3J5QWN0aW9uLCBzdGF0ZS5sb2NhdGlvbiwge1xuICAgICAgICBzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb246IHRydWUsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGlmIHdlJ3JlIGN1cnJlbnRseSBpbiBhIGxvYWRpbmcgc3RhdGUsIGp1c3Qgc3RhcnQgYSBuZXdcbiAgICAvLyBuYXZpZ2F0aW9uIHRvIHRoZSBuYXZpZ2F0aW9uLmxvY2F0aW9uIGJ1dCBkbyBub3QgdHJpZ2dlciBhbiB1bmludGVycnVwdGVkXG4gICAgLy8gcmV2YWxpZGF0aW9uIHNvIHRoYXQgaGlzdG9yeSBjb3JyZWN0bHkgdXBkYXRlcyBvbmNlIHRoZSBuYXZpZ2F0aW9uIGNvbXBsZXRlc1xuICAgIHN0YXJ0TmF2aWdhdGlvbihcbiAgICAgIHBlbmRpbmdBY3Rpb24gfHwgc3RhdGUuaGlzdG9yeUFjdGlvbixcbiAgICAgIHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sXG4gICAgICB7IG92ZXJyaWRlTmF2aWdhdGlvbjogc3RhdGUubmF2aWdhdGlvbiB9XG4gICAgKTtcbiAgfVxuXG4gIC8vIFN0YXJ0IGEgbmF2aWdhdGlvbiB0byB0aGUgZ2l2ZW4gYWN0aW9uL2xvY2F0aW9uLiAgQ2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhXG4gIC8vIG92ZXJyaWRlTmF2aWdhdGlvbiB3aGljaCB3aWxsIG92ZXJyaWRlIHRoZSBub3JtYWxMb2FkIGluIHRoZSBjYXNlIG9mIGEgcmVkaXJlY3RcbiAgLy8gbmF2aWdhdGlvblxuICBhc3luYyBmdW5jdGlvbiBzdGFydE5hdmlnYXRpb24oXG4gICAgaGlzdG9yeUFjdGlvbjogSGlzdG9yeUFjdGlvbixcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgb3B0cz86IHtcbiAgICAgIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uO1xuICAgICAgb3ZlcnJpZGVOYXZpZ2F0aW9uPzogTmF2aWdhdGlvbjtcbiAgICAgIHBlbmRpbmdFcnJvcj86IEVycm9yUmVzcG9uc2U7XG4gICAgICBzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24/OiBib29sZWFuO1xuICAgICAgcHJldmVudFNjcm9sbFJlc2V0PzogYm9vbGVhbjtcbiAgICAgIHJlcGxhY2U/OiBib29sZWFuO1xuICAgIH1cbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gQWJvcnQgYW55IGluLXByb2dyZXNzIG5hdmlnYXRpb25zIGFuZCBzdGFydCBhIG5ldyBvbmUuIFVuc2V0IGFueSBvbmdvaW5nXG4gICAgLy8gdW5pbnRlcnJ1cHRlZCByZXZhbGlkYXRpb25zIHVubGVzcyB0b2xkIG90aGVyd2lzZSwgc2luY2Ugd2Ugd2FudCB0aGlzXG4gICAgLy8gbmV3IG5hdmlnYXRpb24gdG8gdXBkYXRlIGhpc3Rvcnkgbm9ybWFsbHlcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcbiAgICBwZW5kaW5nQWN0aW9uID0gaGlzdG9yeUFjdGlvbjtcbiAgICBpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gPVxuICAgICAgKG9wdHMgJiYgb3B0cy5zdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24pID09PSB0cnVlO1xuXG4gICAgLy8gU2F2ZSB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gZXZlcnkgdGltZSB3ZSBzdGFydCBhIG5ldyBuYXZpZ2F0aW9uLFxuICAgIC8vIGFuZCB0cmFjayB3aGV0aGVyIHdlIHNob3VsZCByZXNldCBzY3JvbGwgb24gY29tcGxldGlvblxuICAgIHNhdmVTY3JvbGxQb3NpdGlvbihzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcyk7XG4gICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IChvcHRzICYmIG9wdHMucHJldmVudFNjcm9sbFJlc2V0KSA9PT0gdHJ1ZTtcblxuICAgIGxldCBsb2FkaW5nTmF2aWdhdGlvbiA9IG9wdHMgJiYgb3B0cy5vdmVycmlkZU5hdmlnYXRpb247XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgaW5pdC5iYXNlbmFtZSk7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IHdpdGggYSA0MDQgb24gdGhlIHJvb3QgZXJyb3IgYm91bmRhcnkgaWYgd2UgbWF0Y2ggbm90aGluZ1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lIH0pO1xuICAgICAgbGV0IHsgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLCByb3V0ZSB9ID1cbiAgICAgICAgZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICAgIC8vIENhbmNlbCBhbGwgcGVuZGluZyBkZWZlcnJlZCBvbiA0MDRzIHNpbmNlIHdlIGRvbid0IGtlZXAgYW55IHJvdXRlc1xuICAgICAgY2FuY2VsQWN0aXZlRGVmZXJyZWRzKCk7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHtcbiAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3IsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIGl0J3Mgb25seSBhIGhhc2ggY2hhbmdlIGFuZCBub3QgYSBtdXRhdGlvbiBzdWJtaXNzaW9uXG4gICAgLy8gRm9yIGV4YW1wbGUsIG9uIC9wYWdlI2hhc2ggYW5kIHN1Ym1pdCBhIDxGb3JtIG1ldGhvZD1cInBvc3RcIj4gd2hpY2ggd2lsbFxuICAgIC8vIGRlZmF1bHQgdG8gYSBuYXZpZ2F0aW9uIHRvIC9wYWdlXG4gICAgaWYgKFxuICAgICAgaXNIYXNoQ2hhbmdlT25seShzdGF0ZS5sb2NhdGlvbiwgbG9jYXRpb24pICYmXG4gICAgICAhKG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpKVxuICAgICkge1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7IG1hdGNoZXMgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgY29udHJvbGxlci9SZXF1ZXN0IGZvciB0aGlzIG5hdmlnYXRpb25cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IHJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLnNpZ25hbCxcbiAgICAgIG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uXG4gICAgKTtcbiAgICBsZXQgcGVuZGluZ0FjdGlvbkRhdGE6IFJvdXRlRGF0YSB8IHVuZGVmaW5lZDtcbiAgICBsZXQgcGVuZGluZ0Vycm9yOiBSb3V0ZURhdGEgfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAob3B0cyAmJiBvcHRzLnBlbmRpbmdFcnJvcikge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBlbmRpbmdFcnJvciwgaXQgbWVhbnMgdGhlIHVzZXIgYXR0ZW1wdGVkIGEgR0VUIHN1Ym1pc3Npb25cbiAgICAgIC8vIHdpdGggYmluYXJ5IEZvcm1EYXRhIHNvIGFzc2lnbiBoZXJlIGFuZCBza2lwIHRvIGhhbmRsZUxvYWRlcnMuICBUaGF0XG4gICAgICAvLyB3YXkgd2UgaGFuZGxlIGNhbGxpbmcgbG9hZGVycyBhYm92ZSB0aGUgYm91bmRhcnkgZXRjLiAgSXQncyBub3QgcmVhbGx5XG4gICAgICAvLyBkaWZmZXJlbnQgZnJvbSBhbiBhY3Rpb25FcnJvciBpbiB0aGF0IHNlbnNlLlxuICAgICAgcGVuZGluZ0Vycm9yID0ge1xuICAgICAgICBbZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzKS5yb3V0ZS5pZF06IG9wdHMucGVuZGluZ0Vycm9yLFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgb3B0cyAmJlxuICAgICAgb3B0cy5zdWJtaXNzaW9uICYmXG4gICAgICBpc011dGF0aW9uTWV0aG9kKG9wdHMuc3VibWlzc2lvbi5mb3JtTWV0aG9kKVxuICAgICkge1xuICAgICAgLy8gQ2FsbCBhY3Rpb24gaWYgd2UgcmVjZWl2ZWQgYW4gYWN0aW9uIHN1Ym1pc3Npb25cbiAgICAgIGxldCBhY3Rpb25PdXRwdXQgPSBhd2FpdCBoYW5kbGVBY3Rpb24oXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBvcHRzLnN1Ym1pc3Npb24sXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHsgcmVwbGFjZTogb3B0cy5yZXBsYWNlIH1cbiAgICAgICk7XG5cbiAgICAgIGlmIChhY3Rpb25PdXRwdXQuc2hvcnRDaXJjdWl0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwZW5kaW5nQWN0aW9uRGF0YSA9IGFjdGlvbk91dHB1dC5wZW5kaW5nQWN0aW9uRGF0YTtcbiAgICAgIHBlbmRpbmdFcnJvciA9IGFjdGlvbk91dHB1dC5wZW5kaW5nQWN0aW9uRXJyb3I7XG5cbiAgICAgIGxldCBuYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgLi4ub3B0cy5zdWJtaXNzaW9uLFxuICAgICAgfTtcbiAgICAgIGxvYWRpbmdOYXZpZ2F0aW9uID0gbmF2aWdhdGlvbjtcblxuICAgICAgLy8gQ3JlYXRlIGEgR0VUIHJlcXVlc3QgZm9yIHRoZSBsb2FkZXJzXG4gICAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QocmVxdWVzdC51cmwsIHsgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbCB9KTtcbiAgICB9XG5cbiAgICAvLyBDYWxsIGxvYWRlcnNcbiAgICBsZXQgeyBzaG9ydENpcmN1aXRlZCwgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBhd2FpdCBoYW5kbGVMb2FkZXJzKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGxvYWRpbmdOYXZpZ2F0aW9uLFxuICAgICAgb3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24sXG4gICAgICBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICAgIHBlbmRpbmdBY3Rpb25EYXRhLFxuICAgICAgcGVuZGluZ0Vycm9yXG4gICAgKTtcblxuICAgIGlmIChzaG9ydENpcmN1aXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIG5vdyB0aGF0IHRoZSBhY3Rpb24vbG9hZGVycyBoYXZlIGNvbXBsZXRlZC4gIERvbid0IGNsZWFuIHVwIGlmXG4gICAgLy8gd2Ugc2hvcnQgY2lyY3VpdGVkIGJlY2F1c2UgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyIHdpbGwgaGF2ZSBhbHJlYWR5XG4gICAgLy8gYmVlbiBhc3NpZ25lZCB0byBhIG5ldyBjb250cm9sbGVyIGZvciB0aGUgbmV4dCBuYXZpZ2F0aW9uXG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcblxuICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwge1xuICAgICAgbWF0Y2hlcyxcbiAgICAgIC4uLihwZW5kaW5nQWN0aW9uRGF0YSA/IHsgYWN0aW9uRGF0YTogcGVuZGluZ0FjdGlvbkRhdGEgfSA6IHt9KSxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnMsXG4gICAgfSk7XG4gIH1cblxuICAvLyBDYWxsIHRoZSBhY3Rpb24gbWF0Y2hlZCBieSB0aGUgbGVhZiByb3V0ZSBmb3IgdGhpcyBuYXZpZ2F0aW9uIGFuZCBoYW5kbGVcbiAgLy8gcmVkaXJlY3RzL2Vycm9yc1xuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBY3Rpb24oXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgc3VibWlzc2lvbjogU3VibWlzc2lvbixcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgb3B0cz86IHsgcmVwbGFjZT86IGJvb2xlYW4gfVxuICApOiBQcm9taXNlPEhhbmRsZUFjdGlvblJlc3VsdD4ge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG5cbiAgICAvLyBQdXQgdXMgaW4gYSBzdWJtaXR0aW5nIHN0YXRlXG4gICAgbGV0IG5hdmlnYXRpb246IE5hdmlnYXRpb25TdGF0ZXNbXCJTdWJtaXR0aW5nXCJdID0ge1xuICAgICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgICAgbG9jYXRpb24sXG4gICAgICAuLi5zdWJtaXNzaW9uLFxuICAgIH07XG4gICAgdXBkYXRlU3RhdGUoeyBuYXZpZ2F0aW9uIH0pO1xuXG4gICAgLy8gQ2FsbCBvdXIgYWN0aW9uIGFuZCBnZXQgdGhlIHJlc3VsdFxuICAgIGxldCByZXN1bHQ6IERhdGFSZXN1bHQ7XG4gICAgbGV0IGFjdGlvbk1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pO1xuXG4gICAgaWYgKCFhY3Rpb25NYXRjaC5yb3V0ZS5hY3Rpb24pIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgICAgcm91dGVJZDogYWN0aW9uTWF0Y2gucm91dGUuaWQsXG4gICAgICAgIH0pLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgICBcImFjdGlvblwiLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBhY3Rpb25NYXRjaCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcm91dGVyLmJhc2VuYW1lXG4gICAgICApO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCByZXBsYWNlOiBib29sZWFuO1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy5yZXBsYWNlICE9IG51bGwpIHtcbiAgICAgICAgcmVwbGFjZSA9IG9wdHMucmVwbGFjZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGRpZG4ndCBleHBsaWNpdHkgaW5kaWNhdGUgcmVwbGFjZSBiZWhhdmlvciwgcmVwbGFjZSBpZlxuICAgICAgICAvLyB3ZSByZWRpcmVjdGVkIHRvIHRoZSBleGFjdCBzYW1lIGxvY2F0aW9uIHdlJ3JlIGN1cnJlbnRseSBhdCB0byBhdm9pZFxuICAgICAgICAvLyBkb3VibGUgYmFjay1idXR0b25zXG4gICAgICAgIHJlcGxhY2UgPVxuICAgICAgICAgIHJlc3VsdC5sb2NhdGlvbiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2g7XG4gICAgICB9XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVzdWx0LCB7IHN1Ym1pc3Npb24sIHJlcGxhY2UgfSk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFN0b3JlIG9mZiB0aGUgcGVuZGluZyBlcnJvciAtIHdlIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hpY2ggbG9hZGVyc1xuICAgICAgLy8gdG8gY2FsbCBhbmQgd2lsbCBjb21taXQgaXQgd2hlbiB3ZSBjb21wbGV0ZSB0aGUgbmF2aWdhdGlvblxuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcblxuICAgICAgLy8gQnkgZGVmYXVsdCwgYWxsIHN1Ym1pc3Npb25zIGFyZSBSRVBMQUNFIG5hdmlnYXRpb25zLCBidXQgaWYgdGhlXG4gICAgICAvLyBhY3Rpb24gdGhyZXcgYW4gZXJyb3IgdGhhdCdsbCBiZSByZW5kZXJlZCBpbiBhbiBlcnJvckVsZW1lbnQsIHdlIGZhbGxcbiAgICAgIC8vIGJhY2sgdG8gUFVTSCBzbyB0aGF0IHRoZSB1c2VyIGNhbiB1c2UgdGhlIGJhY2sgYnV0dG9uIHRvIGdldCBiYWNrIHRvXG4gICAgICAvLyB0aGUgcHJlLXN1Ym1pc3Npb24gZm9ybSBsb2NhdGlvbiB0byB0cnkgYWdhaW5cbiAgICAgIGlmICgob3B0cyAmJiBvcHRzLnJlcGxhY2UpICE9PSB0cnVlKSB7XG4gICAgICAgIHBlbmRpbmdBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlB1c2g7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIFNlbmQgYmFjayBhbiBlbXB0eSBvYmplY3Qgd2UgY2FuIHVzZSB0byBjbGVhciBvdXQgYW55IHByaW9yIGFjdGlvbkRhdGFcbiAgICAgICAgcGVuZGluZ0FjdGlvbkRhdGE6IHt9LFxuICAgICAgICBwZW5kaW5nQWN0aW9uRXJyb3I6IHsgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3IgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHsgdHlwZTogXCJkZWZlci1hY3Rpb25cIiB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGVuZGluZ0FjdGlvbkRhdGE6IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGEgfSxcbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBhbGwgYXBwbGljYWJsZSBsb2FkZXJzIGZvciB0aGUgZ2l2ZW4gbWF0Y2hlcywgaGFuZGxpbmcgcmVkaXJlY3RzLFxuICAvLyBlcnJvcnMsIGV0Yy5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVycyhcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgb3ZlcnJpZGVOYXZpZ2F0aW9uPzogTmF2aWdhdGlvbixcbiAgICBzdWJtaXNzaW9uPzogU3VibWlzc2lvbixcbiAgICByZXBsYWNlPzogYm9vbGVhbixcbiAgICBwZW5kaW5nQWN0aW9uRGF0YT86IFJvdXRlRGF0YSxcbiAgICBwZW5kaW5nRXJyb3I/OiBSb3V0ZURhdGFcbiAgKTogUHJvbWlzZTxIYW5kbGVMb2FkZXJzUmVzdWx0PiB7XG4gICAgLy8gRmlndXJlIG91dCB0aGUgcmlnaHQgbmF2aWdhdGlvbiB3ZSB3YW50IHRvIHVzZSBmb3IgZGF0YSBsb2FkaW5nXG4gICAgbGV0IGxvYWRpbmdOYXZpZ2F0aW9uID0gb3ZlcnJpZGVOYXZpZ2F0aW9uO1xuICAgIGlmICghbG9hZGluZ05hdmlnYXRpb24pIHtcbiAgICAgIGxldCBuYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICAgIC4uLnN1Ym1pc3Npb24sXG4gICAgICB9O1xuICAgICAgbG9hZGluZ05hdmlnYXRpb24gPSBuYXZpZ2F0aW9uO1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgd2FzIGEgcmVkaXJlY3QgZnJvbSBhbiBhY3Rpb24gd2UgZG9uJ3QgaGF2ZSBhIFwic3VibWlzc2lvblwiIGJ1dFxuICAgIC8vIHdlIGhhdmUgaXQgb24gdGhlIGxvYWRpbmcgbmF2aWdhdGlvbiBzbyB1c2UgdGhhdCBpZiBhdmFpbGFibGVcbiAgICBsZXQgYWN0aXZlU3VibWlzc2lvbiA9IHN1Ym1pc3Npb25cbiAgICAgID8gc3VibWlzc2lvblxuICAgICAgOiBsb2FkaW5nTmF2aWdhdGlvbi5mb3JtTWV0aG9kICYmXG4gICAgICAgIGxvYWRpbmdOYXZpZ2F0aW9uLmZvcm1BY3Rpb24gJiZcbiAgICAgICAgbG9hZGluZ05hdmlnYXRpb24uZm9ybURhdGEgJiZcbiAgICAgICAgbG9hZGluZ05hdmlnYXRpb24uZm9ybUVuY1R5cGVcbiAgICAgID8ge1xuICAgICAgICAgIGZvcm1NZXRob2Q6IGxvYWRpbmdOYXZpZ2F0aW9uLmZvcm1NZXRob2QsXG4gICAgICAgICAgZm9ybUFjdGlvbjogbG9hZGluZ05hdmlnYXRpb24uZm9ybUFjdGlvbixcbiAgICAgICAgICBmb3JtRGF0YTogbG9hZGluZ05hdmlnYXRpb24uZm9ybURhdGEsXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IGxvYWRpbmdOYXZpZ2F0aW9uLmZvcm1FbmNUeXBlLFxuICAgICAgICB9XG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGxldCBbbWF0Y2hlc1RvTG9hZCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdID0gZ2V0TWF0Y2hlc1RvTG9hZChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGFjdGl2ZVN1Ym1pc3Npb24sXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQsXG4gICAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcyxcbiAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2FkcyxcbiAgICAgIHBlbmRpbmdBY3Rpb25EYXRhLFxuICAgICAgcGVuZGluZ0Vycm9yLFxuICAgICAgZmV0Y2hMb2FkTWF0Y2hlc1xuICAgICk7XG5cbiAgICAvLyBDYW5jZWwgcGVuZGluZyBkZWZlcnJlZHMgZm9yIG5vLWxvbmdlci1tYXRjaGVkIHJvdXRlcyBvciByb3V0ZXMgd2UncmVcbiAgICAvLyBhYm91dCB0byByZWxvYWQuICBOb3RlIHRoYXQgaWYgdGhpcyBpcyBhbiBhY3Rpb24gcmVsb2FkIHdlIHdvdWxkIGhhdmVcbiAgICAvLyBhbHJlYWR5IGNhbmNlbGxlZCBhbGwgcGVuZGluZyBkZWZlcnJlZHMgc28gdGhpcyB3b3VsZCBiZSBhIG5vLW9wXG4gICAgY2FuY2VsQWN0aXZlRGVmZXJyZWRzKFxuICAgICAgKHJvdXRlSWQpID0+XG4gICAgICAgICEobWF0Y2hlcyAmJiBtYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpKSB8fFxuICAgICAgICAobWF0Y2hlc1RvTG9hZCAmJiBtYXRjaGVzVG9Mb2FkLnNvbWUoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpKVxuICAgICk7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHdlIGhhdmUgbm8gbG9hZGVycyB0byBydW5cbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDAgJiYgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHtcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIC8vIENvbW1pdCBwZW5kaW5nIGVycm9yIGlmIHdlJ3JlIHNob3J0IGNpcmN1aXRpbmdcbiAgICAgICAgZXJyb3JzOiBwZW5kaW5nRXJyb3IgfHwgbnVsbCxcbiAgICAgICAgLi4uKHBlbmRpbmdBY3Rpb25EYXRhID8geyBhY3Rpb25EYXRhOiBwZW5kaW5nQWN0aW9uRGF0YSB9IDoge30pLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgaXMgYW4gdW5pbnRlcnJ1cHRlZCByZXZhbGlkYXRpb24sIHdlIHJlbWFpbiBpbiBvdXIgY3VycmVudCBpZGxlXG4gICAgLy8gc3RhdGUuICBJZiBub3QsIHdlIG5lZWQgdG8gc3dpdGNoIHRvIG91ciBsb2FkaW5nIHN0YXRlIGFuZCBsb2FkIGRhdGEsXG4gICAgLy8gcHJlc2VydmluZyBhbnkgbmV3IGFjdGlvbiBkYXRhIG9yIGV4aXN0aW5nIGFjdGlvbiBkYXRhIChpbiB0aGUgY2FzZSBvZlxuICAgIC8vIGEgcmV2YWxpZGF0aW9uIGludGVycnVwdGluZyBhbiBhY3Rpb25SZWxvYWQpXG4gICAgaWYgKCFpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24pIHtcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiB7XG4gICAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KHJmLmtleSk7XG4gICAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICAgICAgZGF0YTogZmV0Y2hlciAmJiBmZXRjaGVyLmRhdGEsXG4gICAgICAgICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgXCIgX2hhc0ZldGNoZXJEb25lQW55dGhpbmcgXCI6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHN0YXRlLmZldGNoZXJzLnNldChyZi5rZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgICAgfSk7XG4gICAgICBsZXQgYWN0aW9uRGF0YSA9IHBlbmRpbmdBY3Rpb25EYXRhIHx8IHN0YXRlLmFjdGlvbkRhdGE7XG4gICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgIG5hdmlnYXRpb246IGxvYWRpbmdOYXZpZ2F0aW9uLFxuICAgICAgICAuLi4oYWN0aW9uRGF0YVxuICAgICAgICAgID8gT2JqZWN0LmtleXMoYWN0aW9uRGF0YSkubGVuZ3RoID09PSAwXG4gICAgICAgICAgICA/IHsgYWN0aW9uRGF0YTogbnVsbCB9XG4gICAgICAgICAgICA6IHsgYWN0aW9uRGF0YSB9XG4gICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLihyZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPiAwXG4gICAgICAgICAgPyB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9XG4gICAgICAgICAgOiB7fSksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PlxuICAgICAgZmV0Y2hDb250cm9sbGVycy5zZXQocmYua2V5LCBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIhKVxuICAgICk7XG5cbiAgICBsZXQgeyByZXN1bHRzLCBsb2FkZXJSZXN1bHRzLCBmZXRjaGVyUmVzdWx0cyB9ID1cbiAgICAgIGF3YWl0IGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICAgICAgc3RhdGUubWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgICk7XG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbiB1cCBfYWZ0ZXJfIGxvYWRlcnMgaGF2ZSBjb21wbGV0ZWQuICBEb24ndCBjbGVhbiB1cCBpZiB3ZSBzaG9ydFxuICAgIC8vIGNpcmN1aXRlZCBiZWNhdXNlIGZldGNoQ29udHJvbGxlcnMgd291bGQgaGF2ZSBiZWVuIGFib3J0ZWQgYW5kXG4gICAgLy8gcmVhc3NpZ25lZCB0byBuZXcgY29udHJvbGxlcnMgZm9yIHRoZSBuZXh0IG5hdmlnYXRpb25cbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUocmYua2V5KSk7XG5cbiAgICAvLyBJZiBhbnkgbG9hZGVycyByZXR1cm5lZCBhIHJlZGlyZWN0IFJlc3BvbnNlLCBzdGFydCBhIG5ldyBSRVBMQUNFIG5hdmlnYXRpb25cbiAgICBsZXQgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QocmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0KSB7XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVkaXJlY3QsIHsgcmVwbGFjZSB9KTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBhbmQgY29tbWl0IG91dHB1dCBmcm9tIGxvYWRlcnNcbiAgICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IHByb2Nlc3NMb2FkZXJEYXRhKFxuICAgICAgc3RhdGUsXG4gICAgICBtYXRjaGVzLFxuICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICBwZW5kaW5nRXJyb3IsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIGZldGNoZXJSZXN1bHRzLFxuICAgICAgYWN0aXZlRGVmZXJyZWRzXG4gICAgKTtcblxuICAgIC8vIFdpcmUgdXAgc3Vic2NyaWJlcnMgdG8gdXBkYXRlIGxvYWRlckRhdGEgYXMgcHJvbWlzZXMgc2V0dGxlXG4gICAgYWN0aXZlRGVmZXJyZWRzLmZvckVhY2goKGRlZmVycmVkRGF0YSwgcm91dGVJZCkgPT4ge1xuICAgICAgZGVmZXJyZWREYXRhLnN1YnNjcmliZSgoYWJvcnRlZCkgPT4ge1xuICAgICAgICAvLyBOb3RlOiBObyBuZWVkIHRvIHVwZGF0ZVN0YXRlIGhlcmUgc2luY2UgdGhlIFRyYWNrZWRQcm9taXNlIG9uXG4gICAgICAgIC8vIGxvYWRlckRhdGEgaXMgc3RhYmxlIGFjcm9zcyByZXNvbHZlL3JlamVjdFxuICAgICAgICAvLyBSZW1vdmUgdGhpcyBpbnN0YW5jZSBpZiB3ZSB3ZXJlIGFib3J0ZWQgb3IgaWYgcHJvbWlzZXMgaGF2ZSBzZXR0bGVkXG4gICAgICAgIGlmIChhYm9ydGVkIHx8IGRlZmVycmVkRGF0YS5kb25lKSB7XG4gICAgICAgICAgYWN0aXZlRGVmZXJyZWRzLmRlbGV0ZShyb3V0ZUlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBtYXJrRmV0Y2hSZWRpcmVjdHNEb25lKCk7XG4gICAgbGV0IGRpZEFib3J0RmV0Y2hMb2FkcyA9IGFib3J0U3RhbGVGZXRjaExvYWRzKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzLFxuICAgICAgLi4uKGRpZEFib3J0RmV0Y2hMb2FkcyB8fCByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPiAwXG4gICAgICAgID8geyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfVxuICAgICAgICA6IHt9KSxcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RmV0Y2hlcjxURGF0YSA9IGFueT4oa2V5OiBzdHJpbmcpOiBGZXRjaGVyPFREYXRhPiB7XG4gICAgcmV0dXJuIHN0YXRlLmZldGNoZXJzLmdldChrZXkpIHx8IElETEVfRkVUQ0hFUjtcbiAgfVxuXG4gIC8vIFRyaWdnZXIgYSBmZXRjaGVyIGxvYWQvc3VibWl0IGZvciB0aGUgZ2l2ZW4gZmV0Y2hlciBrZXlcbiAgZnVuY3Rpb24gZmV0Y2goXG4gICAga2V5OiBzdHJpbmcsXG4gICAgcm91dGVJZDogc3RyaW5nLFxuICAgIGhyZWY6IHN0cmluZyxcbiAgICBvcHRzPzogUm91dGVyRmV0Y2hPcHRpb25zXG4gICkge1xuICAgIGlmIChpc1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcInJvdXRlci5mZXRjaCgpIHdhcyBjYWxsZWQgZHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyLCBidXQgaXQgc2hvdWxkbid0IGJlLiBcIiArXG4gICAgICAgICAgXCJZb3UgYXJlIGxpa2VseSBjYWxsaW5nIGEgdXNlRmV0Y2hlcigpIG1ldGhvZCBpbiB0aGUgYm9keSBvZiB5b3VyIGNvbXBvbmVudC4gXCIgK1xuICAgICAgICAgIFwiVHJ5IG1vdmluZyBpdCB0byBhIHVzZUVmZmVjdCBvciBhIGNhbGxiYWNrLlwiXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSBhYm9ydEZldGNoZXIoa2V5KTtcblxuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgaHJlZiwgaW5pdC5iYXNlbmFtZSk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3IoXG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZCxcbiAgICAgICAgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IGhyZWYgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHsgcGF0aCwgc3VibWlzc2lvbiB9ID0gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKGhyZWYsIG9wdHMsIHRydWUpO1xuICAgIGxldCBtYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIHBhdGgpO1xuXG4gICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IChvcHRzICYmIG9wdHMucHJldmVudFNjcm9sbFJlc2V0KSA9PT0gdHJ1ZTtcblxuICAgIGlmIChzdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgICAgaGFuZGxlRmV0Y2hlckFjdGlvbihrZXksIHJvdXRlSWQsIHBhdGgsIG1hdGNoLCBtYXRjaGVzLCBzdWJtaXNzaW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTdG9yZSBvZmYgdGhlIG1hdGNoIHNvIHdlIGNhbiBjYWxsIGl0J3Mgc2hvdWxkUmV2YWxpZGF0ZSBvbiBzdWJzZXF1ZW50XG4gICAgLy8gcmV2YWxpZGF0aW9uc1xuICAgIGZldGNoTG9hZE1hdGNoZXMuc2V0KGtleSwgeyByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgbWF0Y2hlcyB9KTtcbiAgICBoYW5kbGVGZXRjaGVyTG9hZGVyKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIG1hdGNoZXMsIHN1Ym1pc3Npb24pO1xuICB9XG5cbiAgLy8gQ2FsbCB0aGUgYWN0aW9uIGZvciB0aGUgbWF0Y2hlZCBmZXRjaGVyLnN1Ym1pdCgpLCBhbmQgdGhlbiBoYW5kbGUgcmVkaXJlY3RzLFxuICAvLyBlcnJvcnMsIGFuZCByZXZhbGlkYXRpb25cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRmV0Y2hlckFjdGlvbihcbiAgICBrZXk6IHN0cmluZyxcbiAgICByb3V0ZUlkOiBzdHJpbmcsXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICAgIHJlcXVlc3RNYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgc3VibWlzc2lvbjogU3VibWlzc2lvblxuICApIHtcbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XG5cbiAgICBpZiAoIW1hdGNoLnJvdXRlLmFjdGlvbikge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgbWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgICAgIHBhdGhuYW1lOiBwYXRoLFxuICAgICAgICByb3V0ZUlkOiByb3V0ZUlkLFxuICAgICAgfSk7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHV0IHRoaXMgZmV0Y2hlciBpbnRvIGl0J3Mgc3VibWl0dGluZyBzdGF0ZVxuICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICBsZXQgZmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIlN1Ym1pdHRpbmdcIl0gPSB7XG4gICAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgICAuLi5zdWJtaXNzaW9uLFxuICAgICAgZGF0YTogZXhpc3RpbmdGZXRjaGVyICYmIGV4aXN0aW5nRmV0Y2hlci5kYXRhLFxuICAgICAgXCIgX2hhc0ZldGNoZXJEb25lQW55dGhpbmcgXCI6IHRydWUsXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBmZXRjaGVyKTtcbiAgICB1cGRhdGVTdGF0ZSh7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9KTtcblxuICAgIC8vIENhbGwgdGhlIGFjdGlvbiBmb3IgdGhlIGZldGNoZXJcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHBhdGgsXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgc3VibWlzc2lvblxuICAgICk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBhYm9ydENvbnRyb2xsZXIpO1xuXG4gICAgbGV0IGFjdGlvblJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXJPckFjdGlvbihcbiAgICAgIFwiYWN0aW9uXCIsXG4gICAgICBmZXRjaFJlcXVlc3QsXG4gICAgICBtYXRjaCxcbiAgICAgIHJlcXVlc3RNYXRjaGVzLFxuICAgICAgcm91dGVyLmJhc2VuYW1lXG4gICAgKTtcblxuICAgIGlmIChmZXRjaFJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIC8vIFdlIGNhbiBkZWxldGUgdGhpcyBzbyBsb25nIGFzIHdlIHdlcmVuJ3QgYWJvcnRlZCBieSBvdSBvdXIgb3duIGZldGNoZXJcbiAgICAgIC8vIHJlLXN1Ym1pdCB3aGljaCB3b3VsZCBoYXZlIHB1dCBfbmV3XyBjb250cm9sbGVyIGlzIGluIGZldGNoQ29udHJvbGxlcnNcbiAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpID09PSBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQoa2V5KTtcbiAgICAgIGxldCBsb2FkaW5nRmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIkxvYWRpbmdcIl0gPSB7XG4gICAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgICBcIiBfaGFzRmV0Y2hlckRvbmVBbnl0aGluZyBcIjogdHJ1ZSxcbiAgICAgIH07XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBsb2FkaW5nRmV0Y2hlcik7XG4gICAgICB1cGRhdGVTdGF0ZSh7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9KTtcblxuICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCBhY3Rpb25SZXN1bHQsIHtcbiAgICAgICAgaXNGZXRjaEFjdGlvblJlZGlyZWN0OiB0cnVlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBhbnkgbm9uLXJlZGlyZWN0IGVycm9ycyB0aHJvd25cbiAgICBpZiAoaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBhY3Rpb25SZXN1bHQuZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7IHR5cGU6IFwiZGVmZXItYWN0aW9uXCIgfSk7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgdGhlIGRhdGEgbG9hZCBmb3IgY3VycmVudCBtYXRjaGVzLCBvciB0aGUgbmV4dCBsb2NhdGlvbiBpZiB3ZSdyZVxuICAgIC8vIGluIHRoZSBtaWRkbGUgb2YgYSBuYXZpZ2F0aW9uXG4gICAgbGV0IG5leHRMb2NhdGlvbiA9IHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24gfHwgc3RhdGUubG9jYXRpb247XG4gICAgbGV0IHJldmFsaWRhdGlvblJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcblxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICk7XG4gICAgbGV0IG1hdGNoZXMgPVxuICAgICAgc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSAhPT0gXCJpZGxlXCJcbiAgICAgICAgPyBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLCBpbml0LmJhc2VuYW1lKVxuICAgICAgICA6IHN0YXRlLm1hdGNoZXM7XG5cbiAgICBpbnZhcmlhbnQobWF0Y2hlcywgXCJEaWRuJ3QgZmluZCBhbnkgbWF0Y2hlcyBhZnRlciBmZXRjaGVyIGFjdGlvblwiKTtcblxuICAgIGxldCBsb2FkSWQgPSArK2luY3JlbWVudGluZ0xvYWRJZDtcbiAgICBmZXRjaFJlbG9hZElkcy5zZXQoa2V5LCBsb2FkSWQpO1xuXG4gICAgbGV0IGxvYWRGZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGRhdGE6IGFjdGlvblJlc3VsdC5kYXRhLFxuICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgIFwiIF9oYXNGZXRjaGVyRG9uZUFueXRoaW5nIFwiOiB0cnVlLFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZEZldGNoZXIpO1xuXG4gICAgbGV0IFttYXRjaGVzVG9Mb2FkLCByZXZhbGlkYXRpbmdGZXRjaGVyc10gPSBnZXRNYXRjaGVzVG9Mb2FkKFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgc3RhdGUsXG4gICAgICBtYXRjaGVzLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQsXG4gICAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcyxcbiAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2FkcyxcbiAgICAgIHsgW21hdGNoLnJvdXRlLmlkXTogYWN0aW9uUmVzdWx0LmRhdGEgfSxcbiAgICAgIHVuZGVmaW5lZCwgLy8gTm8gbmVlZCB0byBzZW5kIHRocm91Z2ggZXJyb3JzIHNpbmNlIHdlIHNob3J0IGNpcmN1aXQgYWJvdmVcbiAgICAgIGZldGNoTG9hZE1hdGNoZXNcbiAgICApO1xuXG4gICAgLy8gUHV0IGFsbCByZXZhbGlkYXRpbmcgZmV0Y2hlcnMgaW50byB0aGUgbG9hZGluZyBzdGF0ZSwgZXhjZXB0IGZvciB0aGVcbiAgICAvLyBjdXJyZW50IGZldGNoZXIgd2hpY2ggd2Ugd2FudCB0byBrZWVwIGluIGl0J3MgY3VycmVudCBsb2FkaW5nIHN0YXRlIHdoaWNoXG4gICAgLy8gY29udGFpbnMgaXQncyBhY3Rpb24gc3VibWlzc2lvbiBpbmZvICsgYWN0aW9uIGRhdGFcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVyc1xuICAgICAgLmZpbHRlcigocmYpID0+IHJmLmtleSAhPT0ga2V5KVxuICAgICAgLmZvckVhY2goKHJmKSA9PiB7XG4gICAgICAgIGxldCBzdGFsZUtleSA9IHJmLmtleTtcbiAgICAgICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChzdGFsZUtleSk7XG4gICAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICAgICAgZGF0YTogZXhpc3RpbmdGZXRjaGVyICYmIGV4aXN0aW5nRmV0Y2hlci5kYXRhLFxuICAgICAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgIFwiIF9oYXNGZXRjaGVyRG9uZUFueXRoaW5nIFwiOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoc3RhbGVLZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLnNldChzdGFsZUtleSwgYWJvcnRDb250cm9sbGVyKTtcbiAgICAgIH0pO1xuXG4gICAgdXBkYXRlU3RhdGUoeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSk7XG5cbiAgICBsZXQgeyByZXN1bHRzLCBsb2FkZXJSZXN1bHRzLCBmZXRjaGVyUmVzdWx0cyB9ID1cbiAgICAgIGF3YWl0IGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICAgICAgc3RhdGUubWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICAgIHJldmFsaWRhdGlvblJlcXVlc3RcbiAgICAgICk7XG5cbiAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyKSA9PiBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShyLmtleSkpO1xuXG4gICAgbGV0IHJlZGlyZWN0ID0gZmluZFJlZGlyZWN0KHJlc3VsdHMpO1xuICAgIGlmIChyZWRpcmVjdCkge1xuICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZWRpcmVjdCk7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBhbmQgY29tbWl0IG91dHB1dCBmcm9tIGxvYWRlcnNcbiAgICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IHByb2Nlc3NMb2FkZXJEYXRhKFxuICAgICAgc3RhdGUsXG4gICAgICBzdGF0ZS5tYXRjaGVzLFxuICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIGZldGNoZXJSZXN1bHRzLFxuICAgICAgYWN0aXZlRGVmZXJyZWRzXG4gICAgKTtcblxuICAgIGxldCBkb25lRmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIklkbGVcIl0gPSB7XG4gICAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgICBkYXRhOiBhY3Rpb25SZXN1bHQuZGF0YSxcbiAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgXCIgX2hhc0ZldGNoZXJEb25lQW55dGhpbmcgXCI6IHRydWUsXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG5cbiAgICBsZXQgZGlkQWJvcnRGZXRjaExvYWRzID0gYWJvcnRTdGFsZUZldGNoTG9hZHMobG9hZElkKTtcblxuICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgaW4gYSBuYXZpZ2F0aW9uIGxvYWRpbmcgc3RhdGUgYW5kIHRoaXMgZmV0Y2hlciBpc1xuICAgIC8vIG1vcmUgcmVjZW50IHRoYW4gdGhlIG5hdmlnYXRpb24sIHdlIHdhbnQgdGhlIG5ld2VyIGRhdGEgc28gYWJvcnQgdGhlXG4gICAgLy8gbmF2aWdhdGlvbiBhbmQgY29tcGxldGUgaXQgd2l0aCB0aGUgZmV0Y2hlciBkYXRhXG4gICAgaWYgKFxuICAgICAgc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgJiZcbiAgICAgIGxvYWRJZCA+IHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkXG4gICAgKSB7XG4gICAgICBpbnZhcmlhbnQocGVuZGluZ0FjdGlvbiwgXCJFeHBlY3RlZCBwZW5kaW5nIGFjdGlvblwiKTtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcblxuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sIHtcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YSxcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycyksXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlIGp1c3QgdXBkYXRlIHdpdGggdGhlIGZldGNoZXIgZGF0YSwgcHJlc2VydmluZyBhbnkgZXhpc3RpbmdcbiAgICAgIC8vIGxvYWRlckRhdGEgZm9yIGxvYWRlcnMgdGhhdCBkaWQgbm90IG5lZWQgdG8gcmVsb2FkLiAgV2UgaGF2ZSB0b1xuICAgICAgLy8gbWFudWFsbHkgbWVyZ2UgaGVyZSBzaW5jZSB3ZSBhcmVuJ3QgZ29pbmcgdGhyb3VnaCBjb21wbGV0ZU5hdmlnYXRpb25cbiAgICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBsb2FkZXJEYXRhOiBtZXJnZUxvYWRlckRhdGEoXG4gICAgICAgICAgc3RhdGUubG9hZGVyRGF0YSxcbiAgICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgZXJyb3JzXG4gICAgICAgICksXG4gICAgICAgIC4uLihkaWRBYm9ydEZldGNoTG9hZHMgPyB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9IDoge30pLFxuICAgICAgfSk7XG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbCB0aGUgbWF0Y2hlZCBsb2FkZXIgZm9yIGZldGNoZXIubG9hZCgpLCBoYW5kbGluZyByZWRpcmVjdHMsIGVycm9ycywgZXRjLlxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaGVyTG9hZGVyKFxuICAgIGtleTogc3RyaW5nLFxuICAgIHJvdXRlSWQ6IHN0cmluZyxcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uXG4gICkge1xuICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAvLyBQdXQgdGhpcyBmZXRjaGVyIGludG8gaXQncyBsb2FkaW5nIHN0YXRlXG4gICAgbGV0IGxvYWRpbmdGZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgIGRhdGE6IGV4aXN0aW5nRmV0Y2hlciAmJiBleGlzdGluZ0ZldGNoZXIuZGF0YSxcbiAgICAgIFwiIF9oYXNGZXRjaGVyRG9uZUFueXRoaW5nIFwiOiB0cnVlLFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZGluZ0ZldGNoZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuXG4gICAgLy8gQ2FsbCB0aGUgbG9hZGVyIGZvciB0aGlzIGZldGNoZXIgcm91dGUgbWF0Y2hcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHBhdGgsXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGFib3J0Q29udHJvbGxlcik7XG4gICAgbGV0IHJlc3VsdDogRGF0YVJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXJPckFjdGlvbihcbiAgICAgIFwibG9hZGVyXCIsXG4gICAgICBmZXRjaFJlcXVlc3QsXG4gICAgICBtYXRjaCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICByb3V0ZXIuYmFzZW5hbWVcbiAgICApO1xuXG4gICAgLy8gRGVmZXJyZWQgaXNuJ3Qgc3VwcG9ydGVkIGZvciBmZXRjaGVyIGxvYWRzLCBhd2FpdCBldmVyeXRoaW5nIGFuZCB0cmVhdCBpdFxuICAgIC8vIGFzIGEgbm9ybWFsIGxvYWQuICByZXNvbHZlRGVmZXJyZWREYXRhIHdpbGwgcmV0dXJuIHVuZGVmaW5lZCBpZiB0aGlzXG4gICAgLy8gZmV0Y2hlciBnZXRzIGFib3J0ZWQsIHNvIHdlIGp1c3QgbGVhdmUgcmVzdWx0IHVudG91Y2hlZCBhbmQgc2hvcnQgY2lyY3VpdFxuICAgIC8vIGJlbG93IGlmIHRoYXQgaGFwcGVuc1xuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdCA9XG4gICAgICAgIChhd2FpdCByZXNvbHZlRGVmZXJyZWREYXRhKHJlc3VsdCwgZmV0Y2hSZXF1ZXN0LnNpZ25hbCwgdHJ1ZSkpIHx8XG4gICAgICAgIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBXZSBjYW4gZGVsZXRlIHRoaXMgc28gbG9uZyBhcyB3ZSB3ZXJlbid0IGFib3J0ZWQgYnkgb3Ugb3VyIG93biBmZXRjaGVyXG4gICAgLy8gcmUtbG9hZCB3aGljaCB3b3VsZCBoYXZlIHB1dCBfbmV3XyBjb250cm9sbGVyIGlzIGluIGZldGNoQ29udHJvbGxlcnNcbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KSA9PT0gYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIH1cblxuICAgIGlmIChmZXRjaFJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbG9hZGVyIHRocmV3IGEgcmVkaXJlY3QgUmVzcG9uc2UsIHN0YXJ0IGEgbmV3IFJFUExBQ0UgbmF2aWdhdGlvblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZXN1bHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgYW55IG5vbi1yZWRpcmVjdCBlcnJvcnMgdGhyb3duXG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIHJvdXRlSWQpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgICAvLyBUT0RPOiBJbiByZW1peCwgdGhpcyB3b3VsZCByZXNldCB0byBJRExFX05BVklHQVRJT04gaWYgaXQgd2FzIGEgY2F0Y2ggLVxuICAgICAgLy8gZG8gd2UgbmVlZCB0byBiZWhhdmUgYW55IGRpZmZlcmVudGx5IHdpdGggb3VyIG5vbi1yZWRpcmVjdCBlcnJvcnM/XG4gICAgICAvLyBXaGF0IGlmIGl0IHdhcyBhIG5vbi1yZWRpcmVjdCBSZXNwb25zZT9cbiAgICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvcixcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludmFyaWFudCghaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpLCBcIlVuaGFuZGxlZCBmZXRjaGVyIGRlZmVycmVkIGRhdGFcIik7XG5cbiAgICAvLyBQdXQgdGhlIGZldGNoZXIgYmFjayBpbnRvIGFuIGlkbGUgc3RhdGVcbiAgICBsZXQgZG9uZUZldGNoZXI6IEZldGNoZXJTdGF0ZXNbXCJJZGxlXCJdID0ge1xuICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgZGF0YTogcmVzdWx0LmRhdGEsXG4gICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIFwiIF9oYXNGZXRjaGVyRG9uZUFueXRoaW5nIFwiOiB0cnVlLFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gaGFuZGxlIHJlZGlyZWN0cyByZXR1cm5lZCBmcm9tIGFuIGFjdGlvbiBvciBsb2FkZXIuXG4gICAqIE5vcm1hbGx5LCBhIHJlZGlyZWN0IFwicmVwbGFjZXNcIiB0aGUgbmF2aWdhdGlvbiB0aGF0IHRyaWdnZXJlZCBpdC4gIFNvLCBmb3JcbiAgICogZXhhbXBsZTpcbiAgICpcbiAgICogIC0gdXNlciBpcyBvbiAvYVxuICAgKiAgLSB1c2VyIGNsaWNrcyBhIGxpbmsgdG8gL2JcbiAgICogIC0gbG9hZGVyIGZvciAvYiByZWRpcmVjdHMgdG8gL2NcbiAgICpcbiAgICogSW4gYSBub24tSlMgYXBwIHRoZSBicm93c2VyIHdvdWxkIHRyYWNrIHRoZSBpbi1mbGlnaHQgbmF2aWdhdGlvbiB0byAvYiBhbmRcbiAgICogdGhlbiByZXBsYWNlIGl0IHdpdGggL2Mgd2hlbiBpdCBlbmNvdW50ZXJlZCB0aGUgcmVkaXJlY3QgcmVzcG9uc2UuICBJblxuICAgKiB0aGUgZW5kIGl0IHdvdWxkIG9ubHkgZXZlciB1cGRhdGUgdGhlIFVSTCBiYXIgd2l0aCAvYy5cbiAgICpcbiAgICogSW4gY2xpZW50LXNpZGUgcm91dGluZyB1c2luZyBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlLCB3ZSBhaW0gdG8gZW11bGF0ZVxuICAgKiB0aGlzIGJlaGF2aW9yIGFuZCB3ZSBhbHNvIGRvIG5vdCB1cGRhdGUgaGlzdG9yeSB1bnRpbCB0aGUgZW5kIG9mIHRoZVxuICAgKiBuYXZpZ2F0aW9uIChpbmNsdWRpbmcgcHJvY2Vzc2VkIHJlZGlyZWN0cykuICBUaGlzIG1lYW5zIHRoYXQgd2UgbmV2ZXJcbiAgICogYWN0dWFsbHkgdG91Y2ggaGlzdG9yeSB1bnRpbCB3ZSd2ZSBwcm9jZXNzZWQgcmVkaXJlY3RzLCBzbyB3ZSBqdXN0IHVzZVxuICAgKiB0aGUgaGlzdG9yeSBhY3Rpb24gZnJvbSB0aGUgb3JpZ2luYWwgbmF2aWdhdGlvbiAoUFVTSCBvciBSRVBMQUNFKS5cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKFxuICAgIHN0YXRlOiBSb3V0ZXJTdGF0ZSxcbiAgICByZWRpcmVjdDogUmVkaXJlY3RSZXN1bHQsXG4gICAge1xuICAgICAgc3VibWlzc2lvbixcbiAgICAgIHJlcGxhY2UsXG4gICAgICBpc0ZldGNoQWN0aW9uUmVkaXJlY3QsXG4gICAgfToge1xuICAgICAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb247XG4gICAgICByZXBsYWNlPzogYm9vbGVhbjtcbiAgICAgIGlzRmV0Y2hBY3Rpb25SZWRpcmVjdD86IGJvb2xlYW47XG4gICAgfSA9IHt9XG4gICkge1xuICAgIGlmIChyZWRpcmVjdC5yZXZhbGlkYXRlKSB7XG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgcmVkaXJlY3RMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKFxuICAgICAgc3RhdGUubG9jYXRpb24sXG4gICAgICByZWRpcmVjdC5sb2NhdGlvbixcbiAgICAgIC8vIFRPRE86IFRoaXMgY2FuIGJlIHJlbW92ZWQgb25jZSB3ZSBnZXQgcmlkIG9mIHVzZVRyYW5zaXRpb24gaW4gUmVtaXggdjJcbiAgICAgIHtcbiAgICAgICAgX2lzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgIC4uLihpc0ZldGNoQWN0aW9uUmVkaXJlY3QgPyB7IF9pc0ZldGNoQWN0aW9uUmVkaXJlY3Q6IHRydWUgfSA6IHt9KSxcbiAgICAgIH1cbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgIHJlZGlyZWN0TG9jYXRpb24sXG4gICAgICBcIkV4cGVjdGVkIGEgbG9jYXRpb24gb24gdGhlIHJlZGlyZWN0IG5hdmlnYXRpb25cIlxuICAgICk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGFuIGFic29sdXRlIGV4dGVybmFsIHJlZGlyZWN0IHRoYXQgZ29lcyB0byBhIG5ldyBvcmlnaW5cbiAgICBpZiAoXG4gICAgICBBQlNPTFVURV9VUkxfUkVHRVgudGVzdChyZWRpcmVjdC5sb2NhdGlvbikgJiZcbiAgICAgIGlzQnJvd3NlciAmJlxuICAgICAgdHlwZW9mIHdpbmRvdz8ubG9jYXRpb24gIT09IFwidW5kZWZpbmVkXCJcbiAgICApIHtcbiAgICAgIGxldCBuZXdPcmlnaW4gPSBpbml0Lmhpc3RvcnkuY3JlYXRlVVJMKHJlZGlyZWN0LmxvY2F0aW9uKS5vcmlnaW47XG4gICAgICBpZiAod2luZG93LmxvY2F0aW9uLm9yaWdpbiAhPT0gbmV3T3JpZ2luKSB7XG4gICAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UocmVkaXJlY3QubG9jYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24ocmVkaXJlY3QubG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gYWJvcnQgb24gcmVkaXJlY3RzLCBzaW5jZSB3ZSBkb24ndCBkZXRlY3QgdGhlXG4gICAgLy8gcmVkaXJlY3QgdW50aWwgdGhlIGFjdGlvbi9sb2FkZXJzIGhhdmUgc2V0dGxlZFxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG5cbiAgICBsZXQgcmVkaXJlY3RIaXN0b3J5QWN0aW9uID1cbiAgICAgIHJlcGxhY2UgPT09IHRydWUgPyBIaXN0b3J5QWN0aW9uLlJlcGxhY2UgOiBIaXN0b3J5QWN0aW9uLlB1c2g7XG5cbiAgICAvLyBVc2UgdGhlIGluY29taW5nIHN1Ym1pc3Npb24gaWYgcHJvdmlkZWQsIGZhbGxiYWNrIG9uIHRoZSBhY3RpdmUgb25lIGluXG4gICAgLy8gc3RhdGUubmF2aWdhdGlvblxuICAgIGxldCB7IGZvcm1NZXRob2QsIGZvcm1BY3Rpb24sIGZvcm1FbmNUeXBlLCBmb3JtRGF0YSB9ID0gc3RhdGUubmF2aWdhdGlvbjtcbiAgICBpZiAoIXN1Ym1pc3Npb24gJiYgZm9ybU1ldGhvZCAmJiBmb3JtQWN0aW9uICYmIGZvcm1EYXRhICYmIGZvcm1FbmNUeXBlKSB7XG4gICAgICBzdWJtaXNzaW9uID0ge1xuICAgICAgICBmb3JtTWV0aG9kLFxuICAgICAgICBmb3JtQWN0aW9uLFxuICAgICAgICBmb3JtRW5jVHlwZSxcbiAgICAgICAgZm9ybURhdGEsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgd2FzIGEgMzA3LzMwOCBzdWJtaXNzaW9uIHdlIHdhbnQgdG8gcHJlc2VydmUgdGhlIEhUVFAgbWV0aG9kIGFuZFxuICAgIC8vIHJlLXN1Ym1pdCB0aGUgR0VUL1BPU1QvUFVUL1BBVENIL0RFTEVURSBhcyBhIHN1Ym1pc3Npb24gbmF2aWdhdGlvbiB0byB0aGVcbiAgICAvLyByZWRpcmVjdGVkIGxvY2F0aW9uXG4gICAgaWYgKFxuICAgICAgcmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzLmhhcyhyZWRpcmVjdC5zdGF0dXMpICYmXG4gICAgICBzdWJtaXNzaW9uICYmXG4gICAgICBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZClcbiAgICApIHtcbiAgICAgIGF3YWl0IHN0YXJ0TmF2aWdhdGlvbihyZWRpcmVjdEhpc3RvcnlBY3Rpb24sIHJlZGlyZWN0TG9jYXRpb24sIHtcbiAgICAgICAgc3VibWlzc2lvbjoge1xuICAgICAgICAgIC4uLnN1Ym1pc3Npb24sXG4gICAgICAgICAgZm9ybUFjdGlvbjogcmVkaXJlY3QubG9jYXRpb24sXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoaXMgZmxhZyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UsIHdlIGtpY2sgb2ZmIGEgbmV3IGxvYWRpbmcgbmF2aWdhdGlvbiwgcHJlc2VydmluZyB0aGVcbiAgICAgIC8vIHN1Ym1pc3Npb24gaW5mbyBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoaXMgbmF2aWdhdGlvblxuICAgICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKHJlZGlyZWN0SGlzdG9yeUFjdGlvbiwgcmVkaXJlY3RMb2NhdGlvbiwge1xuICAgICAgICBvdmVycmlkZU5hdmlnYXRpb246IHtcbiAgICAgICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICAgICAgbG9jYXRpb246IHJlZGlyZWN0TG9jYXRpb24sXG4gICAgICAgICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbiA/IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uID8gc3VibWlzc2lvbi5mb3JtQWN0aW9uIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uID8gc3VibWlzc2lvbi5mb3JtRW5jVHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb3JtRGF0YTogc3VibWlzc2lvbiA/IHN1Ym1pc3Npb24uZm9ybURhdGEgOiB1bmRlZmluZWQsXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoaXMgZmxhZyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICBjdXJyZW50TWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBtYXRjaGVzVG9Mb2FkOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgZmV0Y2hlcnNUb0xvYWQ6IFJldmFsaWRhdGluZ0ZldGNoZXJbXSxcbiAgICByZXF1ZXN0OiBSZXF1ZXN0XG4gICkge1xuICAgIC8vIENhbGwgYWxsIG5hdmlnYXRpb24gbG9hZGVycyBhbmQgcmV2YWxpZGF0aW5nIGZldGNoZXIgbG9hZGVycyBpbiBwYXJhbGxlbCxcbiAgICAvLyB0aGVuIHNsaWNlIG9mZiB0aGUgcmVzdWx0cyBpbnRvIHNlcGFyYXRlIGFycmF5cyBzbyB3ZSBjYW4gaGFuZGxlIHRoZW1cbiAgICAvLyBhY2NvcmRpbmdseVxuICAgIGxldCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgLi4ubWF0Y2hlc1RvTG9hZC5tYXAoKG1hdGNoKSA9PlxuICAgICAgICBjYWxsTG9hZGVyT3JBY3Rpb24oXCJsb2FkZXJcIiwgcmVxdWVzdCwgbWF0Y2gsIG1hdGNoZXMsIHJvdXRlci5iYXNlbmFtZSlcbiAgICAgICksXG4gICAgICAuLi5mZXRjaGVyc1RvTG9hZC5tYXAoKGYpID0+XG4gICAgICAgIGNhbGxMb2FkZXJPckFjdGlvbihcbiAgICAgICAgICBcImxvYWRlclwiLFxuICAgICAgICAgIGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgZi5wYXRoLCByZXF1ZXN0LnNpZ25hbCksXG4gICAgICAgICAgZi5tYXRjaCxcbiAgICAgICAgICBmLm1hdGNoZXMsXG4gICAgICAgICAgcm91dGVyLmJhc2VuYW1lXG4gICAgICAgIClcbiAgICAgICksXG4gICAgXSk7XG4gICAgbGV0IGxvYWRlclJlc3VsdHMgPSByZXN1bHRzLnNsaWNlKDAsIG1hdGNoZXNUb0xvYWQubGVuZ3RoKTtcbiAgICBsZXQgZmV0Y2hlclJlc3VsdHMgPSByZXN1bHRzLnNsaWNlKG1hdGNoZXNUb0xvYWQubGVuZ3RoKTtcblxuICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHJlc29sdmVEZWZlcnJlZFJlc3VsdHMoXG4gICAgICAgIGN1cnJlbnRNYXRjaGVzLFxuICAgICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgICByZXF1ZXN0LnNpZ25hbCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHN0YXRlLmxvYWRlckRhdGFcbiAgICAgICksXG4gICAgICByZXNvbHZlRGVmZXJyZWRSZXN1bHRzKFxuICAgICAgICBjdXJyZW50TWF0Y2hlcyxcbiAgICAgICAgZmV0Y2hlcnNUb0xvYWQubWFwKChmKSA9PiBmLm1hdGNoKSxcbiAgICAgICAgZmV0Y2hlclJlc3VsdHMsXG4gICAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgICB0cnVlXG4gICAgICApLFxuICAgIF0pO1xuXG4gICAgcmV0dXJuIHsgcmVzdWx0cywgbG9hZGVyUmVzdWx0cywgZmV0Y2hlclJlc3VsdHMgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycnVwdEFjdGl2ZUxvYWRzKCkge1xuICAgIC8vIEV2ZXJ5IGludGVycnVwdGlvbiB0cmlnZ2VycyBhIHJldmFsaWRhdGlvblxuICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuXG4gICAgLy8gQ2FuY2VsIHBlbmRpbmcgcm91dGUtbGV2ZWwgZGVmZXJyZWRzIGFuZCBtYXJrIGNhbmNlbGxlZCByb3V0ZXMgZm9yXG4gICAgLy8gcmV2YWxpZGF0aW9uXG4gICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMucHVzaCguLi5jYW5jZWxBY3RpdmVEZWZlcnJlZHMoKSk7XG5cbiAgICAvLyBBYm9ydCBpbi1mbGlnaHQgZmV0Y2hlciBsb2Fkc1xuICAgIGZldGNoTG9hZE1hdGNoZXMuZm9yRWFjaCgoXywga2V5KSA9PiB7XG4gICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkge1xuICAgICAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMucHVzaChrZXkpO1xuICAgICAgICBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEZldGNoZXJFcnJvcihrZXk6IHN0cmluZywgcm91dGVJZDogc3RyaW5nLCBlcnJvcjogYW55KSB7XG4gICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIHJvdXRlSWQpO1xuICAgIGRlbGV0ZUZldGNoZXIoa2V5KTtcbiAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICBlcnJvcnM6IHtcbiAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiBlcnJvcixcbiAgICAgIH0sXG4gICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycyksXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVGZXRjaGVyKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkpIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0RmV0Y2hlcihrZXk6IHN0cmluZykge1xuICAgIGxldCBjb250cm9sbGVyID0gZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KTtcbiAgICBpbnZhcmlhbnQoY29udHJvbGxlciwgYEV4cGVjdGVkIGZldGNoIGNvbnRyb2xsZXI6ICR7a2V5fWApO1xuICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFya0ZldGNoZXJzRG9uZShrZXlzOiBzdHJpbmdbXSkge1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IGdldEZldGNoZXIoa2V5KTtcbiAgICAgIGxldCBkb25lRmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIklkbGVcIl0gPSB7XG4gICAgICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICAgICAgZGF0YTogZmV0Y2hlci5kYXRhLFxuICAgICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgXCIgX2hhc0ZldGNoZXJEb25lQW55dGhpbmcgXCI6IHRydWUsXG4gICAgICB9O1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKTogdm9pZCB7XG4gICAgbGV0IGRvbmVLZXlzID0gW107XG4gICAgZm9yIChsZXQga2V5IG9mIGZldGNoUmVkaXJlY3RJZHMpIHtcbiAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgICBpbnZhcmlhbnQoZmV0Y2hlciwgYEV4cGVjdGVkIGZldGNoZXI6ICR7a2V5fWApO1xuICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuZGVsZXRlKGtleSk7XG4gICAgICAgIGRvbmVLZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWFya0ZldGNoZXJzRG9uZShkb25lS2V5cyk7XG4gIH1cblxuICBmdW5jdGlvbiBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhsYW5kZWRJZDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgbGV0IHllZXRlZEtleXMgPSBbXTtcbiAgICBmb3IgKGxldCBba2V5LCBpZF0gb2YgZmV0Y2hSZWxvYWRJZHMpIHtcbiAgICAgIGlmIChpZCA8IGxhbmRlZElkKSB7XG4gICAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgICAgIGludmFyaWFudChmZXRjaGVyLCBgRXhwZWN0ZWQgZmV0Y2hlcjogJHtrZXl9YCk7XG4gICAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgICAgICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHllZXRlZEtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtGZXRjaGVyc0RvbmUoeWVldGVkS2V5cyk7XG4gICAgcmV0dXJuIHllZXRlZEtleXMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJsb2NrZXIoa2V5OiBzdHJpbmcsIGZuOiBCbG9ja2VyRnVuY3Rpb24pIHtcbiAgICBsZXQgYmxvY2tlcjogQmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChrZXkpIHx8IElETEVfQkxPQ0tFUjtcblxuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLmdldChrZXkpICE9PSBmbikge1xuICAgICAgYmxvY2tlckZ1bmN0aW9ucy5zZXQoa2V5LCBmbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJsb2NrZXI7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVCbG9ja2VyKGtleTogc3RyaW5nKSB7XG4gICAgc3RhdGUuYmxvY2tlcnMuZGVsZXRlKGtleSk7XG4gICAgYmxvY2tlckZ1bmN0aW9ucy5kZWxldGUoa2V5KTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gdXBkYXRlIGJsb2NrZXJzLCBlbnN1cmluZyB2YWxpZCBzdGF0ZSB0cmFuc2l0aW9uc1xuICBmdW5jdGlvbiB1cGRhdGVCbG9ja2VyKGtleTogc3RyaW5nLCBuZXdCbG9ja2VyOiBCbG9ja2VyKSB7XG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoa2V5KSB8fCBJRExFX0JMT0NLRVI7XG5cbiAgICAvLyBQb29yIG1hbnMgc3RhdGUgbWFjaGluZSA6KVxuICAgIC8vIGh0dHBzOi8vbWVybWFpZC5saXZlL2VkaXQjcGFrbzplTnFWa2M5T3d6QU14bDhsOG5uakFZckV0RElPSEVCSWd3dktKVFJlR3kzX2xEcElxTzI3azZhd01HMFhjckxsbno4N253ZG9uRVNvZ0tYWEJ1RTc5cnE3NVhaTzMteUhkczBSSlZ1djcwWXJQbFVyQ0VlMkhmck9SUzNydWJxWmZ1aHRwZzVDOXdrNXRaNFZLY1JVcTg4cTlaOFJTMC00OGNFMWlISmtMMHVnYkh1Rkx1czlMNnNwWnk4blg5TVAyQ05kb21WYXBvc3F1M2ZHYXlUOFQ4LWpKUXdoZXBvX1V0cGdCUWFERVVvbTA0ZFpoQU4xYUpCRGxVS0pCeEUxY2VCMlNtajBNbG4tSUJXNUFGVTJkd1Vpa3R0XzJRYXEyZEJmYUtkRXVwODVVVjdZZC1kS2psbmthYmwyUHZyMERUa1RyZU1cbiAgICBpbnZhcmlhbnQoXG4gICAgICAoYmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIikgfHxcbiAgICAgICAgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiKSB8fFxuICAgICAgICAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIpIHx8XG4gICAgICAgIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiKSB8fFxuICAgICAgICAoYmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIiksXG4gICAgICBgSW52YWxpZCBibG9ja2VyIHN0YXRlIHRyYW5zaXRpb246ICR7YmxvY2tlci5zdGF0ZX0gLT4gJHtuZXdCbG9ja2VyLnN0YXRlfWBcbiAgICApO1xuXG4gICAgc3RhdGUuYmxvY2tlcnMuc2V0KGtleSwgbmV3QmxvY2tlcik7XG4gICAgdXBkYXRlU3RhdGUoeyBibG9ja2VyczogbmV3IE1hcChzdGF0ZS5ibG9ja2VycykgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICBuZXh0TG9jYXRpb24sXG4gICAgaGlzdG9yeUFjdGlvbixcbiAgfToge1xuICAgIGN1cnJlbnRMb2NhdGlvbjogTG9jYXRpb247XG4gICAgbmV4dExvY2F0aW9uOiBMb2NhdGlvbjtcbiAgICBoaXN0b3J5QWN0aW9uOiBIaXN0b3J5QWN0aW9uO1xuICB9KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2Ugb255IHN1cHBvcnQgYSBzaW5nbGUgYWN0aXZlIGJsb2NrZXIgYXQgdGhlIG1vbWVudCBzaW5jZSB3ZSBkb24ndCBoYXZlXG4gICAgLy8gYW55IGNvbXBlbGxpbmcgdXNlIGNhc2VzIGZvciBtdWx0aS1ibG9ja2VyIHlldFxuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLnNpemUgPiAxKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCBcIkEgcm91dGVyIG9ubHkgc3VwcG9ydHMgb25lIGJsb2NrZXIgYXQgYSB0aW1lXCIpO1xuICAgIH1cblxuICAgIGxldCBlbnRyaWVzID0gQXJyYXkuZnJvbShibG9ja2VyRnVuY3Rpb25zLmVudHJpZXMoKSk7XG4gICAgbGV0IFtibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb25dID0gZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdO1xuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGJsb2NrZXJLZXkpO1xuXG4gICAgaWYgKGJsb2NrZXIgJiYgYmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIpIHtcbiAgICAgIC8vIElmIHRoZSBibG9ja2VyIGlzIGN1cnJlbnRseSBwcm9jZWVkaW5nLCB3ZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrXG4gICAgICAvLyBpdCBhbmQgY2FuIGxldCB0aGlzIG5hdmlnYXRpb24gY29udGludWVcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBrbm93IHdlJ3JlIHVuYmxvY2tlZC9ibG9ja2VkIHNvIHdlIG5lZWQgdG8gY2hlY2sgdGhlXG4gICAgLy8gdXNlci1wcm92aWRlZCBibG9ja2VyIGZ1bmN0aW9uXG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbih7IGN1cnJlbnRMb2NhdGlvbiwgbmV4dExvY2F0aW9uLCBoaXN0b3J5QWN0aW9uIH0pKSB7XG4gICAgICByZXR1cm4gYmxvY2tlcktleTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWxBY3RpdmVEZWZlcnJlZHMoXG4gICAgcHJlZGljYXRlPzogKHJvdXRlSWQ6IHN0cmluZykgPT4gYm9vbGVhblxuICApOiBzdHJpbmdbXSB7XG4gICAgbGV0IGNhbmNlbGxlZFJvdXRlSWRzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGFjdGl2ZURlZmVycmVkcy5mb3JFYWNoKChkZmQsIHJvdXRlSWQpID0+IHtcbiAgICAgIGlmICghcHJlZGljYXRlIHx8IHByZWRpY2F0ZShyb3V0ZUlkKSkge1xuICAgICAgICAvLyBDYW5jZWwgdGhlIGRlZmVycmVkIC0gYnV0IGRvIG5vdCByZW1vdmUgZnJvbSBhY3RpdmVEZWZlcnJlZHMgaGVyZSAtXG4gICAgICAgIC8vIHdlIHJlbHkgb24gdGhlIHN1YnNjcmliZXJzIHRvIGRvIHRoYXQgc28gb3VyIHRlc3RzIGNhbiBhc3NlcnQgcHJvcGVyXG4gICAgICAgIC8vIGNsZWFudXAgdmlhIF9pbnRlcm5hbEFjdGl2ZURlZmVycmVkc1xuICAgICAgICBkZmQuY2FuY2VsKCk7XG4gICAgICAgIGNhbmNlbGxlZFJvdXRlSWRzLnB1c2gocm91dGVJZCk7XG4gICAgICAgIGFjdGl2ZURlZmVycmVkcy5kZWxldGUocm91dGVJZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbmNlbGxlZFJvdXRlSWRzO1xuICB9XG5cbiAgLy8gT3B0IGluIHRvIGNhcHR1cmluZyBhbmQgcmVwb3J0aW5nIHNjcm9sbCBwb3NpdGlvbnMgZHVyaW5nIG5hdmlnYXRpb25zLFxuICAvLyB1c2VkIGJ5IHRoZSA8U2Nyb2xsUmVzdG9yYXRpb24+IGNvbXBvbmVudFxuICBmdW5jdGlvbiBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbihcbiAgICBwb3NpdGlvbnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXG4gICAgZ2V0UG9zaXRpb246IEdldFNjcm9sbFBvc2l0aW9uRnVuY3Rpb24sXG4gICAgZ2V0S2V5PzogR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvblxuICApIHtcbiAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICBnZXRTY3JvbGxQb3NpdGlvbiA9IGdldFBvc2l0aW9uO1xuICAgIGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5ID0gZ2V0S2V5IHx8ICgobG9jYXRpb24pID0+IGxvY2F0aW9uLmtleSk7XG5cbiAgICAvLyBQZXJmb3JtIGluaXRpYWwgaHlkcmF0aW9uIHNjcm9sbCByZXN0b3JhdGlvbiwgc2luY2Ugd2UgbWlzcyB0aGUgYm9hdCBvblxuICAgIC8vIHRoZSBpbml0aWFsIHVwZGF0ZVN0YXRlKCkgYmVjYXVzZSB3ZSd2ZSBub3QgeWV0IHJlbmRlcmVkIDxTY3JvbGxSZXN0b3JhdGlvbi8+XG4gICAgLy8gYW5kIHRoZXJlZm9yZSBoYXZlIG5vIHNhdmVkU2Nyb2xsUG9zaXRpb25zIGF2YWlsYWJsZVxuICAgIGlmICghaW5pdGlhbFNjcm9sbFJlc3RvcmVkICYmIHN0YXRlLm5hdmlnYXRpb24gPT09IElETEVfTkFWSUdBVElPTikge1xuICAgICAgaW5pdGlhbFNjcm9sbFJlc3RvcmVkID0gdHJ1ZTtcbiAgICAgIGxldCB5ID0gZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcyk7XG4gICAgICBpZiAoeSAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZVN0YXRlKHsgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiB5IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxSZXN0b3JhdGlvbktleSA9IG51bGw7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhdmVTY3JvbGxQb3NpdGlvbihcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdXG4gICk6IHZvaWQge1xuICAgIGlmIChzYXZlZFNjcm9sbFBvc2l0aW9ucyAmJiBnZXRTY3JvbGxSZXN0b3JhdGlvbktleSAmJiBnZXRTY3JvbGxQb3NpdGlvbikge1xuICAgICAgbGV0IHVzZXJNYXRjaGVzID0gbWF0Y2hlcy5tYXAoKG0pID0+XG4gICAgICAgIGNyZWF0ZVVzZU1hdGNoZXNNYXRjaChtLCBzdGF0ZS5sb2FkZXJEYXRhKVxuICAgICAgKTtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShsb2NhdGlvbiwgdXNlck1hdGNoZXMpIHx8IGxvY2F0aW9uLmtleTtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV0gPSBnZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNhdmVkU2Nyb2xsUG9zaXRpb24oXG4gICAgbG9jYXRpb246IExvY2F0aW9uLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXVxuICApOiBudW1iZXIgfCBudWxsIHtcbiAgICBpZiAoc2F2ZWRTY3JvbGxQb3NpdGlvbnMgJiYgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkgJiYgZ2V0U2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgIGxldCB1c2VyTWF0Y2hlcyA9IG1hdGNoZXMubWFwKChtKSA9PlxuICAgICAgICBjcmVhdGVVc2VNYXRjaGVzTWF0Y2gobSwgc3RhdGUubG9hZGVyRGF0YSlcbiAgICAgICk7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkobG9jYXRpb24sIHVzZXJNYXRjaGVzKSB8fCBsb2NhdGlvbi5rZXk7XG4gICAgICBsZXQgeSA9IHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV07XG4gICAgICBpZiAodHlwZW9mIHkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcm91dGVyID0ge1xuICAgIGdldCBiYXNlbmFtZSgpIHtcbiAgICAgIHJldHVybiBpbml0LmJhc2VuYW1lO1xuICAgIH0sXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgZ2V0IHJvdXRlcygpIHtcbiAgICAgIHJldHVybiBkYXRhUm91dGVzO1xuICAgIH0sXG4gICAgaW5pdGlhbGl6ZSxcbiAgICBzdWJzY3JpYmUsXG4gICAgZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24sXG4gICAgbmF2aWdhdGUsXG4gICAgZmV0Y2gsXG4gICAgcmV2YWxpZGF0ZSxcbiAgICAvLyBQYXNzdGhyb3VnaCB0byBoaXN0b3J5LWF3YXJlIGNyZWF0ZUhyZWYgdXNlZCBieSB1c2VIcmVmIHNvIHdlIGdldCBwcm9wZXJcbiAgICAvLyBoYXNoLWF3YXJlIFVSTHMgaW4gRE9NIHBhdGhzXG4gICAgY3JlYXRlSHJlZjogKHRvOiBUbykgPT4gaW5pdC5oaXN0b3J5LmNyZWF0ZUhyZWYodG8pLFxuICAgIGVuY29kZUxvY2F0aW9uOiAodG86IFRvKSA9PiBpbml0Lmhpc3RvcnkuZW5jb2RlTG9jYXRpb24odG8pLFxuICAgIGdldEZldGNoZXIsXG4gICAgZGVsZXRlRmV0Y2hlcixcbiAgICBkaXNwb3NlLFxuICAgIGdldEJsb2NrZXIsXG4gICAgZGVsZXRlQmxvY2tlcixcbiAgICBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzOiBmZXRjaENvbnRyb2xsZXJzLFxuICAgIF9pbnRlcm5hbEFjdGl2ZURlZmVycmVkczogYWN0aXZlRGVmZXJyZWRzLFxuICB9O1xuXG4gIHJldHVybiByb3V0ZXI7XG59XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBjcmVhdGVTdGF0aWNIYW5kbGVyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgY29uc3QgVU5TQUZFX0RFRkVSUkVEX1NZTUJPTCA9IFN5bWJvbChcImRlZmVycmVkXCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3RhdGljSGFuZGxlcihcbiAgcm91dGVzOiBBZ25vc3RpY1JvdXRlT2JqZWN0W10sXG4gIG9wdHM/OiB7XG4gICAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIH1cbik6IFN0YXRpY0hhbmRsZXIge1xuICBpbnZhcmlhbnQoXG4gICAgcm91dGVzLmxlbmd0aCA+IDAsXG4gICAgXCJZb3UgbXVzdCBwcm92aWRlIGEgbm9uLWVtcHR5IHJvdXRlcyBhcnJheSB0byBjcmVhdGVTdGF0aWNIYW5kbGVyXCJcbiAgKTtcblxuICBsZXQgZGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMocm91dGVzKTtcbiAgbGV0IGJhc2VuYW1lID0gKG9wdHMgPyBvcHRzLmJhc2VuYW1lIDogbnVsbCkgfHwgXCIvXCI7XG5cbiAgLyoqXG4gICAqIFRoZSBxdWVyeSgpIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgZG9jdW1lbnQgcmVxdWVzdHMsIGluIHdoaWNoIHdlIHdhbnQgdG9cbiAgICogY2FsbCBhbiBvcHRpb25hbCBhY3Rpb24gYW5kIHBvdGVudGlhbGx5IG11bHRpcGxlIGxvYWRlcnMgZm9yIGFsbCBuZXN0ZWRcbiAgICogcm91dGVzLiAgSXQgcmV0dXJucyBhIFN0YXRpY0hhbmRsZXJDb250ZXh0IG9iamVjdCwgd2hpY2ggaXMgdmVyeSBzaW1pbGFyXG4gICAqIHRvIHRoZSByb3V0ZXIgc3RhdGUgKGxvY2F0aW9uLCBsb2FkZXJEYXRhLCBhY3Rpb25EYXRhLCBlcnJvcnMsIGV0Yy4pIGFuZFxuICAgKiBhbHNvIGFkZHMgU1NSLXNwZWNpZmljIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHN0YXR1c0NvZGUgYW5kIGhlYWRlcnNcbiAgICogZnJvbSBhY3Rpb24vbG9hZGVycyBSZXNwb25zZXMuXG4gICAqXG4gICAqIEl0IF9zaG91bGRfIG5ldmVyIHRocm93IGFuZCBzaG91bGQgcmVwb3J0IGFsbCBlcnJvcnMgdGhyb3VnaCB0aGVcbiAgICogcmV0dXJuZWQgY29udGV4dC5lcnJvcnMgb2JqZWN0LCBwcm9wZXJseSBhc3NvY2lhdGluZyBlcnJvcnMgdG8gdGhlaXIgZXJyb3JcbiAgICogYm91bmRhcnkuICBBZGRpdGlvbmFsbHksIGl0IHRyYWNrcyBfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCB3aGljaCBjYW4gYmVcbiAgICogdXNlZCB0byBlbXVsYXRlIFJlYWN0IGVycm9yIGJvdW5kYXJpZXMgZHVyaW5nIFNTciBieSBwZXJmb3JtaW5nIGEgc2Vjb25kXG4gICAqIHBhc3Mgb25seSBkb3duIHRvIHRoZSBib3VuZGFyeUlkLlxuICAgKlxuICAgKiBUaGUgb25lIGV4Y2VwdGlvbiB3aGVyZSB3ZSBkbyBub3QgcmV0dXJuIGEgU3RhdGljSGFuZGxlckNvbnRleHQgaXMgd2hlbiBhXG4gICAqIHJlZGlyZWN0IHJlc3BvbnNlIGlzIHJldHVybmVkIG9yIHRocm93biBmcm9tIGFueSBhY3Rpb24vbG9hZGVyLiAgV2VcbiAgICogcHJvcGFnYXRlIHRoYXQgb3V0IGFuZCByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBzbyB0aGUgSFRUUCBzZXJ2ZXIgY2FuXG4gICAqIHJldHVybiBpdCBkaXJlY3RseS5cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5KFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgeyByZXF1ZXN0Q29udGV4dCB9OiB7IHJlcXVlc3RDb250ZXh0PzogdW5rbm93biB9ID0ge31cbiAgKTogUHJvbWlzZTxTdGF0aWNIYW5kbGVyQ29udGV4dCB8IFJlc3BvbnNlPiB7XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKFwiXCIsIGNyZWF0ZVBhdGgodXJsKSwgbnVsbCwgXCJkZWZhdWx0XCIpO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgbG9jYXRpb24sIGJhc2VuYW1lKTtcblxuICAgIC8vIFNTUiBzdXBwb3J0cyBIRUFEIHJlcXVlc3RzIHdoaWxlIFNQQSBkb2Vzbid0XG4gICAgaWYgKCFpc1ZhbGlkTWV0aG9kKG1ldGhvZCkgJiYgbWV0aG9kICE9PSBcImhlYWRcIikge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHsgbWV0aG9kIH0pO1xuICAgICAgbGV0IHsgbWF0Y2hlczogbWV0aG9kTm90QWxsb3dlZE1hdGNoZXMsIHJvdXRlIH0gPVxuICAgICAgICBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzOiBtZXRob2ROb3RBbGxvd2VkTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yLFxuICAgICAgICB9LFxuICAgICAgICBzdGF0dXNDb2RlOiBlcnJvci5zdGF0dXMsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsLFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgICBsZXQgeyBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsIHJvdXRlIH0gPVxuICAgICAgICBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvcixcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdHVzQ29kZTogZXJyb3Iuc3RhdHVzLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5SW1wbChyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQpO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gV2hlbiByZXR1cm5pbmcgU3RhdGljSGFuZGxlckNvbnRleHQsIHdlIHBhdGNoIGJhY2sgaW4gdGhlIGxvY2F0aW9uIGhlcmVcbiAgICAvLyBzaW5jZSB3ZSBuZWVkIGl0IGZvciBSZWFjdCBDb250ZXh0LiAgQnV0IHRoaXMgaGVscHMga2VlcCBvdXIgc3VibWl0IGFuZFxuICAgIC8vIGxvYWRSb3V0ZURhdGEgb3BlcmF0aW5nIG9uIGEgUmVxdWVzdCBpbnN0ZWFkIG9mIGEgTG9jYXRpb25cbiAgICByZXR1cm4geyBsb2NhdGlvbiwgYmFzZW5hbWUsIC4uLnJlc3VsdCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBxdWVyeVJvdXRlKCkgbWV0aG9kIGlzIGludGVuZGVkIGZvciB0YXJnZXRlZCByb3V0ZSByZXF1ZXN0cywgZWl0aGVyXG4gICAqIGZvciBmZXRjaCA/X2RhdGEgcmVxdWVzdHMgb3IgcmVzb3VyY2Ugcm91dGUgcmVxdWVzdHMuICBJbiB0aGlzIGNhc2UsIHdlXG4gICAqIGFyZSBvbmx5IGV2ZXIgY2FsbGluZyBhIHNpbmdsZSBhY3Rpb24gb3IgbG9hZGVyLCBhbmQgd2UgYXJlIHJldHVybmluZyB0aGVcbiAgICogcmV0dXJuZWQgdmFsdWUgZGlyZWN0bHkuICBJbiBtb3N0IGNhc2VzLCB0aGlzIHdpbGwgYmUgYSBSZXNwb25zZSByZXR1cm5lZFxuICAgKiBmcm9tIHRoZSBhY3Rpb24vbG9hZGVyLCBidXQgaXQgbWF5IGJlIGEgcHJpbWl0aXZlIG9yIG90aGVyIHZhbHVlIGFzIHdlbGwgLVxuICAgKiBhbmQgaW4gc3VjaCBjYXNlcyB0aGUgY2FsbGluZyBjb250ZXh0IHNob3VsZCBoYW5kbGUgdGhhdCBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogV2UgZG8gcmVzcGVjdCB0aGUgdGhyb3cvcmV0dXJuIGRpZmZlcmVudGlhdGlvbiwgc28gaWYgYW4gYWN0aW9uL2xvYWRlclxuICAgKiB0aHJvd3MsIHRoZW4gdGhpcyBtZXRob2Qgd2lsbCB0aHJvdyB0aGUgdmFsdWUuICBUaGlzIGlzIGltcG9ydGFudCBzbyB3ZVxuICAgKiBjYW4gZG8gcHJvcGVyIGJvdW5kYXJ5IGlkZW50aWZpY2F0aW9uIGluIFJlbWl4IHdoZXJlIGEgdGhyb3duIFJlc3BvbnNlXG4gICAqIG11c3QgZ28gdG8gdGhlIENhdGNoIEJvdW5kYXJ5IGJ1dCBhIHJldHVybmVkIFJlc3BvbnNlIGlzIGhhcHB5LXBhdGguXG4gICAqXG4gICAqIE9uZSB0aGluZyB0byBub3RlIGlzIHRoYXQgYW55IFJvdXRlci1pbml0aWF0ZWQgRXJyb3JzIHRoYXQgbWFrZSBzZW5zZVxuICAgKiB0byBhc3NvY2lhdGUgd2l0aCBhIHN0YXR1cyBjb2RlIHdpbGwgYmUgdGhyb3duIGFzIGFuIEVycm9yUmVzcG9uc2VcbiAgICogaW5zdGFuY2Ugd2hpY2ggaW5jbHVkZSB0aGUgcmF3IEVycm9yLCBzdWNoIHRoYXQgdGhlIGNhbGxpbmcgY29udGV4dCBjYW5cbiAgICogc2VyaWFsaXplIHRoZSBlcnJvciBhcyB0aGV5IHNlZSBmaXQgd2hpbGUgaW5jbHVkaW5nIHRoZSBwcm9wZXIgcmVzcG9uc2VcbiAgICogY29kZS4gIEV4YW1wbGVzIGhlcmUgYXJlIDQwNCBhbmQgNDA1IGVycm9ycyB0aGF0IG9jY3VyIHByaW9yIHRvIHJlYWNoaW5nXG4gICAqIGFueSB1c2VyLWRlZmluZWQgbG9hZGVycy5cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5Um91dGUoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICB7XG4gICAgICByb3V0ZUlkLFxuICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgfTogeyByZXF1ZXN0Q29udGV4dD86IHVua25vd247IHJvdXRlSWQ/OiBzdHJpbmcgfSA9IHt9XG4gICk6IFByb21pc2U8YW55PiB7XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKFwiXCIsIGNyZWF0ZVBhdGgodXJsKSwgbnVsbCwgXCJkZWZhdWx0XCIpO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgbG9jYXRpb24sIGJhc2VuYW1lKTtcblxuICAgIC8vIFNTUiBzdXBwb3J0cyBIRUFEIHJlcXVlc3RzIHdoaWxlIFNQQSBkb2Vzbid0XG4gICAgaWYgKCFpc1ZhbGlkTWV0aG9kKG1ldGhvZCkgJiYgbWV0aG9kICE9PSBcImhlYWRcIiAmJiBtZXRob2QgIT09IFwib3B0aW9uc1wiKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwgeyBtZXRob2QgfSk7XG4gICAgfSBlbHNlIGlmICghbWF0Y2hlcykge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lIH0pO1xuICAgIH1cblxuICAgIGxldCBtYXRjaCA9IHJvdXRlSWRcbiAgICAgID8gbWF0Y2hlcy5maW5kKChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKVxuICAgICAgOiBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbik7XG5cbiAgICBpZiAocm91dGVJZCAmJiAhbWF0Y2gpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAzLCB7XG4gICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgcm91dGVJZCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoaXQgSSBkb24ndCB0aGluaz9cbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSB9KTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcXVlcnlJbXBsKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgbWF0Y2hcbiAgICApO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbGV0IGVycm9yID0gcmVzdWx0LmVycm9ycyA/IE9iamVjdC52YWx1ZXMocmVzdWx0LmVycm9ycylbMF0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIElmIHdlIGdvdCBiYWNrIHJlc3VsdC5lcnJvcnMsIHRoYXQgbWVhbnMgdGhlIGxvYWRlci9hY3Rpb24gdGhyZXdcbiAgICAgIC8vIF9zb21ldGhpbmdfIHRoYXQgd2Fzbid0IGEgUmVzcG9uc2UsIGJ1dCBpdCdzIG5vdCBndWFyYW50ZWVkL3JlcXVpcmVkXG4gICAgICAvLyB0byBiZSBhbiBgaW5zdGFuY2VvZiBFcnJvcmAgZWl0aGVyLCBzbyB3ZSBoYXZlIHRvIHVzZSB0aHJvdyBoZXJlIHRvXG4gICAgICAvLyBwcmVzZXJ2ZSB0aGUgXCJlcnJvclwiIHN0YXRlIG91dHNpZGUgb2YgcXVlcnlJbXBsLlxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gUGljayBvZmYgdGhlIHJpZ2h0IHN0YXRlIHZhbHVlIHRvIHJldHVyblxuICAgIGlmIChyZXN1bHQuYWN0aW9uRGF0YSkge1xuICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocmVzdWx0LmFjdGlvbkRhdGEpWzBdO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQubG9hZGVyRGF0YSkge1xuICAgICAgbGV0IGRhdGEgPSBPYmplY3QudmFsdWVzKHJlc3VsdC5sb2FkZXJEYXRhKVswXTtcbiAgICAgIGlmIChyZXN1bHQuYWN0aXZlRGVmZXJyZWRzPy5bbWF0Y2gucm91dGUuaWRdKSB7XG4gICAgICAgIGRhdGFbVU5TQUZFX0RFRkVSUkVEX1NZTUJPTF0gPSByZXN1bHQuYWN0aXZlRGVmZXJyZWRzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBxdWVyeUltcGwoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIHJlcXVlc3RDb250ZXh0OiB1bmtub3duLFxuICAgIHJvdXRlTWF0Y2g/OiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoXG4gICk6IFByb21pc2U8T21pdDxTdGF0aWNIYW5kbGVyQ29udGV4dCwgXCJsb2NhdGlvblwiIHwgXCJiYXNlbmFtZVwiPiB8IFJlc3BvbnNlPiB7XG4gICAgaW52YXJpYW50KFxuICAgICAgcmVxdWVzdC5zaWduYWwsXG4gICAgICBcInF1ZXJ5KCkvcXVlcnlSb3V0ZSgpIHJlcXVlc3RzIG11c3QgY29udGFpbiBhbiBBYm9ydENvbnRyb2xsZXIgc2lnbmFsXCJcbiAgICApO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc011dGF0aW9uTWV0aG9kKHJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBzdWJtaXQoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIHJvdXRlTWF0Y2ggfHwgZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pLFxuICAgICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICAgIHJvdXRlTWF0Y2ggIT0gbnVsbFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgbG9hZFJvdXRlRGF0YShcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgIHJvdXRlTWF0Y2hcbiAgICAgICk7XG4gICAgICByZXR1cm4gaXNSZXNwb25zZShyZXN1bHQpXG4gICAgICAgID8gcmVzdWx0XG4gICAgICAgIDoge1xuICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9LFxuICAgICAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdGhyZXcvcmV0dXJuZWQgYSBSZXNwb25zZSBpbiBjYWxsTG9hZGVyT3JBY3Rpb24sIHdlIHRocm93XG4gICAgICAvLyBpdCB0byBiYWlsIG91dCBhbmQgdGhlbiByZXR1cm4gb3IgdGhyb3cgaGVyZSBiYXNlZCBvbiB3aGV0aGVyIHRoZSB1c2VyXG4gICAgICAvLyByZXR1cm5lZCBvciB0aHJld1xuICAgICAgaWYgKGlzUXVlcnlSb3V0ZVJlc3BvbnNlKGUpKSB7XG4gICAgICAgIGlmIChlLnR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3IgJiYgIWlzUmVkaXJlY3RSZXNwb25zZShlLnJlc3BvbnNlKSkge1xuICAgICAgICAgIHRocm93IGUucmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUucmVzcG9uc2U7XG4gICAgICB9XG4gICAgICAvLyBSZWRpcmVjdHMgYXJlIGFsd2F5cyByZXR1cm5lZCBzaW5jZSB0aGV5IGRvbid0IHByb3BhZ2F0ZSB0byBjYXRjaFxuICAgICAgLy8gYm91bmRhcmllc1xuICAgICAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShlKSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gc3VibWl0KFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIGFjdGlvbk1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICAgIHJlcXVlc3RDb250ZXh0OiB1bmtub3duLFxuICAgIGlzUm91dGVSZXF1ZXN0OiBib29sZWFuXG4gICk6IFByb21pc2U8T21pdDxTdGF0aWNIYW5kbGVyQ29udGV4dCwgXCJsb2NhdGlvblwiIHwgXCJiYXNlbmFtZVwiPiB8IFJlc3BvbnNlPiB7XG4gICAgbGV0IHJlc3VsdDogRGF0YVJlc3VsdDtcblxuICAgIGlmICghYWN0aW9uTWF0Y2gucm91dGUuYWN0aW9uKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IGFjdGlvbk1hdGNoLnJvdXRlLmlkLFxuICAgICAgfSk7XG4gICAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgICBcImFjdGlvblwiLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBhY3Rpb25NYXRjaCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgIHRydWUsXG4gICAgICAgIGlzUm91dGVSZXF1ZXN0LFxuICAgICAgICByZXF1ZXN0Q29udGV4dFxuICAgICAgKTtcblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgbGV0IG1ldGhvZCA9IGlzUm91dGVSZXF1ZXN0ID8gXCJxdWVyeVJvdXRlXCIgOiBcInF1ZXJ5XCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHttZXRob2R9KCkgY2FsbCBhYm9ydGVkYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gVWhoaGggLSB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIHdlIHNob3VsZCBhbHdheXMgdGhyb3cgdGhlc2UgZnJvbVxuICAgICAgLy8gY2FsbExvYWRlck9yQWN0aW9uLCBidXQgdGhlIHR5cGUgbmFycm93aW5nIGhlcmUga2VlcHMgVFMgaGFwcHkgYW5kIHdlXG4gICAgICAvLyBjYW4gZ2V0IGJhY2sgb24gdGhlIFwidGhyb3cgYWxsIHJlZGlyZWN0IHJlc3BvbnNlc1wiIHRyYWluIGhlcmUgc2hvdWxkXG4gICAgICAvLyB0aGlzIGV2ZXIgaGFwcGVuIDovXG4gICAgICB0aHJvdyBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBzdGF0dXM6IHJlc3VsdC5zdGF0dXMsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogcmVzdWx0LmxvY2F0aW9uLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHsgdHlwZTogXCJkZWZlci1hY3Rpb25cIiB9KTtcbiAgICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgZXJyb3IsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgLy8gTm90ZTogVGhpcyBzaG91bGQgb25seSBiZSBub24tUmVzcG9uc2UgdmFsdWVzIGlmIHdlIGdldCBoZXJlLCBzaW5jZVxuICAgICAgLy8gaXNSb3V0ZVJlcXVlc3Qgc2hvdWxkIHRocm93IGFueSBSZXNwb25zZSByZWNlaXZlZCBpbiBjYWxsTG9hZGVyT3JBY3Rpb25cbiAgICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzOiBbYWN0aW9uTWF0Y2hdLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YTogeyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YSB9LFxuICAgICAgICBlcnJvcnM6IG51bGwsXG4gICAgICAgIC8vIE5vdGU6IHN0YXR1c0NvZGUgKyBoZWFkZXJzIGFyZSB1bnVzZWQgaGVyZSBzaW5jZSBxdWVyeVJvdXRlIHdpbGxcbiAgICAgICAgLy8gcmV0dXJuIHRoZSByYXcgUmVzcG9uc2Ugb3IgdmFsdWVcbiAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gU3RvcmUgb2ZmIHRoZSBwZW5kaW5nIGVycm9yIC0gd2UgdXNlIGl0IHRvIGRldGVybWluZSB3aGljaCBsb2FkZXJzXG4gICAgICAvLyB0byBjYWxsIGFuZCB3aWxsIGNvbW1pdCBpdCB3aGVuIHdlIGNvbXBsZXRlIHRoZSBuYXZpZ2F0aW9uXG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgYWN0aW9uTWF0Y2gucm91dGUuaWQpO1xuICAgICAgbGV0IGNvbnRleHQgPSBhd2FpdCBsb2FkUm91dGVEYXRhKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB7XG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3IsXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIC8vIGFjdGlvbiBzdGF0dXMgY29kZXMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgbG9hZGVyIHN0YXR1cyBjb2Rlc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgc3RhdHVzQ29kZTogaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LmVycm9yKVxuICAgICAgICAgID8gcmVzdWx0LmVycm9yLnN0YXR1c1xuICAgICAgICAgIDogNTAwLFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7XG4gICAgICAgICAgLi4uKHJlc3VsdC5oZWFkZXJzID8geyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuaGVhZGVycyB9IDoge30pLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBHRVQgcmVxdWVzdCBmb3IgdGhlIGxvYWRlcnNcbiAgICBsZXQgbG9hZGVyUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QudXJsLCB7XG4gICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXG4gICAgICByZWRpcmVjdDogcmVxdWVzdC5yZWRpcmVjdCxcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWwsXG4gICAgfSk7XG4gICAgbGV0IGNvbnRleHQgPSBhd2FpdCBsb2FkUm91dGVEYXRhKGxvYWRlclJlcXVlc3QsIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0KTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5jb250ZXh0LFxuICAgICAgLy8gYWN0aW9uIHN0YXR1cyBjb2RlcyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBsb2FkZXIgc3RhdHVzIGNvZGVzXG4gICAgICAuLi4ocmVzdWx0LnN0YXR1c0NvZGUgPyB7IHN0YXR1c0NvZGU6IHJlc3VsdC5zdGF0dXNDb2RlIH0gOiB7fSksXG4gICAgICBhY3Rpb25EYXRhOiB7XG4gICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhLFxuICAgICAgfSxcbiAgICAgIGFjdGlvbkhlYWRlcnM6IHtcbiAgICAgICAgLi4uKHJlc3VsdC5oZWFkZXJzID8geyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuaGVhZGVycyB9IDoge30pLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gbG9hZFJvdXRlRGF0YShcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICByZXF1ZXN0Q29udGV4dDogdW5rbm93bixcbiAgICByb3V0ZU1hdGNoPzogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgICBwZW5kaW5nQWN0aW9uRXJyb3I/OiBSb3V0ZURhdGFcbiAgKTogUHJvbWlzZTxcbiAgICB8IE9taXQ8XG4gICAgICAgIFN0YXRpY0hhbmRsZXJDb250ZXh0LFxuICAgICAgICBcImxvY2F0aW9uXCIgfCBcImJhc2VuYW1lXCIgfCBcImFjdGlvbkRhdGFcIiB8IFwiYWN0aW9uSGVhZGVyc1wiXG4gICAgICA+XG4gICAgfCBSZXNwb25zZVxuICA+IHtcbiAgICBsZXQgaXNSb3V0ZVJlcXVlc3QgPSByb3V0ZU1hdGNoICE9IG51bGw7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHdlIGhhdmUgbm8gbG9hZGVycyB0byBydW4gKHF1ZXJ5Um91dGUoKSlcbiAgICBpZiAoaXNSb3V0ZVJlcXVlc3QgJiYgIXJvdXRlTWF0Y2g/LnJvdXRlLmxvYWRlcikge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHtcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgcGF0aG5hbWU6IG5ldyBVUkwocmVxdWVzdC51cmwpLnBhdGhuYW1lLFxuICAgICAgICByb3V0ZUlkOiByb3V0ZU1hdGNoPy5yb3V0ZS5pZCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCByZXF1ZXN0TWF0Y2hlcyA9IHJvdXRlTWF0Y2hcbiAgICAgID8gW3JvdXRlTWF0Y2hdXG4gICAgICA6IGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgT2JqZWN0LmtleXMocGVuZGluZ0FjdGlvbkVycm9yIHx8IHt9KVswXVxuICAgICAgICApO1xuICAgIGxldCBtYXRjaGVzVG9Mb2FkID0gcmVxdWVzdE1hdGNoZXMuZmlsdGVyKChtKSA9PiBtLnJvdXRlLmxvYWRlcik7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHdlIGhhdmUgbm8gbG9hZGVycyB0byBydW4gKHF1ZXJ5KCkpXG4gICAgaWYgKG1hdGNoZXNUb0xvYWQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICAvLyBBZGQgYSBudWxsIGZvciBhbGwgbWF0Y2hlZCByb3V0ZXMgZm9yIHByb3BlciByZXZhbGlkYXRpb24gb24gdGhlIGNsaWVudFxuICAgICAgICBsb2FkZXJEYXRhOiBtYXRjaGVzLnJlZHVjZShcbiAgICAgICAgICAoYWNjLCBtKSA9PiBPYmplY3QuYXNzaWduKGFjYywgeyBbbS5yb3V0ZS5pZF06IG51bGwgfSksXG4gICAgICAgICAge31cbiAgICAgICAgKSxcbiAgICAgICAgZXJyb3JzOiBwZW5kaW5nQWN0aW9uRXJyb3IgfHwgbnVsbCxcbiAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIC4uLm1hdGNoZXNUb0xvYWQubWFwKChtYXRjaCkgPT5cbiAgICAgICAgY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgICAgIFwibG9hZGVyXCIsXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIGJhc2VuYW1lLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgaXNSb3V0ZVJlcXVlc3QsXG4gICAgICAgICAgcmVxdWVzdENvbnRleHRcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICBdKTtcblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBsZXQgbWV0aG9kID0gaXNSb3V0ZVJlcXVlc3QgPyBcInF1ZXJ5Um91dGVcIiA6IFwicXVlcnlcIjtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHttZXRob2R9KCkgY2FsbCBhYm9ydGVkYCk7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBhbmQgY29tbWl0IG91dHB1dCBmcm9tIGxvYWRlcnNcbiAgICBsZXQgYWN0aXZlRGVmZXJyZWRzID0gbmV3IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT4oKTtcbiAgICBsZXQgY29udGV4dCA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gICAgICBtYXRjaGVzLFxuICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgIHJlc3VsdHMsXG4gICAgICBwZW5kaW5nQWN0aW9uRXJyb3IsXG4gICAgICBhY3RpdmVEZWZlcnJlZHNcbiAgICApO1xuXG4gICAgLy8gQWRkIGEgbnVsbCBmb3IgYW55IG5vbi1sb2FkZXIgbWF0Y2hlcyBmb3IgcHJvcGVyIHJldmFsaWRhdGlvbiBvbiB0aGUgY2xpZW50XG4gICAgbGV0IGV4ZWN1dGVkTG9hZGVycyA9IG5ldyBTZXQ8c3RyaW5nPihcbiAgICAgIG1hdGNoZXNUb0xvYWQubWFwKChtYXRjaCkgPT4gbWF0Y2gucm91dGUuaWQpXG4gICAgKTtcbiAgICBtYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgICBpZiAoIWV4ZWN1dGVkTG9hZGVycy5oYXMobWF0Y2gucm91dGUuaWQpKSB7XG4gICAgICAgIGNvbnRleHQubG9hZGVyRGF0YVttYXRjaC5yb3V0ZS5pZF0gPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICBtYXRjaGVzLFxuICAgICAgYWN0aXZlRGVmZXJyZWRzOlxuICAgICAgICBhY3RpdmVEZWZlcnJlZHMuc2l6ZSA+IDBcbiAgICAgICAgICA/IE9iamVjdC5mcm9tRW50cmllcyhhY3RpdmVEZWZlcnJlZHMuZW50cmllcygpKVxuICAgICAgICAgIDogbnVsbCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhUm91dGVzLFxuICAgIHF1ZXJ5LFxuICAgIHF1ZXJ5Um91dGUsXG4gIH07XG59XG5cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIEhlbHBlcnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogR2l2ZW4gYW4gZXhpc3RpbmcgU3RhdGljSGFuZGxlckNvbnRleHQgYW5kIGFuIGVycm9yIHRocm93biBhdCByZW5kZXIgdGltZSxcbiAqIHByb3ZpZGUgYW4gdXBkYXRlZCBTdGF0aWNIYW5kbGVyQ29udGV4dCBzdWl0YWJsZSBmb3IgYSBzZWNvbmQgU1NSIHJlbmRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvcihcbiAgcm91dGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdLFxuICBjb250ZXh0OiBTdGF0aWNIYW5kbGVyQ29udGV4dCxcbiAgZXJyb3I6IGFueVxuKSB7XG4gIGxldCBuZXdDb250ZXh0OiBTdGF0aWNIYW5kbGVyQ29udGV4dCA9IHtcbiAgICAuLi5jb250ZXh0LFxuICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICBlcnJvcnM6IHtcbiAgICAgIFtjb250ZXh0Ll9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIHx8IHJvdXRlc1swXS5pZF06IGVycm9yLFxuICAgIH0sXG4gIH07XG4gIHJldHVybiBuZXdDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBpc1N1Ym1pc3Npb25OYXZpZ2F0aW9uKFxuICBvcHRzOiBSb3V0ZXJOYXZpZ2F0ZU9wdGlvbnNcbik6IG9wdHMgaXMgU3VibWlzc2lvbk5hdmlnYXRlT3B0aW9ucyB7XG4gIHJldHVybiBvcHRzICE9IG51bGwgJiYgXCJmb3JtRGF0YVwiIGluIG9wdHM7XG59XG5cbi8vIE5vcm1hbGl6ZSBuYXZpZ2F0aW9uIG9wdGlvbnMgYnkgY29udmVydGluZyBmb3JtTWV0aG9kPUdFVCBmb3JtRGF0YSBvYmplY3RzIHRvXG4vLyBVUkxTZWFyY2hQYXJhbXMgc28gdGhleSBiZWhhdmUgaWRlbnRpY2FsbHkgdG8gbGlua3Mgd2l0aCBxdWVyeSBwYXJhbXNcbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhcbiAgdG86IFRvLFxuICBvcHRzPzogUm91dGVyTmF2aWdhdGVPcHRpb25zLFxuICBpc0ZldGNoZXIgPSBmYWxzZVxuKToge1xuICBwYXRoOiBzdHJpbmc7XG4gIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uO1xuICBlcnJvcj86IEVycm9yUmVzcG9uc2U7XG59IHtcbiAgbGV0IHBhdGggPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuXG4gIC8vIFJldHVybiBsb2NhdGlvbiB2ZXJiYXRpbSBvbiBub24tc3VibWlzc2lvbiBuYXZpZ2F0aW9uc1xuICBpZiAoIW9wdHMgfHwgIWlzU3VibWlzc2lvbk5hdmlnYXRpb24ob3B0cykpIHtcbiAgICByZXR1cm4geyBwYXRoIH07XG4gIH1cblxuICBpZiAob3B0cy5mb3JtTWV0aG9kICYmICFpc1ZhbGlkTWV0aG9kKG9wdHMuZm9ybU1ldGhvZCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aCxcbiAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwgeyBtZXRob2Q6IG9wdHMuZm9ybU1ldGhvZCB9KSxcbiAgICB9O1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgU3VibWlzc2lvbiBvbiBub24tR0VUIG5hdmlnYXRpb25zXG4gIGxldCBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uIHwgdW5kZWZpbmVkO1xuICBpZiAob3B0cy5mb3JtRGF0YSkge1xuICAgIHN1Ym1pc3Npb24gPSB7XG4gICAgICBmb3JtTWV0aG9kOiBvcHRzLmZvcm1NZXRob2QgfHwgXCJnZXRcIixcbiAgICAgIGZvcm1BY3Rpb246IHN0cmlwSGFzaEZyb21QYXRoKHBhdGgpLFxuICAgICAgZm9ybUVuY1R5cGU6XG4gICAgICAgIChvcHRzICYmIG9wdHMuZm9ybUVuY1R5cGUpIHx8IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gICAgICBmb3JtRGF0YTogb3B0cy5mb3JtRGF0YSxcbiAgICB9O1xuXG4gICAgaWYgKGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgICAgcmV0dXJuIHsgcGF0aCwgc3VibWlzc2lvbiB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIEZsYXR0ZW4gc3VibWlzc2lvbiBvbnRvIFVSTFNlYXJjaFBhcmFtcyBmb3IgR0VUIHN1Ym1pc3Npb25zXG4gIGxldCBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKHBhdGgpO1xuICBsZXQgc2VhcmNoUGFyYW1zID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMob3B0cy5mb3JtRGF0YSk7XG4gIC8vIFNpbmNlIGZldGNoZXIgR0VUIHN1Ym1pc3Npb25zIG9ubHkgcnVuIGEgc2luZ2xlIGxvYWRlciAoYXMgb3Bwb3NlZCB0b1xuICAvLyBuYXZpZ2F0aW9uIEdFVCBzdWJtaXNzaW9ucyB3aGljaCBydW4gYWxsIGxvYWRlcnMpLCB3ZSBuZWVkIHRvIHByZXNlcnZlXG4gIC8vIGFueSBpbmNvbWluZyA/aW5kZXggcGFyYW1zXG4gIGlmIChpc0ZldGNoZXIgJiYgcGFyc2VkUGF0aC5zZWFyY2ggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHBhcnNlZFBhdGguc2VhcmNoKSkge1xuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCBcIlwiKTtcbiAgfVxuICBwYXJzZWRQYXRoLnNlYXJjaCA9IGA/JHtzZWFyY2hQYXJhbXN9YDtcblxuICByZXR1cm4geyBwYXRoOiBjcmVhdGVQYXRoKHBhcnNlZFBhdGgpLCBzdWJtaXNzaW9uIH07XG59XG5cbi8vIEZpbHRlciBvdXQgYWxsIHJvdXRlcyBiZWxvdyBhbnkgY2F1Z2h0IGVycm9yIGFzIHRoZXkgYXJlbid0IGdvaW5nIHRvXG4vLyByZW5kZXIgc28gd2UgZG9uJ3QgbmVlZCB0byBsb2FkIHRoZW1cbmZ1bmN0aW9uIGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIGJvdW5kYXJ5SWQ/OiBzdHJpbmdcbikge1xuICBsZXQgYm91bmRhcnlNYXRjaGVzID0gbWF0Y2hlcztcbiAgaWYgKGJvdW5kYXJ5SWQpIHtcbiAgICBsZXQgaW5kZXggPSBtYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gYm91bmRhcnlJZCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGJvdW5kYXJ5TWF0Y2hlcyA9IG1hdGNoZXMuc2xpY2UoMCwgaW5kZXgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRhcnlNYXRjaGVzO1xufVxuXG5mdW5jdGlvbiBnZXRNYXRjaGVzVG9Mb2FkKFxuICBoaXN0b3J5OiBIaXN0b3J5LFxuICBzdGF0ZTogUm91dGVyU3RhdGUsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgc3VibWlzc2lvbjogU3VibWlzc2lvbiB8IHVuZGVmaW5lZCxcbiAgbG9jYXRpb246IExvY2F0aW9uLFxuICBpc1JldmFsaWRhdGlvblJlcXVpcmVkOiBib29sZWFuLFxuICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlczogc3RyaW5nW10sXG4gIGNhbmNlbGxlZEZldGNoZXJMb2Fkczogc3RyaW5nW10sXG4gIHBlbmRpbmdBY3Rpb25EYXRhPzogUm91dGVEYXRhLFxuICBwZW5kaW5nRXJyb3I/OiBSb3V0ZURhdGEsXG4gIGZldGNoTG9hZE1hdGNoZXM/OiBNYXA8c3RyaW5nLCBGZXRjaExvYWRNYXRjaD5cbik6IFtBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sIFJldmFsaWRhdGluZ0ZldGNoZXJbXV0ge1xuICBsZXQgYWN0aW9uUmVzdWx0ID0gcGVuZGluZ0Vycm9yXG4gICAgPyBPYmplY3QudmFsdWVzKHBlbmRpbmdFcnJvcilbMF1cbiAgICA6IHBlbmRpbmdBY3Rpb25EYXRhXG4gICAgPyBPYmplY3QudmFsdWVzKHBlbmRpbmdBY3Rpb25EYXRhKVswXVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGxldCBjdXJyZW50VXJsID0gaGlzdG9yeS5jcmVhdGVVUkwoc3RhdGUubG9jYXRpb24pO1xuICBsZXQgbmV4dFVybCA9IGhpc3RvcnkuY3JlYXRlVVJMKGxvY2F0aW9uKTtcblxuICBsZXQgZGVmYXVsdFNob3VsZFJldmFsaWRhdGUgPVxuICAgIC8vIEZvcmNlZCByZXZhbGlkYXRpb24gZHVlIHRvIHN1Ym1pc3Npb24sIHVzZVJldmFsaWRhdGUsIG9yIFgtUmVtaXgtUmV2YWxpZGF0ZVxuICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgfHxcbiAgICAvLyBDbGlja2VkIHRoZSBzYW1lIGxpbmssIHJlc3VibWl0dGVkIGEgR0VUIGZvcm1cbiAgICBjdXJyZW50VXJsLnRvU3RyaW5nKCkgPT09IG5leHRVcmwudG9TdHJpbmcoKSB8fFxuICAgIC8vIFNlYXJjaCBwYXJhbXMgYWZmZWN0IGFsbCBsb2FkZXJzXG4gICAgY3VycmVudFVybC5zZWFyY2ggIT09IG5leHRVcmwuc2VhcmNoO1xuXG4gIC8vIFBpY2sgbmF2aWdhdGlvbiBtYXRjaGVzIHRoYXQgYXJlIG5ldC1uZXcgb3IgcXVhbGlmeSBmb3IgcmV2YWxpZGF0aW9uXG4gIGxldCBib3VuZGFyeUlkID0gcGVuZGluZ0Vycm9yID8gT2JqZWN0LmtleXMocGVuZGluZ0Vycm9yKVswXSA6IHVuZGVmaW5lZDtcbiAgbGV0IGJvdW5kYXJ5TWF0Y2hlcyA9IGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KG1hdGNoZXMsIGJvdW5kYXJ5SWQpO1xuXG4gIGxldCBuYXZpZ2F0aW9uTWF0Y2hlcyA9IGJvdW5kYXJ5TWF0Y2hlcy5maWx0ZXIoKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGlmIChtYXRjaC5yb3V0ZS5sb2FkZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyBjYWxsIHRoZSBsb2FkZXIgb24gbmV3IHJvdXRlIGluc3RhbmNlcyBhbmQgcGVuZGluZyBkZWZlciBjYW5jZWxsYXRpb25zXG4gICAgaWYgKFxuICAgICAgaXNOZXdMb2FkZXIoc3RhdGUubG9hZGVyRGF0YSwgc3RhdGUubWF0Y2hlc1tpbmRleF0sIG1hdGNoKSB8fFxuICAgICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMuc29tZSgoaWQpID0+IGlkID09PSBtYXRjaC5yb3V0ZS5pZClcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIHdoZW4gd2UgcmV2YWxpZGF0ZS4gIElmIHRoZSByb3V0ZVxuICAgIC8vIHByb3ZpZGVzIGl0J3Mgb3duIGltcGxlbWVudGF0aW9uLCB0aGVuIHdlIGdpdmUgdGhlbSBmdWxsIGNvbnRyb2wgYnV0XG4gICAgLy8gcHJvdmlkZSB0aGlzIHZhbHVlIHNvIHRoZXkgY2FuIGxldmVyYWdlIGl0IGlmIG5lZWRlZCBhZnRlciB0aGV5IGNoZWNrXG4gICAgLy8gdGhlaXIgb3duIHNwZWNpZmljIHVzZSBjYXNlc1xuICAgIGxldCBjdXJyZW50Um91dGVNYXRjaCA9IHN0YXRlLm1hdGNoZXNbaW5kZXhdO1xuICAgIGxldCBuZXh0Um91dGVNYXRjaCA9IG1hdGNoO1xuXG4gICAgcmV0dXJuIHNob3VsZFJldmFsaWRhdGVMb2FkZXIobWF0Y2gsIHtcbiAgICAgIGN1cnJlbnRVcmwsXG4gICAgICBjdXJyZW50UGFyYW1zOiBjdXJyZW50Um91dGVNYXRjaC5wYXJhbXMsXG4gICAgICBuZXh0VXJsLFxuICAgICAgbmV4dFBhcmFtczogbmV4dFJvdXRlTWF0Y2gucGFyYW1zLFxuICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOlxuICAgICAgICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZSB8fFxuICAgICAgICBpc05ld1JvdXRlSW5zdGFuY2UoY3VycmVudFJvdXRlTWF0Y2gsIG5leHRSb3V0ZU1hdGNoKSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gUGljayBmZXRjaGVyLmxvYWRzIHRoYXQgbmVlZCB0byBiZSByZXZhbGlkYXRlZFxuICBsZXQgcmV2YWxpZGF0aW5nRmV0Y2hlcnM6IFJldmFsaWRhdGluZ0ZldGNoZXJbXSA9IFtdO1xuICBmZXRjaExvYWRNYXRjaGVzICYmXG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5mb3JFYWNoKChmLCBrZXkpID0+IHtcbiAgICAgIGlmICghbWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmlkID09PSBmLnJvdXRlSWQpKSB7XG4gICAgICAgIC8vIFRoaXMgZmV0Y2hlciBpcyBub3QgZ29pbmcgdG8gYmUgcHJlc2VudCBpbiB0aGUgc3Vic2VxdWVudCByZW5kZXIgc29cbiAgICAgICAgLy8gdGhlcmUncyBubyBuZWVkIHRvIHJldmFsaWRhdGUgaXRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChjYW5jZWxsZWRGZXRjaGVyTG9hZHMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAvLyBUaGlzIGZldGNoZXIgd2FzIGNhbmNlbGxlZCBmcm9tIGEgcHJpb3IgYWN0aW9uIHN1Ym1pc3Npb24gLSBmb3JjZSByZWxvYWRcbiAgICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMucHVzaCh7IGtleSwgLi4uZiB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldmFsaWRhdGluZyBmZXRjaGVycyBhcmUgZGVjb3VwbGVkIGZyb20gdGhlIHJvdXRlIG1hdGNoZXMgc2luY2UgdGhleVxuICAgICAgICAvLyBoaXQgYSBzdGF0aWMgaHJlZiwgc28gdGhleSBfYWx3YXlzXyBjaGVjayBzaG91bGRSZXZhbGlkYXRlIGFuZCB0aGVcbiAgICAgICAgLy8gZGVmYXVsdCBpcyBzdHJpY3RseSBpZiBhIHJldmFsaWRhdGlvbiBpcyBleHBsaWNpdGx5IHJlcXVpcmVkIChhY3Rpb25cbiAgICAgICAgLy8gc3VibWlzc2lvbnMsIHVzZVJldmFsaWRhdG9yLCBYLVJlbWl4LVJldmFsaWRhdGUpLlxuICAgICAgICBsZXQgc2hvdWxkUmV2YWxpZGF0ZSA9IHNob3VsZFJldmFsaWRhdGVMb2FkZXIoZi5tYXRjaCwge1xuICAgICAgICAgIGN1cnJlbnRVcmwsXG4gICAgICAgICAgY3VycmVudFBhcmFtczogc3RhdGUubWF0Y2hlc1tzdGF0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdLnBhcmFtcyxcbiAgICAgICAgICBuZXh0VXJsLFxuICAgICAgICAgIG5leHRQYXJhbXM6IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5wYXJhbXMsXG4gICAgICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgICAgICBhY3Rpb25SZXN1bHQsXG4gICAgICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgICAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLnB1c2goeyBrZXksIC4uLmYgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICByZXR1cm4gW25hdmlnYXRpb25NYXRjaGVzLCByZXZhbGlkYXRpbmdGZXRjaGVyc107XG59XG5cbmZ1bmN0aW9uIGlzTmV3TG9hZGVyKFxuICBjdXJyZW50TG9hZGVyRGF0YTogUm91dGVEYXRhLFxuICBjdXJyZW50TWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIG1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoXG4pIHtcbiAgbGV0IGlzTmV3ID1cbiAgICAvLyBbYV0gLT4gW2EsIGJdXG4gICAgIWN1cnJlbnRNYXRjaCB8fFxuICAgIC8vIFthLCBiXSAtPiBbYSwgY11cbiAgICBtYXRjaC5yb3V0ZS5pZCAhPT0gY3VycmVudE1hdGNoLnJvdXRlLmlkO1xuXG4gIC8vIEhhbmRsZSB0aGUgY2FzZSB0aGF0IHdlIGRvbid0IGhhdmUgZGF0YSBmb3IgYSByZS11c2VkIHJvdXRlLCBwb3RlbnRpYWxseVxuICAvLyBmcm9tIGEgcHJpb3IgZXJyb3Igb3IgZnJvbSBhIGNhbmNlbGxlZCBwZW5kaW5nIGRlZmVycmVkXG4gIGxldCBpc01pc3NpbmdEYXRhID0gY3VycmVudExvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdID09PSB1bmRlZmluZWQ7XG5cbiAgLy8gQWx3YXlzIGxvYWQgaWYgdGhpcyBpcyBhIG5ldC1uZXcgcm91dGUgb3Igd2UgZG9uJ3QgeWV0IGhhdmUgZGF0YVxuICByZXR1cm4gaXNOZXcgfHwgaXNNaXNzaW5nRGF0YTtcbn1cblxuZnVuY3Rpb24gaXNOZXdSb3V0ZUluc3RhbmNlKFxuICBjdXJyZW50TWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIG1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoXG4pIHtcbiAgbGV0IGN1cnJlbnRQYXRoID0gY3VycmVudE1hdGNoLnJvdXRlLnBhdGg7XG4gIHJldHVybiAoXG4gICAgLy8gcGFyYW0gY2hhbmdlIGZvciB0aGlzIG1hdGNoLCAvdXNlcnMvMTIzIC0+IC91c2Vycy80NTZcbiAgICBjdXJyZW50TWF0Y2gucGF0aG5hbWUgIT09IG1hdGNoLnBhdGhuYW1lIHx8XG4gICAgLy8gc3BsYXQgcGFyYW0gY2hhbmdlZCwgd2hpY2ggaXMgbm90IHByZXNlbnQgaW4gbWF0Y2gucGF0aFxuICAgIC8vIGUuZy4gL2ZpbGVzL2ltYWdlcy9hdmF0YXIuanBnIC0+IGZpbGVzL2ZpbmFuY2VzLnhsc1xuICAgIChjdXJyZW50UGF0aCAhPSBudWxsICYmXG4gICAgICBjdXJyZW50UGF0aC5lbmRzV2l0aChcIipcIikgJiZcbiAgICAgIGN1cnJlbnRNYXRjaC5wYXJhbXNbXCIqXCJdICE9PSBtYXRjaC5wYXJhbXNbXCIqXCJdKVxuICApO1xufVxuXG5mdW5jdGlvbiBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKFxuICBsb2FkZXJNYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgYXJnOiBQYXJhbWV0ZXJzPFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbj5bMF1cbikge1xuICBpZiAobG9hZGVyTWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgIGxldCByb3V0ZUNob2ljZSA9IGxvYWRlck1hdGNoLnJvdXRlLnNob3VsZFJldmFsaWRhdGUoYXJnKTtcbiAgICBpZiAodHlwZW9mIHJvdXRlQ2hvaWNlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIHJvdXRlQ2hvaWNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcmcuZGVmYXVsdFNob3VsZFJldmFsaWRhdGU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJPckFjdGlvbihcbiAgdHlwZTogXCJsb2FkZXJcIiB8IFwiYWN0aW9uXCIsXG4gIHJlcXVlc3Q6IFJlcXVlc3QsXG4gIG1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIGJhc2VuYW1lID0gXCIvXCIsXG4gIGlzU3RhdGljUmVxdWVzdDogYm9vbGVhbiA9IGZhbHNlLFxuICBpc1JvdXRlUmVxdWVzdDogYm9vbGVhbiA9IGZhbHNlLFxuICByZXF1ZXN0Q29udGV4dD86IHVua25vd25cbik6IFByb21pc2U8RGF0YVJlc3VsdD4ge1xuICBsZXQgcmVzdWx0VHlwZTtcbiAgbGV0IHJlc3VsdDtcblxuICAvLyBTZXR1cCBhIHByb21pc2Ugd2UgY2FuIHJhY2UgYWdhaW5zdCBzbyB0aGF0IGFib3J0IHNpZ25hbHMgc2hvcnQgY2lyY3VpdFxuICBsZXQgcmVqZWN0OiAoKSA9PiB2b2lkO1xuICBsZXQgYWJvcnRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHIpID0+IChyZWplY3QgPSByKSk7XG4gIGxldCBvblJlamVjdCA9ICgpID0+IHJlamVjdCgpO1xuICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25SZWplY3QpO1xuXG4gIHRyeSB7XG4gICAgbGV0IGhhbmRsZXIgPSBtYXRjaC5yb3V0ZVt0eXBlXTtcbiAgICBpbnZhcmlhbnQ8RnVuY3Rpb24+KFxuICAgICAgaGFuZGxlcixcbiAgICAgIGBDb3VsZCBub3QgZmluZCB0aGUgJHt0eXBlfSB0byBydW4gb24gdGhlIFwiJHttYXRjaC5yb3V0ZS5pZH1cIiByb3V0ZWBcbiAgICApO1xuXG4gICAgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgIGhhbmRsZXIoeyByZXF1ZXN0LCBwYXJhbXM6IG1hdGNoLnBhcmFtcywgY29udGV4dDogcmVxdWVzdENvbnRleHQgfSksXG4gICAgICBhYm9ydFByb21pc2UsXG4gICAgXSk7XG5cbiAgICBpbnZhcmlhbnQoXG4gICAgICByZXN1bHQgIT09IHVuZGVmaW5lZCxcbiAgICAgIGBZb3UgZGVmaW5lZCAke3R5cGUgPT09IFwiYWN0aW9uXCIgPyBcImFuIGFjdGlvblwiIDogXCJhIGxvYWRlclwifSBmb3Igcm91dGUgYCArXG4gICAgICAgIGBcIiR7bWF0Y2gucm91dGUuaWR9XCIgYnV0IGRpZG4ndCByZXR1cm4gYW55dGhpbmcgZnJvbSB5b3VyIFxcYCR7dHlwZX1cXGAgYCArXG4gICAgICAgIGBmdW5jdGlvbi4gUGxlYXNlIHJldHVybiBhIHZhbHVlIG9yIFxcYG51bGxcXGAuYFxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXN1bHRUeXBlID0gUmVzdWx0VHlwZS5lcnJvcjtcbiAgICByZXN1bHQgPSBlO1xuICB9IGZpbmFsbHkge1xuICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XG4gIH1cblxuICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgbGV0IHN0YXR1cyA9IHJlc3VsdC5zdGF0dXM7XG5cbiAgICAvLyBQcm9jZXNzIHJlZGlyZWN0c1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c0NvZGVzLmhhcyhzdGF0dXMpKSB7XG4gICAgICBsZXQgbG9jYXRpb24gPSByZXN1bHQuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKTtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIFwiUmVkaXJlY3RzIHJldHVybmVkL3Rocm93biBmcm9tIGxvYWRlcnMvYWN0aW9ucyBtdXN0IGhhdmUgYSBMb2NhdGlvbiBoZWFkZXJcIlxuICAgICAgKTtcblxuICAgICAgLy8gU3VwcG9ydCByZWxhdGl2ZSByb3V0aW5nIGluIGludGVybmFsIHJlZGlyZWN0c1xuICAgICAgaWYgKCFBQlNPTFVURV9VUkxfUkVHRVgudGVzdChsb2NhdGlvbikpIHtcbiAgICAgICAgbGV0IGFjdGl2ZU1hdGNoZXMgPSBtYXRjaGVzLnNsaWNlKDAsIG1hdGNoZXMuaW5kZXhPZihtYXRjaCkgKyAxKTtcbiAgICAgICAgbGV0IHJvdXRlUGF0aG5hbWVzID0gZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMoYWN0aXZlTWF0Y2hlcykubWFwKFxuICAgICAgICAgIChtYXRjaCkgPT4gbWF0Y2gucGF0aG5hbWVCYXNlXG4gICAgICAgICk7XG4gICAgICAgIGxldCByZXNvbHZlZExvY2F0aW9uID0gcmVzb2x2ZVRvKFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIHJvdXRlUGF0aG5hbWVzLFxuICAgICAgICAgIG5ldyBVUkwocmVxdWVzdC51cmwpLnBhdGhuYW1lXG4gICAgICAgICk7XG4gICAgICAgIGludmFyaWFudChcbiAgICAgICAgICBjcmVhdGVQYXRoKHJlc29sdmVkTG9jYXRpb24pLFxuICAgICAgICAgIGBVbmFibGUgdG8gcmVzb2x2ZSByZWRpcmVjdCBsb2NhdGlvbjogJHtsb2NhdGlvbn1gXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUHJlcGVuZCB0aGUgYmFzZW5hbWUgdG8gdGhlIHJlZGlyZWN0IGxvY2F0aW9uIGlmIHdlIGhhdmUgb25lXG4gICAgICAgIGlmIChiYXNlbmFtZSkge1xuICAgICAgICAgIGxldCBwYXRoID0gcmVzb2x2ZWRMb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgICAgICByZXNvbHZlZExvY2F0aW9uLnBhdGhuYW1lID1cbiAgICAgICAgICAgIHBhdGggPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoXSk7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhdGlvbiA9IGNyZWF0ZVBhdGgocmVzb2x2ZWRMb2NhdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKCFpc1N0YXRpY1JlcXVlc3QpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSBwcm90b2NvbCtvcmlnaW4gZm9yIHNhbWUtb3JpZ2luIGFic29sdXRlIHJlZGlyZWN0cy5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0YXRpYyByZXF1ZXMsIHdlIGNhbiBsZXQgaXQgZ28gYmFjayB0byB0aGUgYnJvd3NlclxuICAgICAgICAvLyBhcy1pc1xuICAgICAgICBsZXQgY3VycmVudFVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgICAgICBsZXQgdXJsID0gbG9jYXRpb24uc3RhcnRzV2l0aChcIi8vXCIpXG4gICAgICAgICAgPyBuZXcgVVJMKGN1cnJlbnRVcmwucHJvdG9jb2wgKyBsb2NhdGlvbilcbiAgICAgICAgICA6IG5ldyBVUkwobG9jYXRpb24pO1xuICAgICAgICBpZiAodXJsLm9yaWdpbiA9PT0gY3VycmVudFVybC5vcmlnaW4pIHtcbiAgICAgICAgICBsb2NhdGlvbiA9IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2ggKyB1cmwuaGFzaDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCBwcm9jZXNzIHJlZGlyZWN0cyBpbiB0aGUgcm91dGVyIGR1cmluZyBzdGF0aWMgcmVxdWVzdHMgcmVxdWVzdHMuXG4gICAgICAvLyBJbnN0ZWFkLCB0aHJvdyB0aGUgUmVzcG9uc2UgYW5kIGxldCB0aGUgc2VydmVyIGhhbmRsZSBpdCB3aXRoIGFuIEhUVFBcbiAgICAgIC8vIHJlZGlyZWN0LiAgV2UgYWxzbyB1cGRhdGUgdGhlIExvY2F0aW9uIGhlYWRlciBpbiBwbGFjZSBpbiB0aGlzIGZsb3cgc29cbiAgICAgIC8vIGJhc2VuYW1lIGFuZCByZWxhdGl2ZSByb3V0aW5nIGlzIHRha2VuIGludG8gYWNjb3VudFxuICAgICAgaWYgKGlzU3RhdGljUmVxdWVzdCkge1xuICAgICAgICByZXN1bHQuaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCBsb2NhdGlvbik7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5yZWRpcmVjdCxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgcmV2YWxpZGF0ZTogcmVzdWx0LmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZXZhbGlkYXRlXCIpICE9PSBudWxsLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBGb3IgU1NSIHNpbmdsZS1yb3V0ZSByZXF1ZXN0cywgd2Ugd2FudCB0byBoYW5kIFJlc3BvbnNlcyBiYWNrIGRpcmVjdGx5XG4gICAgLy8gd2l0aG91dCB1bndyYXBwaW5nLiAgV2UgZG8gdGhpcyB3aXRoIHRoZSBRdWVyeVJvdXRlUmVzcG9uc2Ugd3JhcHBlclxuICAgIC8vIGludGVyZmFjZSBzbyB3ZSBjYW4ga25vdyB3aGV0aGVyIGl0IHdhcyByZXR1cm5lZCBvciB0aHJvd25cbiAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gICAgICB0aHJvdyB7XG4gICAgICAgIHR5cGU6IHJlc3VsdFR5cGUgfHwgUmVzdWx0VHlwZS5kYXRhLFxuICAgICAgICByZXNwb25zZTogcmVzdWx0LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgZGF0YTogYW55O1xuICAgIGxldCBjb250ZW50VHlwZSA9IHJlc3VsdC5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICAvLyBDaGVjayBiZXR3ZWVuIHdvcmQgYm91bmRhcmllcyBpbnN0ZWFkIG9mIHN0YXJ0c1dpdGgoKSBkdWUgdG8gdGhlIGxhc3RcbiAgICAvLyBwYXJhZ3JhcGggb2YgaHR0cHM6Ly9odHRwd2cub3JnL3NwZWNzL3JmYzkxMTAuaHRtbCNmaWVsZC5jb250ZW50LXR5cGVcbiAgICBpZiAoY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwvanNvblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgIGRhdGEgPSBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gYXdhaXQgcmVzdWx0LnRleHQoKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0VHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogcmVzdWx0VHlwZSxcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvclJlc3BvbnNlKHN0YXR1cywgcmVzdWx0LnN0YXR1c1RleHQsIGRhdGEpLFxuICAgICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVycyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICAgIGRhdGEsXG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzLFxuICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnMsXG4gICAgfTtcbiAgfVxuXG4gIGlmIChyZXN1bHRUeXBlID09PSBSZXN1bHRUeXBlLmVycm9yKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogcmVzdWx0VHlwZSwgZXJyb3I6IHJlc3VsdCB9O1xuICB9XG5cbiAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIERlZmVycmVkRGF0YSkge1xuICAgIHJldHVybiB7IHR5cGU6IFJlc3VsdFR5cGUuZGVmZXJyZWQsIGRlZmVycmVkRGF0YTogcmVzdWx0IH07XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsIGRhdGE6IHJlc3VsdCB9O1xufVxuXG4vLyBVdGlsaXR5IG1ldGhvZCBmb3IgY3JlYXRpbmcgdGhlIFJlcXVlc3QgaW5zdGFuY2VzIGZvciBsb2FkZXJzL2FjdGlvbnMgZHVyaW5nXG4vLyBjbGllbnQtc2lkZSBuYXZpZ2F0aW9ucyBhbmQgZmV0Y2hlcy4gIER1cmluZyBTU1Igd2Ugd2lsbCBhbHdheXMgaGF2ZSBhXG4vLyBSZXF1ZXN0IGluc3RhbmNlIGZyb20gdGhlIHN0YXRpYyBoYW5kbGVyIChxdWVyeS9xdWVyeVJvdXRlKVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gIGhpc3Rvcnk6IEhpc3RvcnksXG4gIGxvY2F0aW9uOiBzdHJpbmcgfCBMb2NhdGlvbixcbiAgc2lnbmFsOiBBYm9ydFNpZ25hbCxcbiAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb25cbik6IFJlcXVlc3Qge1xuICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVVUkwoc3RyaXBIYXNoRnJvbVBhdGgobG9jYXRpb24pKS50b1N0cmluZygpO1xuICBsZXQgaW5pdDogUmVxdWVzdEluaXQgPSB7IHNpZ25hbCB9O1xuXG4gIGlmIChzdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgIGxldCB7IGZvcm1NZXRob2QsIGZvcm1FbmNUeXBlLCBmb3JtRGF0YSB9ID0gc3VibWlzc2lvbjtcbiAgICBpbml0Lm1ldGhvZCA9IGZvcm1NZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICBpbml0LmJvZHkgPVxuICAgICAgZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAgICAgICAgPyBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhmb3JtRGF0YSlcbiAgICAgICAgOiBmb3JtRGF0YTtcbiAgfVxuXG4gIC8vIENvbnRlbnQtVHlwZSBpcyBpbmZlcnJlZCAoaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0KVxuICByZXR1cm4gbmV3IFJlcXVlc3QodXJsLCBpbml0KTtcbn1cblxuZnVuY3Rpb24gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMoZm9ybURhdGE6IEZvcm1EYXRhKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcblxuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgZm9ybURhdGEuZW50cmllcygpKSB7XG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjY29udmVydGluZy1hbi1lbnRyeS1saXN0LXRvLWEtbGlzdC1vZi1uYW1lLXZhbHVlLXBhaXJzXG4gICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlIGluc3RhbmNlb2YgRmlsZSA/IHZhbHVlLm5hbWUgOiB2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gc2VhcmNoUGFyYW1zO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzUm91dGVMb2FkZXJEYXRhKFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIG1hdGNoZXNUb0xvYWQ6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgcmVzdWx0czogRGF0YVJlc3VsdFtdLFxuICBwZW5kaW5nRXJyb3I6IFJvdXRlRGF0YSB8IHVuZGVmaW5lZCxcbiAgYWN0aXZlRGVmZXJyZWRzOiBNYXA8c3RyaW5nLCBEZWZlcnJlZERhdGE+XG4pOiB7XG4gIGxvYWRlckRhdGE6IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXTtcbiAgZXJyb3JzOiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXSB8IG51bGw7XG4gIHN0YXR1c0NvZGU6IG51bWJlcjtcbiAgbG9hZGVySGVhZGVyczogUmVjb3JkPHN0cmluZywgSGVhZGVycz47XG59IHtcbiAgLy8gRmlsbCBpbiBsb2FkZXJEYXRhL2Vycm9ycyBmcm9tIG91ciBsb2FkZXJzXG4gIGxldCBsb2FkZXJEYXRhOiBSb3V0ZXJTdGF0ZVtcImxvYWRlckRhdGFcIl0gPSB7fTtcbiAgbGV0IGVycm9yczogUm91dGVyU3RhdGVbXCJlcnJvcnNcIl0gfCBudWxsID0gbnVsbDtcbiAgbGV0IHN0YXR1c0NvZGU6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgbGV0IGZvdW5kRXJyb3IgPSBmYWxzZTtcbiAgbGV0IGxvYWRlckhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIEhlYWRlcnM+ID0ge307XG5cbiAgLy8gUHJvY2VzcyBsb2FkZXIgcmVzdWx0cyBpbnRvIHN0YXRlLmxvYWRlckRhdGEvc3RhdGUuZXJyb3JzXG4gIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0LCBpbmRleCkgPT4ge1xuICAgIGxldCBpZCA9IG1hdGNoZXNUb0xvYWRbaW5kZXhdLnJvdXRlLmlkO1xuICAgIGludmFyaWFudChcbiAgICAgICFpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCksXG4gICAgICBcIkNhbm5vdCBoYW5kbGUgcmVkaXJlY3QgcmVzdWx0cyBpbiBwcm9jZXNzTG9hZGVyRGF0YVwiXG4gICAgKTtcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBMb29rIHVwd2FyZHMgZnJvbSB0aGUgbWF0Y2hlZCByb3V0ZSBmb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3JcbiAgICAgIC8vIGVycm9yIGJvdW5kYXJ5LCBkZWZhdWx0aW5nIHRvIHRoZSByb290IG1hdGNoXG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgaWQpO1xuICAgICAgbGV0IGVycm9yID0gcmVzdWx0LmVycm9yO1xuICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBlbmRpbmcgYWN0aW9uIGVycm9yLCB3ZSByZXBvcnQgaXQgYXQgdGhlIGhpZ2hlc3Qtcm91dGVcbiAgICAgIC8vIHRoYXQgdGhyb3dzIGEgbG9hZGVyIGVycm9yLCBhbmQgdGhlbiBjbGVhciBpdCBvdXQgdG8gaW5kaWNhdGUgdGhhdFxuICAgICAgLy8gaXQgd2FzIGNvbnN1bWVkXG4gICAgICBpZiAocGVuZGluZ0Vycm9yKSB7XG4gICAgICAgIGVycm9yID0gT2JqZWN0LnZhbHVlcyhwZW5kaW5nRXJyb3IpWzBdO1xuICAgICAgICBwZW5kaW5nRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGVycm9ycyA9IGVycm9ycyB8fCB7fTtcblxuICAgICAgLy8gUHJlZmVyIGhpZ2hlciBlcnJvciB2YWx1ZXMgaWYgbG93ZXIgZXJyb3JzIGJ1YmJsZSB0byB0aGUgc2FtZSBib3VuZGFyeVxuICAgICAgaWYgKGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSA9IGVycm9yO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciBvdXIgYW55IHByaW9yIGxvYWRlckRhdGEgZm9yIHRoZSB0aHJvd2luZyByb3V0ZVxuICAgICAgbG9hZGVyRGF0YVtpZF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIE9uY2Ugd2UgZmluZCBvdXIgZmlyc3QgKGhpZ2hlc3QpIGVycm9yLCB3ZSBzZXQgdGhlIHN0YXR1cyBjb2RlIGFuZFxuICAgICAgLy8gcHJldmVudCBkZWVwZXIgc3RhdHVzIGNvZGVzIGZyb20gb3ZlcnJpZGluZ1xuICAgICAgaWYgKCFmb3VuZEVycm9yKSB7XG4gICAgICAgIGZvdW5kRXJyb3IgPSB0cnVlO1xuICAgICAgICBzdGF0dXNDb2RlID0gaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LmVycm9yKVxuICAgICAgICAgID8gcmVzdWx0LmVycm9yLnN0YXR1c1xuICAgICAgICAgIDogNTAwO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5oZWFkZXJzKSB7XG4gICAgICAgIGxvYWRlckhlYWRlcnNbaWRdID0gcmVzdWx0LmhlYWRlcnM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzLnNldChpZCwgcmVzdWx0LmRlZmVycmVkRGF0YSk7XG4gICAgICAgIGxvYWRlckRhdGFbaWRdID0gcmVzdWx0LmRlZmVycmVkRGF0YS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZGVyRGF0YVtpZF0gPSByZXN1bHQuZGF0YTtcbiAgICAgIH1cblxuICAgICAgLy8gRXJyb3Igc3RhdHVzIGNvZGVzIGFsd2F5cyBvdmVycmlkZSBzdWNjZXNzIHN0YXR1cyBjb2RlcywgYnV0IGlmIGFsbFxuICAgICAgLy8gbG9hZGVycyBhcmUgc3VjY2Vzc2Z1bCB3ZSB0YWtlIHRoZSBkZWVwZXN0IHN0YXR1cyBjb2RlLlxuICAgICAgaWYgKFxuICAgICAgICByZXN1bHQuc3RhdHVzQ29kZSAhPSBudWxsICYmXG4gICAgICAgIHJlc3VsdC5zdGF0dXNDb2RlICE9PSAyMDAgJiZcbiAgICAgICAgIWZvdW5kRXJyb3JcbiAgICAgICkge1xuICAgICAgICBzdGF0dXNDb2RlID0gcmVzdWx0LnN0YXR1c0NvZGU7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmhlYWRlcnMpIHtcbiAgICAgICAgbG9hZGVySGVhZGVyc1tpZF0gPSByZXN1bHQuaGVhZGVycztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIElmIHdlIGRpZG4ndCBjb25zdW1lIHRoZSBwZW5kaW5nIGFjdGlvbiBlcnJvciAoaS5lLiwgYWxsIGxvYWRlcnNcbiAgLy8gcmVzb2x2ZWQpLCB0aGVuIGNvbnN1bWUgaXQgaGVyZS4gIEFsc28gY2xlYXIgb3V0IGFueSBsb2FkZXJEYXRhIGZvciB0aGVcbiAgLy8gdGhyb3dpbmcgcm91dGVcbiAgaWYgKHBlbmRpbmdFcnJvcikge1xuICAgIGVycm9ycyA9IHBlbmRpbmdFcnJvcjtcbiAgICBsb2FkZXJEYXRhW09iamVjdC5rZXlzKHBlbmRpbmdFcnJvcilbMF1dID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsb2FkZXJEYXRhLFxuICAgIGVycm9ycyxcbiAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlIHx8IDIwMCxcbiAgICBsb2FkZXJIZWFkZXJzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzTG9hZGVyRGF0YShcbiAgc3RhdGU6IFJvdXRlclN0YXRlLFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIG1hdGNoZXNUb0xvYWQ6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgcmVzdWx0czogRGF0YVJlc3VsdFtdLFxuICBwZW5kaW5nRXJyb3I6IFJvdXRlRGF0YSB8IHVuZGVmaW5lZCxcbiAgcmV2YWxpZGF0aW5nRmV0Y2hlcnM6IFJldmFsaWRhdGluZ0ZldGNoZXJbXSxcbiAgZmV0Y2hlclJlc3VsdHM6IERhdGFSZXN1bHRbXSxcbiAgYWN0aXZlRGVmZXJyZWRzOiBNYXA8c3RyaW5nLCBEZWZlcnJlZERhdGE+XG4pOiB7XG4gIGxvYWRlckRhdGE6IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXTtcbiAgZXJyb3JzPzogUm91dGVyU3RhdGVbXCJlcnJvcnNcIl07XG59IHtcbiAgbGV0IHsgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBwcm9jZXNzUm91dGVMb2FkZXJEYXRhKFxuICAgIG1hdGNoZXMsXG4gICAgbWF0Y2hlc1RvTG9hZCxcbiAgICByZXN1bHRzLFxuICAgIHBlbmRpbmdFcnJvcixcbiAgICBhY3RpdmVEZWZlcnJlZHNcbiAgKTtcblxuICAvLyBQcm9jZXNzIHJlc3VsdHMgZnJvbSBvdXIgcmV2YWxpZGF0aW5nIGZldGNoZXJzXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBsZXQgeyBrZXksIG1hdGNoIH0gPSByZXZhbGlkYXRpbmdGZXRjaGVyc1tpbmRleF07XG4gICAgaW52YXJpYW50KFxuICAgICAgZmV0Y2hlclJlc3VsdHMgIT09IHVuZGVmaW5lZCAmJiBmZXRjaGVyUmVzdWx0c1tpbmRleF0gIT09IHVuZGVmaW5lZCxcbiAgICAgIFwiRGlkIG5vdCBmaW5kIGNvcnJlc3BvbmRpbmcgZmV0Y2hlciByZXN1bHRcIlxuICAgICk7XG4gICAgbGV0IHJlc3VsdCA9IGZldGNoZXJSZXN1bHRzW2luZGV4XTtcblxuICAgIC8vIFByb2Nlc3MgZmV0Y2hlciBub24tcmVkaXJlY3QgZXJyb3JzXG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIG1hdGNoLnJvdXRlLmlkKTtcbiAgICAgIGlmICghKGVycm9ycyAmJiBlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0pKSB7XG4gICAgICAgIGVycm9ycyA9IHtcbiAgICAgICAgICAuLi5lcnJvcnMsXG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3IsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICB9IGVsc2UgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gU2hvdWxkIG5ldmVyIGdldCBoZXJlLCByZWRpcmVjdHMgc2hvdWxkIGdldCBwcm9jZXNzZWQgYWJvdmUsIGJ1dCB3ZVxuICAgICAgLy8ga2VlcCB0aGlzIHRvIHR5cGUgbmFycm93IHRvIGEgc3VjY2VzcyByZXN1bHQgaW4gdGhlIGVsc2VcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJVbmhhbmRsZWQgZmV0Y2hlciByZXZhbGlkYXRpb24gcmVkaXJlY3RcIik7XG4gICAgfSBlbHNlIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFNob3VsZCBuZXZlciBnZXQgaGVyZSwgZGVmZXJyZWQgZGF0YSBzaG91bGQgYmUgYXdhaXRlZCBmb3IgZmV0Y2hlcnNcbiAgICAgIC8vIGluIHJlc29sdmVEZWZlcnJlZFJlc3VsdHNcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJVbmhhbmRsZWQgZmV0Y2hlciBkZWZlcnJlZCBkYXRhXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZG9uZUZldGNoZXI6IEZldGNoZXJTdGF0ZXNbXCJJZGxlXCJdID0ge1xuICAgICAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgICAgIGRhdGE6IHJlc3VsdC5kYXRhLFxuICAgICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgXCIgX2hhc0ZldGNoZXJEb25lQW55dGhpbmcgXCI6IHRydWUsXG4gICAgICB9O1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGxvYWRlckRhdGEsIGVycm9ycyB9O1xufVxuXG5mdW5jdGlvbiBtZXJnZUxvYWRlckRhdGEoXG4gIGxvYWRlckRhdGE6IFJvdXRlRGF0YSxcbiAgbmV3TG9hZGVyRGF0YTogUm91dGVEYXRhLFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIGVycm9yczogUm91dGVEYXRhIHwgbnVsbCB8IHVuZGVmaW5lZFxuKTogUm91dGVEYXRhIHtcbiAgbGV0IG1lcmdlZExvYWRlckRhdGEgPSB7IC4uLm5ld0xvYWRlckRhdGEgfTtcbiAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGxldCBpZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIGlmIChuZXdMb2FkZXJEYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgaWYgKG5ld0xvYWRlckRhdGFbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWVyZ2VkTG9hZGVyRGF0YVtpZF0gPSBuZXdMb2FkZXJEYXRhW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vLW9wIC0gdGhpcyBpcyBzbyB3ZSBpZ25vcmUgZXhpc3RpbmcgZGF0YSBpZiB3ZSBoYXZlIGEga2V5IGluIHRoZVxuICAgICAgICAvLyBpbmNvbWluZyBvYmplY3Qgd2l0aCBhbiB1bmRlZmluZWQgdmFsdWUsIHdoaWNoIGlzIGhvdyB3ZSB1bnNldCBhIHByaW9yXG4gICAgICAgIC8vIGxvYWRlckRhdGEgaWYgd2UgZW5jb3VudGVyIGEgbG9hZGVyIGVycm9yXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb2FkZXJEYXRhW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtZXJnZWRMb2FkZXJEYXRhW2lkXSA9IGxvYWRlckRhdGFbaWRdO1xuICAgIH1cblxuICAgIGlmIChlcnJvcnMgJiYgZXJyb3JzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgLy8gRG9uJ3Qga2VlcCBhbnkgbG9hZGVyIGRhdGEgYmVsb3cgdGhlIGJvdW5kYXJ5XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlZExvYWRlckRhdGE7XG59XG5cbi8vIEZpbmQgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnksIGxvb2tpbmcgdXB3YXJkcyBmcm9tIHRoZSBsZWFmIHJvdXRlIChvciB0aGVcbi8vIHJvdXRlIHNwZWNpZmllZCBieSByb3V0ZUlkKSBmb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgZXJyb3IgYm91bmRhcnksXG4vLyBkZWZhdWx0aW5nIHRvIHRoZSByb290IG1hdGNoXG5mdW5jdGlvbiBmaW5kTmVhcmVzdEJvdW5kYXJ5KFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIHJvdXRlSWQ/OiBzdHJpbmdcbik6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gge1xuICBsZXQgZWxpZ2libGVNYXRjaGVzID0gcm91dGVJZFxuICAgID8gbWF0Y2hlcy5zbGljZSgwLCBtYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkgKyAxKVxuICAgIDogWy4uLm1hdGNoZXNdO1xuICByZXR1cm4gKFxuICAgIGVsaWdpYmxlTWF0Y2hlcy5yZXZlcnNlKCkuZmluZCgobSkgPT4gbS5yb3V0ZS5oYXNFcnJvckJvdW5kYXJ5ID09PSB0cnVlKSB8fFxuICAgIG1hdGNoZXNbMF1cbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhyb3V0ZXM6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W10pOiB7XG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXTtcbiAgcm91dGU6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0O1xufSB7XG4gIC8vIFByZWZlciBhIHJvb3QgbGF5b3V0IHJvdXRlIGlmIHByZXNlbnQsIG90aGVyd2lzZSBzaGltIGluIGEgcm91dGUgb2JqZWN0XG4gIGxldCByb3V0ZSA9IHJvdXRlcy5maW5kKChyKSA9PiByLmluZGV4IHx8ICFyLnBhdGggfHwgci5wYXRoID09PSBcIi9cIikgfHwge1xuICAgIGlkOiBgX19zaGltLWVycm9yLXJvdXRlX19gLFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbWF0Y2hlczogW1xuICAgICAge1xuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBwYXRobmFtZTogXCJcIixcbiAgICAgICAgcGF0aG5hbWVCYXNlOiBcIlwiLFxuICAgICAgICByb3V0ZSxcbiAgICAgIH0sXG4gICAgXSxcbiAgICByb3V0ZSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcihcbiAgc3RhdHVzOiBudW1iZXIsXG4gIHtcbiAgICBwYXRobmFtZSxcbiAgICByb3V0ZUlkLFxuICAgIG1ldGhvZCxcbiAgICB0eXBlLFxuICB9OiB7XG4gICAgcGF0aG5hbWU/OiBzdHJpbmc7XG4gICAgcm91dGVJZD86IHN0cmluZztcbiAgICBtZXRob2Q/OiBzdHJpbmc7XG4gICAgdHlwZT86IFwiZGVmZXItYWN0aW9uXCI7XG4gIH0gPSB7fVxuKSB7XG4gIGxldCBzdGF0dXNUZXh0ID0gXCJVbmtub3duIFNlcnZlciBFcnJvclwiO1xuICBsZXQgZXJyb3JNZXNzYWdlID0gXCJVbmtub3duIEByZW1peC1ydW4vcm91dGVyIGVycm9yXCI7XG5cbiAgaWYgKHN0YXR1cyA9PT0gNDAwKSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiQmFkIFJlcXVlc3RcIjtcbiAgICBpZiAobWV0aG9kICYmIHBhdGhuYW1lICYmIHJvdXRlSWQpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9XG4gICAgICAgIGBZb3UgbWFkZSBhICR7bWV0aG9kfSByZXF1ZXN0IHRvIFwiJHtwYXRobmFtZX1cIiBidXQgYCArXG4gICAgICAgIGBkaWQgbm90IHByb3ZpZGUgYSBcXGBsb2FkZXJcXGAgZm9yIHJvdXRlIFwiJHtyb3V0ZUlkfVwiLCBgICtcbiAgICAgICAgYHNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuYDtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZGVmZXItYWN0aW9uXCIpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiZGVmZXIoKSBpcyBub3Qgc3VwcG9ydGVkIGluIGFjdGlvbnNcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDMpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJGb3JiaWRkZW5cIjtcbiAgICBlcnJvck1lc3NhZ2UgPSBgUm91dGUgXCIke3JvdXRlSWR9XCIgZG9lcyBub3QgbWF0Y2ggVVJMIFwiJHtwYXRobmFtZX1cImA7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDQpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJOb3QgRm91bmRcIjtcbiAgICBlcnJvck1lc3NhZ2UgPSBgTm8gcm91dGUgbWF0Y2hlcyBVUkwgXCIke3BhdGhuYW1lfVwiYDtcbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwNSkge1xuICAgIHN0YXR1c1RleHQgPSBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiO1xuICAgIGlmIChtZXRob2QgJiYgcGF0aG5hbWUgJiYgcm91dGVJZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgYFlvdSBtYWRlIGEgJHttZXRob2QudG9VcHBlckNhc2UoKX0gcmVxdWVzdCB0byBcIiR7cGF0aG5hbWV9XCIgYnV0IGAgK1xuICAgICAgICBgZGlkIG5vdCBwcm92aWRlIGFuIFxcYGFjdGlvblxcYCBmb3Igcm91dGUgXCIke3JvdXRlSWR9XCIsIGAgK1xuICAgICAgICBgc28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5gO1xuICAgIH0gZWxzZSBpZiAobWV0aG9kKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBgSW52YWxpZCByZXF1ZXN0IG1ldGhvZCBcIiR7bWV0aG9kLnRvVXBwZXJDYXNlKCl9XCJgO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgRXJyb3JSZXNwb25zZShcbiAgICBzdGF0dXMgfHwgNTAwLFxuICAgIHN0YXR1c1RleHQsXG4gICAgbmV3IEVycm9yKGVycm9yTWVzc2FnZSksXG4gICAgdHJ1ZVxuICApO1xufVxuXG4vLyBGaW5kIGFueSByZXR1cm5lZCByZWRpcmVjdCBlcnJvcnMsIHN0YXJ0aW5nIGZyb20gdGhlIGxvd2VzdCBtYXRjaFxuZnVuY3Rpb24gZmluZFJlZGlyZWN0KHJlc3VsdHM6IERhdGFSZXN1bHRbXSk6IFJlZGlyZWN0UmVzdWx0IHwgdW5kZWZpbmVkIHtcbiAgZm9yIChsZXQgaSA9IHJlc3VsdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1tpXTtcbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJpcEhhc2hGcm9tUGF0aChwYXRoOiBUbykge1xuICBsZXQgcGFyc2VkUGF0aCA9IHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHBhdGgpIDogcGF0aDtcbiAgcmV0dXJuIGNyZWF0ZVBhdGgoeyAuLi5wYXJzZWRQYXRoLCBoYXNoOiBcIlwiIH0pO1xufVxuXG5mdW5jdGlvbiBpc0hhc2hDaGFuZ2VPbmx5KGE6IExvY2F0aW9uLCBiOiBMb2NhdGlvbik6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmIGEuaGFzaCAhPT0gYi5oYXNoXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0OiBEYXRhUmVzdWx0KTogcmVzdWx0IGlzIERlZmVycmVkUmVzdWx0IHtcbiAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBSZXN1bHRUeXBlLmRlZmVycmVkO1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yUmVzdWx0KHJlc3VsdDogRGF0YVJlc3VsdCk6IHJlc3VsdCBpcyBFcnJvclJlc3VsdCB7XG4gIHJldHVybiByZXN1bHQudHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcjtcbn1cblxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQ/OiBEYXRhUmVzdWx0KTogcmVzdWx0IGlzIFJlZGlyZWN0UmVzdWx0IHtcbiAgcmV0dXJuIChyZXN1bHQgJiYgcmVzdWx0LnR5cGUpID09PSBSZXN1bHRUeXBlLnJlZGlyZWN0O1xufVxuXG5mdW5jdGlvbiBpc1Jlc3BvbnNlKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBSZXNwb25zZSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiB2YWx1ZS5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiZcbiAgICB0eXBlb2YgdmFsdWUuc3RhdHVzVGV4dCA9PT0gXCJzdHJpbmdcIiAmJlxuICAgIHR5cGVvZiB2YWx1ZS5oZWFkZXJzID09PSBcIm9iamVjdFwiICYmXG4gICAgdHlwZW9mIHZhbHVlLmJvZHkgIT09IFwidW5kZWZpbmVkXCJcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3VsdDogYW55KTogcmVzdWx0IGlzIFJlc3BvbnNlIHtcbiAgaWYgKCFpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBsZXQgc3RhdHVzID0gcmVzdWx0LnN0YXR1cztcbiAgbGV0IGxvY2F0aW9uID0gcmVzdWx0LmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gIHJldHVybiBzdGF0dXMgPj0gMzAwICYmIHN0YXR1cyA8PSAzOTkgJiYgbG9jYXRpb24gIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNRdWVyeVJvdXRlUmVzcG9uc2Uob2JqOiBhbnkpOiBvYmogaXMgUXVlcnlSb3V0ZVJlc3BvbnNlIHtcbiAgcmV0dXJuIChcbiAgICBvYmogJiZcbiAgICBpc1Jlc3BvbnNlKG9iai5yZXNwb25zZSkgJiZcbiAgICAob2JqLnR5cGUgPT09IFJlc3VsdFR5cGUuZGF0YSB8fCBSZXN1bHRUeXBlLmVycm9yKVxuICApO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkTWV0aG9kKG1ldGhvZDogc3RyaW5nKTogbWV0aG9kIGlzIEZvcm1NZXRob2Qge1xuICByZXR1cm4gdmFsaWRSZXF1ZXN0TWV0aG9kcy5oYXMobWV0aG9kIGFzIEZvcm1NZXRob2QpO1xufVxuXG5mdW5jdGlvbiBpc011dGF0aW9uTWV0aG9kKG1ldGhvZD86IHN0cmluZyk6IG1ldGhvZCBpcyBNdXRhdGlvbkZvcm1NZXRob2Qge1xuICByZXR1cm4gdmFsaWRNdXRhdGlvbk1ldGhvZHMuaGFzKG1ldGhvZCBhcyBNdXRhdGlvbkZvcm1NZXRob2QpO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRGVmZXJyZWRSZXN1bHRzKFxuICBjdXJyZW50TWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBtYXRjaGVzVG9Mb2FkOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIHJlc3VsdHM6IERhdGFSZXN1bHRbXSxcbiAgc2lnbmFsOiBBYm9ydFNpZ25hbCxcbiAgaXNGZXRjaGVyOiBib29sZWFuLFxuICBjdXJyZW50TG9hZGVyRGF0YT86IFJvdXRlRGF0YVxuKSB7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByZXN1bHRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2luZGV4XTtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaGVzVG9Mb2FkW2luZGV4XTtcbiAgICBsZXQgY3VycmVudE1hdGNoID0gY3VycmVudE1hdGNoZXMuZmluZChcbiAgICAgIChtKSA9PiBtLnJvdXRlLmlkID09PSBtYXRjaC5yb3V0ZS5pZFxuICAgICk7XG4gICAgbGV0IGlzUmV2YWxpZGF0aW5nTG9hZGVyID1cbiAgICAgIGN1cnJlbnRNYXRjaCAhPSBudWxsICYmXG4gICAgICAhaXNOZXdSb3V0ZUluc3RhbmNlKGN1cnJlbnRNYXRjaCwgbWF0Y2gpICYmXG4gICAgICAoY3VycmVudExvYWRlckRhdGEgJiYgY3VycmVudExvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdKSAhPT0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSAmJiAoaXNGZXRjaGVyIHx8IGlzUmV2YWxpZGF0aW5nTG9hZGVyKSkge1xuICAgICAgLy8gTm90ZTogd2UgZG8gbm90IGhhdmUgdG8gdG91Y2ggYWN0aXZlRGVmZXJyZWRzIGhlcmUgc2luY2Ugd2UgcmFjZSB0aGVtXG4gICAgICAvLyBhZ2FpbnN0IHRoZSBzaWduYWwgaW4gcmVzb2x2ZURlZmVycmVkRGF0YSBhbmQgdGhleSdsbCBnZXQgYWJvcnRlZFxuICAgICAgLy8gdGhlcmUgaWYgbmVlZGVkXG4gICAgICBhd2FpdCByZXNvbHZlRGVmZXJyZWREYXRhKHJlc3VsdCwgc2lnbmFsLCBpc0ZldGNoZXIpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSByZXN1bHQgfHwgcmVzdWx0c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRGVmZXJyZWREYXRhKFxuICByZXN1bHQ6IERlZmVycmVkUmVzdWx0LFxuICBzaWduYWw6IEFib3J0U2lnbmFsLFxuICB1bndyYXAgPSBmYWxzZVxuKTogUHJvbWlzZTxTdWNjZXNzUmVzdWx0IHwgRXJyb3JSZXN1bHQgfCB1bmRlZmluZWQ+IHtcbiAgbGV0IGFib3J0ZWQgPSBhd2FpdCByZXN1bHQuZGVmZXJyZWREYXRhLnJlc29sdmVEYXRhKHNpZ25hbCk7XG4gIGlmIChhYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHVud3JhcCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICAgIGRhdGE6IHJlc3VsdC5kZWZlcnJlZERhdGEudW53cmFwcGVkRGF0YSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSGFuZGxlIGFueSBUcmFja2VkUHJvbWlzZS5fZXJyb3IgdmFsdWVzIGVuY291bnRlcmVkIHdoaWxlIHVud3JhcHBpbmdcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBlLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICBkYXRhOiByZXN1bHQuZGVmZXJyZWREYXRhLmRhdGEsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGhhc05ha2VkSW5kZXhRdWVyeShzZWFyY2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhzZWFyY2gpLmdldEFsbChcImluZGV4XCIpLnNvbWUoKHYpID0+IHYgPT09IFwiXCIpO1xufVxuXG4vLyBOb3RlOiBUaGlzIHNob3VsZCBtYXRjaCB0aGUgZm9ybWF0IGV4cG9ydGVkIGJ5IHVzZU1hdGNoZXMsIHNvIGlmIHlvdSBjaGFuZ2Vcbi8vIHRoaXMgcGxlYXNlIGFsc28gY2hhbmdlIHRoYXQgOikgIEV2ZW50dWFsbHkgd2UnbGwgRFJZIHRoaXMgdXBcbmZ1bmN0aW9uIGNyZWF0ZVVzZU1hdGNoZXNNYXRjaChcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIGxvYWRlckRhdGE6IFJvdXRlRGF0YVxuKTogVXNlTWF0Y2hlc01hdGNoIHtcbiAgbGV0IHsgcm91dGUsIHBhdGhuYW1lLCBwYXJhbXMgfSA9IG1hdGNoO1xuICByZXR1cm4ge1xuICAgIGlkOiByb3V0ZS5pZCxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJhbXMsXG4gICAgZGF0YTogbG9hZGVyRGF0YVtyb3V0ZS5pZF0gYXMgdW5rbm93bixcbiAgICBoYW5kbGU6IHJvdXRlLmhhbmRsZSBhcyB1bmtub3duLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRNYXRjaChcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBsb2NhdGlvbjogTG9jYXRpb24gfCBzdHJpbmdcbikge1xuICBsZXQgc2VhcmNoID1cbiAgICB0eXBlb2YgbG9jYXRpb24gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb24pLnNlYXJjaCA6IGxvY2F0aW9uLnNlYXJjaDtcbiAgaWYgKFxuICAgIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5pbmRleCAmJlxuICAgIGhhc05ha2VkSW5kZXhRdWVyeShzZWFyY2ggfHwgXCJcIilcbiAgKSB7XG4gICAgLy8gUmV0dXJuIHRoZSBsZWFmIGluZGV4IHJvdXRlIHdoZW4gaW5kZXggaXMgcHJlc2VudFxuICAgIHJldHVybiBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gIH1cbiAgLy8gT3RoZXJ3aXNlIGdyYWIgdGhlIGRlZXBlc3QgXCJwYXRoIGNvbnRyaWJ1dGluZ1wiIG1hdGNoIChpZ25vcmluZyBpbmRleCBhbmRcbiAgLy8gcGF0aGxlc3MgbGF5b3V0IHJvdXRlcylcbiAgbGV0IHBhdGhNYXRjaGVzID0gZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcyk7XG4gIHJldHVybiBwYXRoTWF0Y2hlc1twYXRoTWF0Y2hlcy5sZW5ndGggLSAxXTtcbn1cbi8vI2VuZHJlZ2lvblxuIiwiaW1wb3J0IHR5cGUgeyBGb3JtRW5jVHlwZSwgRm9ybU1ldGhvZCB9IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuaW1wb3J0IHR5cGUgeyBSZWxhdGl2ZVJvdXRpbmdUeXBlIH0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdE1ldGhvZCA9IFwiZ2V0XCI7XG5jb25zdCBkZWZhdWx0RW5jVHlwZSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0h0bWxFbGVtZW50KG9iamVjdDogYW55KTogb2JqZWN0IGlzIEhUTUxFbGVtZW50IHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QudGFnTmFtZSA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQnV0dG9uRWxlbWVudChvYmplY3Q6IGFueSk6IG9iamVjdCBpcyBIVE1MQnV0dG9uRWxlbWVudCB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJidXR0b25cIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQob2JqZWN0OiBhbnkpOiBvYmplY3QgaXMgSFRNTEZvcm1FbGVtZW50IHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZvcm1cIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW5wdXRFbGVtZW50KG9iamVjdDogYW55KTogb2JqZWN0IGlzIEhUTUxJbnB1dEVsZW1lbnQge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIjtcbn1cblxudHlwZSBMaW1pdGVkTW91c2VFdmVudCA9IFBpY2s8XG4gIE1vdXNlRXZlbnQsXG4gIFwiYnV0dG9uXCIgfCBcIm1ldGFLZXlcIiB8IFwiYWx0S2V5XCIgfCBcImN0cmxLZXlcIiB8IFwic2hpZnRLZXlcIlxuPjtcblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50OiBMaW1pdGVkTW91c2VFdmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRQcm9jZXNzTGlua0NsaWNrKFxuICBldmVudDogTGltaXRlZE1vdXNlRXZlbnQsXG4gIHRhcmdldD86IHN0cmluZ1xuKSB7XG4gIHJldHVybiAoXG4gICAgZXZlbnQuYnV0dG9uID09PSAwICYmIC8vIElnbm9yZSBldmVyeXRoaW5nIGJ1dCBsZWZ0IGNsaWNrc1xuICAgICghdGFyZ2V0IHx8IHRhcmdldCA9PT0gXCJfc2VsZlwiKSAmJiAvLyBMZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAgICFpc01vZGlmaWVkRXZlbnQoZXZlbnQpIC8vIElnbm9yZSBjbGlja3Mgd2l0aCBtb2RpZmllciBrZXlzXG4gICk7XG59XG5cbmV4cG9ydCB0eXBlIFBhcmFtS2V5VmFsdWVQYWlyID0gW3N0cmluZywgc3RyaW5nXTtcblxuZXhwb3J0IHR5cGUgVVJMU2VhcmNoUGFyYW1zSW5pdCA9XG4gIHwgc3RyaW5nXG4gIHwgUGFyYW1LZXlWYWx1ZVBhaXJbXVxuICB8IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdPlxuICB8IFVSTFNlYXJjaFBhcmFtcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gaW5pdGlhbGl6ZXIuXG4gKlxuICogVGhpcyBpcyBpZGVudGljYWwgdG8gYG5ldyBVUkxTZWFyY2hQYXJhbXMoaW5pdClgIGV4Y2VwdCBpdCBhbHNvXG4gKiBzdXBwb3J0cyBhcnJheXMgYXMgdmFsdWVzIGluIHRoZSBvYmplY3QgZm9ybSBvZiB0aGUgaW5pdGlhbGl6ZXJcbiAqIGluc3RlYWQgb2YganVzdCBzdHJpbmdzLiBUaGlzIGlzIGNvbnZlbmllbnQgd2hlbiB5b3UgbmVlZCBtdWx0aXBsZVxuICogdmFsdWVzIGZvciBhIGdpdmVuIGtleSwgYnV0IGRvbid0IHdhbnQgdG8gdXNlIGFuIGFycmF5IGluaXRpYWxpemVyLlxuICpcbiAqIEZvciBleGFtcGxlLCBpbnN0ZWFkIG9mOlxuICpcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1xuICogICAgIFsnc29ydCcsICduYW1lJ10sXG4gKiAgICAgWydzb3J0JywgJ3ByaWNlJ11cbiAqICAgXSk7XG4gKlxuICogeW91IGNhbiBkbzpcbiAqXG4gKiAgIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMoe1xuICogICAgIHNvcnQ6IFsnbmFtZScsICdwcmljZSddXG4gKiAgIH0pO1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFyYW1zKFxuICBpbml0OiBVUkxTZWFyY2hQYXJhbXNJbml0ID0gXCJcIlxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoXG4gICAgdHlwZW9mIGluaXQgPT09IFwic3RyaW5nXCIgfHxcbiAgICBBcnJheS5pc0FycmF5KGluaXQpIHx8XG4gICAgaW5pdCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtc1xuICAgICAgPyBpbml0XG4gICAgICA6IE9iamVjdC5rZXlzKGluaXQpLnJlZHVjZSgobWVtbywga2V5KSA9PiB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gaW5pdFtrZXldO1xuICAgICAgICAgIHJldHVybiBtZW1vLmNvbmNhdChcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKCh2KSA9PiBba2V5LCB2XSkgOiBbW2tleSwgdmFsdWVdXVxuICAgICAgICAgICk7XG4gICAgICAgIH0sIFtdIGFzIFBhcmFtS2V5VmFsdWVQYWlyW10pXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihcbiAgbG9jYXRpb25TZWFyY2g6IHN0cmluZyxcbiAgZGVmYXVsdFNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zIHwgbnVsbFxuKSB7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMobG9jYXRpb25TZWFyY2gpO1xuXG4gIGlmIChkZWZhdWx0U2VhcmNoUGFyYW1zKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIGRlZmF1bHRTZWFyY2hQYXJhbXMua2V5cygpKSB7XG4gICAgICBpZiAoIXNlYXJjaFBhcmFtcy5oYXMoa2V5KSkge1xuICAgICAgICBkZWZhdWx0U2VhcmNoUGFyYW1zLmdldEFsbChrZXkpLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdWJtaXRPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBIVFRQIG1ldGhvZCB1c2VkIHRvIHN1Ym1pdCB0aGUgZm9ybS4gT3ZlcnJpZGVzIGA8Zm9ybSBtZXRob2Q+YC5cbiAgICogRGVmYXVsdHMgdG8gXCJHRVRcIi5cbiAgICovXG4gIG1ldGhvZD86IEZvcm1NZXRob2Q7XG5cbiAgLyoqXG4gICAqIFRoZSBhY3Rpb24gVVJMIHBhdGggdXNlZCB0byBzdWJtaXQgdGhlIGZvcm0uIE92ZXJyaWRlcyBgPGZvcm0gYWN0aW9uPmAuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBwYXRoIG9mIHRoZSBjdXJyZW50IHJvdXRlLlxuICAgKlxuICAgKiBOb3RlOiBJdCBpcyBhc3N1bWVkIHRoZSBwYXRoIGlzIGFscmVhZHkgcmVzb2x2ZWQuIElmIHlvdSBuZWVkIHRvIHJlc29sdmUgYVxuICAgKiByZWxhdGl2ZSBwYXRoLCB1c2UgYHVzZUZvcm1BY3Rpb25gLlxuICAgKi9cbiAgYWN0aW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgYWN0aW9uIFVSTCB1c2VkIHRvIHN1Ym1pdCB0aGUgZm9ybS4gT3ZlcnJpZGVzIGA8Zm9ybSBlbmNUeXBlPmAuXG4gICAqIERlZmF1bHRzIHRvIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIuXG4gICAqL1xuICBlbmNUeXBlPzogRm9ybUVuY1R5cGU7XG5cbiAgLyoqXG4gICAqIFNldCBgdHJ1ZWAgdG8gcmVwbGFjZSB0aGUgY3VycmVudCBlbnRyeSBpbiB0aGUgYnJvd3NlcidzIGhpc3Rvcnkgc3RhY2tcbiAgICogaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBvbmUgKGkuZS4gc3RheSBvbiBcInRoZSBzYW1lIHBhZ2VcIikuIERlZmF1bHRzXG4gICAqIHRvIGBmYWxzZWAuXG4gICAqL1xuICByZXBsYWNlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmb3JtIGFjdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgcm91dGUgaGllcmFyY2h5IG9yXG4gICAqIHRoZSBwYXRobmFtZS4gIFVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIG9wdCBvdXQgb2YgbmF2aWdhdGluZyB0aGUgcm91dGVcbiAgICogaGllcmFyY2h5IGFuZCB3YW50IHRvIGluc3RlYWQgcm91dGUgYmFzZWQgb24gLy1kZWxpbWl0ZWQgVVJMIHNlZ21lbnRzXG4gICAqL1xuICByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGU7XG5cbiAgLyoqXG4gICAqIEluIGJyb3dzZXItYmFzZWQgZW52aXJvbm1lbnRzLCBwcmV2ZW50IHJlc2V0dGluZyBzY3JvbGwgYWZ0ZXIgdGhpc1xuICAgKiBuYXZpZ2F0aW9uIHdoZW4gdXNpbmcgdGhlIDxTY3JvbGxSZXN0b3JhdGlvbj4gY29tcG9uZW50XG4gICAqL1xuICBwcmV2ZW50U2Nyb2xsUmVzZXQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvKFxuICB0YXJnZXQ6XG4gICAgfCBIVE1MRm9ybUVsZW1lbnRcbiAgICB8IEhUTUxCdXR0b25FbGVtZW50XG4gICAgfCBIVE1MSW5wdXRFbGVtZW50XG4gICAgfCBGb3JtRGF0YVxuICAgIHwgVVJMU2VhcmNoUGFyYW1zXG4gICAgfCB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfVxuICAgIHwgbnVsbCxcbiAgZGVmYXVsdEFjdGlvbjogc3RyaW5nLFxuICBvcHRpb25zOiBTdWJtaXRPcHRpb25zXG4pOiB7XG4gIHVybDogVVJMO1xuICBtZXRob2Q6IHN0cmluZztcbiAgZW5jVHlwZTogc3RyaW5nO1xuICBmb3JtRGF0YTogRm9ybURhdGE7XG59IHtcbiAgbGV0IG1ldGhvZDogc3RyaW5nO1xuICBsZXQgYWN0aW9uOiBzdHJpbmc7XG4gIGxldCBlbmNUeXBlOiBzdHJpbmc7XG4gIGxldCBmb3JtRGF0YTogRm9ybURhdGE7XG5cbiAgaWYgKGlzRm9ybUVsZW1lbnQodGFyZ2V0KSkge1xuICAgIGxldCBzdWJtaXNzaW9uVHJpZ2dlcjogSFRNTEJ1dHRvbkVsZW1lbnQgfCBIVE1MSW5wdXRFbGVtZW50ID0gKFxuICAgICAgb3B0aW9ucyBhcyBhbnlcbiAgICApLnN1Ym1pc3Npb25UcmlnZ2VyO1xuXG4gICAgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgdGFyZ2V0LmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKSB8fCBkZWZhdWx0TWV0aG9kO1xuICAgIGFjdGlvbiA9IG9wdGlvbnMuYWN0aW9uIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIikgfHwgZGVmYXVsdEFjdGlvbjtcbiAgICBlbmNUeXBlID1cbiAgICAgIG9wdGlvbnMuZW5jVHlwZSB8fCB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZW5jdHlwZVwiKSB8fCBkZWZhdWx0RW5jVHlwZTtcblxuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRhcmdldCk7XG5cbiAgICBpZiAoc3VibWlzc2lvblRyaWdnZXIgJiYgc3VibWlzc2lvblRyaWdnZXIubmFtZSkge1xuICAgICAgZm9ybURhdGEuYXBwZW5kKHN1Ym1pc3Npb25UcmlnZ2VyLm5hbWUsIHN1Ym1pc3Npb25UcmlnZ2VyLnZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAgaXNCdXR0b25FbGVtZW50KHRhcmdldCkgfHxcbiAgICAoaXNJbnB1dEVsZW1lbnQodGFyZ2V0KSAmJlxuICAgICAgKHRhcmdldC50eXBlID09PSBcInN1Ym1pdFwiIHx8IHRhcmdldC50eXBlID09PSBcImltYWdlXCIpKVxuICApIHtcbiAgICBsZXQgZm9ybSA9IHRhcmdldC5mb3JtO1xuXG4gICAgaWYgKGZvcm0gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHN1Ym1pdCBhIDxidXR0b24+IG9yIDxpbnB1dCB0eXBlPVwic3VibWl0XCI+IHdpdGhvdXQgYSA8Zm9ybT5gXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIDxidXR0b24+LzxpbnB1dCB0eXBlPVwic3VibWl0XCI+IG1heSBvdmVycmlkZSBhdHRyaWJ1dGVzIG9mIDxmb3JtPlxuXG4gICAgbWV0aG9kID1cbiAgICAgIG9wdGlvbnMubWV0aG9kIHx8XG4gICAgICB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSB8fFxuICAgICAgZm9ybS5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHxcbiAgICAgIGRlZmF1bHRNZXRob2Q7XG4gICAgYWN0aW9uID1cbiAgICAgIG9wdGlvbnMuYWN0aW9uIHx8XG4gICAgICB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWFjdGlvblwiKSB8fFxuICAgICAgZm9ybS5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIikgfHxcbiAgICAgIGRlZmF1bHRBY3Rpb247XG4gICAgZW5jVHlwZSA9XG4gICAgICBvcHRpb25zLmVuY1R5cGUgfHxcbiAgICAgIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtZW5jdHlwZVwiKSB8fFxuICAgICAgZm9ybS5nZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIpIHx8XG4gICAgICBkZWZhdWx0RW5jVHlwZTtcblxuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0pO1xuXG4gICAgLy8gSW5jbHVkZSBuYW1lICsgdmFsdWUgZnJvbSBhIDxidXR0b24+LCBhcHBlbmRpbmcgaW4gY2FzZSB0aGUgYnV0dG9uIG5hbWVcbiAgICAvLyBtYXRjaGVzIGFuIGV4aXN0aW5nIGlucHV0IG5hbWVcbiAgICBpZiAodGFyZ2V0Lm5hbWUpIHtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCh0YXJnZXQubmFtZSwgdGFyZ2V0LnZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNIdG1sRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBzdWJtaXQgZWxlbWVudCB0aGF0IGlzIG5vdCA8Zm9ybT4sIDxidXR0b24+LCBvciBgICtcbiAgICAgICAgYDxpbnB1dCB0eXBlPVwic3VibWl0fGltYWdlXCI+YFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICBhY3Rpb24gPSBvcHRpb25zLmFjdGlvbiB8fCBkZWZhdWx0QWN0aW9uO1xuICAgIGVuY1R5cGUgPSBvcHRpb25zLmVuY1R5cGUgfHwgZGVmYXVsdEVuY1R5cGU7XG5cbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgIGZvcm1EYXRhID0gdGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgICAgIGZvciAobGV0IFtuYW1lLCB2YWx1ZV0gb2YgdGFyZ2V0KSB7XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGxldCBuYW1lIG9mIE9iamVjdC5rZXlzKHRhcmdldCkpIHtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdGFyZ2V0W25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCB7IHByb3RvY29sLCBob3N0IH0gPSB3aW5kb3cubG9jYXRpb247XG4gIGxldCB1cmwgPSBuZXcgVVJMKGFjdGlvbiwgYCR7cHJvdG9jb2x9Ly8ke2hvc3R9YCk7XG5cbiAgcmV0dXJuIHsgdXJsLCBtZXRob2Q6IG1ldGhvZC50b0xvd2VyQ2FzZSgpLCBlbmNUeXBlLCBmb3JtRGF0YSB9O1xufVxuIiwiLyoqXG4gKiBOT1RFOiBJZiB5b3UgcmVmYWN0b3IgdGhpcyB0byBzcGxpdCB1cCB0aGUgbW9kdWxlcyBpbnRvIHNlcGFyYXRlIGZpbGVzLFxuICogeW91J2xsIG5lZWQgdG8gdXBkYXRlIHRoZSByb2xsdXAgY29uZmlnIGZvciByZWFjdC1yb3V0ZXItZG9tLXY1LWNvbXBhdC5cbiAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7XG4gIE5hdmlnYXRlT3B0aW9ucyxcbiAgUmVsYXRpdmVSb3V0aW5nVHlwZSxcbiAgUm91dGVPYmplY3QsXG4gIFRvLFxufSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG5pbXBvcnQge1xuICBSb3V0ZXIsXG4gIGNyZWF0ZVBhdGgsXG4gIHVzZUhyZWYsXG4gIHVzZUxvY2F0aW9uLFxuICB1c2VNYXRjaGVzLFxuICB1c2VOYXZpZ2F0ZSxcbiAgdXNlTmF2aWdhdGlvbixcbiAgdXNlUmVzb2x2ZWRQYXRoLFxuICB1bnN0YWJsZV91c2VCbG9ja2VyIGFzIHVzZUJsb2NrZXIsXG4gIFVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCBhcyBEYXRhUm91dGVyQ29udGV4dCxcbiAgVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgYXMgRGF0YVJvdXRlclN0YXRlQ29udGV4dCxcbiAgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0IGFzIE5hdmlnYXRpb25Db250ZXh0LFxuICBVTlNBRkVfUm91dGVDb250ZXh0IGFzIFJvdXRlQ29udGV4dCxcbiAgVU5TQUZFX2VuaGFuY2VNYW51YWxSb3V0ZU9iamVjdHMgYXMgZW5oYW5jZU1hbnVhbFJvdXRlT2JqZWN0cyxcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuaW1wb3J0IHR5cGUge1xuICBCcm93c2VySGlzdG9yeSxcbiAgRmV0Y2hlcixcbiAgRm9ybUVuY1R5cGUsXG4gIEZvcm1NZXRob2QsXG4gIEdldFNjcm9sbFJlc3RvcmF0aW9uS2V5RnVuY3Rpb24sXG4gIEhhc2hIaXN0b3J5LFxuICBIaXN0b3J5LFxuICBIeWRyYXRpb25TdGF0ZSxcbiAgUm91dGVyIGFzIFJlbWl4Um91dGVyLFxufSBmcm9tIFwiQHJlbWl4LXJ1bi9yb3V0ZXJcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZVJvdXRlcixcbiAgY3JlYXRlQnJvd3Nlckhpc3RvcnksXG4gIGNyZWF0ZUhhc2hIaXN0b3J5LFxuICBpbnZhcmlhbnQsXG4gIGpvaW5QYXRocyxcbiAgRXJyb3JSZXNwb25zZSxcbn0gZnJvbSBcIkByZW1peC1ydW4vcm91dGVyXCI7XG5cbmltcG9ydCB0eXBlIHtcbiAgU3VibWl0T3B0aW9ucyxcbiAgUGFyYW1LZXlWYWx1ZVBhaXIsXG4gIFVSTFNlYXJjaFBhcmFtc0luaXQsXG59IGZyb20gXCIuL2RvbVwiO1xuaW1wb3J0IHtcbiAgY3JlYXRlU2VhcmNoUGFyYW1zLFxuICBkZWZhdWx0TWV0aG9kLFxuICBnZXRGb3JtU3VibWlzc2lvbkluZm8sXG4gIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uLFxuICBzaG91bGRQcm9jZXNzTGlua0NsaWNrLFxufSBmcm9tIFwiLi9kb21cIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBSZS1leHBvcnRzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgdHlwZSB7XG4gIEZvcm1FbmNUeXBlLFxuICBGb3JtTWV0aG9kLFxuICBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uLFxuICBQYXJhbUtleVZhbHVlUGFpcixcbiAgU3VibWl0T3B0aW9ucyxcbiAgVVJMU2VhcmNoUGFyYW1zSW5pdCxcbn07XG5leHBvcnQgeyBjcmVhdGVTZWFyY2hQYXJhbXMgfTtcblxuLy8gTm90ZTogS2VlcCBpbiBzeW5jIHdpdGggcmVhY3Qtcm91dGVyIGV4cG9ydHMhXG5leHBvcnQgdHlwZSB7XG4gIEFjdGlvbkZ1bmN0aW9uLFxuICBBY3Rpb25GdW5jdGlvbkFyZ3MsXG4gIEF3YWl0UHJvcHMsXG4gIHVuc3RhYmxlX0Jsb2NrZXIsXG4gIHVuc3RhYmxlX0Jsb2NrZXJGdW5jdGlvbixcbiAgRGF0YVJvdXRlTWF0Y2gsXG4gIERhdGFSb3V0ZU9iamVjdCxcbiAgRmV0Y2hlcixcbiAgSGFzaCxcbiAgSW5kZXhSb3V0ZU9iamVjdCxcbiAgSW5kZXhSb3V0ZVByb3BzLFxuICBKc29uRnVuY3Rpb24sXG4gIExheW91dFJvdXRlUHJvcHMsXG4gIExvYWRlckZ1bmN0aW9uLFxuICBMb2FkZXJGdW5jdGlvbkFyZ3MsXG4gIExvY2F0aW9uLFxuICBNZW1vcnlSb3V0ZXJQcm9wcyxcbiAgTmF2aWdhdGVGdW5jdGlvbixcbiAgTmF2aWdhdGVPcHRpb25zLFxuICBOYXZpZ2F0ZVByb3BzLFxuICBOYXZpZ2F0aW9uLFxuICBOYXZpZ2F0b3IsXG4gIE5vbkluZGV4Um91dGVPYmplY3QsXG4gIE91dGxldFByb3BzLFxuICBQYXJhbXMsXG4gIFBhcmFtUGFyc2VLZXksXG4gIFBhdGgsXG4gIFBhdGhNYXRjaCxcbiAgUGF0aG5hbWUsXG4gIFBhdGhQYXR0ZXJuLFxuICBQYXRoUm91dGVQcm9wcyxcbiAgUmVkaXJlY3RGdW5jdGlvbixcbiAgUmVsYXRpdmVSb3V0aW5nVHlwZSxcbiAgUm91dGVNYXRjaCxcbiAgUm91dGVPYmplY3QsXG4gIFJvdXRlUHJvcHMsXG4gIFJvdXRlclByb3BzLFxuICBSb3V0ZXJQcm92aWRlclByb3BzLFxuICBSb3V0ZXNQcm9wcyxcbiAgU2VhcmNoLFxuICBTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb24sXG4gIFRvLFxufSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG5leHBvcnQge1xuICBBYm9ydGVkRGVmZXJyZWRFcnJvcixcbiAgQXdhaXQsXG4gIE1lbW9yeVJvdXRlcixcbiAgTmF2aWdhdGUsXG4gIE5hdmlnYXRpb25UeXBlLFxuICBPdXRsZXQsXG4gIFJvdXRlLFxuICBSb3V0ZXIsXG4gIFJvdXRlclByb3ZpZGVyLFxuICBSb3V0ZXMsXG4gIGNyZWF0ZU1lbW9yeVJvdXRlcixcbiAgY3JlYXRlUGF0aCxcbiAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuLFxuICBjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMsXG4gIGRlZmVyLFxuICBpc1JvdXRlRXJyb3JSZXNwb25zZSxcbiAgZ2VuZXJhdGVQYXRoLFxuICBqc29uLFxuICBtYXRjaFBhdGgsXG4gIG1hdGNoUm91dGVzLFxuICBwYXJzZVBhdGgsXG4gIHJlZGlyZWN0LFxuICByZW5kZXJNYXRjaGVzLFxuICByZXNvbHZlUGF0aCxcbiAgdXNlQWN0aW9uRGF0YSxcbiAgdXNlQXN5bmNFcnJvcixcbiAgdXNlQXN5bmNWYWx1ZSxcbiAgdW5zdGFibGVfdXNlQmxvY2tlcixcbiAgdXNlSHJlZixcbiAgdXNlSW5Sb3V0ZXJDb250ZXh0LFxuICB1c2VMb2FkZXJEYXRhLFxuICB1c2VMb2NhdGlvbixcbiAgdXNlTWF0Y2gsXG4gIHVzZU1hdGNoZXMsXG4gIHVzZU5hdmlnYXRlLFxuICB1c2VOYXZpZ2F0aW9uLFxuICB1c2VOYXZpZ2F0aW9uVHlwZSxcbiAgdXNlT3V0bGV0LFxuICB1c2VPdXRsZXRDb250ZXh0LFxuICB1c2VQYXJhbXMsXG4gIHVzZVJlc29sdmVkUGF0aCxcbiAgdXNlUmV2YWxpZGF0b3IsXG4gIHVzZVJvdXRlRXJyb3IsXG4gIHVzZVJvdXRlTG9hZGVyRGF0YSxcbiAgdXNlUm91dGVzLFxufSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIERBTkdFUiEgUExFQVNFIFJFQUQgTUUhXG4vLyBXZSBwcm92aWRlIHRoZXNlIGV4cG9ydHMgYXMgYW4gZXNjYXBlIGhhdGNoIGluIHRoZSBldmVudCB0aGF0IHlvdSBuZWVkIGFueVxuLy8gcm91dGluZyBkYXRhIHRoYXQgd2UgZG9uJ3QgcHJvdmlkZSBhbiBleHBsaWNpdCBBUEkgZm9yLiBXaXRoIHRoYXQgc2FpZCwgd2Vcbi8vIHdhbnQgdG8gY292ZXIgeW91ciB1c2UgY2FzZSBpZiB3ZSBjYW4sIHNvIGlmIHlvdSBmZWVsIHRoZSBuZWVkIHRvIHVzZSB0aGVzZVxuLy8gd2Ugd2FudCB0byBoZWFyIGZyb20geW91LiBMZXQgdXMga25vdyB3aGF0IHlvdSdyZSBidWlsZGluZyBhbmQgd2UnbGwgZG8gb3VyXG4vLyBiZXN0IHRvIG1ha2Ugc3VyZSB3ZSBjYW4gc3VwcG9ydCB5b3UhXG4vL1xuLy8gV2UgY29uc2lkZXIgdGhlc2UgZXhwb3J0cyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgYW5kIGRvIG5vdCBndWFyYW50ZWVcbi8vIGFnYWluc3QgYW55IGJyZWFraW5nIGNoYW5nZXMsIHJlZ2FyZGxlc3Mgb2YgdGhlIHNlbXZlciByZWxlYXNlLiBVc2Ugd2l0aFxuLy8gZXh0cmVtZSBjYXV0aW9uIGFuZCBvbmx5IGlmIHlvdSB1bmRlcnN0YW5kIHRoZSBjb25zZXF1ZW5jZXMuIEdvZHNwZWVkLlxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKiogQGludGVybmFsICovXG5leHBvcnQge1xuICBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQsXG4gIFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0LFxuICBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9Sb3V0ZUNvbnRleHQsXG4gIFVOU0FGRV9lbmhhbmNlTWFudWFsUm91dGVPYmplY3RzLFxufSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG4vLyNlbmRyZWdpb25cblxuZGVjbGFyZSBnbG9iYWwge1xuICB2YXIgX19zdGF0aWNSb3V0ZXJIeWRyYXRpb25EYXRhOiBIeWRyYXRpb25TdGF0ZSB8IHVuZGVmaW5lZDtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBSb3V0ZXJzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQnJvd3NlclJvdXRlcihcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFtdLFxuICBvcHRzPzoge1xuICAgIGJhc2VuYW1lPzogc3RyaW5nO1xuICAgIGh5ZHJhdGlvbkRhdGE/OiBIeWRyYXRpb25TdGF0ZTtcbiAgICB3aW5kb3c/OiBXaW5kb3c7XG4gIH1cbik6IFJlbWl4Um91dGVyIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIGhpc3Rvcnk6IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHsgd2luZG93OiBvcHRzPy53aW5kb3cgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogb3B0cz8uaHlkcmF0aW9uRGF0YSB8fCBwYXJzZUh5ZHJhdGlvbkRhdGEoKSxcbiAgICByb3V0ZXM6IGVuaGFuY2VNYW51YWxSb3V0ZU9iamVjdHMocm91dGVzKSxcbiAgfSkuaW5pdGlhbGl6ZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaFJvdXRlcihcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFtdLFxuICBvcHRzPzoge1xuICAgIGJhc2VuYW1lPzogc3RyaW5nO1xuICAgIGh5ZHJhdGlvbkRhdGE/OiBIeWRyYXRpb25TdGF0ZTtcbiAgICB3aW5kb3c/OiBXaW5kb3c7XG4gIH1cbik6IFJlbWl4Um91dGVyIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIGhpc3Rvcnk6IGNyZWF0ZUhhc2hIaXN0b3J5KHsgd2luZG93OiBvcHRzPy53aW5kb3cgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogb3B0cz8uaHlkcmF0aW9uRGF0YSB8fCBwYXJzZUh5ZHJhdGlvbkRhdGEoKSxcbiAgICByb3V0ZXM6IGVuaGFuY2VNYW51YWxSb3V0ZU9iamVjdHMocm91dGVzKSxcbiAgfSkuaW5pdGlhbGl6ZSgpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUh5ZHJhdGlvbkRhdGEoKTogSHlkcmF0aW9uU3RhdGUgfCB1bmRlZmluZWQge1xuICBsZXQgc3RhdGUgPSB3aW5kb3c/Ll9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YTtcbiAgaWYgKHN0YXRlICYmIHN0YXRlLmVycm9ycykge1xuICAgIHN0YXRlID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBlcnJvcnM6IGRlc2VyaWFsaXplRXJyb3JzKHN0YXRlLmVycm9ycyksXG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplRXJyb3JzKFxuICBlcnJvcnM6IFJlbWl4Um91dGVyW1wic3RhdGVcIl1bXCJlcnJvcnNcIl1cbik6IFJlbWl4Um91dGVyW1wic3RhdGVcIl1bXCJlcnJvcnNcIl0ge1xuICBpZiAoIWVycm9ycykgcmV0dXJuIG51bGw7XG4gIGxldCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZXJyb3JzKTtcbiAgbGV0IHNlcmlhbGl6ZWQ6IFJlbWl4Um91dGVyW1wic3RhdGVcIl1bXCJlcnJvcnNcIl0gPSB7fTtcbiAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBlbnRyaWVzKSB7XG4gICAgLy8gSGV5IHlvdSEgIElmIHlvdSBjaGFuZ2UgdGhpcywgcGxlYXNlIGNoYW5nZSB0aGUgY29ycmVzcG9uZGluZyBsb2dpYyBpblxuICAgIC8vIHNlcmlhbGl6ZUVycm9ycyBpbiByZWFjdC1yb3V0ZXItZG9tL3NlcnZlci50c3ggOilcbiAgICBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiUm91dGVFcnJvclJlc3BvbnNlXCIpIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IG5ldyBFcnJvclJlc3BvbnNlKFxuICAgICAgICB2YWwuc3RhdHVzLFxuICAgICAgICB2YWwuc3RhdHVzVGV4dCxcbiAgICAgICAgdmFsLmRhdGEsXG4gICAgICAgIHZhbC5pbnRlcm5hbCA9PT0gdHJ1ZVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIkVycm9yXCIpIHtcbiAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvcih2YWwubWVzc2FnZSk7XG4gICAgICAvLyBXaXBlIGF3YXkgdGhlIGNsaWVudC1zaWRlIHN0YWNrIHRyYWNlLiAgTm90aGluZyB0byBmaWxsIGl0IGluIHdpdGhcbiAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3Qgc2VyaWFsaXplIFNTUiBzdGFjayB0cmFjZXMgZm9yIHNlY3VyaXR5IHJlYXNvbnNcbiAgICAgIGVycm9yLnN0YWNrID0gXCJcIjtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuXG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBDb21wb25lbnRzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgaW50ZXJmYWNlIEJyb3dzZXJSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgd2luZG93PzogV2luZG93O1xufVxuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCBmb3IgdXNlIGluIHdlYiBicm93c2Vycy4gUHJvdmlkZXMgdGhlIGNsZWFuZXN0IFVSTHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBCcm93c2VyUm91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICB3aW5kb3csXG59OiBCcm93c2VyUm91dGVyUHJvcHMpIHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWY8QnJvd3Nlckhpc3Rvcnk+KCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHsgd2luZG93LCB2NUNvbXBhdDogdHJ1ZSB9KTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgfSk7XG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnldKTtcblxuICByZXR1cm4gKFxuICAgIDxSb3V0ZXJcbiAgICAgIGJhc2VuYW1lPXtiYXNlbmFtZX1cbiAgICAgIGNoaWxkcmVuPXtjaGlsZHJlbn1cbiAgICAgIGxvY2F0aW9uPXtzdGF0ZS5sb2NhdGlvbn1cbiAgICAgIG5hdmlnYXRpb25UeXBlPXtzdGF0ZS5hY3Rpb259XG4gICAgICBuYXZpZ2F0b3I9e2hpc3Rvcnl9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIYXNoUm91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIHdpbmRvdz86IFdpbmRvdztcbn1cblxuLyoqXG4gKiBBIGA8Um91dGVyPmAgZm9yIHVzZSBpbiB3ZWIgYnJvd3NlcnMuIFN0b3JlcyB0aGUgbG9jYXRpb24gaW4gdGhlIGhhc2hcbiAqIHBvcnRpb24gb2YgdGhlIFVSTCBzbyBpdCBpcyBub3Qgc2VudCB0byB0aGUgc2VydmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gSGFzaFJvdXRlcih7IGJhc2VuYW1lLCBjaGlsZHJlbiwgd2luZG93IH06IEhhc2hSb3V0ZXJQcm9wcykge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZjxIYXNoSGlzdG9yeT4oKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlSGFzaEhpc3RvcnkoeyB3aW5kb3csIHY1Q29tcGF0OiB0cnVlIH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLFxuICB9KTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlclxuICAgICAgYmFzZW5hbWU9e2Jhc2VuYW1lfVxuICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmFjdGlvbn1cbiAgICAgIG5hdmlnYXRvcj17aGlzdG9yeX1cbiAgICAvPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhpc3RvcnlSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgaGlzdG9yeTogSGlzdG9yeTtcbn1cblxuLyoqXG4gKiBBIGA8Um91dGVyPmAgdGhhdCBhY2NlcHRzIGEgcHJlLWluc3RhbnRpYXRlZCBoaXN0b3J5IG9iamVjdC4gSXQncyBpbXBvcnRhbnRcbiAqIHRvIG5vdGUgdGhhdCB1c2luZyB5b3VyIG93biBoaXN0b3J5IG9iamVjdCBpcyBoaWdobHkgZGlzY291cmFnZWQgYW5kIG1heSBhZGRcbiAqIHR3byB2ZXJzaW9ucyBvZiB0aGUgaGlzdG9yeSBsaWJyYXJ5IHRvIHlvdXIgYnVuZGxlcyB1bmxlc3MgeW91IHVzZSB0aGUgc2FtZVxuICogdmVyc2lvbiBvZiB0aGUgaGlzdG9yeSBsaWJyYXJ5IHRoYXQgUmVhY3QgUm91dGVyIHVzZXMgaW50ZXJuYWxseS5cbiAqL1xuZnVuY3Rpb24gSGlzdG9yeVJvdXRlcih7IGJhc2VuYW1lLCBjaGlsZHJlbiwgaGlzdG9yeSB9OiBIaXN0b3J5Um91dGVyUHJvcHMpIHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgfSk7XG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnldKTtcblxuICByZXR1cm4gKFxuICAgIDxSb3V0ZXJcbiAgICAgIGJhc2VuYW1lPXtiYXNlbmFtZX1cbiAgICAgIGNoaWxkcmVuPXtjaGlsZHJlbn1cbiAgICAgIGxvY2F0aW9uPXtzdGF0ZS5sb2NhdGlvbn1cbiAgICAgIG5hdmlnYXRpb25UeXBlPXtzdGF0ZS5hY3Rpb259XG4gICAgICBuYXZpZ2F0b3I9e2hpc3Rvcnl9XG4gICAgLz5cbiAgKTtcbn1cblxuaWYgKF9fREVWX18pIHtcbiAgSGlzdG9yeVJvdXRlci5kaXNwbGF5TmFtZSA9IFwidW5zdGFibGVfSGlzdG9yeVJvdXRlclwiO1xufVxuXG5leHBvcnQgeyBIaXN0b3J5Um91dGVyIGFzIHVuc3RhYmxlX0hpc3RvcnlSb3V0ZXIgfTtcblxuZXhwb3J0IGludGVyZmFjZSBMaW5rUHJvcHNcbiAgZXh0ZW5kcyBPbWl0PFJlYWN0LkFuY2hvckhUTUxBdHRyaWJ1dGVzPEhUTUxBbmNob3JFbGVtZW50PiwgXCJocmVmXCI+IHtcbiAgcmVsb2FkRG9jdW1lbnQ/OiBib29sZWFuO1xuICByZXBsYWNlPzogYm9vbGVhbjtcbiAgc3RhdGU/OiBhbnk7XG4gIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG4gIHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZTtcbiAgdG86IFRvO1xufVxuXG5jb25zdCBpc0Jyb3dzZXIgPVxuICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgYSBoaXN0b3J5LWF3YXJlIDxhPi5cbiAqL1xuZXhwb3J0IGNvbnN0IExpbmsgPSBSZWFjdC5mb3J3YXJkUmVmPEhUTUxBbmNob3JFbGVtZW50LCBMaW5rUHJvcHM+KFxuICBmdW5jdGlvbiBMaW5rV2l0aFJlZihcbiAgICB7XG4gICAgICBvbkNsaWNrLFxuICAgICAgcmVsYXRpdmUsXG4gICAgICByZWxvYWREb2N1bWVudCxcbiAgICAgIHJlcGxhY2UsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIHRvLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgLi4ucmVzdFxuICAgIH0sXG4gICAgcmVmXG4gICkge1xuICAgIC8vIFJlbmRlcmVkIGludG8gPGEgaHJlZj4gZm9yIGFic29sdXRlIFVSTHNcbiAgICBsZXQgYWJzb2x1dGVIcmVmO1xuICAgIGxldCBpc0V4dGVybmFsID0gZmFsc2U7XG5cbiAgICBpZiAoXG4gICAgICBpc0Jyb3dzZXIgJiZcbiAgICAgIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgL14oPzpbYS16XVthLXowLTkrLi1dKjp8XFwvXFwvKS9pLnRlc3QodG8pXG4gICAgKSB7XG4gICAgICBhYnNvbHV0ZUhyZWYgPSB0bztcbiAgICAgIGxldCBjdXJyZW50VXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICBsZXQgdGFyZ2V0VXJsID0gdG8uc3RhcnRzV2l0aChcIi8vXCIpXG4gICAgICAgID8gbmV3IFVSTChjdXJyZW50VXJsLnByb3RvY29sICsgdG8pXG4gICAgICAgIDogbmV3IFVSTCh0byk7XG4gICAgICBpZiAodGFyZ2V0VXJsLm9yaWdpbiA9PT0gY3VycmVudFVybC5vcmlnaW4pIHtcbiAgICAgICAgLy8gU3RyaXAgdGhlIHByb3RvY29sL29yaWdpbiBmb3Igc2FtZS1vcmlnaW4gYWJzb2x1dGUgVVJMc1xuICAgICAgICB0byA9IHRhcmdldFVybC5wYXRobmFtZSArIHRhcmdldFVybC5zZWFyY2ggKyB0YXJnZXRVcmwuaGFzaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzRXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbmRlcmVkIGludG8gPGEgaHJlZj4gZm9yIHJlbGF0aXZlIFVSTHNcbiAgICBsZXQgaHJlZiA9IHVzZUhyZWYodG8sIHsgcmVsYXRpdmUgfSk7XG5cbiAgICBsZXQgaW50ZXJuYWxPbkNsaWNrID0gdXNlTGlua0NsaWNrSGFuZGxlcih0bywge1xuICAgICAgcmVwbGFjZSxcbiAgICAgIHN0YXRlLFxuICAgICAgdGFyZ2V0LFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgcmVsYXRpdmUsXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soXG4gICAgICBldmVudDogUmVhY3QuTW91c2VFdmVudDxIVE1MQW5jaG9yRWxlbWVudCwgTW91c2VFdmVudD5cbiAgICApIHtcbiAgICAgIGlmIChvbkNsaWNrKSBvbkNsaWNrKGV2ZW50KTtcbiAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICBpbnRlcm5hbE9uQ2xpY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganN4LWExMXkvYW5jaG9yLWhhcy1jb250ZW50XG4gICAgICA8YVxuICAgICAgICB7Li4ucmVzdH1cbiAgICAgICAgaHJlZj17YWJzb2x1dGVIcmVmIHx8IGhyZWZ9XG4gICAgICAgIG9uQ2xpY2s9e2lzRXh0ZXJuYWwgfHwgcmVsb2FkRG9jdW1lbnQgPyBvbkNsaWNrIDogaGFuZGxlQ2xpY2t9XG4gICAgICAgIHJlZj17cmVmfVxuICAgICAgICB0YXJnZXQ9e3RhcmdldH1cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTGluay5kaXNwbGF5TmFtZSA9IFwiTGlua1wiO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hdkxpbmtQcm9wc1xuICBleHRlbmRzIE9taXQ8TGlua1Byb3BzLCBcImNsYXNzTmFtZVwiIHwgXCJzdHlsZVwiIHwgXCJjaGlsZHJlblwiPiB7XG4gIGNoaWxkcmVuPzpcbiAgICB8IFJlYWN0LlJlYWN0Tm9kZVxuICAgIHwgKChwcm9wczogeyBpc0FjdGl2ZTogYm9vbGVhbjsgaXNQZW5kaW5nOiBib29sZWFuIH0pID0+IFJlYWN0LlJlYWN0Tm9kZSk7XG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICBjbGFzc05hbWU/OlxuICAgIHwgc3RyaW5nXG4gICAgfCAoKHByb3BzOiB7XG4gICAgICAgIGlzQWN0aXZlOiBib29sZWFuO1xuICAgICAgICBpc1BlbmRpbmc6IGJvb2xlYW47XG4gICAgICB9KSA9PiBzdHJpbmcgfCB1bmRlZmluZWQpO1xuICBlbmQ/OiBib29sZWFuO1xuICBzdHlsZT86XG4gICAgfCBSZWFjdC5DU1NQcm9wZXJ0aWVzXG4gICAgfCAoKHByb3BzOiB7XG4gICAgICAgIGlzQWN0aXZlOiBib29sZWFuO1xuICAgICAgICBpc1BlbmRpbmc6IGJvb2xlYW47XG4gICAgICB9KSA9PiBSZWFjdC5DU1NQcm9wZXJ0aWVzIHwgdW5kZWZpbmVkKTtcbn1cblxuLyoqXG4gKiBBIDxMaW5rPiB3cmFwcGVyIHRoYXQga25vd3MgaWYgaXQncyBcImFjdGl2ZVwiIG9yIG5vdC5cbiAqL1xuZXhwb3J0IGNvbnN0IE5hdkxpbmsgPSBSZWFjdC5mb3J3YXJkUmVmPEhUTUxBbmNob3JFbGVtZW50LCBOYXZMaW5rUHJvcHM+KFxuICBmdW5jdGlvbiBOYXZMaW5rV2l0aFJlZihcbiAgICB7XG4gICAgICBcImFyaWEtY3VycmVudFwiOiBhcmlhQ3VycmVudFByb3AgPSBcInBhZ2VcIixcbiAgICAgIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lUHJvcCA9IFwiXCIsXG4gICAgICBlbmQgPSBmYWxzZSxcbiAgICAgIHN0eWxlOiBzdHlsZVByb3AsXG4gICAgICB0byxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgLi4ucmVzdFxuICAgIH0sXG4gICAgcmVmXG4gICkge1xuICAgIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7IHJlbGF0aXZlOiByZXN0LnJlbGF0aXZlIH0pO1xuICAgIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gICAgbGV0IHJvdXRlclN0YXRlID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgICBsZXQgeyBuYXZpZ2F0b3IgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuXG4gICAgbGV0IHRvUGF0aG5hbWUgPSBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb25cbiAgICAgID8gbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uKHBhdGgpLnBhdGhuYW1lXG4gICAgICA6IHBhdGgucGF0aG5hbWU7XG4gICAgbGV0IGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICBsZXQgbmV4dExvY2F0aW9uUGF0aG5hbWUgPVxuICAgICAgcm91dGVyU3RhdGUgJiYgcm91dGVyU3RhdGUubmF2aWdhdGlvbiAmJiByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uXG4gICAgICAgID8gcm91dGVyU3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICA6IG51bGw7XG5cbiAgICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcbiAgICAgIGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBuZXh0TG9jYXRpb25QYXRobmFtZSA9IG5leHRMb2NhdGlvblBhdGhuYW1lXG4gICAgICAgID8gbmV4dExvY2F0aW9uUGF0aG5hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgICA6IG51bGw7XG4gICAgICB0b1BhdGhuYW1lID0gdG9QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGxldCBpc0FjdGl2ZSA9XG4gICAgICBsb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8XG4gICAgICAoIWVuZCAmJlxuICAgICAgICBsb2NhdGlvblBhdGhuYW1lLnN0YXJ0c1dpdGgodG9QYXRobmFtZSkgJiZcbiAgICAgICAgbG9jYXRpb25QYXRobmFtZS5jaGFyQXQodG9QYXRobmFtZS5sZW5ndGgpID09PSBcIi9cIik7XG5cbiAgICBsZXQgaXNQZW5kaW5nID1cbiAgICAgIG5leHRMb2NhdGlvblBhdGhuYW1lICE9IG51bGwgJiZcbiAgICAgIChuZXh0TG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fFxuICAgICAgICAoIWVuZCAmJlxuICAgICAgICAgIG5leHRMb2NhdGlvblBhdGhuYW1lLnN0YXJ0c1dpdGgodG9QYXRobmFtZSkgJiZcbiAgICAgICAgICBuZXh0TG9jYXRpb25QYXRobmFtZS5jaGFyQXQodG9QYXRobmFtZS5sZW5ndGgpID09PSBcIi9cIikpO1xuXG4gICAgbGV0IGFyaWFDdXJyZW50ID0gaXNBY3RpdmUgPyBhcmlhQ3VycmVudFByb3AgOiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgY2xhc3NOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiBjbGFzc05hbWVQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZVByb3AoeyBpc0FjdGl2ZSwgaXNQZW5kaW5nIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgY2xhc3NOYW1lIHByb3AgaXMgbm90IGEgZnVuY3Rpb24sIHdlIHVzZSBhIGRlZmF1bHQgYGFjdGl2ZWBcbiAgICAgIC8vIGNsYXNzIGZvciA8TmF2TGluayAvPnMgdGhhdCBhcmUgYWN0aXZlLiBJbiB2NSBgYWN0aXZlYCB3YXMgdGhlIGRlZmF1bHRcbiAgICAgIC8vIHZhbHVlIGZvciBgYWN0aXZlQ2xhc3NOYW1lYCwgYnV0IHdlIGFyZSByZW1vdmluZyB0aGF0IEFQSSBhbmQgY2FuIHN0aWxsXG4gICAgICAvLyB1c2UgdGhlIG9sZCBkZWZhdWx0IGJlaGF2aW9yIGZvciBhIGNsZWFuZXIgdXBncmFkZSBwYXRoIGFuZCBrZWVwIHRoZVxuICAgICAgLy8gc2ltcGxlIHN0eWxpbmcgcnVsZXMgd29ya2luZyBhcyB0aGV5IGN1cnJlbnRseSBkby5cbiAgICAgIGNsYXNzTmFtZSA9IFtcbiAgICAgICAgY2xhc3NOYW1lUHJvcCxcbiAgICAgICAgaXNBY3RpdmUgPyBcImFjdGl2ZVwiIDogbnVsbCxcbiAgICAgICAgaXNQZW5kaW5nID8gXCJwZW5kaW5nXCIgOiBudWxsLFxuICAgICAgXVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgIC5qb2luKFwiIFwiKTtcbiAgICB9XG5cbiAgICBsZXQgc3R5bGUgPVxuICAgICAgdHlwZW9mIHN0eWxlUHJvcCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gc3R5bGVQcm9wKHsgaXNBY3RpdmUsIGlzUGVuZGluZyB9KVxuICAgICAgICA6IHN0eWxlUHJvcDtcblxuICAgIHJldHVybiAoXG4gICAgICA8TGlua1xuICAgICAgICB7Li4ucmVzdH1cbiAgICAgICAgYXJpYS1jdXJyZW50PXthcmlhQ3VycmVudH1cbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgICAgIHJlZj17cmVmfVxuICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICAgIHRvPXt0b31cbiAgICAgID5cbiAgICAgICAge3R5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBjaGlsZHJlbih7IGlzQWN0aXZlLCBpc1BlbmRpbmcgfSlcbiAgICAgICAgICA6IGNoaWxkcmVufVxuICAgICAgPC9MaW5rPlxuICAgICk7XG4gIH1cbik7XG5cbmlmIChfX0RFVl9fKSB7XG4gIE5hdkxpbmsuZGlzcGxheU5hbWUgPSBcIk5hdkxpbmtcIjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGb3JtUHJvcHMgZXh0ZW5kcyBSZWFjdC5Gb3JtSFRNTEF0dHJpYnV0ZXM8SFRNTEZvcm1FbGVtZW50PiB7XG4gIC8qKlxuICAgKiBUaGUgSFRUUCB2ZXJiIHRvIHVzZSB3aGVuIHRoZSBmb3JtIGlzIHN1Ym1pdC4gU3VwcG9ydHMgXCJnZXRcIiwgXCJwb3N0XCIsXG4gICAqIFwicHV0XCIsIFwiZGVsZXRlXCIsIFwicGF0Y2hcIi5cbiAgICovXG4gIG1ldGhvZD86IEZvcm1NZXRob2Q7XG5cbiAgLyoqXG4gICAqIE5vcm1hbCBgPGZvcm0gYWN0aW9uPmAgYnV0IHN1cHBvcnRzIFJlYWN0IFJvdXRlcidzIHJlbGF0aXZlIHBhdGhzLlxuICAgKi9cbiAgYWN0aW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBGb3JjZXMgYSBmdWxsIGRvY3VtZW50IG5hdmlnYXRpb24gaW5zdGVhZCBvZiBhIGZldGNoLlxuICAgKi9cbiAgcmVsb2FkRG9jdW1lbnQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgY3VycmVudCBlbnRyeSBpbiB0aGUgYnJvd3NlciBoaXN0b3J5IHN0YWNrIHdoZW4gdGhlIGZvcm1cbiAgICogbmF2aWdhdGVzLiBVc2UgdGhpcyBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgdXNlciB0byBiZSBhYmxlIHRvIGNsaWNrIFwiYmFja1wiXG4gICAqIHRvIHRoZSBwYWdlIHdpdGggdGhlIGZvcm0gb24gaXQuXG4gICAqL1xuICByZXBsYWNlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmb3JtIGFjdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgcm91dGUgaGllcmFyY2h5IG9yXG4gICAqIHRoZSBwYXRobmFtZS4gIFVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIG9wdCBvdXQgb2YgbmF2aWdhdGluZyB0aGUgcm91dGVcbiAgICogaGllcmFyY2h5IGFuZCB3YW50IHRvIGluc3RlYWQgcm91dGUgYmFzZWQgb24gLy1kZWxpbWl0ZWQgVVJMIHNlZ21lbnRzXG4gICAqL1xuICByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGU7XG5cbiAgLyoqXG4gICAqIFByZXZlbnQgdGhlIHNjcm9sbCBwb3NpdGlvbiBmcm9tIHJlc2V0dGluZyB0byB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydCBvblxuICAgKiBjb21wbGV0aW9uIG9mIHRoZSBuYXZpZ2F0aW9uIHdoZW4gdXNpbmcgdGhlIDxTY3JvbGxSZXN0b3JhdGlvbj4gY29tcG9uZW50XG4gICAqL1xuICBwcmV2ZW50U2Nyb2xsUmVzZXQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZm9ybSBpcyBzdWJtaXR0ZWQuIElmIHlvdSBjYWxsXG4gICAqIGBldmVudC5wcmV2ZW50RGVmYXVsdCgpYCB0aGVuIHRoaXMgZm9ybSB3aWxsIG5vdCBkbyBhbnl0aGluZy5cbiAgICovXG4gIG9uU3VibWl0PzogUmVhY3QuRm9ybUV2ZW50SGFuZGxlcjxIVE1MRm9ybUVsZW1lbnQ+O1xufVxuXG4vKipcbiAqIEEgYEByZW1peC1ydW4vcm91dGVyYC1hd2FyZSBgPGZvcm0+YC4gSXQgYmVoYXZlcyBsaWtlIGEgbm9ybWFsIGZvcm0gZXhjZXB0XG4gKiB0aGF0IHRoZSBpbnRlcmFjdGlvbiB3aXRoIHRoZSBzZXJ2ZXIgaXMgd2l0aCBgZmV0Y2hgIGluc3RlYWQgb2YgbmV3IGRvY3VtZW50XG4gKiByZXF1ZXN0cywgYWxsb3dpbmcgY29tcG9uZW50cyB0byBhZGQgbmljZXIgVVggdG8gdGhlIHBhZ2UgYXMgdGhlIGZvcm0gaXNcbiAqIHN1Ym1pdHRlZCBhbmQgcmV0dXJucyB3aXRoIGRhdGEuXG4gKi9cbmV4cG9ydCBjb25zdCBGb3JtID0gUmVhY3QuZm9yd2FyZFJlZjxIVE1MRm9ybUVsZW1lbnQsIEZvcm1Qcm9wcz4oXG4gIChwcm9wcywgcmVmKSA9PiB7XG4gICAgcmV0dXJuIDxGb3JtSW1wbCB7Li4ucHJvcHN9IHJlZj17cmVmfSAvPjtcbiAgfVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgRm9ybS5kaXNwbGF5TmFtZSA9IFwiRm9ybVwiO1xufVxuXG50eXBlIEhUTUxTdWJtaXRFdmVudCA9IFJlYWN0LkJhc2VTeW50aGV0aWNFdmVudDxcbiAgU3VibWl0RXZlbnQsXG4gIEV2ZW50LFxuICBIVE1MRm9ybUVsZW1lbnRcbj47XG5cbnR5cGUgSFRNTEZvcm1TdWJtaXR0ZXIgPSBIVE1MQnV0dG9uRWxlbWVudCB8IEhUTUxJbnB1dEVsZW1lbnQ7XG5cbmludGVyZmFjZSBGb3JtSW1wbFByb3BzIGV4dGVuZHMgRm9ybVByb3BzIHtcbiAgZmV0Y2hlcktleT86IHN0cmluZztcbiAgcm91dGVJZD86IHN0cmluZztcbn1cblxuY29uc3QgRm9ybUltcGwgPSBSZWFjdC5mb3J3YXJkUmVmPEhUTUxGb3JtRWxlbWVudCwgRm9ybUltcGxQcm9wcz4oXG4gIChcbiAgICB7XG4gICAgICByZWxvYWREb2N1bWVudCxcbiAgICAgIHJlcGxhY2UsXG4gICAgICBtZXRob2QgPSBkZWZhdWx0TWV0aG9kLFxuICAgICAgYWN0aW9uLFxuICAgICAgb25TdWJtaXQsXG4gICAgICBmZXRjaGVyS2V5LFxuICAgICAgcm91dGVJZCxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgLi4ucHJvcHNcbiAgICB9LFxuICAgIGZvcndhcmRlZFJlZlxuICApID0+IHtcbiAgICBsZXQgc3VibWl0ID0gdXNlU3VibWl0SW1wbChmZXRjaGVyS2V5LCByb3V0ZUlkKTtcbiAgICBsZXQgZm9ybU1ldGhvZDogRm9ybU1ldGhvZCA9XG4gICAgICBtZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJnZXRcIiA/IFwiZ2V0XCIgOiBcInBvc3RcIjtcbiAgICBsZXQgZm9ybUFjdGlvbiA9IHVzZUZvcm1BY3Rpb24oYWN0aW9uLCB7IHJlbGF0aXZlIH0pO1xuICAgIGxldCBzdWJtaXRIYW5kbGVyOiBSZWFjdC5Gb3JtRXZlbnRIYW5kbGVyPEhUTUxGb3JtRWxlbWVudD4gPSAoZXZlbnQpID0+IHtcbiAgICAgIG9uU3VibWl0ICYmIG9uU3VibWl0KGV2ZW50KTtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBsZXQgc3VibWl0dGVyID0gKGV2ZW50IGFzIHVua25vd24gYXMgSFRNTFN1Ym1pdEV2ZW50KS5uYXRpdmVFdmVudFxuICAgICAgICAuc3VibWl0dGVyIGFzIEhUTUxGb3JtU3VibWl0dGVyIHwgbnVsbDtcblxuICAgICAgbGV0IHN1Ym1pdE1ldGhvZCA9XG4gICAgICAgIChzdWJtaXR0ZXI/LmdldEF0dHJpYnV0ZShcImZvcm1tZXRob2RcIikgYXMgRm9ybU1ldGhvZCB8IHVuZGVmaW5lZCkgfHxcbiAgICAgICAgbWV0aG9kO1xuXG4gICAgICBzdWJtaXQoc3VibWl0dGVyIHx8IGV2ZW50LmN1cnJlbnRUYXJnZXQsIHtcbiAgICAgICAgbWV0aG9kOiBzdWJtaXRNZXRob2QsXG4gICAgICAgIHJlcGxhY2UsXG4gICAgICAgIHJlbGF0aXZlLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxmb3JtXG4gICAgICAgIHJlZj17Zm9yd2FyZGVkUmVmfVxuICAgICAgICBtZXRob2Q9e2Zvcm1NZXRob2R9XG4gICAgICAgIGFjdGlvbj17Zm9ybUFjdGlvbn1cbiAgICAgICAgb25TdWJtaXQ9e3JlbG9hZERvY3VtZW50ID8gb25TdWJtaXQgOiBzdWJtaXRIYW5kbGVyfVxuICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAvPlxuICAgICk7XG4gIH1cbik7XG5cbmlmIChfX0RFVl9fKSB7XG4gIEZvcm1JbXBsLmRpc3BsYXlOYW1lID0gXCJGb3JtSW1wbFwiO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjcm9sbFJlc3RvcmF0aW9uUHJvcHMge1xuICBnZXRLZXk/OiBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uO1xuICBzdG9yYWdlS2V5Pzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHdpbGwgZW11bGF0ZSB0aGUgYnJvd3NlcidzIHNjcm9sbCByZXN0b3JhdGlvbiBvbiBsb2NhdGlvblxuICogY2hhbmdlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNjcm9sbFJlc3RvcmF0aW9uKHtcbiAgZ2V0S2V5LFxuICBzdG9yYWdlS2V5LFxufTogU2Nyb2xsUmVzdG9yYXRpb25Qcm9wcykge1xuICB1c2VTY3JvbGxSZXN0b3JhdGlvbih7IGdldEtleSwgc3RvcmFnZUtleSB9KTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmlmIChfX0RFVl9fKSB7XG4gIFNjcm9sbFJlc3RvcmF0aW9uLmRpc3BsYXlOYW1lID0gXCJTY3JvbGxSZXN0b3JhdGlvblwiO1xufVxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gSG9va3Ncbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmVudW0gRGF0YVJvdXRlckhvb2sge1xuICBVc2VTY3JvbGxSZXN0b3JhdGlvbiA9IFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIixcbiAgVXNlU3VibWl0SW1wbCA9IFwidXNlU3VibWl0SW1wbFwiLFxuICBVc2VGZXRjaGVyID0gXCJ1c2VGZXRjaGVyXCIsXG59XG5cbmVudW0gRGF0YVJvdXRlclN0YXRlSG9vayB7XG4gIFVzZUZldGNoZXJzID0gXCJ1c2VGZXRjaGVyc1wiLFxuICBVc2VTY3JvbGxSZXN0b3JhdGlvbiA9IFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIixcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihcbiAgaG9va05hbWU6IERhdGFSb3V0ZXJIb29rIHwgRGF0YVJvdXRlclN0YXRlSG9va1xuKSB7XG4gIHJldHVybiBgJHtob29rTmFtZX0gbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGRhdGEgcm91dGVyLiAgU2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlcnMvcGlja2luZy1hLXJvdXRlci5gO1xufVxuXG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyQ29udGV4dChob29rTmFtZTogRGF0YVJvdXRlckhvb2spIHtcbiAgbGV0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBpbnZhcmlhbnQoY3R4LCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSk7XG4gIHJldHVybiBjdHg7XG59XG5cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJTdGF0ZShob29rTmFtZTogRGF0YVJvdXRlclN0YXRlSG9vaykge1xuICBsZXQgc3RhdGUgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQoc3RhdGUsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEhhbmRsZXMgdGhlIGNsaWNrIGJlaGF2aW9yIGZvciByb3V0ZXIgYDxMaW5rPmAgY29tcG9uZW50cy4gVGhpcyBpcyB1c2VmdWwgaWZcbiAqIHlvdSBuZWVkIHRvIGNyZWF0ZSBjdXN0b20gYDxMaW5rPmAgY29tcG9uZW50cyB3aXRoIHRoZSBzYW1lIGNsaWNrIGJlaGF2aW9yIHdlXG4gKiB1c2UgaW4gb3VyIGV4cG9ydGVkIGA8TGluaz5gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGlua0NsaWNrSGFuZGxlcjxFIGV4dGVuZHMgRWxlbWVudCA9IEhUTUxBbmNob3JFbGVtZW50PihcbiAgdG86IFRvLFxuICB7XG4gICAgdGFyZ2V0LFxuICAgIHJlcGxhY2U6IHJlcGxhY2VQcm9wLFxuICAgIHN0YXRlLFxuICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICByZWxhdGl2ZSxcbiAgfToge1xuICAgIHRhcmdldD86IFJlYWN0LkhUTUxBdHRyaWJ1dGVBbmNob3JUYXJnZXQ7XG4gICAgcmVwbGFjZT86IGJvb2xlYW47XG4gICAgc3RhdGU/OiBhbnk7XG4gICAgcHJldmVudFNjcm9sbFJlc2V0PzogYm9vbGVhbjtcbiAgICByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGU7XG4gIH0gPSB7fVxuKTogKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEUsIE1vdXNlRXZlbnQ+KSA9PiB2b2lkIHtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmUgfSk7XG5cbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChldmVudDogUmVhY3QuTW91c2VFdmVudDxFLCBNb3VzZUV2ZW50PikgPT4ge1xuICAgICAgaWYgKHNob3VsZFByb2Nlc3NMaW5rQ2xpY2soZXZlbnQsIHRhcmdldCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBJZiB0aGUgVVJMIGhhc24ndCBjaGFuZ2VkLCBhIHJlZ3VsYXIgPGE+IHdpbGwgZG8gYSByZXBsYWNlIGluc3RlYWQgb2ZcbiAgICAgICAgLy8gYSBwdXNoLCBzbyBkbyB0aGUgc2FtZSBoZXJlIHVubGVzcyB0aGUgcmVwbGFjZSBwcm9wIGlzIGV4cGxpY2l0bHkgc2V0XG4gICAgICAgIGxldCByZXBsYWNlID1cbiAgICAgICAgICByZXBsYWNlUHJvcCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHJlcGxhY2VQcm9wXG4gICAgICAgICAgICA6IGNyZWF0ZVBhdGgobG9jYXRpb24pID09PSBjcmVhdGVQYXRoKHBhdGgpO1xuXG4gICAgICAgIG5hdmlnYXRlKHRvLCB7IHJlcGxhY2UsIHN0YXRlLCBwcmV2ZW50U2Nyb2xsUmVzZXQsIHJlbGF0aXZlIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgbG9jYXRpb24sXG4gICAgICBuYXZpZ2F0ZSxcbiAgICAgIHBhdGgsXG4gICAgICByZXBsYWNlUHJvcCxcbiAgICAgIHN0YXRlLFxuICAgICAgdGFyZ2V0LFxuICAgICAgdG8sXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZWxhdGl2ZSxcbiAgICBdXG4gICk7XG59XG5cbi8qKlxuICogQSBjb252ZW5pZW50IHdyYXBwZXIgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcgc2VhcmNoIHBhcmFtZXRlcnMgdmlhIHRoZVxuICogVVJMU2VhcmNoUGFyYW1zIGludGVyZmFjZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVNlYXJjaFBhcmFtcyhcbiAgZGVmYXVsdEluaXQ/OiBVUkxTZWFyY2hQYXJhbXNJbml0XG4pOiBbVVJMU2VhcmNoUGFyYW1zLCBTZXRVUkxTZWFyY2hQYXJhbXNdIHtcbiAgd2FybmluZyhcbiAgICB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSBcInVuZGVmaW5lZFwiLFxuICAgIGBZb3UgY2Fubm90IHVzZSB0aGUgXFxgdXNlU2VhcmNoUGFyYW1zXFxgIGhvb2sgaW4gYSBicm93c2VyIHRoYXQgZG9lcyBub3QgYCArXG4gICAgICBgc3VwcG9ydCB0aGUgVVJMU2VhcmNoUGFyYW1zIEFQSS4gSWYgeW91IG5lZWQgdG8gc3VwcG9ydCBJbnRlcm5ldCBgICtcbiAgICAgIGBFeHBsb3JlciAxMSwgd2UgcmVjb21tZW5kIHlvdSBsb2FkIGEgcG9seWZpbGwgc3VjaCBhcyBgICtcbiAgICAgIGBodHRwczovL2dpdGh1Yi5jb20vdW5nYXAvdXJsLXNlYXJjaC1wYXJhbXNcXG5cXG5gICtcbiAgICAgIGBJZiB5b3UncmUgdW5zdXJlIGhvdyB0byBsb2FkIHBvbHlmaWxscywgd2UgcmVjb21tZW5kIHlvdSBjaGVjayBvdXQgYCArXG4gICAgICBgaHR0cHM6Ly9wb2x5ZmlsbC5pby92My8gd2hpY2ggcHJvdmlkZXMgc29tZSByZWNvbW1lbmRhdGlvbnMgYWJvdXQgaG93IGAgK1xuICAgICAgYHRvIGxvYWQgcG9seWZpbGxzIG9ubHkgZm9yIHVzZXJzIHRoYXQgbmVlZCB0aGVtLCBpbnN0ZWFkIG9mIGZvciBldmVyeSBgICtcbiAgICAgIGB1c2VyLmBcbiAgKTtcblxuICBsZXQgZGVmYXVsdFNlYXJjaFBhcmFtc1JlZiA9IFJlYWN0LnVzZVJlZihjcmVhdGVTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQpKTtcbiAgbGV0IGhhc1NldFNlYXJjaFBhcmFtc1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG5cbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT5cbiAgICAgIC8vIE9ubHkgbWVyZ2UgaW4gdGhlIGRlZmF1bHRzIGlmIHdlIGhhdmVuJ3QgeWV0IGNhbGxlZCBzZXRTZWFyY2hQYXJhbXMuXG4gICAgICAvLyBPbmNlIHdlIGNhbGwgdGhhdCB3ZSB3YW50IHRob3NlIHRvIHRha2UgcHJlY2VkZW5jZSwgb3RoZXJ3aXNlIHlvdSBjYW4ndFxuICAgICAgLy8gcmVtb3ZlIGEgcGFyYW0gd2l0aCBzZXRTZWFyY2hQYXJhbXMoe30pIGlmIGl0IGhhcyBhbiBpbml0aWFsIHZhbHVlXG4gICAgICBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihcbiAgICAgICAgbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNTZXRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCA/IG51bGwgOiBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnRcbiAgICAgICksXG4gICAgW2xvY2F0aW9uLnNlYXJjaF1cbiAgKTtcblxuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgc2V0U2VhcmNoUGFyYW1zID0gUmVhY3QudXNlQ2FsbGJhY2s8U2V0VVJMU2VhcmNoUGFyYW1zPihcbiAgICAobmV4dEluaXQsIG5hdmlnYXRlT3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgbmV3U2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKFxuICAgICAgICB0eXBlb2YgbmV4dEluaXQgPT09IFwiZnVuY3Rpb25cIiA/IG5leHRJbml0KHNlYXJjaFBhcmFtcykgOiBuZXh0SW5pdFxuICAgICAgKTtcbiAgICAgIGhhc1NldFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIG5hdmlnYXRlKFwiP1wiICsgbmV3U2VhcmNoUGFyYW1zLCBuYXZpZ2F0ZU9wdGlvbnMpO1xuICAgIH0sXG4gICAgW25hdmlnYXRlLCBzZWFyY2hQYXJhbXNdXG4gICk7XG5cbiAgcmV0dXJuIFtzZWFyY2hQYXJhbXMsIHNldFNlYXJjaFBhcmFtc107XG59XG5cbnR5cGUgU2V0VVJMU2VhcmNoUGFyYW1zID0gKFxuICBuZXh0SW5pdD86XG4gICAgfCBVUkxTZWFyY2hQYXJhbXNJbml0XG4gICAgfCAoKHByZXY6IFVSTFNlYXJjaFBhcmFtcykgPT4gVVJMU2VhcmNoUGFyYW1zSW5pdCksXG4gIG5hdmlnYXRlT3B0cz86IE5hdmlnYXRlT3B0aW9uc1xuKSA9PiB2b2lkO1xuXG50eXBlIFN1Ym1pdFRhcmdldCA9XG4gIHwgSFRNTEZvcm1FbGVtZW50XG4gIHwgSFRNTEJ1dHRvbkVsZW1lbnRcbiAgfCBIVE1MSW5wdXRFbGVtZW50XG4gIHwgRm9ybURhdGFcbiAgfCBVUkxTZWFyY2hQYXJhbXNcbiAgfCB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfVxuICB8IG51bGw7XG5cbi8qKlxuICogU3VibWl0cyBhIEhUTUwgYDxmb3JtPmAgdG8gdGhlIHNlcnZlciB3aXRob3V0IHJlbG9hZGluZyB0aGUgcGFnZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdWJtaXRGdW5jdGlvbiB7XG4gIChcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGA8Zm9ybT5gIHRvIGJlIHN1Ym1pdHRlZCB0byB0aGUgc2VydmVyLCBhIHNwZWNpZmljXG4gICAgICogYDxidXR0b24+YCBvciBgPGlucHV0IHR5cGU9XCJzdWJtaXRcIj5gIHRvIHVzZSB0byBzdWJtaXQgdGhlIGZvcm0sIG9yIHNvbWVcbiAgICAgKiBhcmJpdHJhcnkgZGF0YSB0byBzdWJtaXQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBXaGVuIHVzaW5nIGEgYDxidXR0b24+YCBpdHMgYG5hbWVgIGFuZCBgdmFsdWVgIHdpbGwgYWxzbyBiZVxuICAgICAqIGluY2x1ZGVkIGluIHRoZSBmb3JtIGRhdGEgdGhhdCBpcyBzdWJtaXR0ZWQuXG4gICAgICovXG4gICAgdGFyZ2V0OiBTdWJtaXRUYXJnZXQsXG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zIHRoYXQgb3ZlcnJpZGUgdGhlIGA8Zm9ybT5gJ3Mgb3duIGF0dHJpYnV0ZXMuIFJlcXVpcmVkIHdoZW5cbiAgICAgKiBzdWJtaXR0aW5nIGFyYml0cmFyeSBkYXRhIHdpdGhvdXQgYSBiYWNraW5nIGA8Zm9ybT5gLlxuICAgICAqL1xuICAgIG9wdGlvbnM/OiBTdWJtaXRPcHRpb25zXG4gICk6IHZvaWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gcHJvZ3JhbW1hdGljYWxseSBzdWJtaXQgYSBmb3JtIChvclxuICogc29tZSBhcmJpdHJhcnkgZGF0YSkgdG8gdGhlIHNlcnZlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN1Ym1pdCgpOiBTdWJtaXRGdW5jdGlvbiB7XG4gIHJldHVybiB1c2VTdWJtaXRJbXBsKCk7XG59XG5cbmZ1bmN0aW9uIHVzZVN1Ym1pdEltcGwoZmV0Y2hlcktleT86IHN0cmluZywgcm91dGVJZD86IHN0cmluZyk6IFN1Ym1pdEZ1bmN0aW9uIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VTdWJtaXRJbXBsKTtcbiAgbGV0IGRlZmF1bHRBY3Rpb24gPSB1c2VGb3JtQWN0aW9uKCk7XG5cbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICh0YXJnZXQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJZb3UgYXJlIGNhbGxpbmcgc3VibWl0IGR1cmluZyB0aGUgc2VydmVyIHJlbmRlci4gXCIgK1xuICAgICAgICAgICAgXCJUcnkgY2FsbGluZyBzdWJtaXQgd2l0aGluIGEgYHVzZUVmZmVjdGAgb3IgY2FsbGJhY2sgaW5zdGVhZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBsZXQgeyBtZXRob2QsIGVuY1R5cGUsIGZvcm1EYXRhLCB1cmwgfSA9IGdldEZvcm1TdWJtaXNzaW9uSW5mbyhcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBkZWZhdWx0QWN0aW9uLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuXG4gICAgICBsZXQgaHJlZiA9IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2g7XG4gICAgICBsZXQgb3B0cyA9IHtcbiAgICAgICAgcmVwbGFjZTogb3B0aW9ucy5yZXBsYWNlLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdGlvbnMucHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgZm9ybU1ldGhvZDogbWV0aG9kIGFzIEZvcm1NZXRob2QsXG4gICAgICAgIGZvcm1FbmNUeXBlOiBlbmNUeXBlIGFzIEZvcm1FbmNUeXBlLFxuICAgICAgfTtcbiAgICAgIGlmIChmZXRjaGVyS2V5KSB7XG4gICAgICAgIGludmFyaWFudChyb3V0ZUlkICE9IG51bGwsIFwiTm8gcm91dGVJZCBhdmFpbGFibGUgZm9yIHVzZUZldGNoZXIoKVwiKTtcbiAgICAgICAgcm91dGVyLmZldGNoKGZldGNoZXJLZXksIHJvdXRlSWQsIGhyZWYsIG9wdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm91dGVyLm5hdmlnYXRlKGhyZWYsIG9wdHMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2RlZmF1bHRBY3Rpb24sIHJvdXRlciwgZmV0Y2hlcktleSwgcm91dGVJZF1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvcm1BY3Rpb24oXG4gIGFjdGlvbj86IHN0cmluZyxcbiAgeyByZWxhdGl2ZSB9OiB7IHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZSB9ID0ge31cbik6IHN0cmluZyB7XG4gIGxldCB7IGJhc2VuYW1lIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHJvdXRlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgaW52YXJpYW50KHJvdXRlQ29udGV4dCwgXCJ1c2VGb3JtQWN0aW9uIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBSb3V0ZUNvbnRleHRcIik7XG5cbiAgbGV0IFttYXRjaF0gPSByb3V0ZUNvbnRleHQubWF0Y2hlcy5zbGljZSgtMSk7XG4gIC8vIFNoYWxsb3cgY2xvbmUgcGF0aCBzbyB3ZSBjYW4gbW9kaWZ5IGl0IGJlbG93LCBvdGhlcndpc2Ugd2UgbW9kaWZ5IHRoZVxuICAvLyBvYmplY3QgcmVmZXJlbmNlZCBieSB1c2VNZW1vIGluc2lkZSB1c2VSZXNvbHZlZFBhdGhcbiAgbGV0IHBhdGggPSB7IC4uLnVzZVJlc29sdmVkUGF0aChhY3Rpb24gPyBhY3Rpb24gOiBcIi5cIiwgeyByZWxhdGl2ZSB9KSB9O1xuXG4gIC8vIFByZXZpb3VzbHkgd2Ugc2V0IHRoZSBkZWZhdWx0IGFjdGlvbiB0byBcIi5cIi4gVGhlIHByb2JsZW0gd2l0aCB0aGlzIGlzIHRoYXRcbiAgLy8gYHVzZVJlc29sdmVkUGF0aChcIi5cIilgIGV4Y2x1ZGVzIHNlYXJjaCBwYXJhbXMgYW5kIHRoZSBoYXNoIG9mIHRoZSByZXNvbHZlZFxuICAvLyBVUkwuIFRoaXMgaXMgdGhlIGludGVuZGVkIGJlaGF2aW9yIG9mIHdoZW4gXCIuXCIgaXMgc3BlY2lmaWNhbGx5IHByb3ZpZGVkIGFzXG4gIC8vIHRoZSBmb3JtIGFjdGlvbiwgYnV0IGluY29uc2lzdGVudCB3LyBicm93c2VycyB3aGVuIHRoZSBhY3Rpb24gaXMgb21pdHRlZC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZW1peC9pc3N1ZXMvOTI3XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGlmIChhY3Rpb24gPT0gbnVsbCkge1xuICAgIC8vIFNhZmUgdG8gd3JpdGUgdG8gdGhlc2UgZGlyZWN0bHkgaGVyZSBzaW5jZSBpZiBhY3Rpb24gd2FzIHVuZGVmaW5lZCwgd2VcbiAgICAvLyB3b3VsZCBoYXZlIGNhbGxlZCB1c2VSZXNvbHZlZFBhdGgoXCIuXCIpIHdoaWNoIHdpbGwgbmV2ZXIgaW5jbHVkZSBhIHNlYXJjaFxuICAgIC8vIG9yIGhhc2hcbiAgICBwYXRoLnNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICBwYXRoLmhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuXG4gICAgLy8gV2hlbiBncmFiYmluZyBzZWFyY2ggcGFyYW1zIGZyb20gdGhlIFVSTCwgcmVtb3ZlIHRoZSBhdXRvbWF0aWNhbGx5XG4gICAgLy8gaW5zZXJ0ZWQgP2luZGV4IHBhcmFtIHNvIHdlIG1hdGNoIHRoZSB1c2VSZXNvbHZlZFBhdGggc2VhcmNoIGJlaGF2aW9yXG4gICAgLy8gd2hpY2ggd291bGQgbm90IGluY2x1ZGUgP2luZGV4XG4gICAgaWYgKG1hdGNoLnJvdXRlLmluZGV4KSB7XG4gICAgICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXRoLnNlYXJjaCk7XG4gICAgICBwYXJhbXMuZGVsZXRlKFwiaW5kZXhcIik7XG4gICAgICBwYXRoLnNlYXJjaCA9IHBhcmFtcy50b1N0cmluZygpID8gYD8ke3BhcmFtcy50b1N0cmluZygpfWAgOiBcIlwiO1xuICAgIH1cbiAgfVxuXG4gIGlmICgoIWFjdGlvbiB8fCBhY3Rpb24gPT09IFwiLlwiKSAmJiBtYXRjaC5yb3V0ZS5pbmRleCkge1xuICAgIHBhdGguc2VhcmNoID0gcGF0aC5zZWFyY2hcbiAgICAgID8gcGF0aC5zZWFyY2gucmVwbGFjZSgvXlxcPy8sIFwiP2luZGV4JlwiKVxuICAgICAgOiBcIj9pbmRleFwiO1xuICB9XG5cbiAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZSBwcmlvclxuICAvLyB0byBjcmVhdGluZyB0aGUgZm9ybSBhY3Rpb24uICBJZiB0aGlzIGlzIGEgcm9vdCBuYXZpZ2F0aW9uLCB0aGVuIGp1c3QgdXNlXG4gIC8vIHRoZSByYXcgYmFzZW5hbWUgd2hpY2ggYWxsb3dzIHRoZSBiYXNlbmFtZSB0byBoYXZlIGZ1bGwgY29udHJvbCBvdmVyIHRoZVxuICAvLyBwcmVzZW5jZSBvZiBhIHRyYWlsaW5nIHNsYXNoIG9uIHJvb3QgYWN0aW9uc1xuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgcGF0aC5wYXRobmFtZSA9XG4gICAgICBwYXRoLnBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZVBhdGgocGF0aCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoZXJGb3JtKGZldGNoZXJLZXk6IHN0cmluZywgcm91dGVJZDogc3RyaW5nKSB7XG4gIGxldCBGZXRjaGVyRm9ybSA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTEZvcm1FbGVtZW50LCBGb3JtUHJvcHM+KFxuICAgIChwcm9wcywgcmVmKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8Rm9ybUltcGxcbiAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgICAgZmV0Y2hlcktleT17ZmV0Y2hlcktleX1cbiAgICAgICAgICByb3V0ZUlkPXtyb3V0ZUlkfVxuICAgICAgICAvPlxuICAgICAgKTtcbiAgICB9XG4gICk7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgRmV0Y2hlckZvcm0uZGlzcGxheU5hbWUgPSBcImZldGNoZXIuRm9ybVwiO1xuICB9XG4gIHJldHVybiBGZXRjaGVyRm9ybTtcbn1cblxubGV0IGZldGNoZXJJZCA9IDA7XG5cbmV4cG9ydCB0eXBlIEZldGNoZXJXaXRoQ29tcG9uZW50czxURGF0YT4gPSBGZXRjaGVyPFREYXRhPiAmIHtcbiAgRm9ybTogUmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlRmV0Y2hlckZvcm0+O1xuICBzdWJtaXQ6IChcbiAgICB0YXJnZXQ6IFN1Ym1pdFRhcmdldCxcbiAgICAvLyBGZXRjaGVycyBjYW5ub3QgcmVwbGFjZS9wcmV2ZW50U2Nyb2xsUmVzZXQgYmVjYXVzZSB0aGV5IGFyZSBub3RcbiAgICAvLyBuYXZpZ2F0aW9uIGV2ZW50c1xuICAgIG9wdGlvbnM/OiBPbWl0PFN1Ym1pdE9wdGlvbnMsIFwicmVwbGFjZVwiIHwgXCJwcmV2ZW50U2Nyb2xsUmVzZXRcIj5cbiAgKSA9PiB2b2lkO1xuICBsb2FkOiAoaHJlZjogc3RyaW5nKSA9PiB2b2lkO1xufTtcblxuLyoqXG4gKiBJbnRlcmFjdHMgd2l0aCByb3V0ZSBsb2FkZXJzIGFuZCBhY3Rpb25zIHdpdGhvdXQgY2F1c2luZyBhIG5hdmlnYXRpb24uIEdyZWF0XG4gKiBmb3IgYW55IGludGVyYWN0aW9uIHRoYXQgc3RheXMgb24gdGhlIHNhbWUgcGFnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZldGNoZXI8VERhdGEgPSBhbnk+KCk6IEZldGNoZXJXaXRoQ29tcG9uZW50czxURGF0YT4ge1xuICBsZXQgeyByb3V0ZXIgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZUZldGNoZXIpO1xuXG4gIGxldCByb3V0ZSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgaW52YXJpYW50KHJvdXRlLCBgdXNlRmV0Y2hlciBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgUm91dGVDb250ZXh0YCk7XG5cbiAgbGV0IHJvdXRlSWQgPSByb3V0ZS5tYXRjaGVzW3JvdXRlLm1hdGNoZXMubGVuZ3RoIC0gMV0/LnJvdXRlLmlkO1xuICBpbnZhcmlhbnQoXG4gICAgcm91dGVJZCAhPSBudWxsLFxuICAgIGB1c2VGZXRjaGVyIGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcImlkXCJgXG4gICk7XG5cbiAgbGV0IFtmZXRjaGVyS2V5XSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IFN0cmluZygrK2ZldGNoZXJJZCkpO1xuICBsZXQgW0Zvcm1dID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgIGludmFyaWFudChyb3V0ZUlkLCBgTm8gcm91dGVJZCBhdmFpbGFibGUgZm9yIGZldGNoZXIuRm9ybSgpYCk7XG4gICAgcmV0dXJuIGNyZWF0ZUZldGNoZXJGb3JtKGZldGNoZXJLZXksIHJvdXRlSWQpO1xuICB9KTtcbiAgbGV0IFtsb2FkXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IChocmVmOiBzdHJpbmcpID0+IHtcbiAgICBpbnZhcmlhbnQocm91dGVyLCBcIk5vIHJvdXRlciBhdmFpbGFibGUgZm9yIGZldGNoZXIubG9hZCgpXCIpO1xuICAgIGludmFyaWFudChyb3V0ZUlkLCBcIk5vIHJvdXRlSWQgYXZhaWxhYmxlIGZvciBmZXRjaGVyLmxvYWQoKVwiKTtcbiAgICByb3V0ZXIuZmV0Y2goZmV0Y2hlcktleSwgcm91dGVJZCwgaHJlZik7XG4gIH0pO1xuICBsZXQgc3VibWl0ID0gdXNlU3VibWl0SW1wbChmZXRjaGVyS2V5LCByb3V0ZUlkKTtcblxuICBsZXQgZmV0Y2hlciA9IHJvdXRlci5nZXRGZXRjaGVyPFREYXRhPihmZXRjaGVyS2V5KTtcblxuICBsZXQgZmV0Y2hlcldpdGhDb21wb25lbnRzID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgRm9ybSxcbiAgICAgIHN1Ym1pdCxcbiAgICAgIGxvYWQsXG4gICAgICAuLi5mZXRjaGVyLFxuICAgIH0pLFxuICAgIFtmZXRjaGVyLCBGb3JtLCBzdWJtaXQsIGxvYWRdXG4gICk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBJcyB0aGlzIGJ1c3RlZCB3aGVuIHRoZSBSZWFjdCB0ZWFtIGdldHMgcmVhbCB3ZWlyZCBhbmQgY2FsbHMgZWZmZWN0c1xuICAgIC8vIHR3aWNlIG9uIG1vdW50PyAgV2UgcmVhbGx5IGp1c3QgbmVlZCB0byBnYXJiYWdlIGNvbGxlY3QgaGVyZSB3aGVuIHRoaXNcbiAgICAvLyBmZXRjaGVyIGlzIG5vIGxvbmdlciBhcm91bmQuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgTm8gZmV0Y2hlciBhdmFpbGFibGUgdG8gY2xlYW4gdXAgZnJvbSB1c2VGZXRjaGVyKClgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcm91dGVyLmRlbGV0ZUZldGNoZXIoZmV0Y2hlcktleSk7XG4gICAgfTtcbiAgfSwgW3JvdXRlciwgZmV0Y2hlcktleV0pO1xuXG4gIHJldHVybiBmZXRjaGVyV2l0aENvbXBvbmVudHM7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgYWxsIGZldGNoZXJzIGN1cnJlbnRseSBvbiB0aGUgcGFnZS4gVXNlZnVsIGZvciBsYXlvdXRzIGFuZCBwYXJlbnRcbiAqIHJvdXRlcyB0aGF0IG5lZWQgdG8gcHJvdmlkZSBwZW5kaW5nL29wdGltaXN0aWMgVUkgcmVnYXJkaW5nIHRoZSBmZXRjaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZldGNoZXJzKCk6IEZldGNoZXJbXSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUZldGNoZXJzKTtcbiAgcmV0dXJuIFsuLi5zdGF0ZS5mZXRjaGVycy52YWx1ZXMoKV07XG59XG5cbmNvbnN0IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSA9IFwicmVhY3Qtcm91dGVyLXNjcm9sbC1wb3NpdGlvbnNcIjtcbmxldCBzYXZlZFNjcm9sbFBvc2l0aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuXG4vKipcbiAqIFdoZW4gcmVuZGVyZWQgaW5zaWRlIGEgUm91dGVyUHJvdmlkZXIsIHdpbGwgcmVzdG9yZSBzY3JvbGwgcG9zaXRpb25zIG9uIG5hdmlnYXRpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZVNjcm9sbFJlc3RvcmF0aW9uKHtcbiAgZ2V0S2V5LFxuICBzdG9yYWdlS2V5LFxufToge1xuICBnZXRLZXk/OiBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uO1xuICBzdG9yYWdlS2V5Pzogc3RyaW5nO1xufSA9IHt9KSB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlU2Nyb2xsUmVzdG9yYXRpb24pO1xuICBsZXQgeyByZXN0b3JlU2Nyb2xsUG9zaXRpb24sIHByZXZlbnRTY3JvbGxSZXNldCB9ID0gdXNlRGF0YVJvdXRlclN0YXRlKFxuICAgIERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlU2Nyb2xsUmVzdG9yYXRpb25cbiAgKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG1hdGNoZXMgPSB1c2VNYXRjaGVzKCk7XG4gIGxldCBuYXZpZ2F0aW9uID0gdXNlTmF2aWdhdGlvbigpO1xuXG4gIC8vIFRyaWdnZXIgbWFudWFsIHNjcm9sbCByZXN0b3JhdGlvbiB3aGlsZSB3ZSdyZSBhY3RpdmVcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCI7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vIFNhdmUgcG9zaXRpb25zIG9uIHBhZ2VoaWRlXG4gIHVzZVBhZ2VIaWRlKFxuICAgIFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIGlmIChuYXZpZ2F0aW9uLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgICBsZXQga2V5ID0gKGdldEtleSA/IGdldEtleShsb2NhdGlvbiwgbWF0Y2hlcykgOiBudWxsKSB8fCBsb2NhdGlvbi5rZXk7XG4gICAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV0gPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgIH1cbiAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgIHN0b3JhZ2VLZXkgfHwgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZLFxuICAgICAgICBKU09OLnN0cmluZ2lmeShzYXZlZFNjcm9sbFBvc2l0aW9ucylcbiAgICAgICk7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xuICAgIH0sIFtzdG9yYWdlS2V5LCBnZXRLZXksIG5hdmlnYXRpb24uc3RhdGUsIGxvY2F0aW9uLCBtYXRjaGVzXSlcbiAgKTtcblxuICAvLyBSZWFkIGluIGFueSBzYXZlZCBzY3JvbGwgbG9jYXRpb25zXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHNlc3Npb25Qb3NpdGlvbnMgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFxuICAgICAgICAgIHN0b3JhZ2VLZXkgfHwgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzZXNzaW9uUG9zaXRpb25zKSB7XG4gICAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIG5vLW9wLCB1c2UgZGVmYXVsdCBlbXB0eSBvYmplY3RcbiAgICAgIH1cbiAgICB9LCBbc3RvcmFnZUtleV0pO1xuXG4gICAgLy8gRW5hYmxlIHNjcm9sbCByZXN0b3JhdGlvbiBpbiB0aGUgcm91dGVyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIGxldCBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24gPSByb3V0ZXI/LmVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uKFxuICAgICAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyxcbiAgICAgICAgKCkgPT4gd2luZG93LnNjcm9sbFksXG4gICAgICAgIGdldEtleVxuICAgICAgKTtcbiAgICAgIHJldHVybiAoKSA9PiBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24gJiYgZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uKCk7XG4gICAgfSwgW3JvdXRlciwgZ2V0S2V5XSk7XG5cbiAgICAvLyBSZXN0b3JlIHNjcm9sbGluZyB3aGVuIHN0YXRlLnJlc3RvcmVTY3JvbGxQb3NpdGlvbiBjaGFuZ2VzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIC8vIEV4cGxpY2l0IGZhbHNlIG1lYW5zIGRvbid0IGRvIGFueXRoaW5nICh1c2VkIGZvciBzdWJtaXNzaW9ucylcbiAgICAgIGlmIChyZXN0b3JlU2Nyb2xsUG9zaXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYmVlbiBoZXJlIGJlZm9yZSwgc2Nyb2xsIHRvIGl0XG4gICAgICBpZiAodHlwZW9mIHJlc3RvcmVTY3JvbGxQb3NpdGlvbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB0cnkgdG8gc2Nyb2xsIHRvIHRoZSBoYXNoXG4gICAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChsb2NhdGlvbi5oYXNoLnNsaWNlKDEpKTtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgZWwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRG9uJ3QgcmVzZXQgaWYgdGhpcyBuYXZpZ2F0aW9uIG9wdGVkIG91dFxuICAgICAgaWYgKHByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIG90aGVyd2lzZSBnbyB0byB0aGUgdG9wIG9uIG5ldyBsb2NhdGlvbnNcbiAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICB9LCBbbG9jYXRpb24sIHJlc3RvcmVTY3JvbGxQb3NpdGlvbiwgcHJldmVudFNjcm9sbFJlc2V0XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXR1cCBhIGNhbGxiYWNrIHRvIGJlIGZpcmVkIG9uIHRoZSB3aW5kb3cncyBgYmVmb3JldW5sb2FkYCBldmVudC4gVGhpcyBpc1xuICogdXNlZnVsIGZvciBzYXZpbmcgc29tZSBkYXRhIHRvIGB3aW5kb3cubG9jYWxTdG9yYWdlYCBqdXN0IGJlZm9yZSB0aGUgcGFnZVxuICogcmVmcmVzaGVzLlxuICpcbiAqIE5vdGU6IFRoZSBgY2FsbGJhY2tgIGFyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uIGNyZWF0ZWQgd2l0aFxuICogYFJlYWN0LnVzZUNhbGxiYWNrKClgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmVmb3JlVW5sb2FkKFxuICBjYWxsYmFjazogKGV2ZW50OiBCZWZvcmVVbmxvYWRFdmVudCkgPT4gYW55LFxuICBvcHRpb25zPzogeyBjYXB0dXJlPzogYm9vbGVhbiB9XG4pOiB2b2lkIHtcbiAgbGV0IHsgY2FwdHVyZSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgb3B0cyA9IGNhcHR1cmUgIT0gbnVsbCA/IHsgY2FwdHVyZSB9IDogdW5kZWZpbmVkO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH07XG4gIH0sIFtjYWxsYmFjaywgY2FwdHVyZV0pO1xufVxuXG4vKipcbiAqIFNldHVwIGEgY2FsbGJhY2sgdG8gYmUgZmlyZWQgb24gdGhlIHdpbmRvdydzIGBwYWdlaGlkZWAgZXZlbnQuIFRoaXMgaXNcbiAqIHVzZWZ1bCBmb3Igc2F2aW5nIHNvbWUgZGF0YSB0byBgd2luZG93LmxvY2FsU3RvcmFnZWAganVzdCBiZWZvcmUgdGhlIHBhZ2VcbiAqIHJlZnJlc2hlcy4gIFRoaXMgZXZlbnQgaXMgYmV0dGVyIHN1cHBvcnRlZCB0aGFuIGJlZm9yZXVubG9hZCBhY3Jvc3MgYnJvd3NlcnMuXG4gKlxuICogTm90ZTogVGhlIGBjYWxsYmFja2AgYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24gY3JlYXRlZCB3aXRoXG4gKiBgUmVhY3QudXNlQ2FsbGJhY2soKWAuXG4gKi9cbmZ1bmN0aW9uIHVzZVBhZ2VIaWRlKFxuICBjYWxsYmFjazogKGV2ZW50OiBQYWdlVHJhbnNpdGlvbkV2ZW50KSA9PiBhbnksXG4gIG9wdGlvbnM/OiB7IGNhcHR1cmU/OiBib29sZWFuIH1cbik6IHZvaWQge1xuICBsZXQgeyBjYXB0dXJlIH0gPSBvcHRpb25zIHx8IHt9O1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBvcHRzID0gY2FwdHVyZSAhPSBudWxsID8geyBjYXB0dXJlIH0gOiB1bmRlZmluZWQ7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH07XG4gIH0sIFtjYWxsYmFjaywgY2FwdHVyZV0pO1xufVxuXG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIHVzZUJsb2NrZXIgdG8gc2hvdyBhIHdpbmRvdy5jb25maXJtIHByb21wdCB0byB1c2VycyBpbnN0ZWFkXG4gKiBvZiBidWlsZGluZyBhIGN1c3RvbSBVSSB3aXRoIHVzZUJsb2NrZXIuXG4gKlxuICogV2FybmluZzogVGhpcyBoYXMgKmEgbG90IG9mIHJvdWdoIGVkZ2VzKiBhbmQgYmVoYXZlcyB2ZXJ5IGRpZmZlcmVudGx5IChhbmRcbiAqIHZlcnkgaW5jb3JyZWN0bHkgaW4gc29tZSBjYXNlcykgYWNyb3NzIGJyb3dzZXJzIGlmIHVzZXIgY2xpY2sgYWRkaXRpb25cbiAqIGJhY2svZm9yd2FyZCBuYXZpZ2F0aW9ucyB3aGlsZSB0aGUgY29uZmlybSBpcyBvcGVuLiAgVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gKi9cbmZ1bmN0aW9uIHVzZVByb21wdCh7IHdoZW4sIG1lc3NhZ2UgfTogeyB3aGVuOiBib29sZWFuOyBtZXNzYWdlOiBzdHJpbmcgfSkge1xuICBsZXQgYmxvY2tlciA9IHVzZUJsb2NrZXIod2hlbik7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgIXdoZW4pIHtcbiAgICAgIGJsb2NrZXIucmVzZXQoKTtcbiAgICB9XG4gIH0sIFtibG9ja2VyLCB3aGVuXSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIpIHtcbiAgICAgIGxldCBwcm9jZWVkID0gd2luZG93LmNvbmZpcm0obWVzc2FnZSk7XG4gICAgICBpZiAocHJvY2VlZCkge1xuICAgICAgICBzZXRUaW1lb3V0KGJsb2NrZXIucHJvY2VlZCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBibG9ja2VyLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbYmxvY2tlciwgbWVzc2FnZV0pO1xufVxuXG5leHBvcnQgeyB1c2VQcm9tcHQgYXMgdW5zdGFibGVfdXNlUHJvbXB0IH07XG5cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIFV0aWxzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiB3YXJuaW5nKGNvbmQ6IGJvb2xlYW4sIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoIWNvbmQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IFJvdXRlciFcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHlvdSBjYW4gbW9yZSBlYXNpbHlcbiAgICAgIC8vIGZpbmQgdGhlIHNvdXJjZSBmb3IgYSB3YXJuaW5nIHRoYXQgYXBwZWFycyBpbiB0aGUgY29uc29sZSBieVxuICAgICAgLy8gZW5hYmxpbmcgXCJwYXVzZSBvbiBleGNlcHRpb25zXCIgaW4geW91ciBKYXZhU2NyaXB0IGRlYnVnZ2VyLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxufVxuLy8jZW5kcmVnaW9uXG5cbmV4cG9ydCB7IHVzZVNjcm9sbFJlc3RvcmF0aW9uIGFzIFVOU0FGRV91c2VTY3JvbGxSZXN0b3JhdGlvbiB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHJvdXRlciA9IHJlcXVpcmUoJ0ByZW1peC1ydW4vcm91dGVyJyk7XG52YXIgcmVhY3RSb3V0ZXJEb20gPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXItZG9tJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlKGUpIHtcbiAgICBpZiAoZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuICAgIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbltcImRlZmF1bHRcIl0gPSBlO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgUmVhY3RfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShSZWFjdCk7XG5cbi8qKlxuICogQSA8Um91dGVyPiB0aGF0IG1heSBub3QgbmF2aWdhdGUgdG8gYW55IG90aGVyIGxvY2F0aW9uLiBUaGlzIGlzIHVzZWZ1bFxuICogb24gdGhlIHNlcnZlciB3aGVyZSB0aGVyZSBpcyBubyBzdGF0ZWZ1bCBVSS5cbiAqL1xuXG5mdW5jdGlvbiBTdGF0aWNSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIGxvY2F0aW9uOiBsb2NhdGlvblByb3AgPSBcIi9cIlxufSkge1xuICBpZiAodHlwZW9mIGxvY2F0aW9uUHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxvY2F0aW9uUHJvcCA9IHJlYWN0Um91dGVyRG9tLnBhcnNlUGF0aChsb2NhdGlvblByb3ApO1xuICB9XG5cbiAgbGV0IGFjdGlvbiA9IHJvdXRlci5BY3Rpb24uUG9wO1xuICBsZXQgbG9jYXRpb24gPSB7XG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uUHJvcC5wYXRobmFtZSB8fCBcIi9cIixcbiAgICBzZWFyY2g6IGxvY2F0aW9uUHJvcC5zZWFyY2ggfHwgXCJcIixcbiAgICBoYXNoOiBsb2NhdGlvblByb3AuaGFzaCB8fCBcIlwiLFxuICAgIHN0YXRlOiBsb2NhdGlvblByb3Auc3RhdGUgfHwgbnVsbCxcbiAgICBrZXk6IGxvY2F0aW9uUHJvcC5rZXkgfHwgXCJkZWZhdWx0XCJcbiAgfTtcbiAgbGV0IHN0YXRpY05hdmlnYXRvciA9IGdldFN0YXRlbGVzc05hdmlnYXRvcigpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChyZWFjdFJvdXRlckRvbS5Sb3V0ZXIsIHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICBuYXZpZ2F0aW9uVHlwZTogYWN0aW9uLFxuICAgIG5hdmlnYXRvcjogc3RhdGljTmF2aWdhdG9yLFxuICAgIHN0YXRpYzogdHJ1ZVxuICB9KTtcbn1cbi8qKlxuICogQSBEYXRhIFJvdXRlciB0aGF0IG1heSBub3QgbmF2aWdhdGUgdG8gYW55IG90aGVyIGxvY2F0aW9uLiBUaGlzIGlzIHVzZWZ1bFxuICogb24gdGhlIHNlcnZlciB3aGVyZSB0aGVyZSBpcyBubyBzdGF0ZWZ1bCBVSS5cbiAqL1xuXG5mdW5jdGlvbiBTdGF0aWNSb3V0ZXJQcm92aWRlcih7XG4gIGNvbnRleHQsXG4gIHJvdXRlcjogcm91dGVyJDEsXG4gIGh5ZHJhdGUgPSB0cnVlLFxuICBub25jZVxufSkge1xuICAhKHJvdXRlciQxICYmIGNvbnRleHQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gcm91dGVyLmludmFyaWFudChmYWxzZSwgXCJZb3UgbXVzdCBwcm92aWRlIGByb3V0ZXJgIGFuZCBgY29udGV4dGAgdG8gPFN0YXRpY1JvdXRlclByb3ZpZGVyPlwiKSA6IHJvdXRlci5pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSB7XG4gICAgcm91dGVyOiByb3V0ZXIkMSxcbiAgICBuYXZpZ2F0b3I6IGdldFN0YXRlbGVzc05hdmlnYXRvcigpLFxuICAgIHN0YXRpYzogdHJ1ZSxcbiAgICBzdGF0aWNDb250ZXh0OiBjb250ZXh0LFxuICAgIGJhc2VuYW1lOiBjb250ZXh0LmJhc2VuYW1lIHx8IFwiL1wiXG4gIH07XG4gIGxldCBoeWRyYXRlU2NyaXB0ID0gXCJcIjtcblxuICBpZiAoaHlkcmF0ZSAhPT0gZmFsc2UpIHtcbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgIGxvYWRlckRhdGE6IGNvbnRleHQubG9hZGVyRGF0YSxcbiAgICAgIGFjdGlvbkRhdGE6IGNvbnRleHQuYWN0aW9uRGF0YSxcbiAgICAgIGVycm9yczogc2VyaWFsaXplRXJyb3JzKGNvbnRleHQuZXJyb3JzKVxuICAgIH07IC8vIFVzZSBKU09OLnBhcnNlIGhlcmUgaW5zdGVhZCBvZiBlbWJlZGRpbmcgYSByYXcgSlMgb2JqZWN0IGhlcmUgdG8gc3BlZWRcbiAgICAvLyB1cCBwYXJzaW5nIG9uIHRoZSBjbGllbnQuICBEdWFsLXN0cmluZ2lmeSBpcyBuZWVkZWQgdG8gZW5zdXJlIGFsbCBxdW90ZXNcbiAgICAvLyBhcmUgcHJvcGVybHkgZXNjYXBlZCBpbiB0aGUgcmVzdWx0aW5nIHN0cmluZy4gIFNlZTpcbiAgICAvLyAgIGh0dHBzOi8vdjguZGV2L2Jsb2cvY29zdC1vZi1qYXZhc2NyaXB0LTIwMTkjanNvblxuXG4gICAgbGV0IGpzb24gPSBKU09OLnN0cmluZ2lmeShKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgaHlkcmF0ZVNjcmlwdCA9IGB3aW5kb3cuX19zdGF0aWNSb3V0ZXJIeWRyYXRpb25EYXRhID0gSlNPTi5wYXJzZSgke2pzb259KTtgO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChyZWFjdFJvdXRlckRvbS5VTlNBRkVfRGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZGF0YVJvdXRlckNvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChyZWFjdFJvdXRlckRvbS5VTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBkYXRhUm91dGVyQ29udGV4dC5yb3V0ZXIuc3RhdGVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChyZWFjdFJvdXRlckRvbS5Sb3V0ZXIsIHtcbiAgICBiYXNlbmFtZTogZGF0YVJvdXRlckNvbnRleHQuYmFzZW5hbWUsXG4gICAgbG9jYXRpb246IGRhdGFSb3V0ZXJDb250ZXh0LnJvdXRlci5zdGF0ZS5sb2NhdGlvbixcbiAgICBuYXZpZ2F0aW9uVHlwZTogZGF0YVJvdXRlckNvbnRleHQucm91dGVyLnN0YXRlLmhpc3RvcnlBY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBkYXRhUm91dGVyQ29udGV4dC5uYXZpZ2F0b3JcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChyZWFjdFJvdXRlckRvbS5Sb3V0ZXMsIG51bGwpKSkpLCBoeWRyYXRlU2NyaXB0ID8gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiLCB7XG4gICAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiB0cnVlLFxuICAgIG5vbmNlOiBub25jZSxcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgX19odG1sOiBoeWRyYXRlU2NyaXB0XG4gICAgfVxuICB9KSA6IG51bGwpO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVFcnJvcnMoZXJyb3JzKSB7XG4gIGlmICghZXJyb3JzKSByZXR1cm4gbnVsbDtcbiAgbGV0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhlcnJvcnMpO1xuICBsZXQgc2VyaWFsaXplZCA9IHt9O1xuXG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIC8vIEhleSB5b3UhICBJZiB5b3UgY2hhbmdlIHRoaXMsIHBsZWFzZSBjaGFuZ2UgdGhlIGNvcnJlc3BvbmRpbmcgbG9naWMgaW5cbiAgICAvLyBkZXNlcmlhbGl6ZUVycm9ycyBpbiByZWFjdC1yb3V0ZXItZG9tL2luZGV4LnRzeCA6KVxuICAgIGlmIChyb3V0ZXIuaXNSb3V0ZUVycm9yUmVzcG9uc2UodmFsKSkge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0geyAuLi52YWwsXG4gICAgICAgIF9fdHlwZTogXCJSb3V0ZUVycm9yUmVzcG9uc2VcIlxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBEbyBub3Qgc2VyaWFsaXplIHN0YWNrIHRyYWNlcyBmcm9tIFNTUiBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgc2VyaWFsaXplZFtrZXldID0ge1xuICAgICAgICBtZXNzYWdlOiB2YWwubWVzc2FnZSxcbiAgICAgICAgX190eXBlOiBcIkVycm9yXCJcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVsZXNzTmF2aWdhdG9yKCkge1xuICByZXR1cm4ge1xuICAgIGNyZWF0ZUhyZWYsXG4gICAgZW5jb2RlTG9jYXRpb24sXG5cbiAgICBwdXNoKHRvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5wdXNoKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGAgKyBgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBgICsgYFxcYG5hdmlnYXRlKCR7SlNPTi5zdHJpbmdpZnkodG8pfSlcXGAgc29tZXdoZXJlIGluIHlvdXIgYXBwLmApO1xuICAgIH0sXG5cbiAgICByZXBsYWNlKHRvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5yZXBsYWNlKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGAgKyBgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBgICsgYFxcYG5hdmlnYXRlKCR7SlNPTi5zdHJpbmdpZnkodG8pfSwgeyByZXBsYWNlOiB0cnVlIH0pXFxgIHNvbWV3aGVyZSBgICsgYGluIHlvdXIgYXBwLmApO1xuICAgIH0sXG5cbiAgICBnbyhkZWx0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuZ28oKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgYCArIGBlbnZpcm9ubWVudC4gVGhpcyBlcnJvciB3YXMgcHJvYmFibHkgdHJpZ2dlcmVkIHdoZW4geW91IGRpZCBhIGAgKyBgXFxgbmF2aWdhdGUoJHtkZWx0YX0pXFxgIHNvbWV3aGVyZSBpbiB5b3VyIGFwcC5gKTtcbiAgICB9LFxuXG4gICAgYmFjaygpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLmJhY2soKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgYCArIGBlbnZpcm9ubWVudC5gKTtcbiAgICB9LFxuXG4gICAgZm9yd2FyZCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLmZvcndhcmQoKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgYCArIGBlbnZpcm9ubWVudC5gKTtcbiAgICB9XG5cbiAgfTtcbn0gLy8gVGVtcG9yYXJ5IG1hbmlmZXN0IGdlbmVyYXRpb24gLSB3ZSBzaG91bGQgb3B0aW1pemUgdGhpcyBieSBjb21iaW5pbmcgdGhlXG4vLyB0cmVlLXdhbGtzIGJldHdlZW4gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcywgZW5oYW5jZU1hbnVhbFJvdXRlT2JqZWN0cyxcbi8vIGFuZCBnZW5lcmF0ZU1hbmlmZXN0LlxuLy8gQWxzbyBsb29rIGludG8gZ2V0dGluZyByaWQgb2YgYHJvdXRlIGFzIEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0YCBkb3duIGJlbG93P1xuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlTWFuaWZlc3Qocm91dGVzLCBtYW5pZmVzdCA9IG5ldyBNYXAoKSkge1xuICByb3V0ZXMuZm9yRWFjaChyb3V0ZSA9PiB7XG4gICAgbWFuaWZlc3Quc2V0KHJvdXRlLmlkLCByb3V0ZSk7XG5cbiAgICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAgIGdlbmVyYXRlTWFuaWZlc3Qocm91dGUuY2hpbGRyZW4sIG1hbmlmZXN0KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWFuaWZlc3Q7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1JvdXRlcihyb3V0ZXMsIGNvbnRleHQpIHtcbiAgbGV0IGRhdGFSb3V0ZXMgPSByb3V0ZXIuVU5TQUZFX2NvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMocmVhY3RSb3V0ZXJEb20uVU5TQUZFX2VuaGFuY2VNYW51YWxSb3V0ZU9iamVjdHMocm91dGVzKSk7XG4gIGxldCBtYW5pZmVzdCA9IGdlbmVyYXRlTWFuaWZlc3QoZGF0YVJvdXRlcyk7IC8vIEJlY2F1c2Ugb3VyIGNvbnRleHQgbWF0Y2hlcyBtYXkgYmUgZnJvbSBhIGZyYW1ld29yay1hZ25vc3RpYyBzZXQgb2ZcbiAgLy8gcm91dGVzIHBhc3NlZCB0byBjcmVhdGVTdGF0aWNIYW5kbGVyKCksIHdlIHVwZGF0ZSB0aGVtIGhlcmUgd2l0aCBvdXJcbiAgLy8gbmV3bHkgY3JlYXRlZC9lbmhhbmNlZCBkYXRhIHJvdXRlc1xuXG4gIGxldCBtYXRjaGVzID0gY29udGV4dC5tYXRjaGVzLm1hcChtYXRjaCA9PiB7XG4gICAgbGV0IHJvdXRlID0gbWFuaWZlc3QuZ2V0KG1hdGNoLnJvdXRlLmlkKSB8fCBtYXRjaC5yb3V0ZTtcbiAgICByZXR1cm4geyAuLi5tYXRjaCxcbiAgICAgIHJvdXRlOiByb3V0ZVxuICAgIH07XG4gIH0pO1xuXG4gIGxldCBtc2cgPSBtZXRob2QgPT4gYFlvdSBjYW5ub3QgdXNlIHJvdXRlci4ke21ldGhvZH0oKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnRgO1xuXG4gIHJldHVybiB7XG4gICAgZ2V0IGJhc2VuYW1lKCkge1xuICAgICAgcmV0dXJuIGNvbnRleHQuYmFzZW5hbWU7XG4gICAgfSxcblxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhpc3RvcnlBY3Rpb246IHJvdXRlci5BY3Rpb24uUG9wLFxuICAgICAgICBsb2NhdGlvbjogY29udGV4dC5sb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YTogY29udGV4dC5sb2FkZXJEYXRhLFxuICAgICAgICBhY3Rpb25EYXRhOiBjb250ZXh0LmFjdGlvbkRhdGEsXG4gICAgICAgIGVycm9yczogY29udGV4dC5lcnJvcnMsXG4gICAgICAgIGluaXRpYWxpemVkOiB0cnVlLFxuICAgICAgICBuYXZpZ2F0aW9uOiByb3V0ZXIuSURMRV9OQVZJR0FUSU9OLFxuICAgICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IG51bGwsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogZmFsc2UsXG4gICAgICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKCksXG4gICAgICAgIGJsb2NrZXJzOiBuZXcgTWFwKClcbiAgICAgIH07XG4gICAgfSxcblxuICAgIGdldCByb3V0ZXMoKSB7XG4gICAgICByZXR1cm4gZGF0YVJvdXRlcztcbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgIHRocm93IG1zZyhcImluaXRpYWxpemVcIik7XG4gICAgfSxcblxuICAgIHN1YnNjcmliZSgpIHtcbiAgICAgIHRocm93IG1zZyhcInN1YnNjcmliZVwiKTtcbiAgICB9LFxuXG4gICAgZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oKSB7XG4gICAgICB0aHJvdyBtc2coXCJlbmFibGVTY3JvbGxSZXN0b3JhdGlvblwiKTtcbiAgICB9LFxuXG4gICAgbmF2aWdhdGUoKSB7XG4gICAgICB0aHJvdyBtc2coXCJuYXZpZ2F0ZVwiKTtcbiAgICB9LFxuXG4gICAgZmV0Y2goKSB7XG4gICAgICB0aHJvdyBtc2coXCJmZXRjaFwiKTtcbiAgICB9LFxuXG4gICAgcmV2YWxpZGF0ZSgpIHtcbiAgICAgIHRocm93IG1zZyhcInJldmFsaWRhdGVcIik7XG4gICAgfSxcblxuICAgIGNyZWF0ZUhyZWYsXG4gICAgZW5jb2RlTG9jYXRpb24sXG5cbiAgICBnZXRGZXRjaGVyKCkge1xuICAgICAgcmV0dXJuIHJvdXRlci5JRExFX0ZFVENIRVI7XG4gICAgfSxcblxuICAgIGRlbGV0ZUZldGNoZXIoKSB7XG4gICAgICB0aHJvdyBtc2coXCJkZWxldGVGZXRjaGVyXCIpO1xuICAgIH0sXG5cbiAgICBkaXNwb3NlKCkge1xuICAgICAgdGhyb3cgbXNnKFwiZGlzcG9zZVwiKTtcbiAgICB9LFxuXG4gICAgZ2V0QmxvY2tlcigpIHtcbiAgICAgIHRocm93IG1zZyhcImdldEJsb2NrZXJcIik7XG4gICAgfSxcblxuICAgIGRlbGV0ZUJsb2NrZXIoKSB7XG4gICAgICB0aHJvdyBtc2coXCJkZWxldGVCbG9ja2VyXCIpO1xuICAgIH0sXG5cbiAgICBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzOiBuZXcgTWFwKCksXG4gICAgX2ludGVybmFsQWN0aXZlRGVmZXJyZWRzOiBuZXcgTWFwKClcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSHJlZih0bykge1xuICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiByZWFjdFJvdXRlckRvbS5jcmVhdGVQYXRoKHRvKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgLy8gTG9jYXRpb25zIHNob3VsZCBhbHJlYWR5IGJlIGVuY29kZWQgb24gdGhlIHNlcnZlciwgc28ganVzdCByZXR1cm4gYXMtaXNcbiAgbGV0IHBhdGggPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyByZWFjdFJvdXRlckRvbS5wYXJzZVBhdGgodG8pIDogdG87XG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGgucGF0aG5hbWUgfHwgXCJcIixcbiAgICBzZWFyY2g6IHBhdGguc2VhcmNoIHx8IFwiXCIsXG4gICAgaGFzaDogcGF0aC5oYXNoIHx8IFwiXCJcbiAgfTtcbn1cblxuZXhwb3J0cy5TdGF0aWNSb3V0ZXIgPSBTdGF0aWNSb3V0ZXI7XG5leHBvcnRzLlN0YXRpY1JvdXRlclByb3ZpZGVyID0gU3RhdGljUm91dGVyUHJvdmlkZXI7XG5leHBvcnRzLmNyZWF0ZVN0YXRpY1JvdXRlciA9IGNyZWF0ZVN0YXRpY1JvdXRlcjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzUG9seWZpbGwoeDogYW55LCB5OiBhbnkpIHtcbiAgcmV0dXJuIChcbiAgICAoeCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpKSB8fCAoeCAhPT0geCAmJiB5ICE9PSB5KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICApO1xufVxuXG5jb25zdCBpczogKHg6IGFueSwgeTogYW55KSA9PiBib29sZWFuID1cbiAgdHlwZW9mIE9iamVjdC5pcyA9PT0gXCJmdW5jdGlvblwiID8gT2JqZWN0LmlzIDogaXNQb2x5ZmlsbDtcblxuLy8gSW50ZW50aW9uYWxseSBub3QgdXNpbmcgbmFtZWQgaW1wb3J0cyBiZWNhdXNlIFJvbGx1cCB1c2VzIGR5bmFtaWNcbi8vIGRpc3BhdGNoIGZvciBDb21tb25KUyBpbnRlcm9wIG5hbWVkIGltcG9ydHMuXG5jb25zdCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlRGVidWdWYWx1ZSB9ID0gUmVhY3Q7XG5cbmxldCBkaWRXYXJuT2xkMThBbHBoYSA9IGZhbHNlO1xubGV0IGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gZmFsc2U7XG5cbi8vIERpc2NsYWltZXI6IFRoaXMgc2hpbSBicmVha3MgbWFueSBvZiB0aGUgcnVsZXMgb2YgUmVhY3QsIGFuZCBvbmx5IHdvcmtzXG4vLyBiZWNhdXNlIG9mIGEgdmVyeSBwYXJ0aWN1bGFyIHNldCBvZiBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIGFuZCBhc3N1bXB0aW9uc1xuLy8gLS0gY2hhbmdlIGFueSBvbmUgb2YgdGhlbSBhbmQgaXQgd2lsbCBicmVhay4gVGhlIG1vc3QgaW1wb3J0YW50IGFzc3VtcHRpb25cbi8vIGlzIHRoYXQgdXBkYXRlcyBhcmUgYWx3YXlzIHN5bmNocm9ub3VzLCBiZWNhdXNlIGNvbmN1cnJlbnQgcmVuZGVyaW5nIGlzXG4vLyBvbmx5IGF2YWlsYWJsZSBpbiB2ZXJzaW9ucyBvZiBSZWFjdCB0aGF0IGFsc28gaGF2ZSBhIGJ1aWx0LWluXG4vLyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSBBUEkuIEFuZCB3ZSBvbmx5IHVzZSB0aGlzIHNoaW0gd2hlbiB0aGUgYnVpbHQtaW4gQVBJXG4vLyBkb2VzIG5vdCBleGlzdC5cbi8vXG4vLyBEbyBub3QgYXNzdW1lIHRoYXQgdGhlIGNsZXZlciBoYWNrcyB1c2VkIGJ5IHRoaXMgaG9vayBhbHNvIHdvcmsgaW4gZ2VuZXJhbC5cbi8vIFRoZSBwb2ludCBvZiB0aGlzIHNoaW0gaXMgdG8gcmVwbGFjZSB0aGUgbmVlZCBmb3IgaGFja3MgYnkgb3RoZXIgbGlicmFyaWVzLlxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlPFQ+KFxuICBzdWJzY3JpYmU6IChmbjogKCkgPT4gdm9pZCkgPT4gKCkgPT4gdm9pZCxcbiAgZ2V0U25hcHNob3Q6ICgpID0+IFQsXG4gIC8vIE5vdGU6IFRoZSBzaGltIGRvZXMgbm90IHVzZSBnZXRTZXJ2ZXJTbmFwc2hvdCwgYmVjYXVzZSBwcmUtMTggdmVyc2lvbnMgb2ZcbiAgLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG4gIC8vIHdpbGwgbmVlZCB0byB0cmFjayB0aGF0IHRoZW1zZWx2ZXMgYW5kIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZVxuICAvLyBmcm9tIGBnZXRTbmFwc2hvdGAuXG4gIGdldFNlcnZlclNuYXBzaG90PzogKCkgPT4gVFxuKTogVCB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaWYgKCFkaWRXYXJuT2xkMThBbHBoYSkge1xuICAgICAgaWYgKFwic3RhcnRUcmFuc2l0aW9uXCIgaW4gUmVhY3QpIHtcbiAgICAgICAgZGlkV2Fybk9sZDE4QWxwaGEgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiWW91IGFyZSB1c2luZyBhbiBvdXRkYXRlZCwgcHJlLXJlbGVhc2UgYWxwaGEgb2YgUmVhY3QgMTggdGhhdCBcIiArXG4gICAgICAgICAgICBcImRvZXMgbm90IHN1cHBvcnQgdXNlU3luY0V4dGVybmFsU3RvcmUuIFRoZSBcIiArXG4gICAgICAgICAgICBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlIHNoaW0gd2lsbCBub3Qgd29yayBjb3JyZWN0bHkuIFVwZ3JhZGUgXCIgK1xuICAgICAgICAgICAgXCJ0byBhIG5ld2VyIHByZS1yZWxlYXNlLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVhZCB0aGUgY3VycmVudCBzbmFwc2hvdCBmcm9tIHRoZSBzdG9yZSBvbiBldmVyeSByZW5kZXIuIEFnYWluLCB0aGlzXG4gIC8vIGJyZWFrcyB0aGUgcnVsZXMgb2YgUmVhY3QsIGFuZCBvbmx5IHdvcmtzIGhlcmUgYmVjYXVzZSBvZiBzcGVjaWZpY1xuICAvLyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLCBtb3N0IGltcG9ydGFudGx5IHRoYXQgdXBkYXRlcyBhcmVcbiAgLy8gYWx3YXlzIHN5bmNocm9ub3VzLlxuICBjb25zdCB2YWx1ZSA9IGdldFNuYXBzaG90KCk7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuICAgICAgY29uc3QgY2FjaGVkVmFsdWUgPSBnZXRTbmFwc2hvdCgpO1xuICAgICAgaWYgKCFpcyh2YWx1ZSwgY2FjaGVkVmFsdWUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcFwiXG4gICAgICAgICk7XG4gICAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBCZWNhdXNlIHVwZGF0ZXMgYXJlIHN5bmNocm9ub3VzLCB3ZSBkb24ndCBxdWV1ZSB0aGVtLiBJbnN0ZWFkIHdlIGZvcmNlIGFcbiAgLy8gcmUtcmVuZGVyIHdoZW5ldmVyIHRoZSBzdWJzY3JpYmVkIHN0YXRlIGNoYW5nZXMgYnkgdXBkYXRpbmcgYW4gc29tZVxuICAvLyBhcmJpdHJhcnkgdXNlU3RhdGUgaG9vay4gVGhlbiwgZHVyaW5nIHJlbmRlciwgd2UgY2FsbCBnZXRTbmFwc2hvdCB0byByZWFkXG4gIC8vIHRoZSBjdXJyZW50IHZhbHVlLlxuICAvL1xuICAvLyBCZWNhdXNlIHdlIGRvbid0IGFjdHVhbGx5IHVzZSB0aGUgc3RhdGUgcmV0dXJuZWQgYnkgdGhlIHVzZVN0YXRlIGhvb2ssIHdlXG4gIC8vIGNhbiBzYXZlIGEgYml0IG9mIG1lbW9yeSBieSBzdG9yaW5nIG90aGVyIHN0dWZmIGluIHRoYXQgc2xvdC5cbiAgLy9cbiAgLy8gVG8gaW1wbGVtZW50IHRoZSBlYXJseSBiYWlsb3V0LCB3ZSBuZWVkIHRvIHRyYWNrIHNvbWUgdGhpbmdzIG9uIGEgbXV0YWJsZVxuICAvLyBvYmplY3QuIFVzdWFsbHksIHdlIHdvdWxkIHB1dCB0aGF0IGluIGEgdXNlUmVmIGhvb2ssIGJ1dCB3ZSBjYW4gc3Rhc2ggaXQgaW5cbiAgLy8gb3VyIHVzZVN0YXRlIGhvb2sgaW5zdGVhZC5cbiAgLy9cbiAgLy8gVG8gZm9yY2UgYSByZS1yZW5kZXIsIHdlIGNhbGwgZm9yY2VVcGRhdGUoe2luc3R9KS4gVGhhdCB3b3JrcyBiZWNhdXNlIHRoZVxuICAvLyBuZXcgb2JqZWN0IGFsd2F5cyBmYWlscyBhbiBlcXVhbGl0eSBjaGVjay5cbiAgY29uc3QgW3sgaW5zdCB9LCBmb3JjZVVwZGF0ZV0gPSB1c2VTdGF0ZSh7IGluc3Q6IHsgdmFsdWUsIGdldFNuYXBzaG90IH0gfSk7XG5cbiAgLy8gVHJhY2sgdGhlIGxhdGVzdCBnZXRTbmFwc2hvdCBmdW5jdGlvbiB3aXRoIGEgcmVmLiBUaGlzIG5lZWRzIHRvIGJlIHVwZGF0ZWRcbiAgLy8gaW4gdGhlIGxheW91dCBwaGFzZSBzbyB3ZSBjYW4gYWNjZXNzIGl0IGR1cmluZyB0aGUgdGVhcmluZyBjaGVjayB0aGF0XG4gIC8vIGhhcHBlbnMgb24gc3Vic2NyaWJlLlxuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGluc3QudmFsdWUgPSB2YWx1ZTtcbiAgICBpbnN0LmdldFNuYXBzaG90ID0gZ2V0U25hcHNob3Q7XG5cbiAgICAvLyBXaGVuZXZlciBnZXRTbmFwc2hvdCBvciBzdWJzY3JpYmUgY2hhbmdlcywgd2UgbmVlZCB0byBjaGVjayBpbiB0aGVcbiAgICAvLyBjb21taXQgcGhhc2UgaWYgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIG11dGF0aW9uLiBJbiBjb25jdXJyZW50IG1vZGVcbiAgICAvLyB0aGlzIGNhbiBoYXBwZW4gYWxsIHRoZSB0aW1lLCBidXQgZXZlbiBpbiBzeW5jaHJvbm91cyBtb2RlLCBhbiBlYXJsaWVyXG4gICAgLy8gZWZmZWN0IG1heSBoYXZlIG11dGF0ZWQgdGhlIHN0b3JlLlxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlVXBkYXRlKHsgaW5zdCB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbc3Vic2NyaWJlLCB2YWx1ZSwgZ2V0U25hcHNob3RdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIENoZWNrIGZvciBjaGFuZ2VzIHJpZ2h0IGJlZm9yZSBzdWJzY3JpYmluZy4gU3Vic2VxdWVudCBjaGFuZ2VzIHdpbGwgYmVcbiAgICAvLyBkZXRlY3RlZCBpbiB0aGUgc3Vic2NyaXB0aW9uIGhhbmRsZXIuXG4gICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgIC8vIEZvcmNlIGEgcmUtcmVuZGVyLlxuICAgICAgZm9yY2VVcGRhdGUoeyBpbnN0IH0pO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVTdG9yZUNoYW5nZSA9ICgpID0+IHtcbiAgICAgIC8vIFRPRE86IEJlY2F1c2UgdGhlcmUgaXMgbm8gY3Jvc3MtcmVuZGVyZXIgQVBJIGZvciBiYXRjaGluZyB1cGRhdGVzLCBpdCdzXG4gICAgICAvLyB1cCB0byB0aGUgY29uc3VtZXIgb2YgdGhpcyBsaWJyYXJ5IHRvIHdyYXAgdGhlaXIgc3Vic2NyaXB0aW9uIGV2ZW50XG4gICAgICAvLyB3aXRoIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzLiBTaG91bGQgd2UgdHJ5IHRvIGRldGVjdCB3aGVuIHRoaXMgaXNuJ3RcbiAgICAgIC8vIHRoZSBjYXNlIGFuZCBwcmludCBhIHdhcm5pbmcgaW4gZGV2ZWxvcG1lbnQ/XG5cbiAgICAgIC8vIFRoZSBzdG9yZSBjaGFuZ2VkLiBDaGVjayBpZiB0aGUgc25hcHNob3QgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlXG4gICAgICAvLyByZWFkIGZyb20gdGhlIHN0b3JlLlxuICAgICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgICAgIGZvcmNlVXBkYXRlKHsgaW5zdCB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8vIFN1YnNjcmliZSB0byB0aGUgc3RvcmUgYW5kIHJldHVybiBhIGNsZWFuLXVwIGZ1bmN0aW9uLlxuICAgIHJldHVybiBzdWJzY3JpYmUoaGFuZGxlU3RvcmVDaGFuZ2UpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW3N1YnNjcmliZV0pO1xuXG4gIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdDogYW55KSB7XG4gIGNvbnN0IGxhdGVzdEdldFNuYXBzaG90ID0gaW5zdC5nZXRTbmFwc2hvdDtcbiAgY29uc3QgcHJldlZhbHVlID0gaW5zdC52YWx1ZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBuZXh0VmFsdWUgPSBsYXRlc3RHZXRTbmFwc2hvdCgpO1xuICAgIHJldHVybiAhaXMocHJldlZhbHVlLCBuZXh0VmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlPFQ+KFxuICBzdWJzY3JpYmU6IChmbjogKCkgPT4gdm9pZCkgPT4gKCkgPT4gdm9pZCxcbiAgZ2V0U25hcHNob3Q6ICgpID0+IFQsXG4gIGdldFNlcnZlclNuYXBzaG90PzogKCkgPT4gVFxuKTogVCB7XG4gIC8vIE5vdGU6IFRoZSBzaGltIGRvZXMgbm90IHVzZSBnZXRTZXJ2ZXJTbmFwc2hvdCwgYmVjYXVzZSBwcmUtMTggdmVyc2lvbnMgb2ZcbiAgLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG4gIC8vIHdpbGwgbmVlZCB0byB0cmFjayB0aGF0IHRoZW1zZWx2ZXMgYW5kIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZVxuICAvLyBmcm9tIGBnZXRTbmFwc2hvdGAuXG4gIHJldHVybiBnZXRTbmFwc2hvdCgpO1xufVxuIiwiLyoqXG4gKiBJbmxpbmVkIGludG8gdGhlIHJlYWN0LXJvdXRlciByZXBvIHNpbmNlIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlIGRvZXMgbm90XG4gKiBwcm92aWRlIGEgVU1ELWNvbXBhdGlibGUgcGFja2FnZSwgc28gd2UgbmVlZCB0aGlzIHRvIGJlIGFibGUgdG8gZGlzdHJpYnV0ZVxuICogVU1EIHJlYWN0LXJvdXRlciBidW5kbGVzXG4gKi9cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSBhcyBjbGllbnQgfSBmcm9tIFwiLi91c2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1DbGllbnRcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIGFzIHNlcnZlciB9IGZyb20gXCIuL3VzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbVNlcnZlclwiO1xuXG5jb25zdCBjYW5Vc2VET006IGJvb2xlYW4gPSAhIShcbiAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIlxuKTtcbmNvbnN0IGlzU2VydmVyRW52aXJvbm1lbnQgPSAhY2FuVXNlRE9NO1xuY29uc3Qgc2hpbSA9IGlzU2VydmVyRW52aXJvbm1lbnQgPyBzZXJ2ZXIgOiBjbGllbnQ7XG5cbmV4cG9ydCBjb25zdCB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9XG4gIFwidXNlU3luY0V4dGVybmFsU3RvcmVcIiBpbiBSZWFjdFxuICAgID8gKChtb2R1bGUpID0+IG1vZHVsZS51c2VTeW5jRXh0ZXJuYWxTdG9yZSkoUmVhY3QpXG4gICAgOiBzaGltO1xuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7XG4gIEFnbm9zdGljUm91dGVNYXRjaCxcbiAgQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0LFxuICBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3QsXG4gIEhpc3RvcnksXG4gIExvY2F0aW9uLFxuICBSb3V0ZXIsXG4gIFN0YXRpY0hhbmRsZXJDb250ZXh0LFxuICBUbyxcbiAgVHJhY2tlZFByb21pc2UsXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuaW1wb3J0IHR5cGUgeyBBY3Rpb24gYXMgTmF2aWdhdGlvblR5cGUgfSBmcm9tIFwiQHJlbWl4LXJ1bi9yb3V0ZXJcIjtcblxuLy8gQ3JlYXRlIHJlYWN0LXNwZWNpZmljIHR5cGVzIGZyb20gdGhlIGFnbm9zdGljIHR5cGVzIGluIEByZW1peC1ydW4vcm91dGVyIHRvXG4vLyBleHBvcnQgZnJvbSByZWFjdC1yb3V0ZXJcbmV4cG9ydCBpbnRlcmZhY2UgSW5kZXhSb3V0ZU9iamVjdCB7XG4gIGNhc2VTZW5zaXRpdmU/OiBBZ25vc3RpY0luZGV4Um91dGVPYmplY3RbXCJjYXNlU2Vuc2l0aXZlXCJdO1xuICBwYXRoPzogQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0W1wicGF0aFwiXTtcbiAgaWQ/OiBBZ25vc3RpY0luZGV4Um91dGVPYmplY3RbXCJpZFwiXTtcbiAgbG9hZGVyPzogQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0W1wibG9hZGVyXCJdO1xuICBhY3Rpb24/OiBBZ25vc3RpY0luZGV4Um91dGVPYmplY3RbXCJhY3Rpb25cIl07XG4gIGhhc0Vycm9yQm91bmRhcnk/OiBBZ25vc3RpY0luZGV4Um91dGVPYmplY3RbXCJoYXNFcnJvckJvdW5kYXJ5XCJdO1xuICBzaG91bGRSZXZhbGlkYXRlPzogQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0W1wic2hvdWxkUmV2YWxpZGF0ZVwiXTtcbiAgaGFuZGxlPzogQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0W1wiaGFuZGxlXCJdO1xuICBpbmRleDogdHJ1ZTtcbiAgY2hpbGRyZW4/OiB1bmRlZmluZWQ7XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBlcnJvckVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vbkluZGV4Um91dGVPYmplY3Qge1xuICBjYXNlU2Vuc2l0aXZlPzogQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0W1wiY2FzZVNlbnNpdGl2ZVwiXTtcbiAgcGF0aD86IEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdFtcInBhdGhcIl07XG4gIGlkPzogQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0W1wiaWRcIl07XG4gIGxvYWRlcj86IEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdFtcImxvYWRlclwiXTtcbiAgYWN0aW9uPzogQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0W1wiYWN0aW9uXCJdO1xuICBoYXNFcnJvckJvdW5kYXJ5PzogQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0W1wiaGFzRXJyb3JCb3VuZGFyeVwiXTtcbiAgc2hvdWxkUmV2YWxpZGF0ZT86IEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdFtcInNob3VsZFJldmFsaWRhdGVcIl07XG4gIGhhbmRsZT86IEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdFtcImhhbmRsZVwiXTtcbiAgaW5kZXg/OiBmYWxzZTtcbiAgY2hpbGRyZW4/OiBSb3V0ZU9iamVjdFtdO1xuICBlbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbiAgZXJyb3JFbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbn1cblxuZXhwb3J0IHR5cGUgUm91dGVPYmplY3QgPSBJbmRleFJvdXRlT2JqZWN0IHwgTm9uSW5kZXhSb3V0ZU9iamVjdDtcblxuZXhwb3J0IHR5cGUgRGF0YVJvdXRlT2JqZWN0ID0gUm91dGVPYmplY3QgJiB7XG4gIGNoaWxkcmVuPzogRGF0YVJvdXRlT2JqZWN0W107XG4gIGlkOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlTWF0Y2g8XG4gIFBhcmFtS2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLFxuICBSb3V0ZU9iamVjdFR5cGUgZXh0ZW5kcyBSb3V0ZU9iamVjdCA9IFJvdXRlT2JqZWN0XG4+IGV4dGVuZHMgQWdub3N0aWNSb3V0ZU1hdGNoPFBhcmFtS2V5LCBSb3V0ZU9iamVjdFR5cGU+IHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVJvdXRlTWF0Y2ggZXh0ZW5kcyBSb3V0ZU1hdGNoPHN0cmluZywgRGF0YVJvdXRlT2JqZWN0PiB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFSb3V0ZXJDb250ZXh0T2JqZWN0IGV4dGVuZHMgTmF2aWdhdGlvbkNvbnRleHRPYmplY3Qge1xuICByb3V0ZXI6IFJvdXRlcjtcbiAgc3RhdGljQ29udGV4dD86IFN0YXRpY0hhbmRsZXJDb250ZXh0O1xufVxuXG5leHBvcnQgY29uc3QgRGF0YVJvdXRlckNvbnRleHQgPVxuICBSZWFjdC5jcmVhdGVDb250ZXh0PERhdGFSb3V0ZXJDb250ZXh0T2JqZWN0IHwgbnVsbD4obnVsbCk7XG5pZiAoX19ERVZfXykge1xuICBEYXRhUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGF0YVJvdXRlclwiO1xufVxuXG5leHBvcnQgY29uc3QgRGF0YVJvdXRlclN0YXRlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8XG4gIFJvdXRlcltcInN0YXRlXCJdIHwgbnVsbFxuPihudWxsKTtcbmlmIChfX0RFVl9fKSB7XG4gIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkRhdGFSb3V0ZXJTdGF0ZVwiO1xufVxuXG5leHBvcnQgY29uc3QgQXdhaXRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxUcmFja2VkUHJvbWlzZSB8IG51bGw+KG51bGwpO1xuaWYgKF9fREVWX18pIHtcbiAgQXdhaXRDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJBd2FpdFwiO1xufVxuXG5leHBvcnQgdHlwZSBSZWxhdGl2ZVJvdXRpbmdUeXBlID0gXCJyb3V0ZVwiIHwgXCJwYXRoXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVPcHRpb25zIHtcbiAgcmVwbGFjZT86IGJvb2xlYW47XG4gIHN0YXRlPzogYW55O1xuICBwcmV2ZW50U2Nyb2xsUmVzZXQ/OiBib29sZWFuO1xuICByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGU7XG59XG5cbi8qKlxuICogQSBOYXZpZ2F0b3IgaXMgYSBcImxvY2F0aW9uIGNoYW5nZXJcIjsgaXQncyBob3cgeW91IGdldCB0byBkaWZmZXJlbnQgbG9jYXRpb25zLlxuICpcbiAqIEV2ZXJ5IGhpc3RvcnkgaW5zdGFuY2UgY29uZm9ybXMgdG8gdGhlIE5hdmlnYXRvciBpbnRlcmZhY2UsIGJ1dCB0aGVcbiAqIGRpc3RpbmN0aW9uIGlzIHVzZWZ1bCBwcmltYXJpbHkgd2hlbiBpdCBjb21lcyB0byB0aGUgbG93LWxldmVsIDxSb3V0ZXI+IEFQSVxuICogd2hlcmUgYm90aCB0aGUgbG9jYXRpb24gYW5kIGEgbmF2aWdhdG9yIG11c3QgYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBpbiBvcmRlclxuICogdG8gYXZvaWQgXCJ0ZWFyaW5nXCIgdGhhdCBtYXkgb2NjdXIgaW4gYSBzdXNwZW5zZS1lbmFibGVkIGFwcCBpZiB0aGUgYWN0aW9uXG4gKiBhbmQvb3IgbG9jYXRpb24gd2VyZSB0byBiZSByZWFkIGRpcmVjdGx5IGZyb20gdGhlIGhpc3RvcnkgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdG9yIHtcbiAgY3JlYXRlSHJlZjogSGlzdG9yeVtcImNyZWF0ZUhyZWZcIl07XG4gIC8vIE9wdGlvbmFsIGZvciBiYWNrd2FyZHMtY29tcGF0IHdpdGggUm91dGVyL0hpc3RvcnlSb3V0ZXIgdXNhZ2UgKGVkZ2UgY2FzZSlcbiAgZW5jb2RlTG9jYXRpb24/OiBIaXN0b3J5W1wiZW5jb2RlTG9jYXRpb25cIl07XG4gIGdvOiBIaXN0b3J5W1wiZ29cIl07XG4gIHB1c2godG86IFRvLCBzdGF0ZT86IGFueSwgb3B0cz86IE5hdmlnYXRlT3B0aW9ucyk6IHZvaWQ7XG4gIHJlcGxhY2UodG86IFRvLCBzdGF0ZT86IGFueSwgb3B0cz86IE5hdmlnYXRlT3B0aW9ucyk6IHZvaWQ7XG59XG5cbmludGVyZmFjZSBOYXZpZ2F0aW9uQ29udGV4dE9iamVjdCB7XG4gIGJhc2VuYW1lOiBzdHJpbmc7XG4gIG5hdmlnYXRvcjogTmF2aWdhdG9yO1xuICBzdGF0aWM6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBOYXZpZ2F0aW9uQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8TmF2aWdhdGlvbkNvbnRleHRPYmplY3Q+KFxuICBudWxsIVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTmF2aWdhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIk5hdmlnYXRpb25cIjtcbn1cblxuaW50ZXJmYWNlIExvY2F0aW9uQ29udGV4dE9iamVjdCB7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbiAgbmF2aWdhdGlvblR5cGU6IE5hdmlnYXRpb25UeXBlO1xufVxuXG5leHBvcnQgY29uc3QgTG9jYXRpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxMb2NhdGlvbkNvbnRleHRPYmplY3Q+KFxuICBudWxsIVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTG9jYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJMb2NhdGlvblwiO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlQ29udGV4dE9iamVjdCB7XG4gIG91dGxldDogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbDtcbiAgbWF0Y2hlczogUm91dGVNYXRjaFtdO1xufVxuXG5leHBvcnQgY29uc3QgUm91dGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxSb3V0ZUNvbnRleHRPYmplY3Q+KHtcbiAgb3V0bGV0OiBudWxsLFxuICBtYXRjaGVzOiBbXSxcbn0pO1xuXG5pZiAoX19ERVZfXykge1xuICBSb3V0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdXRlXCI7XG59XG5cbmV4cG9ydCBjb25zdCBSb3V0ZUVycm9yQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8YW55PihudWxsKTtcblxuaWYgKF9fREVWX18pIHtcbiAgUm91dGVFcnJvckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdXRlRXJyb3JcIjtcbn1cbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUge1xuICBCbG9ja2VyLFxuICBCbG9ja2VyRnVuY3Rpb24sXG4gIExvY2F0aW9uLFxuICBQYXJhbVBhcnNlS2V5LFxuICBQYXJhbXMsXG4gIFBhdGgsXG4gIFBhdGhNYXRjaCxcbiAgUGF0aFBhdHRlcm4sXG4gIFJvdXRlciBhcyBSZW1peFJvdXRlcixcbiAgVG8sXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuaW1wb3J0IHtcbiAgQWN0aW9uIGFzIE5hdmlnYXRpb25UeXBlLFxuICBpbnZhcmlhbnQsXG4gIGlzUm91dGVFcnJvclJlc3BvbnNlLFxuICBqb2luUGF0aHMsXG4gIG1hdGNoUGF0aCxcbiAgbWF0Y2hSb3V0ZXMsXG4gIHBhcnNlUGF0aCxcbiAgcmVzb2x2ZVRvLFxuICB3YXJuaW5nLFxuICBVTlNBRkVfZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMgYXMgZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMsXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuXG5pbXBvcnQgdHlwZSB7XG4gIE5hdmlnYXRlT3B0aW9ucyxcbiAgUm91dGVDb250ZXh0T2JqZWN0LFxuICBSb3V0ZU1hdGNoLFxuICBSb3V0ZU9iamVjdCxcbiAgRGF0YVJvdXRlTWF0Y2gsXG4gIFJlbGF0aXZlUm91dGluZ1R5cGUsXG59IGZyb20gXCIuL2NvbnRleHRcIjtcbmltcG9ydCB7XG4gIERhdGFSb3V0ZXJDb250ZXh0LFxuICBEYXRhUm91dGVyU3RhdGVDb250ZXh0LFxuICBMb2NhdGlvbkNvbnRleHQsXG4gIE5hdmlnYXRpb25Db250ZXh0LFxuICBSb3V0ZUNvbnRleHQsXG4gIFJvdXRlRXJyb3JDb250ZXh0LFxuICBBd2FpdENvbnRleHQsXG59IGZyb20gXCIuL2NvbnRleHRcIjtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmdWxsIGhyZWYgZm9yIHRoZSBnaXZlbiBcInRvXCIgdmFsdWUuIFRoaXMgaXMgdXNlZnVsIGZvciBidWlsZGluZ1xuICogY3VzdG9tIGxpbmtzIHRoYXQgYXJlIGFsc28gYWNjZXNzaWJsZSBhbmQgcHJlc2VydmUgcmlnaHQtY2xpY2sgYmVoYXZpb3IuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtaHJlZlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSHJlZihcbiAgdG86IFRvLFxuICB7IHJlbGF0aXZlIH06IHsgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlIH0gPSB7fVxuKTogc3RyaW5nIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlSHJlZigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIGxldCB7IGJhc2VuYW1lLCBuYXZpZ2F0b3IgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBoYXNoLCBwYXRobmFtZSwgc2VhcmNoIH0gPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmUgfSk7XG5cbiAgbGV0IGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWU7XG5cbiAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZSBwcmlvclxuICAvLyB0byBjcmVhdGluZyB0aGUgaHJlZi4gIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4ganVzdCB1c2UgdGhlIHJhd1xuICAvLyBiYXNlbmFtZSB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlXG4gIC8vIG9mIGEgdHJhaWxpbmcgc2xhc2ggb24gcm9vdCBsaW5rc1xuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgam9pbmVkUGF0aG5hbWUgPVxuICAgICAgcGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRobmFtZV0pO1xuICB9XG5cbiAgcmV0dXJuIG5hdmlnYXRvci5jcmVhdGVIcmVmKHsgcGF0aG5hbWU6IGpvaW5lZFBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY29tcG9uZW50IGlzIGEgZGVzY2VuZGFudCBvZiBhIDxSb3V0ZXI+LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLWluLXJvdXRlci1jb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VJblJvdXRlckNvbnRleHQoKTogYm9vbGVhbiB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkgIT0gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGxvY2F0aW9uIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgY3VycmVudCBVUkwgaW4gd2ViXG4gKiBicm93c2Vycy5cbiAqXG4gKiBOb3RlOiBJZiB5b3UncmUgdXNpbmcgdGhpcyBpdCBtYXkgbWVhbiB5b3UncmUgZG9pbmcgc29tZSBvZiB5b3VyIG93blxuICogXCJyb3V0aW5nXCIgaW4geW91ciBhcHAsIGFuZCB3ZSdkIGxpa2UgdG8ga25vdyB3aGF0IHlvdXIgdXNlIGNhc2UgaXMuIFdlIG1heVxuICogYmUgYWJsZSB0byBwcm92aWRlIHNvbWV0aGluZyBoaWdoZXItbGV2ZWwgdG8gYmV0dGVyIHN1aXQgeW91ciBuZWVkcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1sb2NhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9jYXRpb24oKTogTG9jYXRpb24ge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VMb2NhdGlvbigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubG9jYXRpb247XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIGFjdGlvbiB3aGljaCBkZXNjcmliZXMgaG93IHRoZSByb3V0ZXIgY2FtZSB0b1xuICogdGhlIGN1cnJlbnQgbG9jYXRpb24sIGVpdGhlciBieSBhIHBvcCwgcHVzaCwgb3IgcmVwbGFjZSBvbiB0aGUgaGlzdG9yeSBzdGFjay5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1uYXZpZ2F0aW9uLXR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU5hdmlnYXRpb25UeXBlKCk6IE5hdmlnYXRpb25UeXBlIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KS5uYXZpZ2F0aW9uVHlwZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgUGF0aE1hdGNoIG9iamVjdCBpZiB0aGUgZ2l2ZW4gcGF0dGVybiBtYXRjaGVzIHRoZSBjdXJyZW50IFVSTC5cbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBjb21wb25lbnRzIHRoYXQgbmVlZCB0byBrbm93IFwiYWN0aXZlXCIgc3RhdGUsIGUuZy5cbiAqIDxOYXZMaW5rPi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1tYXRjaFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWF0Y2g8XG4gIFBhcmFtS2V5IGV4dGVuZHMgUGFyYW1QYXJzZUtleTxQYXRoPixcbiAgUGF0aCBleHRlbmRzIHN0cmluZ1xuPihwYXR0ZXJuOiBQYXRoUGF0dGVybjxQYXRoPiB8IFBhdGgpOiBQYXRoTWF0Y2g8UGFyYW1LZXk+IHwgbnVsbCB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZU1hdGNoKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgcGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+IG1hdGNoUGF0aDxQYXJhbUtleSwgUGF0aD4ocGF0dGVybiwgcGF0aG5hbWUpLFxuICAgIFtwYXRobmFtZSwgcGF0dGVybl1cbiAgKTtcbn1cblxuLyoqXG4gKiBUaGUgaW50ZXJmYWNlIGZvciB0aGUgbmF2aWdhdGUoKSBmdW5jdGlvbiByZXR1cm5lZCBmcm9tIHVzZU5hdmlnYXRlKCkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVGdW5jdGlvbiB7XG4gICh0bzogVG8sIG9wdGlvbnM/OiBOYXZpZ2F0ZU9wdGlvbnMpOiB2b2lkO1xuICAoZGVsdGE6IG51bWJlcik6IHZvaWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBpbXBlcmF0aXZlIG1ldGhvZCBmb3IgY2hhbmdpbmcgdGhlIGxvY2F0aW9uLiBVc2VkIGJ5IDxMaW5rPnMsIGJ1dFxuICogbWF5IGFsc28gYmUgdXNlZCBieSBvdGhlciBlbGVtZW50cyB0byBjaGFuZ2UgdGhlIGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW5hdmlnYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VOYXZpZ2F0ZSgpOiBOYXZpZ2F0ZUZ1bmN0aW9uIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlTmF2aWdhdGUoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICBsZXQgeyBiYXNlbmFtZSwgbmF2aWdhdG9yIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcblxuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcykubWFwKChtYXRjaCkgPT4gbWF0Y2gucGF0aG5hbWVCYXNlKVxuICApO1xuXG4gIGxldCBhY3RpdmVSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG5cbiAgbGV0IG5hdmlnYXRlOiBOYXZpZ2F0ZUZ1bmN0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKHRvOiBUbyB8IG51bWJlciwgb3B0aW9uczogTmF2aWdhdGVPcHRpb25zID0ge30pID0+IHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGFjdGl2ZVJlZi5jdXJyZW50LFxuICAgICAgICBgWW91IHNob3VsZCBjYWxsIG5hdmlnYXRlKCkgaW4gYSBSZWFjdC51c2VFZmZlY3QoKSwgbm90IHdoZW4gYCArXG4gICAgICAgICAgYHlvdXIgY29tcG9uZW50IGlzIGZpcnN0IHJlbmRlcmVkLmBcbiAgICAgICk7XG5cbiAgICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBuYXZpZ2F0b3IuZ28odG8pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBwYXRoID0gcmVzb2x2ZVRvKFxuICAgICAgICB0byxcbiAgICAgICAgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLFxuICAgICAgICBsb2NhdGlvblBhdGhuYW1lLFxuICAgICAgICBvcHRpb25zLnJlbGF0aXZlID09PSBcInBhdGhcIlxuICAgICAgKTtcblxuICAgICAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZSBwcmlvclxuICAgICAgLy8gdG8gaGFuZGluZyBvZmYgdG8gaGlzdG9yeS4gIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4gd2VcbiAgICAgIC8vIG5hdmlnYXRlIHRvIHRoZSByYXcgYmFzZW5hbWUgd2hpY2ggYWxsb3dzIHRoZSBiYXNlbmFtZSB0byBoYXZlIGZ1bGxcbiAgICAgIC8vIGNvbnRyb2wgb3ZlciB0aGUgcHJlc2VuY2Ugb2YgYSB0cmFpbGluZyBzbGFzaCBvbiByb290IGxpbmtzXG4gICAgICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgICAgIHBhdGgucGF0aG5hbWUgPVxuICAgICAgICAgIHBhdGgucGF0aG5hbWUgPT09IFwiL1wiXG4gICAgICAgICAgICA/IGJhc2VuYW1lXG4gICAgICAgICAgICA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgKCEhb3B0aW9ucy5yZXBsYWNlID8gbmF2aWdhdG9yLnJlcGxhY2UgOiBuYXZpZ2F0b3IucHVzaCkoXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9wdGlvbnMuc3RhdGUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgfSxcbiAgICBbYmFzZW5hbWUsIG5hdmlnYXRvciwgcm91dGVQYXRobmFtZXNKc29uLCBsb2NhdGlvblBhdGhuYW1lXVxuICApO1xuXG4gIHJldHVybiBuYXZpZ2F0ZTtcbn1cblxuY29uc3QgT3V0bGV0Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8dW5rbm93bj4obnVsbCk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29udGV4dCAoaWYgcHJvdmlkZWQpIGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcbiAqIGhpZXJhcmNoeS5cbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW91dGxldC1jb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VPdXRsZXRDb250ZXh0PENvbnRleHQgPSB1bmtub3duPigpOiBDb250ZXh0IHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoT3V0bGV0Q29udGV4dCkgYXMgQ29udGV4dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcbiAqIGhpZXJhcmNoeS4gVXNlZCBpbnRlcm5hbGx5IGJ5IDxPdXRsZXQ+IHRvIHJlbmRlciBjaGlsZCByb3V0ZXMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2Utb3V0bGV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VPdXRsZXQoY29udGV4dD86IHVua25vd24pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgbGV0IG91dGxldCA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KS5vdXRsZXQ7XG4gIGlmIChvdXRsZXQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPE91dGxldENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHR9PntvdXRsZXR9PC9PdXRsZXRDb250ZXh0LlByb3ZpZGVyPlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG91dGxldDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBrZXkvdmFsdWUgcGFpcnMgb2YgdGhlIGR5bmFtaWMgcGFyYW1zIGZyb20gdGhlIGN1cnJlbnRcbiAqIFVSTCB0aGF0IHdlcmUgbWF0Y2hlZCBieSB0aGUgcm91dGUgcGF0aC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1wYXJhbXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhcmFtczxcbiAgUGFyYW1zT3JLZXkgZXh0ZW5kcyBzdHJpbmcgfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+ID0gc3RyaW5nXG4+KCk6IFJlYWRvbmx5PFxuICBbUGFyYW1zT3JLZXldIGV4dGVuZHMgW3N0cmluZ10gPyBQYXJhbXM8UGFyYW1zT3JLZXk+IDogUGFydGlhbDxQYXJhbXNPcktleT5cbj4ge1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gcm91dGVNYXRjaCA/IChyb3V0ZU1hdGNoLnBhcmFtcyBhcyBhbnkpIDoge307XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhlIHBhdGhuYW1lIG9mIHRoZSBnaXZlbiBgdG9gIHZhbHVlIGFnYWluc3QgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtcmVzb2x2ZWQtcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVzb2x2ZWRQYXRoKFxuICB0bzogVG8sXG4gIHsgcmVsYXRpdmUgfTogeyByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGUgfSA9IHt9XG4pOiBQYXRoIHtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcblxuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcykubWFwKChtYXRjaCkgPT4gbWF0Y2gucGF0aG5hbWVCYXNlKVxuICApO1xuXG4gIHJldHVybiBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+XG4gICAgICByZXNvbHZlVG8oXG4gICAgICAgIHRvLFxuICAgICAgICBKU09OLnBhcnNlKHJvdXRlUGF0aG5hbWVzSnNvbiksXG4gICAgICAgIGxvY2F0aW9uUGF0aG5hbWUsXG4gICAgICAgIHJlbGF0aXZlID09PSBcInBhdGhcIlxuICAgICAgKSxcbiAgICBbdG8sIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZSwgcmVsYXRpdmVdXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBvZiB0aGUgcm91dGUgdGhhdCBtYXRjaGVkIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBwcmVwYXJlZFxuICogd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0IHRvIHJlbmRlciB0aGUgcmVtYWluZGVyIG9mIHRoZSByb3V0ZSB0cmVlLiBSb3V0ZVxuICogZWxlbWVudHMgaW4gdGhlIHRyZWUgbXVzdCByZW5kZXIgYW4gPE91dGxldD4gdG8gcmVuZGVyIHRoZWlyIGNoaWxkIHJvdXRlJ3NcbiAqIGVsZW1lbnQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2Utcm91dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZXMoXG4gIHJvdXRlczogUm91dGVPYmplY3RbXSxcbiAgbG9jYXRpb25Bcmc/OiBQYXJ0aWFsPExvY2F0aW9uPiB8IHN0cmluZ1xuKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZVJvdXRlcygpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIGxldCB7IG5hdmlnYXRvciB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCBkYXRhUm91dGVyU3RhdGVDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgbGV0IHsgbWF0Y2hlczogcGFyZW50TWF0Y2hlcyB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IHBhcmVudE1hdGNoZXNbcGFyZW50TWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgbGV0IHBhcmVudFBhcmFtcyA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xuICBsZXQgcGFyZW50UGF0aG5hbWUgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZSA6IFwiL1wiO1xuICBsZXQgcGFyZW50UGF0aG5hbWVCYXNlID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGF0aG5hbWVCYXNlIDogXCIvXCI7XG4gIGxldCBwYXJlbnRSb3V0ZSA9IHJvdXRlTWF0Y2ggJiYgcm91dGVNYXRjaC5yb3V0ZTtcblxuICBpZiAoX19ERVZfXykge1xuICAgIC8vIFlvdSB3b24ndCBnZXQgYSB3YXJuaW5nIGFib3V0IDIgZGlmZmVyZW50IDxSb3V0ZXM+IHVuZGVyIGEgPFJvdXRlPlxuICAgIC8vIHdpdGhvdXQgYSB0cmFpbGluZyAqLCBidXQgdGhpcyBpcyBhIGJlc3QtZWZmb3J0IHdhcm5pbmcgYW55d2F5IHNpbmNlIHdlXG4gICAgLy8gY2Fubm90IGV2ZW4gZ2l2ZSB0aGUgd2FybmluZyB1bmxlc3MgdGhleSBsYW5kIGF0IHRoZSBwYXJlbnQgcm91dGUuXG4gICAgLy9cbiAgICAvLyBFeGFtcGxlOlxuICAgIC8vXG4gICAgLy8gPFJvdXRlcz5cbiAgICAvLyAgIHsvKiBUaGlzIHJvdXRlIHBhdGggTVVTVCBlbmQgd2l0aCAvKiBiZWNhdXNlIG90aGVyd2lzZVxuICAgIC8vICAgICAgIGl0IHdpbGwgbmV2ZXIgbWF0Y2ggL2Jsb2cvcG9zdC8xMjMgKi99XG4gICAgLy8gICA8Um91dGUgcGF0aD1cImJsb2dcIiBlbGVtZW50PXs8QmxvZyAvPn0gLz5cbiAgICAvLyAgIDxSb3V0ZSBwYXRoPVwiYmxvZy9mZWVkXCIgZWxlbWVudD17PEJsb2dGZWVkIC8+fSAvPlxuICAgIC8vIDwvUm91dGVzPlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gQmxvZygpIHtcbiAgICAvLyAgIHJldHVybiAoXG4gICAgLy8gICAgIDxSb3V0ZXM+XG4gICAgLy8gICAgICAgPFJvdXRlIHBhdGg9XCJwb3N0LzppZFwiIGVsZW1lbnQ9ezxQb3N0IC8+fSAvPlxuICAgIC8vICAgICA8L1JvdXRlcz5cbiAgICAvLyAgICk7XG4gICAgLy8gfVxuICAgIGxldCBwYXJlbnRQYXRoID0gKHBhcmVudFJvdXRlICYmIHBhcmVudFJvdXRlLnBhdGgpIHx8IFwiXCI7XG4gICAgd2FybmluZ09uY2UoXG4gICAgICBwYXJlbnRQYXRobmFtZSxcbiAgICAgICFwYXJlbnRSb3V0ZSB8fCBwYXJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSxcbiAgICAgIGBZb3UgcmVuZGVyZWQgZGVzY2VuZGFudCA8Um91dGVzPiAob3IgY2FsbGVkIFxcYHVzZVJvdXRlcygpXFxgKSBhdCBgICtcbiAgICAgICAgYFwiJHtwYXJlbnRQYXRobmFtZX1cIiAodW5kZXIgPFJvdXRlIHBhdGg9XCIke3BhcmVudFBhdGh9XCI+KSBidXQgdGhlIGAgK1xuICAgICAgICBgcGFyZW50IHJvdXRlIHBhdGggaGFzIG5vIHRyYWlsaW5nIFwiKlwiLiBUaGlzIG1lYW5zIGlmIHlvdSBuYXZpZ2F0ZSBgICtcbiAgICAgICAgYGRlZXBlciwgdGhlIHBhcmVudCB3b24ndCBtYXRjaCBhbnltb3JlIGFuZCB0aGVyZWZvcmUgdGhlIGNoaWxkIGAgK1xuICAgICAgICBgcm91dGVzIHdpbGwgbmV2ZXIgcmVuZGVyLlxcblxcbmAgK1xuICAgICAgICBgUGxlYXNlIGNoYW5nZSB0aGUgcGFyZW50IDxSb3V0ZSBwYXRoPVwiJHtwYXJlbnRQYXRofVwiPiB0byA8Um91dGUgYCArXG4gICAgICAgIGBwYXRoPVwiJHtwYXJlbnRQYXRoID09PSBcIi9cIiA/IFwiKlwiIDogYCR7cGFyZW50UGF0aH0vKmB9XCI+LmBcbiAgICApO1xuICB9XG5cbiAgbGV0IGxvY2F0aW9uRnJvbUNvbnRleHQgPSB1c2VMb2NhdGlvbigpO1xuXG4gIGxldCBsb2NhdGlvbjtcbiAgaWYgKGxvY2F0aW9uQXJnKSB7XG4gICAgbGV0IHBhcnNlZExvY2F0aW9uQXJnID1cbiAgICAgIHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcblxuICAgIGludmFyaWFudChcbiAgICAgIHBhcmVudFBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgfHxcbiAgICAgICAgcGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWU/LnN0YXJ0c1dpdGgocGFyZW50UGF0aG5hbWVCYXNlKSxcbiAgICAgIGBXaGVuIG92ZXJyaWRpbmcgdGhlIGxvY2F0aW9uIHVzaW5nIFxcYDxSb3V0ZXMgbG9jYXRpb24+XFxgIG9yIFxcYHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKVxcYCwgYCArXG4gICAgICAgIGB0aGUgbG9jYXRpb24gcGF0aG5hbWUgbXVzdCBiZWdpbiB3aXRoIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgYCArXG4gICAgICAgIGBtYXRjaGVkIGJ5IGFsbCBwYXJlbnQgcm91dGVzLiBUaGUgY3VycmVudCBwYXRobmFtZSBiYXNlIGlzIFwiJHtwYXJlbnRQYXRobmFtZUJhc2V9XCIgYCArXG4gICAgICAgIGBidXQgcGF0aG5hbWUgXCIke3BhcnNlZExvY2F0aW9uQXJnLnBhdGhuYW1lfVwiIHdhcyBnaXZlbiBpbiB0aGUgXFxgbG9jYXRpb25cXGAgcHJvcC5gXG4gICAgKTtcblxuICAgIGxvY2F0aW9uID0gcGFyc2VkTG9jYXRpb25Bcmc7XG4gIH0gZWxzZSB7XG4gICAgbG9jYXRpb24gPSBsb2NhdGlvbkZyb21Db250ZXh0O1xuICB9XG5cbiAgbGV0IHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCI7XG4gIGxldCByZW1haW5pbmdQYXRobmFtZSA9XG4gICAgcGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIlxuICAgICAgPyBwYXRobmFtZVxuICAgICAgOiBwYXRobmFtZS5zbGljZShwYXJlbnRQYXRobmFtZUJhc2UubGVuZ3RoKSB8fCBcIi9cIjtcblxuICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlcywgeyBwYXRobmFtZTogcmVtYWluaW5nUGF0aG5hbWUgfSk7XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICB3YXJuaW5nKFxuICAgICAgcGFyZW50Um91dGUgfHwgbWF0Y2hlcyAhPSBudWxsLFxuICAgICAgYE5vIHJvdXRlcyBtYXRjaGVkIGxvY2F0aW9uIFwiJHtsb2NhdGlvbi5wYXRobmFtZX0ke2xvY2F0aW9uLnNlYXJjaH0ke2xvY2F0aW9uLmhhc2h9XCIgYFxuICAgICk7XG5cbiAgICB3YXJuaW5nKFxuICAgICAgbWF0Y2hlcyA9PSBudWxsIHx8XG4gICAgICAgIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5lbGVtZW50ICE9PSB1bmRlZmluZWQsXG4gICAgICBgTWF0Y2hlZCBsZWFmIHJvdXRlIGF0IGxvY2F0aW9uIFwiJHtsb2NhdGlvbi5wYXRobmFtZX0ke2xvY2F0aW9uLnNlYXJjaH0ke2xvY2F0aW9uLmhhc2h9XCIgZG9lcyBub3QgaGF2ZSBhbiBlbGVtZW50LiBgICtcbiAgICAgICAgYFRoaXMgbWVhbnMgaXQgd2lsbCByZW5kZXIgYW4gPE91dGxldCAvPiB3aXRoIGEgbnVsbCB2YWx1ZSBieSBkZWZhdWx0IHJlc3VsdGluZyBpbiBhbiBcImVtcHR5XCIgcGFnZS5gXG4gICAgKTtcbiAgfVxuXG4gIGxldCByZW5kZXJlZE1hdGNoZXMgPSBfcmVuZGVyTWF0Y2hlcyhcbiAgICBtYXRjaGVzICYmXG4gICAgICBtYXRjaGVzLm1hcCgobWF0Y2gpID0+XG4gICAgICAgIE9iamVjdC5hc3NpZ24oe30sIG1hdGNoLCB7XG4gICAgICAgICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRQYXJhbXMsIG1hdGNoLnBhcmFtcyksXG4gICAgICAgICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbXG4gICAgICAgICAgICBwYXJlbnRQYXRobmFtZUJhc2UsXG4gICAgICAgICAgICAvLyBSZS1lbmNvZGUgcGF0aG5hbWVzIHRoYXQgd2VyZSBkZWNvZGVkIGluc2lkZSBtYXRjaFJvdXRlc1xuICAgICAgICAgICAgbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uXG4gICAgICAgICAgICAgID8gbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uKG1hdGNoLnBhdGhuYW1lKS5wYXRobmFtZVxuICAgICAgICAgICAgICA6IG1hdGNoLnBhdGhuYW1lLFxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHBhdGhuYW1lQmFzZTpcbiAgICAgICAgICAgIG1hdGNoLnBhdGhuYW1lQmFzZSA9PT0gXCIvXCJcbiAgICAgICAgICAgICAgPyBwYXJlbnRQYXRobmFtZUJhc2VcbiAgICAgICAgICAgICAgOiBqb2luUGF0aHMoW1xuICAgICAgICAgICAgICAgICAgcGFyZW50UGF0aG5hbWVCYXNlLFxuICAgICAgICAgICAgICAgICAgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvblxuICAgICAgICAgICAgICAgICAgICA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihtYXRjaC5wYXRobmFtZUJhc2UpLnBhdGhuYW1lXG4gICAgICAgICAgICAgICAgICAgIDogbWF0Y2gucGF0aG5hbWVCYXNlLFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICBwYXJlbnRNYXRjaGVzLFxuICAgIGRhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgfHwgdW5kZWZpbmVkXG4gICk7XG5cbiAgLy8gV2hlbiBhIHVzZXIgcGFzc2VzIGluIGEgYGxvY2F0aW9uQXJnYCwgdGhlIGFzc29jaWF0ZWQgcm91dGVzIG5lZWQgdG9cbiAgLy8gYmUgd3JhcHBlZCBpbiBhIG5ldyBgTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyYCBpbiBvcmRlciBmb3IgYHVzZUxvY2F0aW9uYFxuICAvLyB0byB1c2UgdGhlIHNjb3BlZCBsb2NhdGlvbiBpbnN0ZWFkIG9mIHRoZSBnbG9iYWwgbG9jYXRpb24uXG4gIGlmIChsb2NhdGlvbkFyZyAmJiByZW5kZXJlZE1hdGNoZXMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPExvY2F0aW9uQ29udGV4dC5Qcm92aWRlclxuICAgICAgICB2YWx1ZT17e1xuICAgICAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgICAgICBwYXRobmFtZTogXCIvXCIsXG4gICAgICAgICAgICBzZWFyY2g6IFwiXCIsXG4gICAgICAgICAgICBoYXNoOiBcIlwiLFxuICAgICAgICAgICAgc3RhdGU6IG51bGwsXG4gICAgICAgICAgICBrZXk6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgLi4ubG9jYXRpb24sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYXZpZ2F0aW9uVHlwZTogTmF2aWdhdGlvblR5cGUuUG9wLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7cmVuZGVyZWRNYXRjaGVzfVxuICAgICAgPC9Mb2NhdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiByZW5kZXJlZE1hdGNoZXM7XG59XG5cbmZ1bmN0aW9uIERlZmF1bHRFcnJvckVsZW1lbnQoKSB7XG4gIGxldCBlcnJvciA9IHVzZVJvdXRlRXJyb3IoKTtcbiAgbGV0IG1lc3NhZ2UgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcilcbiAgICA/IGAke2Vycm9yLnN0YXR1c30gJHtlcnJvci5zdGF0dXNUZXh0fWBcbiAgICA6IGVycm9yIGluc3RhbmNlb2YgRXJyb3JcbiAgICA/IGVycm9yLm1lc3NhZ2VcbiAgICA6IEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgbGV0IHN0YWNrID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogbnVsbDtcbiAgbGV0IGxpZ2h0Z3JleSA9IFwicmdiYSgyMDAsMjAwLDIwMCwgMC41KVwiO1xuICBsZXQgcHJlU3R5bGVzID0geyBwYWRkaW5nOiBcIjAuNXJlbVwiLCBiYWNrZ3JvdW5kQ29sb3I6IGxpZ2h0Z3JleSB9O1xuICBsZXQgY29kZVN0eWxlcyA9IHsgcGFkZGluZzogXCIycHggNHB4XCIsIGJhY2tncm91bmRDb2xvcjogbGlnaHRncmV5IH07XG5cbiAgbGV0IGRldkluZm8gPSBudWxsO1xuICBpZiAoX19ERVZfXykge1xuICAgIGRldkluZm8gPSAoXG4gICAgICA8PlxuICAgICAgICA8cD7wn5K/IEhleSBkZXZlbG9wZXIg8J+RizwvcD5cbiAgICAgICAgPHA+XG4gICAgICAgICAgWW91IGNhbiBwcm92aWRlIGEgd2F5IGJldHRlciBVWCB0aGFuIHRoaXMgd2hlbiB5b3VyIGFwcCB0aHJvd3MgZXJyb3JzXG4gICAgICAgICAgYnkgcHJvdmlkaW5nIHlvdXIgb3duJm5ic3A7XG4gICAgICAgICAgPGNvZGUgc3R5bGU9e2NvZGVTdHlsZXN9PmVycm9yRWxlbWVudDwvY29kZT4gcHJvcHMgb24mbmJzcDtcbiAgICAgICAgICA8Y29kZSBzdHlsZT17Y29kZVN0eWxlc30+Jmx0O1JvdXRlJmd0OzwvY29kZT5cbiAgICAgICAgPC9wPlxuICAgICAgPC8+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxoMj5VbmV4cGVjdGVkIEFwcGxpY2F0aW9uIEVycm9yITwvaDI+XG4gICAgICA8aDMgc3R5bGU9e3sgZm9udFN0eWxlOiBcIml0YWxpY1wiIH19PnttZXNzYWdlfTwvaDM+XG4gICAgICB7c3RhY2sgPyA8cHJlIHN0eWxlPXtwcmVTdHlsZXN9PntzdGFja308L3ByZT4gOiBudWxsfVxuICAgICAge2RldkluZm99XG4gICAgPC8+XG4gICk7XG59XG5cbnR5cGUgUmVuZGVyRXJyb3JCb3VuZGFyeVByb3BzID0gUmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48e1xuICBsb2NhdGlvbjogTG9jYXRpb247XG4gIGVycm9yOiBhbnk7XG4gIGNvbXBvbmVudDogUmVhY3QuUmVhY3ROb2RlO1xuICByb3V0ZUNvbnRleHQ6IFJvdXRlQ29udGV4dE9iamVjdDtcbn0+O1xuXG50eXBlIFJlbmRlckVycm9yQm91bmRhcnlTdGF0ZSA9IHtcbiAgbG9jYXRpb246IExvY2F0aW9uO1xuICBlcnJvcjogYW55O1xufTtcblxuZXhwb3J0IGNsYXNzIFJlbmRlckVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8XG4gIFJlbmRlckVycm9yQm91bmRhcnlQcm9wcyxcbiAgUmVuZGVyRXJyb3JCb3VuZGFyeVN0YXRlXG4+IHtcbiAgY29uc3RydWN0b3IocHJvcHM6IFJlbmRlckVycm9yQm91bmRhcnlQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uLFxuICAgICAgZXJyb3I6IHByb3BzLmVycm9yLFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yOiBhbnkpIHtcbiAgICByZXR1cm4geyBlcnJvcjogZXJyb3IgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgcHJvcHM6IFJlbmRlckVycm9yQm91bmRhcnlQcm9wcyxcbiAgICBzdGF0ZTogUmVuZGVyRXJyb3JCb3VuZGFyeVN0YXRlXG4gICkge1xuICAgIC8vIFdoZW4gd2UgZ2V0IGludG8gYW4gZXJyb3Igc3RhdGUsIHRoZSB1c2VyIHdpbGwgbGlrZWx5IGNsaWNrIFwiYmFja1wiIHRvIHRoZVxuICAgIC8vIHByZXZpb3VzIHBhZ2UgdGhhdCBkaWRuJ3QgaGF2ZSBhbiBlcnJvci4gQmVjYXVzZSB0aGlzIHdyYXBzIHRoZSBlbnRpcmVcbiAgICAvLyBhcHBsaWNhdGlvbiwgdGhhdCB3aWxsIGhhdmUgbm8gZWZmZWN0LS10aGUgZXJyb3IgcGFnZSBjb250aW51ZXMgdG8gZGlzcGxheS5cbiAgICAvLyBUaGlzIGdpdmVzIHVzIGEgbWVjaGFuaXNtIHRvIHJlY292ZXIgZnJvbSB0aGUgZXJyb3Igd2hlbiB0aGUgbG9jYXRpb24gY2hhbmdlcy5cbiAgICAvL1xuICAgIC8vIFdoZXRoZXIgd2UncmUgaW4gYW4gZXJyb3Igc3RhdGUgb3Igbm90LCB3ZSB1cGRhdGUgdGhlIGxvY2F0aW9uIGluIHN0YXRlXG4gICAgLy8gc28gdGhhdCB3aGVuIHdlIGFyZSBpbiBhbiBlcnJvciBzdGF0ZSwgaXQgZ2V0cyByZXNldCB3aGVuIGEgbmV3IGxvY2F0aW9uXG4gICAgLy8gY29tZXMgaW4gYW5kIHRoZSB1c2VyIHJlY292ZXJzIGZyb20gdGhlIGVycm9yLlxuICAgIGlmIChzdGF0ZS5sb2NhdGlvbiAhPT0gcHJvcHMubG9jYXRpb24pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBwcm9wcy5lcnJvcixcbiAgICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBub3QgY2hhbmdpbmcgbG9jYXRpb25zLCBwcmVzZXJ2ZSB0aGUgbG9jYXRpb24gYnV0IHN0aWxsIHN1cmZhY2VcbiAgICAvLyBhbnkgbmV3IGVycm9ycyB0aGF0IG1heSBjb21lIHRocm91Z2guIFdlIHJldGFpbiB0aGUgZXhpc3RpbmcgZXJyb3IsIHdlIGRvXG4gICAgLy8gdGhpcyBiZWNhdXNlIHRoZSBlcnJvciBwcm92aWRlZCBmcm9tIHRoZSBhcHAgc3RhdGUgbWF5IGJlIGNsZWFyZWQgd2l0aG91dFxuICAgIC8vIHRoZSBsb2NhdGlvbiBjaGFuZ2luZy5cbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IHByb3BzLmVycm9yIHx8IHN0YXRlLmVycm9yLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgIH07XG4gIH1cblxuICBjb21wb25lbnREaWRDYXRjaChlcnJvcjogYW55LCBlcnJvckluZm86IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIlJlYWN0IFJvdXRlciBjYXVnaHQgdGhlIGZvbGxvd2luZyBlcnJvciBkdXJpbmcgcmVuZGVyXCIsXG4gICAgICBlcnJvcixcbiAgICAgIGVycm9ySW5mb1xuICAgICk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3IgPyAoXG4gICAgICA8Um91dGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt0aGlzLnByb3BzLnJvdXRlQ29udGV4dH0+XG4gICAgICAgIDxSb3V0ZUVycm9yQ29udGV4dC5Qcm92aWRlclxuICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLmVycm9yfVxuICAgICAgICAgIGNoaWxkcmVuPXt0aGlzLnByb3BzLmNvbXBvbmVudH1cbiAgICAgICAgLz5cbiAgICAgIDwvUm91dGVDb250ZXh0LlByb3ZpZGVyPlxuICAgICkgOiAoXG4gICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgKTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgUmVuZGVyZWRSb3V0ZVByb3BzIHtcbiAgcm91dGVDb250ZXh0OiBSb3V0ZUNvbnRleHRPYmplY3Q7XG4gIG1hdGNoOiBSb3V0ZU1hdGNoPHN0cmluZywgUm91dGVPYmplY3Q+O1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gUmVuZGVyZWRSb3V0ZSh7IHJvdXRlQ29udGV4dCwgbWF0Y2gsIGNoaWxkcmVuIH06IFJlbmRlcmVkUm91dGVQcm9wcykge1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcblxuICAvLyBUcmFjayBob3cgZGVlcCB3ZSBnb3QgaW4gb3VyIHJlbmRlciBwYXNzIHRvIGVtdWxhdGUgU1NSIGNvbXBvbmVudERpZENhdGNoXG4gIC8vIGluIGEgRGF0YVN0YXRpY1JvdXRlclxuICBpZiAoXG4gICAgZGF0YVJvdXRlckNvbnRleHQgJiZcbiAgICBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWMgJiZcbiAgICBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWNDb250ZXh0ICYmXG4gICAgbWF0Y2gucm91dGUuZXJyb3JFbGVtZW50XG4gICkge1xuICAgIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY0NvbnRleHQuX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17cm91dGVDb250ZXh0fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1JvdXRlQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9yZW5kZXJNYXRjaGVzKFxuICBtYXRjaGVzOiBSb3V0ZU1hdGNoW10gfCBudWxsLFxuICBwYXJlbnRNYXRjaGVzOiBSb3V0ZU1hdGNoW10gPSBbXSxcbiAgZGF0YVJvdXRlclN0YXRlPzogUmVtaXhSb3V0ZXJbXCJzdGF0ZVwiXVxuKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIGlmIChtYXRjaGVzID09IG51bGwpIHtcbiAgICBpZiAoZGF0YVJvdXRlclN0YXRlPy5lcnJvcnMpIHtcbiAgICAgIC8vIERvbid0IGJhaWwgaWYgd2UgaGF2ZSBkYXRhIHJvdXRlciBlcnJvcnMgc28gd2UgY2FuIHJlbmRlciB0aGVtIGluIHRoZVxuICAgICAgLy8gYm91bmRhcnkuICBVc2UgdGhlIHByZS1tYXRjaGVkIChvciBzaGltbWVkKSBtYXRjaGVzXG4gICAgICBtYXRjaGVzID0gZGF0YVJvdXRlclN0YXRlLm1hdGNoZXMgYXMgRGF0YVJvdXRlTWF0Y2hbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgbGV0IHJlbmRlcmVkTWF0Y2hlcyA9IG1hdGNoZXM7XG5cbiAgLy8gSWYgd2UgaGF2ZSBkYXRhIGVycm9ycywgdHJpbSBtYXRjaGVzIHRvIHRoZSBoaWdoZXN0IGVycm9yIGJvdW5kYXJ5XG4gIGxldCBlcnJvcnMgPSBkYXRhUm91dGVyU3RhdGU/LmVycm9ycztcbiAgaWYgKGVycm9ycyAhPSBudWxsKSB7XG4gICAgbGV0IGVycm9ySW5kZXggPSByZW5kZXJlZE1hdGNoZXMuZmluZEluZGV4KFxuICAgICAgKG0pID0+IG0ucm91dGUuaWQgJiYgZXJyb3JzPy5bbS5yb3V0ZS5pZF1cbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgIGVycm9ySW5kZXggPj0gMCxcbiAgICAgIGBDb3VsZCBub3QgZmluZCBhIG1hdGNoaW5nIHJvdXRlIGZvciB0aGUgY3VycmVudCBlcnJvcnM6ICR7ZXJyb3JzfWBcbiAgICApO1xuICAgIHJlbmRlcmVkTWF0Y2hlcyA9IHJlbmRlcmVkTWF0Y2hlcy5zbGljZShcbiAgICAgIDAsXG4gICAgICBNYXRoLm1pbihyZW5kZXJlZE1hdGNoZXMubGVuZ3RoLCBlcnJvckluZGV4ICsgMSlcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHJlbmRlcmVkTWF0Y2hlcy5yZWR1Y2VSaWdodCgob3V0bGV0LCBtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBsZXQgZXJyb3IgPSBtYXRjaC5yb3V0ZS5pZCA/IGVycm9ycz8uW21hdGNoLnJvdXRlLmlkXSA6IG51bGw7XG4gICAgLy8gT25seSBkYXRhIHJvdXRlcnMgaGFuZGxlIGVycm9yc1xuICAgIGxldCBlcnJvckVsZW1lbnQgPSBkYXRhUm91dGVyU3RhdGVcbiAgICAgID8gbWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IDxEZWZhdWx0RXJyb3JFbGVtZW50IC8+XG4gICAgICA6IG51bGw7XG4gICAgbGV0IG1hdGNoZXMgPSBwYXJlbnRNYXRjaGVzLmNvbmNhdChyZW5kZXJlZE1hdGNoZXMuc2xpY2UoMCwgaW5kZXggKyAxKSk7XG4gICAgbGV0IGdldENoaWxkcmVuID0gKCkgPT4gKFxuICAgICAgPFJlbmRlcmVkUm91dGUgbWF0Y2g9e21hdGNofSByb3V0ZUNvbnRleHQ9e3sgb3V0bGV0LCBtYXRjaGVzIH19PlxuICAgICAgICB7ZXJyb3JcbiAgICAgICAgICA/IGVycm9yRWxlbWVudFxuICAgICAgICAgIDogbWF0Y2gucm91dGUuZWxlbWVudCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBtYXRjaC5yb3V0ZS5lbGVtZW50XG4gICAgICAgICAgOiBvdXRsZXR9XG4gICAgICA8L1JlbmRlcmVkUm91dGU+XG4gICAgKTtcbiAgICAvLyBPbmx5IHdyYXAgaW4gYW4gZXJyb3IgYm91bmRhcnkgd2l0aGluIGRhdGEgcm91dGVyIHVzYWdlcyB3aGVuIHdlIGhhdmUgYW5cbiAgICAvLyBlcnJvckVsZW1lbnQgb24gdGhpcyByb3V0ZS4gIE90aGVyd2lzZSBsZXQgaXQgYnViYmxlIHVwIHRvIGFuIGFuY2VzdG9yXG4gICAgLy8gZXJyb3JFbGVtZW50XG4gICAgcmV0dXJuIGRhdGFSb3V0ZXJTdGF0ZSAmJiAobWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IGluZGV4ID09PSAwKSA/IChcbiAgICAgIDxSZW5kZXJFcnJvckJvdW5kYXJ5XG4gICAgICAgIGxvY2F0aW9uPXtkYXRhUm91dGVyU3RhdGUubG9jYXRpb259XG4gICAgICAgIGNvbXBvbmVudD17ZXJyb3JFbGVtZW50fVxuICAgICAgICBlcnJvcj17ZXJyb3J9XG4gICAgICAgIGNoaWxkcmVuPXtnZXRDaGlsZHJlbigpfVxuICAgICAgICByb3V0ZUNvbnRleHQ9e3sgb3V0bGV0OiBudWxsLCBtYXRjaGVzIH19XG4gICAgICAvPlxuICAgICkgOiAoXG4gICAgICBnZXRDaGlsZHJlbigpXG4gICAgKTtcbiAgfSwgbnVsbCBhcyBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsKTtcbn1cblxuZW51bSBEYXRhUm91dGVySG9vayB7XG4gIFVzZUJsb2NrZXIgPSBcInVzZUJsb2NrZXJcIixcbiAgVXNlUmV2YWxpZGF0b3IgPSBcInVzZVJldmFsaWRhdG9yXCIsXG59XG5cbmVudW0gRGF0YVJvdXRlclN0YXRlSG9vayB7XG4gIFVzZUxvYWRlckRhdGEgPSBcInVzZUxvYWRlckRhdGFcIixcbiAgVXNlQWN0aW9uRGF0YSA9IFwidXNlQWN0aW9uRGF0YVwiLFxuICBVc2VSb3V0ZUVycm9yID0gXCJ1c2VSb3V0ZUVycm9yXCIsXG4gIFVzZU5hdmlnYXRpb24gPSBcInVzZU5hdmlnYXRpb25cIixcbiAgVXNlUm91dGVMb2FkZXJEYXRhID0gXCJ1c2VSb3V0ZUxvYWRlckRhdGFcIixcbiAgVXNlTWF0Y2hlcyA9IFwidXNlTWF0Y2hlc1wiLFxuICBVc2VSZXZhbGlkYXRvciA9IFwidXNlUmV2YWxpZGF0b3JcIixcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihcbiAgaG9va05hbWU6IERhdGFSb3V0ZXJIb29rIHwgRGF0YVJvdXRlclN0YXRlSG9va1xuKSB7XG4gIHJldHVybiBgJHtob29rTmFtZX0gbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGRhdGEgcm91dGVyLiAgU2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlcnMvcGlja2luZy1hLXJvdXRlci5gO1xufVxuXG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyQ29udGV4dChob29rTmFtZTogRGF0YVJvdXRlckhvb2spIHtcbiAgbGV0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBpbnZhcmlhbnQoY3R4LCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSk7XG4gIHJldHVybiBjdHg7XG59XG5cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJTdGF0ZShob29rTmFtZTogRGF0YVJvdXRlclN0YXRlSG9vaykge1xuICBsZXQgc3RhdGUgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQoc3RhdGUsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiB1c2VSb3V0ZUNvbnRleHQoaG9va05hbWU6IERhdGFSb3V0ZXJTdGF0ZUhvb2spIHtcbiAgbGV0IHJvdXRlID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQocm91dGUsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKTtcbiAgcmV0dXJuIHJvdXRlO1xufVxuXG5mdW5jdGlvbiB1c2VDdXJyZW50Um91dGVJZChob29rTmFtZTogRGF0YVJvdXRlclN0YXRlSG9vaykge1xuICBsZXQgcm91dGUgPSB1c2VSb3V0ZUNvbnRleHQoaG9va05hbWUpO1xuICBsZXQgdGhpc1JvdXRlID0gcm91dGUubWF0Y2hlc1tyb3V0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBpbnZhcmlhbnQoXG4gICAgdGhpc1JvdXRlLnJvdXRlLmlkLFxuICAgIGAke2hvb2tOYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIHJvdXRlcyB0aGF0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiYFxuICApO1xuICByZXR1cm4gdGhpc1JvdXRlLnJvdXRlLmlkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiwgZGVmYXVsdGluZyB0byBhbiBcImlkbGVcIiBuYXZpZ2F0aW9uIHdoZW5cbiAqIG5vIG5hdmlnYXRpb24gaXMgaW4gcHJvZ3Jlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU5hdmlnYXRpb24oKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZU5hdmlnYXRpb24pO1xuICByZXR1cm4gc3RhdGUubmF2aWdhdGlvbjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmV2YWxpZGF0ZSBmdW5jdGlvbiBmb3IgbWFudWFsbHkgdHJpZ2dlcmluZyByZXZhbGlkYXRpb24sIGFzIHdlbGxcbiAqIGFzIHRoZSBjdXJyZW50IHN0YXRlIG9mIGFueSBtYW51YWwgcmV2YWxpZGF0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmV2YWxpZGF0b3IoKSB7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZVJldmFsaWRhdG9yKTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUmV2YWxpZGF0b3IpO1xuICByZXR1cm4ge1xuICAgIHJldmFsaWRhdGU6IGRhdGFSb3V0ZXJDb250ZXh0LnJvdXRlci5yZXZhbGlkYXRlLFxuICAgIHN0YXRlOiBzdGF0ZS5yZXZhbGlkYXRpb24sXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYWN0aXZlIHJvdXRlIG1hdGNoZXMsIHVzZWZ1bCBmb3IgYWNjZXNzaW5nIGxvYWRlckRhdGEgZm9yXG4gKiBwYXJlbnQvY2hpbGQgcm91dGVzIG9yIHRoZSByb3V0ZSBcImhhbmRsZVwiIHByb3BlcnR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYXRjaGVzKCkge1xuICBsZXQgeyBtYXRjaGVzLCBsb2FkZXJEYXRhIH0gPSB1c2VEYXRhUm91dGVyU3RhdGUoXG4gICAgRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VNYXRjaGVzXG4gICk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+XG4gICAgICBtYXRjaGVzLm1hcCgobWF0Y2gpID0+IHtcbiAgICAgICAgbGV0IHsgcGF0aG5hbWUsIHBhcmFtcyB9ID0gbWF0Y2g7XG4gICAgICAgIC8vIE5vdGU6IFRoaXMgc3RydWN0dXJlIG1hdGNoZXMgdGhhdCBjcmVhdGVkIGJ5IGNyZWF0ZVVzZU1hdGNoZXNNYXRjaFxuICAgICAgICAvLyBpbiB0aGUgQHJlbWl4LXJ1bi9yb3V0ZXIgLCBzbyBpZiB5b3UgY2hhbmdlIHRoaXMgcGxlYXNlIGFsc28gY2hhbmdlXG4gICAgICAgIC8vIHRoYXQgOikgIEV2ZW50dWFsbHkgd2UnbGwgRFJZIHRoaXMgdXBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogbWF0Y2gucm91dGUuaWQsXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgIGRhdGE6IGxvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdIGFzIHVua25vd24sXG4gICAgICAgICAgaGFuZGxlOiBtYXRjaC5yb3V0ZS5oYW5kbGUgYXMgdW5rbm93bixcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgIFttYXRjaGVzLCBsb2FkZXJEYXRhXVxuICApO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGxvYWRlciBkYXRhIGZvciB0aGUgbmVhcmVzdCBhbmNlc3RvciBSb3V0ZSBsb2FkZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvYWRlckRhdGEoKTogdW5rbm93biB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUxvYWRlckRhdGEpO1xuICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTG9hZGVyRGF0YSk7XG5cbiAgaWYgKHN0YXRlLmVycm9ycyAmJiBzdGF0ZS5lcnJvcnNbcm91dGVJZF0gIT0gbnVsbCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBgWW91IGNhbm5vdCBcXGB1c2VMb2FkZXJEYXRhXFxgIGluIGFuIGVycm9yRWxlbWVudCAocm91dGVJZDogJHtyb3V0ZUlkfSlgXG4gICAgKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlSWRdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGxvYWRlckRhdGEgZm9yIHRoZSBnaXZlbiByb3V0ZUlkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZUxvYWRlckRhdGEocm91dGVJZDogc3RyaW5nKTogdW5rbm93biB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJvdXRlTG9hZGVyRGF0YSk7XG4gIHJldHVybiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlSWRdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGFjdGlvbiBkYXRhIGZvciB0aGUgbmVhcmVzdCBhbmNlc3RvciBSb3V0ZSBhY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjdGlvbkRhdGEoKTogdW5rbm93biB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUFjdGlvbkRhdGEpO1xuXG4gIGxldCByb3V0ZSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgaW52YXJpYW50KHJvdXRlLCBgdXNlQWN0aW9uRGF0YSBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgUm91dGVDb250ZXh0YCk7XG5cbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoc3RhdGU/LmFjdGlvbkRhdGEgfHwge30pWzBdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG5lYXJlc3QgYW5jZXN0b3IgUm91dGUgZXJyb3IsIHdoaWNoIGNvdWxkIGJlIGEgbG9hZGVyL2FjdGlvblxuICogZXJyb3Igb3IgYSByZW5kZXIgZXJyb3IuICBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCBmcm9tIHlvdXJcbiAqIGVycm9yRWxlbWVudCB0byBkaXNwbGF5IGEgcHJvcGVyIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZUVycm9yKCk6IHVua25vd24ge1xuICBsZXQgZXJyb3IgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlRXJyb3JDb250ZXh0KTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVFcnJvcik7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSb3V0ZUVycm9yKTtcblxuICAvLyBJZiB0aGlzIHdhcyBhIHJlbmRlciBlcnJvciwgd2UgcHV0IGl0IGluIGEgUm91dGVFcnJvciBjb250ZXh0IGluc2lkZVxuICAvLyBvZiBSZW5kZXJFcnJvckJvdW5kYXJ5XG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSBsb29rIGZvciBlcnJvcnMgZnJvbSBvdXIgZGF0YSByb3V0ZXIgc3RhdGVcbiAgcmV0dXJuIHN0YXRlLmVycm9ycz8uW3JvdXRlSWRdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGhhcHB5LXBhdGggZGF0YSBmcm9tIHRoZSBuZWFyZXN0IGFuY2VzdG9yIDxBd2FpdCAvPiB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQXN5bmNWYWx1ZSgpOiB1bmtub3duIHtcbiAgbGV0IHZhbHVlID0gUmVhY3QudXNlQ29udGV4dChBd2FpdENvbnRleHQpO1xuICByZXR1cm4gdmFsdWU/Ll9kYXRhO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGVycm9yIGZyb20gdGhlIG5lYXJlc3QgYW5jZXN0b3IgPEF3YWl0IC8+IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VBc3luY0Vycm9yKCk6IHVua25vd24ge1xuICBsZXQgdmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KEF3YWl0Q29udGV4dCk7XG4gIHJldHVybiB2YWx1ZT8uX2Vycm9yO1xufVxuXG5sZXQgYmxvY2tlcklkID0gMDtcblxuLyoqXG4gKiBBbGxvdyB0aGUgYXBwbGljYXRpb24gdG8gYmxvY2sgbmF2aWdhdGlvbnMgd2l0aGluIHRoZSBTUEEgYW5kIHByZXNlbnQgdGhlXG4gKiB1c2VyIGEgY29uZmlybWF0aW9uIGRpYWxvZyB0byBjb25maXJtIHRoZSBuYXZpZ2F0aW9uLiAgTW9zdGx5IHVzZWQgdG8gYXZvaWRcbiAqIHVzaW5nIGhhbGYtZmlsbGVkIGZvcm0gZGF0YS4gIFRoaXMgZG9lcyBub3QgaGFuZGxlIGhhcmQtcmVsb2FkcyBvclxuICogY3Jvc3Mtb3JpZ2luIG5hdmlnYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmxvY2tlcihzaG91bGRCbG9jazogYm9vbGVhbiB8IEJsb2NrZXJGdW5jdGlvbik6IEJsb2NrZXIge1xuICBsZXQgeyByb3V0ZXIgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZUJsb2NrZXIpO1xuICBsZXQgW2Jsb2NrZXJLZXldID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gU3RyaW5nKCsrYmxvY2tlcklkKSk7XG5cbiAgbGV0IGJsb2NrZXJGdW5jdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrPEJsb2NrZXJGdW5jdGlvbj4oXG4gICAgKGFyZ3MpID0+IHtcbiAgICAgIHJldHVybiB0eXBlb2Ygc2hvdWxkQmxvY2sgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/ICEhc2hvdWxkQmxvY2soYXJncylcbiAgICAgICAgOiAhIXNob3VsZEJsb2NrO1xuICAgIH0sXG4gICAgW3Nob3VsZEJsb2NrXVxuICApO1xuXG4gIGxldCBibG9ja2VyID0gcm91dGVyLmdldEJsb2NrZXIoYmxvY2tlcktleSwgYmxvY2tlckZ1bmN0aW9uKTtcblxuICAvLyBDbGVhbnVwIG9uIHVubW91bnRcbiAgUmVhY3QudXNlRWZmZWN0KFxuICAgICgpID0+ICgpID0+IHJvdXRlci5kZWxldGVCbG9ja2VyKGJsb2NrZXJLZXkpLFxuICAgIFtyb3V0ZXIsIGJsb2NrZXJLZXldXG4gICk7XG5cbiAgcmV0dXJuIGJsb2NrZXI7XG59XG5cbmNvbnN0IGFscmVhZHlXYXJuZWQ6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5pbmdPbmNlKGtleTogc3RyaW5nLCBjb25kOiBib29sZWFuLCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgaWYgKCFjb25kICYmICFhbHJlYWR5V2FybmVkW2tleV0pIHtcbiAgICBhbHJlYWR5V2FybmVkW2tleV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsIG1lc3NhZ2UpO1xuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHtcbiAgVHJhY2tlZFByb21pc2UsXG4gIEluaXRpYWxFbnRyeSxcbiAgTG9jYXRpb24sXG4gIE1lbW9yeUhpc3RvcnksXG4gIFJvdXRlciBhcyBSZW1peFJvdXRlcixcbiAgUm91dGVyU3RhdGUsXG4gIFRvLFxufSBmcm9tIFwiQHJlbWl4LXJ1bi9yb3V0ZXJcIjtcbmltcG9ydCB7XG4gIEFjdGlvbiBhcyBOYXZpZ2F0aW9uVHlwZSxcbiAgQWJvcnRlZERlZmVycmVkRXJyb3IsXG4gIGNyZWF0ZU1lbW9yeUhpc3RvcnksXG4gIGludmFyaWFudCxcbiAgcGFyc2VQYXRoLFxuICBzdHJpcEJhc2VuYW1lLFxuICB3YXJuaW5nLFxufSBmcm9tIFwiQHJlbWl4LXJ1bi9yb3V0ZXJcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbSB9IGZyb20gXCIuL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW1cIjtcblxuaW1wb3J0IHR5cGUge1xuICBEYXRhUm91dGVPYmplY3QsXG4gIEluZGV4Um91dGVPYmplY3QsXG4gIFJvdXRlTWF0Y2gsXG4gIFJvdXRlT2JqZWN0LFxuICBOYXZpZ2F0b3IsXG4gIE5vbkluZGV4Um91dGVPYmplY3QsXG4gIFJlbGF0aXZlUm91dGluZ1R5cGUsXG59IGZyb20gXCIuL2NvbnRleHRcIjtcbmltcG9ydCB7XG4gIExvY2F0aW9uQ29udGV4dCxcbiAgTmF2aWdhdGlvbkNvbnRleHQsXG4gIERhdGFSb3V0ZXJDb250ZXh0LFxuICBEYXRhUm91dGVyU3RhdGVDb250ZXh0LFxuICBBd2FpdENvbnRleHQsXG59IGZyb20gXCIuL2NvbnRleHRcIjtcbmltcG9ydCB7XG4gIHVzZUFzeW5jVmFsdWUsXG4gIHVzZUluUm91dGVyQ29udGV4dCxcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU91dGxldCxcbiAgdXNlUm91dGVzLFxuICBfcmVuZGVyTWF0Y2hlcyxcbn0gZnJvbSBcIi4vaG9va3NcIjtcblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJQcm92aWRlclByb3BzIHtcbiAgZmFsbGJhY2tFbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlO1xuICByb3V0ZXI6IFJlbWl4Um91dGVyO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVtaXggUm91dGVyIGluc3RhbmNlLCByZW5kZXIgdGhlIGFwcHJvcHJpYXRlIFVJXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZXJQcm92aWRlcih7XG4gIGZhbGxiYWNrRWxlbWVudCxcbiAgcm91dGVyLFxufTogUm91dGVyUHJvdmlkZXJQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB7XG4gIC8vIFN5bmMgcm91dGVyIHN0YXRlIHRvIG91ciBjb21wb25lbnQgc3RhdGUgdG8gZm9yY2UgcmUtcmVuZGVyc1xuICBsZXQgc3RhdGU6IFJvdXRlclN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmVTaGltKFxuICAgIHJvdXRlci5zdWJzY3JpYmUsXG4gICAgKCkgPT4gcm91dGVyLnN0YXRlLFxuICAgIC8vIFdlIGhhdmUgdG8gcHJvdmlkZSB0aGlzIHNvIFJlYWN0QDE4IGRvZXNuJ3QgY29tcGxhaW4gZHVyaW5nIGh5ZHJhdGlvbixcbiAgICAvLyBidXQgd2UgcGFzcyBvdXIgc2VyaWFsaXplZCBoeWRyYXRpb24gZGF0YSBpbnRvIHRoZSByb3V0ZXIgc28gc3RhdGUgaGVyZVxuICAgIC8vIGlzIGFscmVhZHkgc3luY2VkIHdpdGggd2hhdCB0aGUgc2VydmVyIHNhd1xuICAgICgpID0+IHJvdXRlci5zdGF0ZVxuICApO1xuXG4gIGxldCBuYXZpZ2F0b3IgPSBSZWFjdC51c2VNZW1vKCgpOiBOYXZpZ2F0b3IgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVIcmVmOiByb3V0ZXIuY3JlYXRlSHJlZixcbiAgICAgIGVuY29kZUxvY2F0aW9uOiByb3V0ZXIuZW5jb2RlTG9jYXRpb24sXG4gICAgICBnbzogKG4pID0+IHJvdXRlci5uYXZpZ2F0ZShuKSxcbiAgICAgIHB1c2g6ICh0bywgc3RhdGUsIG9wdHMpID0+XG4gICAgICAgIHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cz8ucHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICB9KSxcbiAgICAgIHJlcGxhY2U6ICh0bywgc3RhdGUsIG9wdHMpID0+XG4gICAgICAgIHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzPy5wcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIH0pLFxuICAgIH07XG4gIH0sIFtyb3V0ZXJdKTtcblxuICBsZXQgYmFzZW5hbWUgPSByb3V0ZXIuYmFzZW5hbWUgfHwgXCIvXCI7XG5cbiAgLy8gVGhlIGZyYWdtZW50IGFuZCB7bnVsbH0gaGVyZSBhcmUgaW1wb3J0YW50ISAgV2UgbmVlZCB0aGVtIHRvIGtlZXAgUmVhY3QgMTgnc1xuICAvLyB1c2VJZCBoYXBweSB3aGVuIHdlIGFyZSBzZXJ2ZXItcmVuZGVyaW5nIHNpbmNlIHdlIG1heSBoYXZlIGEgPHNjcmlwdD4gaGVyZVxuICAvLyBjb250YWluaW5nIHRoZSBoeWRyYXRlZCBzZXJ2ZXItc2lkZSBzdGF0aWNDb250ZXh0IChmcm9tIFN0YXRpY1JvdXRlclByb3ZpZGVyKS5cbiAgLy8gdXNlSWQgcmVsaWVzIG9uIHRoZSBjb21wb25lbnQgdHJlZSBzdHJ1Y3R1cmUgdG8gZ2VuZXJhdGUgZGV0ZXJtaW5pc3RpYyBpZCdzXG4gIC8vIHNvIHdlIG5lZWQgdG8gZW5zdXJlIGl0IHJlbWFpbnMgdGhlIHNhbWUgb24gdGhlIGNsaWVudCBldmVuIHRob3VnaFxuICAvLyB3ZSBkb24ndCBuZWVkIHRoZSA8c2NyaXB0PiB0YWdcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPERhdGFSb3V0ZXJDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgIHZhbHVlPXt7XG4gICAgICAgICAgcm91dGVyLFxuICAgICAgICAgIG5hdmlnYXRvcixcbiAgICAgICAgICBzdGF0aWM6IGZhbHNlLFxuICAgICAgICAgIC8vIERvIHdlIG5lZWQgdGhpcz9cbiAgICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgPERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3N0YXRlfT5cbiAgICAgICAgICA8Um91dGVyXG4gICAgICAgICAgICBiYXNlbmFtZT17cm91dGVyLmJhc2VuYW1lfVxuICAgICAgICAgICAgbG9jYXRpb249e3JvdXRlci5zdGF0ZS5sb2NhdGlvbn1cbiAgICAgICAgICAgIG5hdmlnYXRpb25UeXBlPXtyb3V0ZXIuc3RhdGUuaGlzdG9yeUFjdGlvbn1cbiAgICAgICAgICAgIG5hdmlnYXRvcj17bmF2aWdhdG9yfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtyb3V0ZXIuc3RhdGUuaW5pdGlhbGl6ZWQgPyA8Um91dGVzIC8+IDogZmFsbGJhY2tFbGVtZW50fVxuICAgICAgICAgIDwvUm91dGVyPlxuICAgICAgICA8L0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXI+XG4gICAgICA8L0RhdGFSb3V0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAge251bGx9XG4gICAgPC8+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVtb3J5Um91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGluaXRpYWxFbnRyaWVzPzogSW5pdGlhbEVudHJ5W107XG4gIGluaXRpYWxJbmRleD86IG51bWJlcjtcbn1cblxuLyoqXG4gKiBBIDxSb3V0ZXI+IHRoYXQgc3RvcmVzIGFsbCBlbnRyaWVzIGluIG1lbW9yeS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlci1jb21wb25lbnRzL21lbW9yeS1yb3V0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1lbW9yeVJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgaW5pdGlhbEVudHJpZXMsXG4gIGluaXRpYWxJbmRleCxcbn06IE1lbW9yeVJvdXRlclByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWY8TWVtb3J5SGlzdG9yeT4oKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlTWVtb3J5SGlzdG9yeSh7XG4gICAgICBpbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxJbmRleCxcbiAgICAgIHY1Q29tcGF0OiB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLFxuICB9KTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlclxuICAgICAgYmFzZW5hbWU9e2Jhc2VuYW1lfVxuICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmFjdGlvbn1cbiAgICAgIG5hdmlnYXRvcj17aGlzdG9yeX1cbiAgICAvPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hdmlnYXRlUHJvcHMge1xuICB0bzogVG87XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbiAgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlO1xufVxuXG4vKipcbiAqIENoYW5nZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogTm90ZTogVGhpcyBBUEkgaXMgbW9zdGx5IHVzZWZ1bCBpbiBSZWFjdC5Db21wb25lbnQgc3ViY2xhc3NlcyB0aGF0IGFyZSBub3RcbiAqIGFibGUgdG8gdXNlIGhvb2tzLiBJbiBmdW5jdGlvbmFsIGNvbXBvbmVudHMsIHdlIHJlY29tbWVuZCB5b3UgdXNlIHRoZVxuICogYHVzZU5hdmlnYXRlYCBob29rIGluc3RlYWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9jb21wb25lbnRzL25hdmlnYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBOYXZpZ2F0ZSh7XG4gIHRvLFxuICByZXBsYWNlLFxuICBzdGF0ZSxcbiAgcmVsYXRpdmUsXG59OiBOYXZpZ2F0ZVByb3BzKTogbnVsbCB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZlxuICAgIC8vIHRoZSByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYDxOYXZpZ2F0ZT4gbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgd2FybmluZyhcbiAgICAhUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCkuc3RhdGljLFxuICAgIGA8TmF2aWdhdGU+IG11c3Qgbm90IGJlIHVzZWQgb24gdGhlIGluaXRpYWwgcmVuZGVyIGluIGEgPFN0YXRpY1JvdXRlcj4uIGAgK1xuICAgICAgYFRoaXMgaXMgYSBuby1vcCwgYnV0IHlvdSBzaG91bGQgbW9kaWZ5IHlvdXIgY29kZSBzbyB0aGUgPE5hdmlnYXRlPiBpcyBgICtcbiAgICAgIGBvbmx5IGV2ZXIgcmVuZGVyZWQgaW4gcmVzcG9uc2UgdG8gc29tZSB1c2VyIGludGVyYWN0aW9uIG9yIHN0YXRlIGNoYW5nZS5gXG4gICk7XG5cbiAgbGV0IGRhdGFSb3V0ZXJTdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBBdm9pZCBraWNraW5nIG9mZiBtdWx0aXBsZSBuYXZpZ2F0aW9ucyBpZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGFcbiAgICAvLyBkYXRhLXJvdXRlciBuYXZpZ2F0aW9uLCBzaW5jZSBjb21wb25lbnRzIGdldCByZS1yZW5kZXJlZCB3aGVuIHdlIGVudGVyXG4gICAgLy8gYSBzdWJtaXR0aW5nL2xvYWRpbmcgc3RhdGVcbiAgICBpZiAoZGF0YVJvdXRlclN0YXRlICYmIGRhdGFSb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlICE9PSBcImlkbGVcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBuYXZpZ2F0ZSh0bywgeyByZXBsYWNlLCBzdGF0ZSwgcmVsYXRpdmUgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE91dGxldFByb3BzIHtcbiAgY29udGV4dD86IHVua25vd247XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgY2hpbGQgcm91dGUncyBlbGVtZW50LCBpZiB0aGVyZSBpcyBvbmUuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9jb21wb25lbnRzL291dGxldFxuICovXG5leHBvcnQgZnVuY3Rpb24gT3V0bGV0KHByb3BzOiBPdXRsZXRQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICByZXR1cm4gdXNlT3V0bGV0KHByb3BzLmNvbnRleHQpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhdGhSb3V0ZVByb3BzIHtcbiAgY2FzZVNlbnNpdGl2ZT86IE5vbkluZGV4Um91dGVPYmplY3RbXCJjYXNlU2Vuc2l0aXZlXCJdO1xuICBwYXRoPzogTm9uSW5kZXhSb3V0ZU9iamVjdFtcInBhdGhcIl07XG4gIGlkPzogTm9uSW5kZXhSb3V0ZU9iamVjdFtcImlkXCJdO1xuICBsb2FkZXI/OiBOb25JbmRleFJvdXRlT2JqZWN0W1wibG9hZGVyXCJdO1xuICBhY3Rpb24/OiBOb25JbmRleFJvdXRlT2JqZWN0W1wiYWN0aW9uXCJdO1xuICBoYXNFcnJvckJvdW5kYXJ5PzogTm9uSW5kZXhSb3V0ZU9iamVjdFtcImhhc0Vycm9yQm91bmRhcnlcIl07XG4gIHNob3VsZFJldmFsaWRhdGU/OiBOb25JbmRleFJvdXRlT2JqZWN0W1wic2hvdWxkUmV2YWxpZGF0ZVwiXTtcbiAgaGFuZGxlPzogTm9uSW5kZXhSb3V0ZU9iamVjdFtcImhhbmRsZVwiXTtcbiAgaW5kZXg/OiBmYWxzZTtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBlcnJvckVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExheW91dFJvdXRlUHJvcHMgZXh0ZW5kcyBQYXRoUm91dGVQcm9wcyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGV4Um91dGVQcm9wcyB7XG4gIGNhc2VTZW5zaXRpdmU/OiBJbmRleFJvdXRlT2JqZWN0W1wiY2FzZVNlbnNpdGl2ZVwiXTtcbiAgcGF0aD86IEluZGV4Um91dGVPYmplY3RbXCJwYXRoXCJdO1xuICBpZD86IEluZGV4Um91dGVPYmplY3RbXCJpZFwiXTtcbiAgbG9hZGVyPzogSW5kZXhSb3V0ZU9iamVjdFtcImxvYWRlclwiXTtcbiAgYWN0aW9uPzogSW5kZXhSb3V0ZU9iamVjdFtcImFjdGlvblwiXTtcbiAgaGFzRXJyb3JCb3VuZGFyeT86IEluZGV4Um91dGVPYmplY3RbXCJoYXNFcnJvckJvdW5kYXJ5XCJdO1xuICBzaG91bGRSZXZhbGlkYXRlPzogSW5kZXhSb3V0ZU9iamVjdFtcInNob3VsZFJldmFsaWRhdGVcIl07XG4gIGhhbmRsZT86IEluZGV4Um91dGVPYmplY3RbXCJoYW5kbGVcIl07XG4gIGluZGV4OiB0cnVlO1xuICBjaGlsZHJlbj86IHVuZGVmaW5lZDtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG4gIGVycm9yRWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG59XG5cbmV4cG9ydCB0eXBlIFJvdXRlUHJvcHMgPSBQYXRoUm91dGVQcm9wcyB8IExheW91dFJvdXRlUHJvcHMgfCBJbmRleFJvdXRlUHJvcHM7XG5cbi8qKlxuICogRGVjbGFyZXMgYW4gZWxlbWVudCB0aGF0IHNob3VsZCBiZSByZW5kZXJlZCBhdCBhIGNlcnRhaW4gVVJMIHBhdGguXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9jb21wb25lbnRzL3JvdXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZShfcHJvcHM6IFJvdXRlUHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIGZhbHNlLFxuICAgIGBBIDxSb3V0ZT4gaXMgb25seSBldmVyIHRvIGJlIHVzZWQgYXMgdGhlIGNoaWxkIG9mIDxSb3V0ZXM+IGVsZW1lbnQsIGAgK1xuICAgICAgYG5ldmVyIHJlbmRlcmVkIGRpcmVjdGx5LiBQbGVhc2Ugd3JhcCB5b3VyIDxSb3V0ZT4gaW4gYSA8Um91dGVzPi5gXG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGxvY2F0aW9uOiBQYXJ0aWFsPExvY2F0aW9uPiB8IHN0cmluZztcbiAgbmF2aWdhdGlvblR5cGU/OiBOYXZpZ2F0aW9uVHlwZTtcbiAgbmF2aWdhdG9yOiBOYXZpZ2F0b3I7XG4gIHN0YXRpYz86IGJvb2xlYW47XG59XG5cbi8qKlxuICogUHJvdmlkZXMgbG9jYXRpb24gY29udGV4dCBmb3IgdGhlIHJlc3Qgb2YgdGhlIGFwcC5cbiAqXG4gKiBOb3RlOiBZb3UgdXN1YWxseSB3b24ndCByZW5kZXIgYSA8Um91dGVyPiBkaXJlY3RseS4gSW5zdGVhZCwgeW91J2xsIHJlbmRlciBhXG4gKiByb3V0ZXIgdGhhdCBpcyBtb3JlIHNwZWNpZmljIHRvIHlvdXIgZW52aXJvbm1lbnQgc3VjaCBhcyBhIDxCcm93c2VyUm91dGVyPlxuICogaW4gd2ViIGJyb3dzZXJzIG9yIGEgPFN0YXRpY1JvdXRlcj4gZm9yIHNlcnZlciByZW5kZXJpbmcuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXItY29tcG9uZW50cy9yb3V0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlcih7XG4gIGJhc2VuYW1lOiBiYXNlbmFtZVByb3AgPSBcIi9cIixcbiAgY2hpbGRyZW4gPSBudWxsLFxuICBsb2NhdGlvbjogbG9jYXRpb25Qcm9wLFxuICBuYXZpZ2F0aW9uVHlwZSA9IE5hdmlnYXRpb25UeXBlLlBvcCxcbiAgbmF2aWdhdG9yLFxuICBzdGF0aWM6IHN0YXRpY1Byb3AgPSBmYWxzZSxcbn06IFJvdXRlclByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIGludmFyaWFudChcbiAgICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgYFlvdSBjYW5ub3QgcmVuZGVyIGEgPFJvdXRlcj4gaW5zaWRlIGFub3RoZXIgPFJvdXRlcj4uYCArXG4gICAgICBgIFlvdSBzaG91bGQgbmV2ZXIgaGF2ZSBtb3JlIHRoYW4gb25lIGluIHlvdXIgYXBwLmBcbiAgKTtcblxuICAvLyBQcmVzZXJ2ZSB0cmFpbGluZyBzbGFzaGVzIG9uIGJhc2VuYW1lLCBzbyB3ZSBjYW4gbGV0IHRoZSB1c2VyIGNvbnRyb2xcbiAgLy8gdGhlIGVuZm9yY2VtZW50IG9mIHRyYWlsaW5nIHNsYXNoZXMgdGhyb3VnaG91dCB0aGUgYXBwXG4gIGxldCBiYXNlbmFtZSA9IGJhc2VuYW1lUHJvcC5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcbiAgbGV0IG5hdmlnYXRpb25Db250ZXh0ID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiAoeyBiYXNlbmFtZSwgbmF2aWdhdG9yLCBzdGF0aWM6IHN0YXRpY1Byb3AgfSksXG4gICAgW2Jhc2VuYW1lLCBuYXZpZ2F0b3IsIHN0YXRpY1Byb3BdXG4gICk7XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvblByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsb2NhdGlvblByb3AgPSBwYXJzZVBhdGgobG9jYXRpb25Qcm9wKTtcbiAgfVxuXG4gIGxldCB7XG4gICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiLFxuICAgIHN0YXRlID0gbnVsbCxcbiAgICBrZXkgPSBcImRlZmF1bHRcIixcbiAgfSA9IGxvY2F0aW9uUHJvcDtcblxuICBsZXQgbG9jYXRpb24gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgdHJhaWxpbmdQYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUocGF0aG5hbWUsIGJhc2VuYW1lKTtcblxuICAgIGlmICh0cmFpbGluZ1BhdGhuYW1lID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYXRobmFtZTogdHJhaWxpbmdQYXRobmFtZSxcbiAgICAgIHNlYXJjaCxcbiAgICAgIGhhc2gsXG4gICAgICBzdGF0ZSxcbiAgICAgIGtleSxcbiAgICB9O1xuICB9LCBbYmFzZW5hbWUsIHBhdGhuYW1lLCBzZWFyY2gsIGhhc2gsIHN0YXRlLCBrZXldKTtcblxuICB3YXJuaW5nKFxuICAgIGxvY2F0aW9uICE9IG51bGwsXG4gICAgYDxSb3V0ZXIgYmFzZW5hbWU9XCIke2Jhc2VuYW1lfVwiPiBpcyBub3QgYWJsZSB0byBtYXRjaCB0aGUgVVJMIGAgK1xuICAgICAgYFwiJHtwYXRobmFtZX0ke3NlYXJjaH0ke2hhc2h9XCIgYmVjYXVzZSBpdCBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBgICtcbiAgICAgIGBiYXNlbmFtZSwgc28gdGhlIDxSb3V0ZXI+IHdvbid0IHJlbmRlciBhbnl0aGluZy5gXG4gICk7XG5cbiAgaWYgKGxvY2F0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPE5hdmlnYXRpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXtuYXZpZ2F0aW9uQ29udGV4dH0+XG4gICAgICA8TG9jYXRpb25Db250ZXh0LlByb3ZpZGVyXG4gICAgICAgIGNoaWxkcmVuPXtjaGlsZHJlbn1cbiAgICAgICAgdmFsdWU9e3sgbG9jYXRpb24sIG5hdmlnYXRpb25UeXBlIH19XG4gICAgICAvPlxuICAgIDwvTmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVzUHJvcHMge1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgbG9jYXRpb24/OiBQYXJ0aWFsPExvY2F0aW9uPiB8IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgYSBuZXN0ZWQgdHJlZSBvZiA8Um91dGU+IGVsZW1lbnRzIHRoYXQgcmVuZGVycyB0aGUgYnJhbmNoXG4gKiB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvcm91dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZXMoe1xuICBjaGlsZHJlbixcbiAgbG9jYXRpb24sXG59OiBSb3V0ZXNQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgLy8gV2hlbiBpbiBhIERhdGFSb3V0ZXJDb250ZXh0IF93aXRob3V0XyBjaGlsZHJlbiwgd2UgdXNlIHRoZSByb3V0ZXIgcm91dGVzXG4gIC8vIGRpcmVjdGx5LiAgSWYgd2UgaGF2ZSBjaGlsZHJlbiwgdGhlbiB3ZSdyZSBpbiBhIGRlc2NlbmRhbnQgdHJlZSBhbmQgd2VcbiAgLy8gbmVlZCB0byB1c2UgY2hpbGQgcm91dGVzLlxuICBsZXQgcm91dGVzID1cbiAgICBkYXRhUm91dGVyQ29udGV4dCAmJiAhY2hpbGRyZW5cbiAgICAgID8gKGRhdGFSb3V0ZXJDb250ZXh0LnJvdXRlci5yb3V0ZXMgYXMgRGF0YVJvdXRlT2JqZWN0W10pXG4gICAgICA6IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbik7XG4gIHJldHVybiB1c2VSb3V0ZXMocm91dGVzLCBsb2NhdGlvbik7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXdhaXRSZXNvbHZlUmVuZGVyRnVuY3Rpb24ge1xuICAoZGF0YTogQXdhaXRlZDxhbnk+KTogUmVhY3QuUmVhY3ROb2RlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF3YWl0UHJvcHMge1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIHwgQXdhaXRSZXNvbHZlUmVuZGVyRnVuY3Rpb247XG4gIGVycm9yRWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgcmVzb2x2ZTogVHJhY2tlZFByb21pc2UgfCBhbnk7XG59XG5cbi8qKlxuICogQ29tcG9uZW50IHRvIHVzZSBmb3IgcmVuZGVyaW5nIGxhemlseSBsb2FkZWQgZGF0YSBmcm9tIHJldHVybmluZyBkZWZlcigpXG4gKiBpbiBhIGxvYWRlciBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gQXdhaXQoeyBjaGlsZHJlbiwgZXJyb3JFbGVtZW50LCByZXNvbHZlIH06IEF3YWl0UHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8QXdhaXRFcnJvckJvdW5kYXJ5IHJlc29sdmU9e3Jlc29sdmV9IGVycm9yRWxlbWVudD17ZXJyb3JFbGVtZW50fT5cbiAgICAgIDxSZXNvbHZlQXdhaXQ+e2NoaWxkcmVufTwvUmVzb2x2ZUF3YWl0PlxuICAgIDwvQXdhaXRFcnJvckJvdW5kYXJ5PlxuICApO1xufVxuXG50eXBlIEF3YWl0RXJyb3JCb3VuZGFyeVByb3BzID0gUmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48e1xuICBlcnJvckVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIHJlc29sdmU6IFRyYWNrZWRQcm9taXNlIHwgYW55O1xufT47XG5cbnR5cGUgQXdhaXRFcnJvckJvdW5kYXJ5U3RhdGUgPSB7XG4gIGVycm9yOiBhbnk7XG59O1xuXG5lbnVtIEF3YWl0UmVuZGVyU3RhdHVzIHtcbiAgcGVuZGluZyxcbiAgc3VjY2VzcyxcbiAgZXJyb3IsXG59XG5cbmNvbnN0IG5ldmVyU2V0dGxlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgoKSA9PiB7fSk7XG5cbmNsYXNzIEF3YWl0RXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxcbiAgQXdhaXRFcnJvckJvdW5kYXJ5UHJvcHMsXG4gIEF3YWl0RXJyb3JCb3VuZGFyeVN0YXRlXG4+IHtcbiAgY29uc3RydWN0b3IocHJvcHM6IEF3YWl0RXJyb3JCb3VuZGFyeVByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7IGVycm9yOiBudWxsIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yOiBhbnkpIHtcbiAgICByZXR1cm4geyBlcnJvciB9O1xuICB9XG5cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3I6IGFueSwgZXJyb3JJbmZvOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCI8QXdhaXQ+IGNhdWdodCB0aGUgZm9sbG93aW5nIGVycm9yIGR1cmluZyByZW5kZXJcIixcbiAgICAgIGVycm9yLFxuICAgICAgZXJyb3JJbmZvXG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBjaGlsZHJlbiwgZXJyb3JFbGVtZW50LCByZXNvbHZlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgbGV0IHByb21pc2U6IFRyYWNrZWRQcm9taXNlIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IHN0YXR1czogQXdhaXRSZW5kZXJTdGF0dXMgPSBBd2FpdFJlbmRlclN0YXR1cy5wZW5kaW5nO1xuXG4gICAgaWYgKCEocmVzb2x2ZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAvLyBEaWRuJ3QgZ2V0IGEgcHJvbWlzZSAtIHByb3ZpZGUgYXMgYSByZXNvbHZlZCBwcm9taXNlXG4gICAgICBzdGF0dXMgPSBBd2FpdFJlbmRlclN0YXR1cy5zdWNjZXNzO1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwgeyBnZXQ6ICgpID0+IHRydWUgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZGF0YVwiLCB7IGdldDogKCkgPT4gcmVzb2x2ZSB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgIC8vIENhdWdodCBhIHJlbmRlciBlcnJvciwgcHJvdmlkZSBpdCBhcyBhIHJlamVjdGVkIHByb21pc2VcbiAgICAgIHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yO1xuICAgICAgbGV0IHJlbmRlckVycm9yID0gdGhpcy5zdGF0ZS5lcnJvcjtcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlamVjdCgpLmNhdGNoKCgpID0+IHt9KTsgLy8gQXZvaWQgdW5oYW5kbGVkIHJlamVjdGlvbiB3YXJuaW5nc1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwgeyBnZXQ6ICgpID0+IHRydWUgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwgeyBnZXQ6ICgpID0+IHJlbmRlckVycm9yIH0pO1xuICAgIH0gZWxzZSBpZiAoKHJlc29sdmUgYXMgVHJhY2tlZFByb21pc2UpLl90cmFja2VkKSB7XG4gICAgICAvLyBBbHJlYWR5IHRyYWNrZWQgcHJvbWlzZSAtIGNoZWNrIGNvbnRlbnRzXG4gICAgICBwcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgIHN0YXR1cyA9XG4gICAgICAgIHByb21pc2UuX2Vycm9yICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yXG4gICAgICAgICAgOiBwcm9taXNlLl9kYXRhICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IEF3YWl0UmVuZGVyU3RhdHVzLnN1Y2Nlc3NcbiAgICAgICAgICA6IEF3YWl0UmVuZGVyU3RhdHVzLnBlbmRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJhdyAodW50cmFja2VkKSBwcm9taXNlIC0gdHJhY2sgaXRcbiAgICAgIHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLnBlbmRpbmc7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfdHJhY2tlZFwiLCB7IGdldDogKCkgPT4gdHJ1ZSB9KTtcbiAgICAgIHByb21pc2UgPSByZXNvbHZlLnRoZW4oXG4gICAgICAgIChkYXRhOiBhbnkpID0+XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX2RhdGFcIiwgeyBnZXQ6ICgpID0+IGRhdGEgfSksXG4gICAgICAgIChlcnJvcjogYW55KSA9PlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl9lcnJvclwiLCB7IGdldDogKCkgPT4gZXJyb3IgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvciAmJlxuICAgICAgcHJvbWlzZS5fZXJyb3IgaW5zdGFuY2VvZiBBYm9ydGVkRGVmZXJyZWRFcnJvclxuICAgICkge1xuICAgICAgLy8gRnJlZXplIHRoZSBVSSBieSB0aHJvd2luZyBhIG5ldmVyIHJlc29sdmVkIHByb21pc2VcbiAgICAgIHRocm93IG5ldmVyU2V0dGxlZFByb21pc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3IgJiYgIWVycm9yRWxlbWVudCkge1xuICAgICAgLy8gTm8gZXJyb3JFbGVtZW50LCB0aHJvdyB0byB0aGUgbmVhcmVzdCByb3V0ZS1sZXZlbCBlcnJvciBib3VuZGFyeVxuICAgICAgdGhyb3cgcHJvbWlzZS5fZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3IpIHtcbiAgICAgIC8vIFJlbmRlciB2aWEgb3VyIGVycm9yRWxlbWVudFxuICAgICAgcmV0dXJuIDxBd2FpdENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3Byb21pc2V9IGNoaWxkcmVuPXtlcnJvckVsZW1lbnR9IC8+O1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IEF3YWl0UmVuZGVyU3RhdHVzLnN1Y2Nlc3MpIHtcbiAgICAgIC8vIFJlbmRlciBjaGlsZHJlbiB3aXRoIHJlc29sdmVkIHZhbHVlXG4gICAgICByZXR1cm4gPEF3YWl0Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17cHJvbWlzZX0gY2hpbGRyZW49e2NoaWxkcmVufSAvPjtcbiAgICB9XG5cbiAgICAvLyBUaHJvdyB0byB0aGUgc3VzcGVuc2UgYm91bmRhcnlcbiAgICB0aHJvdyBwcm9taXNlO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEluZGlyZWN0aW9uIHRvIGxldmVyYWdlIHVzZUFzeW5jVmFsdWUgZm9yIGEgcmVuZGVyLXByb3AgQVBJIG9uIDxBd2FpdD5cbiAqL1xuZnVuY3Rpb24gUmVzb2x2ZUF3YWl0KHtcbiAgY2hpbGRyZW4sXG59OiB7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfCBBd2FpdFJlc29sdmVSZW5kZXJGdW5jdGlvbjtcbn0pIHtcbiAgbGV0IGRhdGEgPSB1c2VBc3luY1ZhbHVlKCk7XG4gIGxldCB0b1JlbmRlciA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4oZGF0YSkgOiBjaGlsZHJlbjtcbiAgcmV0dXJuIDw+e3RvUmVuZGVyfTwvPjtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVVRJTFNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDcmVhdGVzIGEgcm91dGUgY29uZmlnIGZyb20gYSBSZWFjdCBcImNoaWxkcmVuXCIgb2JqZWN0LCB3aGljaCBpcyB1c3VhbGx5XG4gKiBlaXRoZXIgYSBgPFJvdXRlPmAgZWxlbWVudCBvciBhbiBhcnJheSBvZiB0aGVtLiBVc2VkIGludGVybmFsbHkgYnlcbiAqIGA8Um91dGVzPmAgdG8gY3JlYXRlIGEgcm91dGUgY29uZmlnIGZyb20gaXRzIGNoaWxkcmVuLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvY3JlYXRlLXJvdXRlcy1mcm9tLWNoaWxkcmVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oXG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUsXG4gIHBhcmVudFBhdGg6IG51bWJlcltdID0gW11cbik6IFJvdXRlT2JqZWN0W10ge1xuICBsZXQgcm91dGVzOiBSb3V0ZU9iamVjdFtdID0gW107XG5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgLy8gSWdub3JlIG5vbi1lbGVtZW50cy4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIG1vcmUgZWFzaWx5IGlubGluZVxuICAgICAgLy8gY29uZGl0aW9uYWxzIGluIHRoZWlyIHJvdXRlIGNvbmZpZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSZWFjdC5GcmFnbWVudCkge1xuICAgICAgLy8gVHJhbnNwYXJlbnRseSBzdXBwb3J0IFJlYWN0LkZyYWdtZW50IGFuZCBpdHMgY2hpbGRyZW4uXG4gICAgICByb3V0ZXMucHVzaC5hcHBseShcbiAgICAgICAgcm91dGVzLFxuICAgICAgICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcGFyZW50UGF0aClcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52YXJpYW50KFxuICAgICAgZWxlbWVudC50eXBlID09PSBSb3V0ZSxcbiAgICAgIGBbJHtcbiAgICAgICAgdHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVsZW1lbnQudHlwZSA6IGVsZW1lbnQudHlwZS5uYW1lXG4gICAgICB9XSBpcyBub3QgYSA8Um91dGU+IGNvbXBvbmVudC4gQWxsIGNvbXBvbmVudCBjaGlsZHJlbiBvZiA8Um91dGVzPiBtdXN0IGJlIGEgPFJvdXRlPiBvciA8UmVhY3QuRnJhZ21lbnQ+YFxuICAgICk7XG5cbiAgICBpbnZhcmlhbnQoXG4gICAgICAhZWxlbWVudC5wcm9wcy5pbmRleCB8fCAhZWxlbWVudC5wcm9wcy5jaGlsZHJlbixcbiAgICAgIFwiQW4gaW5kZXggcm91dGUgY2Fubm90IGhhdmUgY2hpbGQgcm91dGVzLlwiXG4gICAgKTtcblxuICAgIGxldCB0cmVlUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBpbmRleF07XG4gICAgbGV0IHJvdXRlOiBSb3V0ZU9iamVjdCA9IHtcbiAgICAgIGlkOiBlbGVtZW50LnByb3BzLmlkIHx8IHRyZWVQYXRoLmpvaW4oXCItXCIpLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogZWxlbWVudC5wcm9wcy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgZWxlbWVudDogZWxlbWVudC5wcm9wcy5lbGVtZW50LFxuICAgICAgaW5kZXg6IGVsZW1lbnQucHJvcHMuaW5kZXgsXG4gICAgICBwYXRoOiBlbGVtZW50LnByb3BzLnBhdGgsXG4gICAgICBsb2FkZXI6IGVsZW1lbnQucHJvcHMubG9hZGVyLFxuICAgICAgYWN0aW9uOiBlbGVtZW50LnByb3BzLmFjdGlvbixcbiAgICAgIGVycm9yRWxlbWVudDogZWxlbWVudC5wcm9wcy5lcnJvckVsZW1lbnQsXG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OiBlbGVtZW50LnByb3BzLmVycm9yRWxlbWVudCAhPSBudWxsLFxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogZWxlbWVudC5wcm9wcy5zaG91bGRSZXZhbGlkYXRlLFxuICAgICAgaGFuZGxlOiBlbGVtZW50LnByb3BzLmhhbmRsZSxcbiAgICB9O1xuXG4gICAgaWYgKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgIHJvdXRlLmNoaWxkcmVuID0gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKFxuICAgICAgICBlbGVtZW50LnByb3BzLmNoaWxkcmVuLFxuICAgICAgICB0cmVlUGF0aFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByb3V0ZXMucHVzaChyb3V0ZSk7XG4gIH0pO1xuXG4gIHJldHVybiByb3V0ZXM7XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgcmVzdWx0IG9mIGBtYXRjaFJvdXRlcygpYCBpbnRvIGEgUmVhY3QgZWxlbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlck1hdGNoZXMoXG4gIG1hdGNoZXM6IFJvdXRlTWF0Y2hbXSB8IG51bGxcbik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICByZXR1cm4gX3JlbmRlck1hdGNoZXMobWF0Y2hlcyk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFdhbGsgdGhlIHJvdXRlIHRyZWUgYW5kIGFkZCBoYXNFcnJvckJvdW5kYXJ5IGlmIGl0J3Mgbm90IHByb3ZpZGVkLCBzbyB0aGF0XG4gKiB1c2VycyBwcm92aWRpbmcgbWFudWFsIHJvdXRlIGFycmF5cyBjYW4ganVzdCBzcGVjaWZ5IGVycm9yRWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5oYW5jZU1hbnVhbFJvdXRlT2JqZWN0cyhcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFtdXG4pOiBSb3V0ZU9iamVjdFtdIHtcbiAgcmV0dXJuIHJvdXRlcy5tYXAoKHJvdXRlKSA9PiB7XG4gICAgbGV0IHJvdXRlQ2xvbmUgPSB7IC4uLnJvdXRlIH07XG4gICAgaWYgKHJvdXRlQ2xvbmUuaGFzRXJyb3JCb3VuZGFyeSA9PSBudWxsKSB7XG4gICAgICByb3V0ZUNsb25lLmhhc0Vycm9yQm91bmRhcnkgPSByb3V0ZUNsb25lLmVycm9yRWxlbWVudCAhPSBudWxsO1xuICAgIH1cbiAgICBpZiAocm91dGVDbG9uZS5jaGlsZHJlbikge1xuICAgICAgcm91dGVDbG9uZS5jaGlsZHJlbiA9IGVuaGFuY2VNYW51YWxSb3V0ZU9iamVjdHMocm91dGVDbG9uZS5jaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiByb3V0ZUNsb25lO1xuICB9KTtcbn1cbiIsImltcG9ydCB0eXBlIHtcbiAgQWN0aW9uRnVuY3Rpb24sXG4gIEFjdGlvbkZ1bmN0aW9uQXJncyxcbiAgQmxvY2tlcixcbiAgQmxvY2tlckZ1bmN0aW9uLFxuICBGZXRjaGVyLFxuICBIeWRyYXRpb25TdGF0ZSxcbiAgSnNvbkZ1bmN0aW9uLFxuICBMb2FkZXJGdW5jdGlvbixcbiAgTG9hZGVyRnVuY3Rpb25BcmdzLFxuICBMb2NhdGlvbixcbiAgTmF2aWdhdGlvbixcbiAgUGFyYW1zLFxuICBQYXJhbVBhcnNlS2V5LFxuICBQYXRoLFxuICBQYXRoTWF0Y2gsXG4gIFBhdGhQYXR0ZXJuLFxuICBSZWRpcmVjdEZ1bmN0aW9uLFxuICBSb3V0ZXIgYXMgUmVtaXhSb3V0ZXIsXG4gIFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbixcbiAgVG8sXG4gIEluaXRpYWxFbnRyeSxcbn0gZnJvbSBcIkByZW1peC1ydW4vcm91dGVyXCI7XG5pbXBvcnQge1xuICBBYm9ydGVkRGVmZXJyZWRFcnJvcixcbiAgQWN0aW9uIGFzIE5hdmlnYXRpb25UeXBlLFxuICBjcmVhdGVNZW1vcnlIaXN0b3J5LFxuICBjcmVhdGVQYXRoLFxuICBjcmVhdGVSb3V0ZXIsXG4gIGRlZmVyLFxuICBnZW5lcmF0ZVBhdGgsXG4gIGlzUm91dGVFcnJvclJlc3BvbnNlLFxuICBqc29uLFxuICBtYXRjaFBhdGgsXG4gIG1hdGNoUm91dGVzLFxuICBwYXJzZVBhdGgsXG4gIHJlZGlyZWN0LFxuICByZXNvbHZlUGF0aCxcbn0gZnJvbSBcIkByZW1peC1ydW4vcm91dGVyXCI7XG5cbmltcG9ydCB0eXBlIHtcbiAgQXdhaXRQcm9wcyxcbiAgTWVtb3J5Um91dGVyUHJvcHMsXG4gIE5hdmlnYXRlUHJvcHMsXG4gIE91dGxldFByb3BzLFxuICBSb3V0ZVByb3BzLFxuICBQYXRoUm91dGVQcm9wcyxcbiAgTGF5b3V0Um91dGVQcm9wcyxcbiAgSW5kZXhSb3V0ZVByb3BzLFxuICBSb3V0ZXJQcm9wcyxcbiAgUm91dGVzUHJvcHMsXG4gIFJvdXRlclByb3ZpZGVyUHJvcHMsXG59IGZyb20gXCIuL2xpYi9jb21wb25lbnRzXCI7XG5pbXBvcnQge1xuICBlbmhhbmNlTWFudWFsUm91dGVPYmplY3RzLFxuICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sXG4gIHJlbmRlck1hdGNoZXMsXG4gIEF3YWl0LFxuICBNZW1vcnlSb3V0ZXIsXG4gIE5hdmlnYXRlLFxuICBPdXRsZXQsXG4gIFJvdXRlLFxuICBSb3V0ZXIsXG4gIFJvdXRlclByb3ZpZGVyLFxuICBSb3V0ZXMsXG59IGZyb20gXCIuL2xpYi9jb21wb25lbnRzXCI7XG5pbXBvcnQgdHlwZSB7XG4gIERhdGFSb3V0ZU1hdGNoLFxuICBEYXRhUm91dGVPYmplY3QsXG4gIEluZGV4Um91dGVPYmplY3QsXG4gIE5hdmlnYXRvcixcbiAgTmF2aWdhdGVPcHRpb25zLFxuICBOb25JbmRleFJvdXRlT2JqZWN0LFxuICBSb3V0ZU1hdGNoLFxuICBSb3V0ZU9iamVjdCxcbiAgUmVsYXRpdmVSb3V0aW5nVHlwZSxcbn0gZnJvbSBcIi4vbGliL2NvbnRleHRcIjtcbmltcG9ydCB7XG4gIERhdGFSb3V0ZXJDb250ZXh0LFxuICBEYXRhUm91dGVyU3RhdGVDb250ZXh0LFxuICBMb2NhdGlvbkNvbnRleHQsXG4gIE5hdmlnYXRpb25Db250ZXh0LFxuICBSb3V0ZUNvbnRleHQsXG59IGZyb20gXCIuL2xpYi9jb250ZXh0XCI7XG5pbXBvcnQgdHlwZSB7IE5hdmlnYXRlRnVuY3Rpb24gfSBmcm9tIFwiLi9saWIvaG9va3NcIjtcbmltcG9ydCB7XG4gIHVzZUJsb2NrZXIsXG4gIHVzZUhyZWYsXG4gIHVzZUluUm91dGVyQ29udGV4dCxcbiAgdXNlTG9jYXRpb24sXG4gIHVzZU1hdGNoLFxuICB1c2VOYXZpZ2F0aW9uVHlwZSxcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU91dGxldCxcbiAgdXNlT3V0bGV0Q29udGV4dCxcbiAgdXNlUGFyYW1zLFxuICB1c2VSZXNvbHZlZFBhdGgsXG4gIHVzZVJvdXRlcyxcbiAgdXNlQWN0aW9uRGF0YSxcbiAgdXNlQXN5bmNFcnJvcixcbiAgdXNlQXN5bmNWYWx1ZSxcbiAgdXNlTG9hZGVyRGF0YSxcbiAgdXNlTWF0Y2hlcyxcbiAgdXNlTmF2aWdhdGlvbixcbiAgdXNlUmV2YWxpZGF0b3IsXG4gIHVzZVJvdXRlRXJyb3IsXG4gIHVzZVJvdXRlTG9hZGVyRGF0YSxcbn0gZnJvbSBcIi4vbGliL2hvb2tzXCI7XG5cbi8vIEV4cG9ydGVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYnV0IG5vdCBiZWluZyB1c2VkIGludGVybmFsbHkgYW55bW9yZVxudHlwZSBIYXNoID0gc3RyaW5nO1xudHlwZSBQYXRobmFtZSA9IHN0cmluZztcbnR5cGUgU2VhcmNoID0gc3RyaW5nO1xuXG4vLyBFeHBvc2UgcmVhY3Qtcm91dGVyIHB1YmxpYyBBUElcbmV4cG9ydCB0eXBlIHtcbiAgQWN0aW9uRnVuY3Rpb24sXG4gIEFjdGlvbkZ1bmN0aW9uQXJncyxcbiAgQXdhaXRQcm9wcyxcbiAgQmxvY2tlciBhcyB1bnN0YWJsZV9CbG9ja2VyLFxuICBCbG9ja2VyRnVuY3Rpb24gYXMgdW5zdGFibGVfQmxvY2tlckZ1bmN0aW9uLFxuICBEYXRhUm91dGVNYXRjaCxcbiAgRGF0YVJvdXRlT2JqZWN0LFxuICBGZXRjaGVyLFxuICBIYXNoLFxuICBJbmRleFJvdXRlT2JqZWN0LFxuICBJbmRleFJvdXRlUHJvcHMsXG4gIEpzb25GdW5jdGlvbixcbiAgTGF5b3V0Um91dGVQcm9wcyxcbiAgTG9hZGVyRnVuY3Rpb24sXG4gIExvYWRlckZ1bmN0aW9uQXJncyxcbiAgTG9jYXRpb24sXG4gIE1lbW9yeVJvdXRlclByb3BzLFxuICBOYXZpZ2F0ZUZ1bmN0aW9uLFxuICBOYXZpZ2F0ZU9wdGlvbnMsXG4gIE5hdmlnYXRlUHJvcHMsXG4gIE5hdmlnYXRpb24sXG4gIE5hdmlnYXRvcixcbiAgTm9uSW5kZXhSb3V0ZU9iamVjdCxcbiAgT3V0bGV0UHJvcHMsXG4gIFBhcmFtcyxcbiAgUGFyYW1QYXJzZUtleSxcbiAgUGF0aCxcbiAgUGF0aE1hdGNoLFxuICBQYXRobmFtZSxcbiAgUGF0aFBhdHRlcm4sXG4gIFBhdGhSb3V0ZVByb3BzLFxuICBSZWRpcmVjdEZ1bmN0aW9uLFxuICBSZWxhdGl2ZVJvdXRpbmdUeXBlLFxuICBSb3V0ZU1hdGNoLFxuICBSb3V0ZU9iamVjdCxcbiAgUm91dGVQcm9wcyxcbiAgUm91dGVyUHJvcHMsXG4gIFJvdXRlclByb3ZpZGVyUHJvcHMsXG4gIFJvdXRlc1Byb3BzLFxuICBTZWFyY2gsXG4gIFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbixcbiAgVG8sXG59O1xuZXhwb3J0IHtcbiAgQWJvcnRlZERlZmVycmVkRXJyb3IsXG4gIEF3YWl0LFxuICBNZW1vcnlSb3V0ZXIsXG4gIE5hdmlnYXRlLFxuICBOYXZpZ2F0aW9uVHlwZSxcbiAgT3V0bGV0LFxuICBSb3V0ZSxcbiAgUm91dGVyLFxuICBSb3V0ZXJQcm92aWRlcixcbiAgUm91dGVzLFxuICBjcmVhdGVQYXRoLFxuICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sXG4gIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiBhcyBjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMsXG4gIGRlZmVyLFxuICBpc1JvdXRlRXJyb3JSZXNwb25zZSxcbiAgZ2VuZXJhdGVQYXRoLFxuICBqc29uLFxuICBtYXRjaFBhdGgsXG4gIG1hdGNoUm91dGVzLFxuICBwYXJzZVBhdGgsXG4gIHJlZGlyZWN0LFxuICByZW5kZXJNYXRjaGVzLFxuICByZXNvbHZlUGF0aCxcbiAgdXNlQWN0aW9uRGF0YSxcbiAgdXNlQXN5bmNFcnJvcixcbiAgdXNlQXN5bmNWYWx1ZSxcbiAgdXNlQmxvY2tlciBhcyB1bnN0YWJsZV91c2VCbG9ja2VyLFxuICB1c2VIcmVmLFxuICB1c2VJblJvdXRlckNvbnRleHQsXG4gIHVzZUxvYWRlckRhdGEsXG4gIHVzZUxvY2F0aW9uLFxuICB1c2VNYXRjaCxcbiAgdXNlTWF0Y2hlcyxcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU5hdmlnYXRpb24sXG4gIHVzZU5hdmlnYXRpb25UeXBlLFxuICB1c2VPdXRsZXQsXG4gIHVzZU91dGxldENvbnRleHQsXG4gIHVzZVBhcmFtcyxcbiAgdXNlUmVzb2x2ZWRQYXRoLFxuICB1c2VSZXZhbGlkYXRvcixcbiAgdXNlUm91dGVFcnJvcixcbiAgdXNlUm91dGVMb2FkZXJEYXRhLFxuICB1c2VSb3V0ZXMsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWVtb3J5Um91dGVyKFxuICByb3V0ZXM6IFJvdXRlT2JqZWN0W10sXG4gIG9wdHM/OiB7XG4gICAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gICAgaHlkcmF0aW9uRGF0YT86IEh5ZHJhdGlvblN0YXRlO1xuICAgIGluaXRpYWxFbnRyaWVzPzogSW5pdGlhbEVudHJ5W107XG4gICAgaW5pdGlhbEluZGV4PzogbnVtYmVyO1xuICB9XG4pOiBSZW1peFJvdXRlciB7XG4gIHJldHVybiBjcmVhdGVSb3V0ZXIoe1xuICAgIGJhc2VuYW1lOiBvcHRzPy5iYXNlbmFtZSxcbiAgICBoaXN0b3J5OiBjcmVhdGVNZW1vcnlIaXN0b3J5KHtcbiAgICAgIGluaXRpYWxFbnRyaWVzOiBvcHRzPy5pbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxJbmRleDogb3B0cz8uaW5pdGlhbEluZGV4LFxuICAgIH0pLFxuICAgIGh5ZHJhdGlvbkRhdGE6IG9wdHM/Lmh5ZHJhdGlvbkRhdGEsXG4gICAgcm91dGVzOiBlbmhhbmNlTWFudWFsUm91dGVPYmplY3RzKHJvdXRlcyksXG4gIH0pLmluaXRpYWxpemUoKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gREFOR0VSISBQTEVBU0UgUkVBRCBNRSFcbi8vIFdlIHByb3ZpZGUgdGhlc2UgZXhwb3J0cyBhcyBhbiBlc2NhcGUgaGF0Y2ggaW4gdGhlIGV2ZW50IHRoYXQgeW91IG5lZWQgYW55XG4vLyByb3V0aW5nIGRhdGEgdGhhdCB3ZSBkb24ndCBwcm92aWRlIGFuIGV4cGxpY2l0IEFQSSBmb3IuIFdpdGggdGhhdCBzYWlkLCB3ZVxuLy8gd2FudCB0byBjb3ZlciB5b3VyIHVzZSBjYXNlIGlmIHdlIGNhbiwgc28gaWYgeW91IGZlZWwgdGhlIG5lZWQgdG8gdXNlIHRoZXNlXG4vLyB3ZSB3YW50IHRvIGhlYXIgZnJvbSB5b3UuIExldCB1cyBrbm93IHdoYXQgeW91J3JlIGJ1aWxkaW5nIGFuZCB3ZSdsbCBkbyBvdXJcbi8vIGJlc3QgdG8gbWFrZSBzdXJlIHdlIGNhbiBzdXBwb3J0IHlvdSFcbi8vXG4vLyBXZSBjb25zaWRlciB0aGVzZSBleHBvcnRzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBhbmQgZG8gbm90IGd1YXJhbnRlZVxuLy8gYWdhaW5zdCBhbnkgYnJlYWtpbmcgY2hhbmdlcywgcmVnYXJkbGVzcyBvZiB0aGUgc2VtdmVyIHJlbGVhc2UuIFVzZSB3aXRoXG4vLyBleHRyZW1lIGNhdXRpb24gYW5kIG9ubHkgaWYgeW91IHVuZGVyc3RhbmQgdGhlIGNvbnNlcXVlbmNlcy4gR29kc3BlZWQuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCB7XG4gIE5hdmlnYXRpb25Db250ZXh0IGFzIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCxcbiAgTG9jYXRpb25Db250ZXh0IGFzIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQsXG4gIFJvdXRlQ29udGV4dCBhcyBVTlNBRkVfUm91dGVDb250ZXh0LFxuICBEYXRhUm91dGVyQ29udGV4dCBhcyBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQsXG4gIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgYXMgVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsXG4gIGVuaGFuY2VNYW51YWxSb3V0ZU9iamVjdHMgYXMgVU5TQUZFX2VuaGFuY2VNYW51YWxSb3V0ZU9iamVjdHMsXG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0U7XG5cbntcbiAgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1vZHVsZS5yZWZlcmVuY2UnKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoICFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG4vLyBldmVuIHdpdGggdGhlIHByb2QgdHJhbnNmb3JtLiBUaGlzIG1lYW5zIHRoYXQganN4REVWIGlzIHB1cmVseVxuLy8gb3B0LWluIGJlaGF2aW9yIGZvciBiZXR0ZXIgbWVzc2FnZXMgYnV0IHRoYXQgd2Ugd29uJ3Qgc3RvcFxuLy8gZ2l2aW5nIHlvdSB3YXJuaW5ncyBpZiB5b3UgdXNlIHByb2R1Y3Rpb24gYXBpcy5cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25TdGF0aWModHlwZSwgcHJvcHMsIGtleSkge1xuICB7XG4gICAgcmV0dXJuIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWModHlwZSwgcHJvcHMsIGtleSkge1xuICB7XG4gICAgcmV0dXJuIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGZhbHNlKTtcbiAgfVxufVxuXG52YXIganN4ID0gIGpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyA7IC8vIHdlIG1heSB3YW50IHRvIHNwZWNpYWwgY2FzZSBqc3hzIGludGVybmFsbHkgdG8gdGFrZSBhZHZhbnRhZ2Ugb2Ygc3RhdGljIGNoaWxkcmVuLlxuLy8gZm9yIG5vdyB3ZSBjYW4gc2hpcCBpZGVudGljYWwgcHJvZCBmdW5jdGlvbnNcblxudmFyIGpzeHMgPSAganN4V2l0aFZhbGlkYXRpb25TdGF0aWMgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4ID0ganN4O1xuZXhwb3J0cy5qc3hzID0ganN4cztcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgZGVmYXVsdCB7XCJIZWFkZXJcIjpcIllZTXJhUnNtX2oxZFVpeXZFTGszXCIsXCJIZWFkZXJUaXRsZVwiOlwibDFtVFNsNUJ6T0k3a3pGbVVRT2FcIn07IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgZGVmYXVsdCB7XCJIZWFkZXJMaW5rXCI6XCJDSUExWkx2a0hURDZwWFozWEhiY1wifTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCBkZWZhdWx0IHtcIlRvZG9MaXN0XCI6XCJidWt3WFk3WVhfNmFObHdnOHF5a1wifTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCBkZWZhdWx0IHtcIlN0YXRzQm9hcmRDb250YWluZXJcIjpcImNfUDhMZnM4eW1UcEtPakk3eVI0XCIsXCJUaXRsZVwiOlwia09CbXNGYjhWMDZZYXU5eF82d2RcIixcIlN0YXRzQm9hcmRcIjpcInMxaERnRUFsc2JlbjF4ejJsblFlXCIsXCJCb2FyZFRpdGxlXCI6XCJOMm9LY2FaVlJYcW5CSUJGOU85VlwifTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCwgRnJhZ21lbnQgYXMgX0ZyYWdtZW50LCBqc3hzIGFzIF9qc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgXCIuL3N0eWxlcy9fYmFzZS5zY3NzXCI7XG5pbXBvcnQgSGVhZGVyIGZyb20gXCIuL19wYXJ0aWFscy9IZWFkZXIvSGVhZGVyXCI7XG5pbXBvcnQgeyBBcHBTdGF0ZVByb3ZpZGVyIH0gZnJvbSBcIi4vaG9jL3VzZUFwcFN0YXRlXCI7XG5pbXBvcnQgeyBSb3V0ZSwgUm91dGVzIH0gZnJvbSBcInJlYWN0LXJvdXRlci1kb21cIjtcbmltcG9ydCB7IHdpdGhTdXNwZW5zZSB9IGZyb20gXCIuL2hvYy93aXRoU3VzcGVuc2VcIjtcbmltcG9ydCB7IFBhZ2VMYXlvdXQgfSBmcm9tIFwiLi9jb21wb25lbnRzL1BhZ2VMYXlvdXQvUGFnZUxheW91dFwiO1xuaW1wb3J0IFN0YXRzQ29udGFpbmVyIGZyb20gXCIuL2NvbnRhaW5lcnMvU3RhdHNDb250YWluZXJcIjtcbnZhciBBc3luY1RvZG9Db250YWluZXIgPSB3aXRoU3VzcGVuc2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gaW1wb3J0KFwiLi9jb250YWluZXJzL1RvZG9Db250YWluZXJcIik7IH0pO1xudmFyIEFzeW5jRWRpdFRvZG9JdGVtID0gd2l0aFN1c3BlbnNlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGltcG9ydChcIi4vY29udGFpbmVycy9Ub2RvQ29udGFpbmVyL0VkaXRUb2RvSXRlbVwiKTsgfSk7XG52YXIgQXN5bmNTdGF0c0NvbnRhaW5lciA9IHdpdGhTdXNwZW5zZShmdW5jdGlvbiAoKSB7IHJldHVybiBpbXBvcnQoXCIuL2NvbnRhaW5lcnMvU3RhdHNDb250YWluZXJcIik7IH0pO1xudmFyIEFzeW5jQWJvdXRDb250YWluZXIgPSB3aXRoU3VzcGVuc2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gaW1wb3J0KFwiLi9jb250YWluZXJzL0Fib3V0Q29udGFpbmVyXCIpOyB9KTtcbmZ1bmN0aW9uIEFwcCgpIHtcbiAgICByZXR1cm4gKF9qc3goX0ZyYWdtZW50LCB7IGNoaWxkcmVuOiBfanN4cyhBcHBTdGF0ZVByb3ZpZGVyLCB7IGNoaWxkcmVuOiBbX2pzeChIZWFkZXIsIHt9KSwgX2pzeChQYWdlTGF5b3V0LCB7IGNoaWxkcmVuOiBfanN4cyhSb3V0ZXMsIHsgY2hpbGRyZW46IFtfanN4KFJvdXRlLCB7IHBhdGg6IFwiL1wiLCBlbGVtZW50OiBfanN4cyhfRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtBc3luY1RvZG9Db250YWluZXIsIEFzeW5jRWRpdFRvZG9JdGVtXSB9KSB9KSwgX2pzeChSb3V0ZSwgeyBwYXRoOiBcIi9zdGF0c1wiLCBlbGVtZW50OiBfanN4KFN0YXRzQ29udGFpbmVyLCB7fSkgfSksIF9qc3goUm91dGUsIHsgcGF0aDogXCIvYWJvdXRcIiwgZWxlbWVudDogQXN5bmNBYm91dENvbnRhaW5lciB9KV0gfSkgfSldIH0pIH0pKTtcbn1cbmV4cG9ydCBkZWZhdWx0IEFwcDtcbiIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5pbXBvcnQgeyBqc3ggYXMgX2pzeCwganN4cyBhcyBfanN4cyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IGNsYXNzZXMgZnJvbSBcIi4vSGVhZGVyLm1vZHVsZS5zY3NzXCI7XG5pbXBvcnQgSGVhZGVyTGluayBmcm9tIFwiLi9IZWFkZXJMaW5rL0hlYWRlckxpbmtcIjtcbnZhciBIZWFkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChfanN4cyhcImhlYWRlclwiLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogY2xhc3Nlcy5IZWFkZXIgfSwgeyBjaGlsZHJlbjogW19qc3goXCJoMVwiLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogY2xhc3Nlcy5IZWFkZXJUaXRsZSB9LCB7IGNoaWxkcmVuOiBcIlRvZG8gUHJvIE1heCBBcHBcIiB9KSksIF9qc3hzKFwibmF2XCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBcIm0tYXV0b1wiIH0sIHsgY2hpbGRyZW46IFtfanN4KEhlYWRlckxpbmssIF9fYXNzaWduKHsgdXJsOiBcIi9cIiB9LCB7IGNoaWxkcmVuOiBcIkhvbWVcIiB9KSksIF9qc3goSGVhZGVyTGluaywgX19hc3NpZ24oeyB1cmw6IFwiL3N0YXRzXCIgfSwgeyBjaGlsZHJlbjogXCJTdGF0c1wiIH0pKSwgX2pzeChIZWFkZXJMaW5rLCBfX2Fzc2lnbih7IHVybDogXCIvYWJvdXRcIiB9LCB7IGNoaWxkcmVuOiBcIkFib3V0XCIgfSkpXSB9KSldIH0pKSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgSGVhZGVyO1xuIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBMaW5rIH0gZnJvbSBcInJlYWN0LXJvdXRlci1kb21cIjtcbmltcG9ydCBjbGFzc2VzIGZyb20gXCIuL0hlYWRlckxpbmsubW9kdWxlLnNjc3NcIjtcbnZhciBIZWFkZXJMaW5rID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHVybCA9IF9hLnVybCwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcbiAgICByZXR1cm4gKF9qc3goTGluaywgX19hc3NpZ24oeyB0bzogXCJcIi5jb25jYXQodXJsKSwgY2xhc3NOYW1lOiBjbGFzc2VzLkhlYWRlckxpbmsgKyBcIiBtci0yIG1yLTJcIiB9LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSkpO1xufTtcbmV4cG9ydCBkZWZhdWx0IEhlYWRlckxpbms7XG4iLCJ2YXIgSHR0cEFkYXB0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHR0cEFkYXB0ZXIoX2EpIHtcbiAgICAgICAgdmFyIGJhc2VVcmwgPSBfYS5iYXNlVXJsO1xuICAgICAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICAgIH1cbiAgICBIdHRwQWRhcHRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybCwgcGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMgPT09IHZvaWQgMCkgeyBwYXJhbXMgPSB7IHF1ZXJ5OiB7fSB9OyB9XG4gICAgICAgIHZhciBxdWVyeSA9IE9iamVjdC5rZXlzKChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucXVlcnkpIHx8IHt9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHZhciBfYTsgcmV0dXJuIFwiXCIuY29uY2F0KGtleSwgXCI9XCIpLmNvbmNhdCgoX2EgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmFtcy5xdWVyeSwga2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbHVlKTsgfSlcbiAgICAgICAgICAgIC5qb2luKFwiJlwiKTtcbiAgICAgICAgcmV0dXJuIGZldGNoKHRoaXMuYmFzZVVybCArIHVybCArIFwiP1wiICsgcXVlcnkpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEh0dHBBZGFwdGVyLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKHVybCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gZmV0Y2godGhpcy5iYXNlVXJsICsgdXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gcmVzcG9uc2UuanNvbigpOyB9KTtcbiAgICB9O1xuICAgIEh0dHBBZGFwdGVyLnByb3RvdHlwZS5wYXRjaCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoKHRoaXMuYmFzZVVybCArIHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiByZXNwb25zZS5qc29uKCk7IH0pO1xuICAgIH07XG4gICAgSHR0cEFkYXB0ZXIucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICh1cmwsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoKHRoaXMuYmFzZVVybCArIHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gcmVzcG9uc2UuanNvbigpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBIdHRwQWRhcHRlcjtcbn0oKSk7XG5leHBvcnQgeyBIdHRwQWRhcHRlciB9O1xuIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgY2xhc3NlcyBmcm9tIFwiLi9QYWdlTGF5b3V0Lm1vZHVsZS5zY3NzXCI7XG5leHBvcnQgdmFyIFBhZ2VMYXlvdXQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcbiAgICByZXR1cm4gKF9qc3goXCJkaXZcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzZXMuVG9kb0xpc3QgKyBcIiBtci1hdXRvIG1sLWF1dG9cIiB9LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSkpO1xufTtcbiIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5pbXBvcnQgeyBqc3ggYXMgX2pzeCwganN4cyBhcyBfanN4cyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IGNsYXNzZXMgZnJvbSBcIi4vU3RhdHNDb250YWluZXIubW9kdWxlLnNjc3NcIjtcbmV4cG9ydCB2YXIgU3RhdHNDb250YWluZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgdG9kb1NlcnZpY2UgPSBfYS50b2RvU2VydmljZTtcbiAgICB2YXIgX2IgPSB1c2VTdGF0ZShbXSksIHRvZG9zID0gX2JbMF0sIHNldFRvZG9zID0gX2JbMV07XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdG9kb1NlcnZpY2UuZ2V0QWxsVG9kb3MoKS50aGVuKGZ1bmN0aW9uICh0b2Rvcykge1xuICAgICAgICAgICAgc2V0VG9kb3ModG9kb3MpO1xuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIGRvbmVUb2RvcyA9IHRvZG9zLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGlzRG9uZSA9IF9hLmlzRG9uZTtcbiAgICAgICAgcmV0dXJuIGlzRG9uZTtcbiAgICB9KTtcbiAgICB2YXIgbm90RG9uZVRvZG9zID0gdG9kb3MuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgaXNEb25lID0gX2EuaXNEb25lO1xuICAgICAgICByZXR1cm4gIWlzRG9uZTtcbiAgICB9KTtcbiAgICByZXR1cm4gKF9qc3hzKFwiZGl2XCIsIHsgY2hpbGRyZW46IFtfanN4KFwiaDJcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzZXMuVGl0bGUgfSwgeyBjaGlsZHJlbjogXCJTdGF0c1wiIH0pKSwgX2pzeHMoXCJkaXZcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzZXMuU3RhdHNCb2FyZENvbnRhaW5lciB9LCB7IGNoaWxkcmVuOiBbX2pzeHMoXCJkaXZcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzZXMuU3RhdHNCb2FyZCB9LCB7IGNoaWxkcmVuOiBbX2pzeHMoXCJoM1wiLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogY2xhc3Nlcy5TdGF0c1RpdGxlIH0sIHsgY2hpbGRyZW46IFtcIkRvbmUgVG9kbyAoXCIsIGRvbmVUb2Rvcy5sZW5ndGgsIFwiKVwiXSB9KSksIF9qc3goXCJ1bFwiLCB7IGNoaWxkcmVuOiBkb25lVG9kb3MubWFwKGZ1bmN0aW9uICh0b2RvKSB7IHJldHVybiAoX2pzeChcImxpXCIsIHsgY2hpbGRyZW46IHRvZG8udGFzayB9LCB0b2RvLmlkKSk7IH0pIH0pXSB9KSksIF9qc3hzKFwiZGl2XCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc2VzLlN0YXRzQm9hcmQgfSwgeyBjaGlsZHJlbjogW19qc3hzKFwiaDNcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzZXMuU3RhdHNUaXRsZSB9LCB7IGNoaWxkcmVuOiBbXCJOb3QgRG9uZSAoXCIsIG5vdERvbmVUb2Rvcy5sZW5ndGgsIFwiKVwiXSB9KSksIF9qc3goXCJ1bFwiLCB7IGNoaWxkcmVuOiBub3REb25lVG9kb3MubWFwKGZ1bmN0aW9uICh0b2RvKSB7IHJldHVybiAoX2pzeChcImxpXCIsIHsgY2hpbGRyZW46IHRvZG8udGFzayB9LCB0b2RvLmlkKSk7IH0pIH0pXSB9KSldIH0pKV0gfSkpO1xufTtcbiIsImltcG9ydCB7IGRlcGVuZGVuY2llcyB9IGZyb20gXCIuLi8uLi9kZXBlbmRlbmNpZXNcIjtcbmltcG9ydCB7IHdpdGhEZXBlbmRlbmN5IH0gZnJvbSBcIi4uLy4uL2hvYy93aXRoRGVwZW5kZW5jaWVzXCI7XG5pbXBvcnQgeyBTdGF0c0NvbnRhaW5lciB9IGZyb20gXCIuL1N0YXRzQ29udGFpbmVyXCI7XG5leHBvcnQgZGVmYXVsdCB3aXRoRGVwZW5kZW5jeShTdGF0c0NvbnRhaW5lciwge1xuICAgIHRvZG9TZXJ2aWNlOiBkZXBlbmRlbmNpZXMuVG9kb1NlcnZpY2UsXG59KTtcbiIsImltcG9ydCB7IEh0dHBBZGFwdGVyIH0gZnJvbSBcIi4vYWRhcHRlcnMvSHR0cEFkYXB0ZXJcIjtcbmltcG9ydCB7IFRvZG9TZXJ2aWNlIH0gZnJvbSBcIi4vc2VydmljZXMvVG9kby5zZXJ2aWNlXCI7XG52YXIgRGVwZW5kZW5jeUNvbnRhaW5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXBlbmRlbmN5Q29udGFpbmVyKCkge1xuICAgICAgICB0aGlzLl9kZXBlbmRlbmN5ID0ge307XG4gICAgfVxuICAgIERlcGVuZGVuY3lDb250YWluZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChrZXksIGRlcGVuZGVuY3kpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuX2RlcGVuZGVuY3ksIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IGRlcGVuZGVuY3ksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGVwZW5kZW5jeUNvbnRhaW5lci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMuX2RlcGVuZGVuY3ksIGtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBEZXBlbmRlbmN5Q29udGFpbmVyO1xufSgpKTtcbnZhciBodHRwQWRhcHRlciA9IG5ldyBIdHRwQWRhcHRlcih7IGJhc2VVcmw6IFwiaHR0cDovL2xvY2FsaG9zdDozMDAxXCIgfSk7XG52YXIgdG9kb1NlcnZpY2UgPSBuZXcgVG9kb1NlcnZpY2UoaHR0cEFkYXB0ZXIpO1xudmFyIGRlcGVuZGVuY2llcyA9IHtcbiAgICBUb2RvU2VydmljZTogU3ltYm9sKFwiVG9kb1NlcnZpY2VcIiksXG59O1xudmFyIGNvbnRhaW5lciA9IG5ldyBEZXBlbmRlbmN5Q29udGFpbmVyKCk7XG5jb250YWluZXIuYWRkKGRlcGVuZGVuY2llcy5Ub2RvU2VydmljZSwgdG9kb1NlcnZpY2UpO1xuZXhwb3J0IHsgZGVwZW5kZW5jaWVzLCBjb250YWluZXIgfTtcbiIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5pbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUNvbnRleHQsIH0gZnJvbSBcInJlYWN0XCI7XG5leHBvcnQgdmFyIEFwcFNhdGUgPSBjcmVhdGVDb250ZXh0KHtcbiAgICBhcHBTdGF0ZTogeyBlZGl0VG9kb0lkOiAtMSwgaXNEcmF3ZXJPcGVuOiBmYWxzZSB9LFxuICAgIHNldEFwcFN0YXRlOiBmdW5jdGlvbiAoKSB7IH0sXG59KTtcbmV4cG9ydCB2YXIgdXNlQXBwU3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1c2VDb250ZXh0KEFwcFNhdGUpOyB9O1xuZXhwb3J0IHZhciBBcHBTdGF0ZVByb3ZpZGVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XG4gICAgdmFyIF9iID0gdXNlU3RhdGUoe1xuICAgICAgICBlZGl0VG9kb0lkOiAtMSxcbiAgICAgICAgaXNEcmF3ZXJPcGVuOiBmYWxzZSxcbiAgICB9KSwgYXBwU3RhdGUgPSBfYlswXSwgc2V0QXBwU3RhdGUgPSBfYlsxXTtcbiAgICByZXR1cm4gKF9qc3goQXBwU2F0ZS5Qcm92aWRlciwgX19hc3NpZ24oeyB2YWx1ZTogeyBhcHBTdGF0ZTogYXBwU3RhdGUsIHNldEFwcFN0YXRlOiBzZXRBcHBTdGF0ZSB9IH0sIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pKSk7XG59O1xuIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBjb250YWluZXIgfSBmcm9tIFwiLi4vZGVwZW5kZW5jaWVzXCI7XG5leHBvcnQgdmFyIHdpdGhEZXBlbmRlbmN5ID0gZnVuY3Rpb24gKENvbXBvbmVudCwgZGVwZW5kZW5jaWVzKSB7XG4gICAgdmFyIHJlc29sdmVkRGVwZW5kZW5jaWVzID0ge307XG4gICAgT2JqZWN0LmtleXMoZGVwZW5kZW5jaWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBkZXBlbmRlbmN5S2V5ID0gKF9hID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZXBlbmRlbmNpZXMsIHByb3BOYW1lKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbHVlO1xuICAgICAgICB2YXIgZGVwZW5kZW5jeSA9IGNvbnRhaW5lci5nZXQoZGVwZW5kZW5jeUtleSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlZERlcGVuZGVuY2llcywgcHJvcE5hbWUsIHtcbiAgICAgICAgICAgIHZhbHVlOiBkZXBlbmRlbmN5LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKF9qc3goQ29tcG9uZW50LCBfX2Fzc2lnbih7fSwgcHJvcHMsIHJlc29sdmVkRGVwZW5kZW5jaWVzKSkpOyB9O1xufTtcbiIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5pbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IFJlYWN0LCB7IFN1c3BlbnNlIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgTG9hZGluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9qc3goXCJkaXZcIiwgeyBjaGlsZHJlbjogXCJMb2FkaW5nLi4uXCIgfSk7IH07XG5leHBvcnQgdmFyIHdpdGhTdXNwZW5zZSA9IGZ1bmN0aW9uIChDb21wb25lbnRJbXBvcnRDYWxsYmFjaykge1xuICAgIHZhciBBc3luY0NvbXBvbmVudCA9IFJlYWN0LmxhenkoQ29tcG9uZW50SW1wb3J0Q2FsbGJhY2spO1xuICAgIHJldHVybiAoX2pzeChTdXNwZW5zZSwgX19hc3NpZ24oeyBmYWxsYmFjazogX2pzeChMb2FkaW5nLCB7fSkgfSwgeyBjaGlsZHJlbjogX2pzeChBc3luY0NvbXBvbmVudCwge30pIH0pKSk7XG59O1xuIiwidmFyIFRvZG9TZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvZG9TZXJ2aWNlKGh0dHBBZGFwdGVyKSB7XG4gICAgICAgIHRoaXMuaHR0cCA9IGh0dHBBZGFwdGVyO1xuICAgIH1cbiAgICBUb2RvU2VydmljZS5wcm90b3R5cGUuZ2V0VG9kbyA9IGZ1bmN0aW9uICh0b2RvSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5nZXQoXCIvdG9kb3MvXCIgKyB0b2RvSWQpO1xuICAgIH07XG4gICAgVG9kb1NlcnZpY2UucHJvdG90eXBlLmdldEFsbFRvZG9zID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5odHRwLmdldChcIi90b2Rvc1wiLCBwYXJhbXMpO1xuICAgIH07XG4gICAgVG9kb1NlcnZpY2UucHJvdG90eXBlLmFkZFRvZG8gPSBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICByZXR1cm4gdGhpcy5odHRwLnBvc3QoXCIvdG9kb3NcIiwgeyB0b2RvOiB0YXNrIH0pO1xuICAgIH07XG4gICAgVG9kb1NlcnZpY2UucHJvdG90eXBlLnVwZGF0ZVRvZG8gPSBmdW5jdGlvbiAodG9kb0lkLCB0YXNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAucGF0Y2goXCIvdG9kb3MvXCIgKyB0b2RvSWQsIHRhc2spO1xuICAgIH07XG4gICAgVG9kb1NlcnZpY2UucHJvdG90eXBlLmRlbGV0ZVRvZG8gPSBmdW5jdGlvbiAodG9kb0lkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAuZGVsZXRlKFwiL3RvZG9zXCIsIHsgaWQ6IHRvZG9JZCB9KTtcbiAgICB9O1xuICAgIHJldHVybiBUb2RvU2VydmljZTtcbn0oKSk7XG5leHBvcnQgeyBUb2RvU2VydmljZSB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVhY3RcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwib3NcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicGF0aFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwcm9jZXNzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInR0eVwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1cmxcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXRpbFwiKTsiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbl9fd2VicGFja19yZXF1aXJlX18ubSA9IF9fd2VicGFja19tb2R1bGVzX187XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5mID0ge307XG4vLyBUaGlzIGZpbGUgY29udGFpbnMgb25seSB0aGUgZW50cnkgY2h1bmsuXG4vLyBUaGUgY2h1bmsgbG9hZGluZyBmdW5jdGlvbiBmb3IgYWRkaXRpb25hbCBjaHVua3Ncbl9fd2VicGFja19yZXF1aXJlX18uZSA9IChjaHVua0lkKSA9PiB7XG5cdHJldHVybiBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLmYpLnJlZHVjZSgocHJvbWlzZXMsIGtleSkgPT4ge1xuXHRcdF9fd2VicGFja19yZXF1aXJlX18uZltrZXldKGNodW5rSWQsIHByb21pc2VzKTtcblx0XHRyZXR1cm4gcHJvbWlzZXM7XG5cdH0sIFtdKSk7XG59OyIsIi8vIFRoaXMgZnVuY3Rpb24gYWxsb3cgdG8gcmVmZXJlbmNlIGFzeW5jIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy51ID0gKGNodW5rSWQpID0+IHtcblx0Ly8gcmV0dXJuIHVybCBmb3IgZmlsZW5hbWVzIGJhc2VkIG9uIHRlbXBsYXRlXG5cdHJldHVybiBcIlwiICsgY2h1bmtJZCArIFwiLmpzXCI7XG59OyIsIi8vIFRoaXMgZnVuY3Rpb24gYWxsb3cgdG8gcmVmZXJlbmNlIGFzeW5jIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5taW5pQ3NzRiA9IChjaHVua0lkKSA9PiB7XG5cdC8vIHJldHVybiB1cmwgZm9yIGZpbGVuYW1lcyBiYXNlZCBvbiB0ZW1wbGF0ZVxuXHRyZXR1cm4gXCJcIiArIGNodW5rSWQgKyBcIi5jc3NcIjtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL1wiOyIsImlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcbnZhciBjcmVhdGVTdHlsZXNoZWV0ID0gKGNodW5rSWQsIGZ1bGxocmVmLCBvbGRUYWcsIHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHR2YXIgbGlua1RhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGxpbmtUYWcucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cdGxpbmtUYWcudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0dmFyIG9uTGlua0NvbXBsZXRlID0gKGV2ZW50KSA9PiB7XG5cdFx0Ly8gYXZvaWQgbWVtIGxlYWtzLlxuXHRcdGxpbmtUYWcub25lcnJvciA9IGxpbmtUYWcub25sb2FkID0gbnVsbDtcblx0XHRpZiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnKSB7XG5cdFx0XHRyZXNvbHZlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBlcnJvclR5cGUgPSBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnID8gJ21pc3NpbmcnIDogZXZlbnQudHlwZSk7XG5cdFx0XHR2YXIgcmVhbEhyZWYgPSBldmVudCAmJiBldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0LmhyZWYgfHwgZnVsbGhyZWY7XG5cdFx0XHR2YXIgZXJyID0gbmV3IEVycm9yKFwiTG9hZGluZyBDU1MgY2h1bmsgXCIgKyBjaHVua0lkICsgXCIgZmFpbGVkLlxcbihcIiArIHJlYWxIcmVmICsgXCIpXCIpO1xuXHRcdFx0ZXJyLmNvZGUgPSBcIkNTU19DSFVOS19MT0FEX0ZBSUxFRFwiO1xuXHRcdFx0ZXJyLnR5cGUgPSBlcnJvclR5cGU7XG5cdFx0XHRlcnIucmVxdWVzdCA9IHJlYWxIcmVmO1xuXHRcdFx0bGlua1RhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpbmtUYWcpXG5cdFx0XHRyZWplY3QoZXJyKTtcblx0XHR9XG5cdH1cblx0bGlua1RhZy5vbmVycm9yID0gbGlua1RhZy5vbmxvYWQgPSBvbkxpbmtDb21wbGV0ZTtcblx0bGlua1RhZy5ocmVmID0gZnVsbGhyZWY7XG5cblx0aWYgKG9sZFRhZykge1xuXHRcdG9sZFRhZy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShsaW5rVGFnLCBvbGRUYWcubmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGlua1RhZyk7XG5cdH1cblx0cmV0dXJuIGxpbmtUYWc7XG59O1xudmFyIGZpbmRTdHlsZXNoZWV0ID0gKGhyZWYsIGZ1bGxocmVmKSA9PiB7XG5cdHZhciBleGlzdGluZ0xpbmtUYWdzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsaW5rXCIpO1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgZXhpc3RpbmdMaW5rVGFncy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciB0YWcgPSBleGlzdGluZ0xpbmtUYWdzW2ldO1xuXHRcdHZhciBkYXRhSHJlZiA9IHRhZy5nZXRBdHRyaWJ1dGUoXCJkYXRhLWhyZWZcIikgfHwgdGFnLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG5cdFx0aWYodGFnLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIgJiYgKGRhdGFIcmVmID09PSBocmVmIHx8IGRhdGFIcmVmID09PSBmdWxsaHJlZikpIHJldHVybiB0YWc7XG5cdH1cblx0dmFyIGV4aXN0aW5nU3R5bGVUYWdzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdHlsZVwiKTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IGV4aXN0aW5nU3R5bGVUYWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHRhZyA9IGV4aXN0aW5nU3R5bGVUYWdzW2ldO1xuXHRcdHZhciBkYXRhSHJlZiA9IHRhZy5nZXRBdHRyaWJ1dGUoXCJkYXRhLWhyZWZcIik7XG5cdFx0aWYoZGF0YUhyZWYgPT09IGhyZWYgfHwgZGF0YUhyZWYgPT09IGZ1bGxocmVmKSByZXR1cm4gdGFnO1xuXHR9XG59O1xudmFyIGxvYWRTdHlsZXNoZWV0ID0gKGNodW5rSWQpID0+IHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHR2YXIgaHJlZiA9IF9fd2VicGFja19yZXF1aXJlX18ubWluaUNzc0YoY2h1bmtJZCk7XG5cdFx0dmFyIGZ1bGxocmVmID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgaHJlZjtcblx0XHRpZihmaW5kU3R5bGVzaGVldChocmVmLCBmdWxsaHJlZikpIHJldHVybiByZXNvbHZlKCk7XG5cdFx0Y3JlYXRlU3R5bGVzaGVldChjaHVua0lkLCBmdWxsaHJlZiwgbnVsbCwgcmVzb2x2ZSwgcmVqZWN0KTtcblx0fSk7XG59XG4vLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIENTUyBjaHVua3NcbnZhciBpbnN0YWxsZWRDc3NDaHVua3MgPSB7XG5cdFwibWFpblwiOiAwXG59O1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmYubWluaUNzcyA9IChjaHVua0lkLCBwcm9taXNlcykgPT4ge1xuXHR2YXIgY3NzQ2h1bmtzID0ge1wic3JjX2NvbnRhaW5lcnNfVG9kb0NvbnRhaW5lcl9pbmRleF90c3hcIjoxLFwic3JjX2NvbnRhaW5lcnNfVG9kb0NvbnRhaW5lcl9FZGl0VG9kb0l0ZW1faW5kZXhfdHN4XCI6MX07XG5cdGlmKGluc3RhbGxlZENzc0NodW5rc1tjaHVua0lkXSkgcHJvbWlzZXMucHVzaChpbnN0YWxsZWRDc3NDaHVua3NbY2h1bmtJZF0pO1xuXHRlbHNlIGlmKGluc3RhbGxlZENzc0NodW5rc1tjaHVua0lkXSAhPT0gMCAmJiBjc3NDaHVua3NbY2h1bmtJZF0pIHtcblx0XHRwcm9taXNlcy5wdXNoKGluc3RhbGxlZENzc0NodW5rc1tjaHVua0lkXSA9IGxvYWRTdHlsZXNoZWV0KGNodW5rSWQpLnRoZW4oKCkgPT4ge1xuXHRcdFx0aW5zdGFsbGVkQ3NzQ2h1bmtzW2NodW5rSWRdID0gMDtcblx0XHR9LCAoZSkgPT4ge1xuXHRcdFx0ZGVsZXRlIGluc3RhbGxlZENzc0NodW5rc1tjaHVua0lkXTtcblx0XHRcdHRocm93IGU7XG5cdFx0fSkpO1xuXHR9XG59O1xuXG4vLyBubyBobXIiLCIvLyBubyBiYXNlVVJJXG5cbi8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgY2h1bmtzXG4vLyBcIjFcIiBtZWFucyBcImxvYWRlZFwiLCBvdGhlcndpc2Ugbm90IGxvYWRlZCB5ZXRcbnZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG5cdFwibWFpblwiOiAxXG59O1xuXG4vLyBubyBvbiBjaHVua3MgbG9hZGVkXG5cbnZhciBpbnN0YWxsQ2h1bmsgPSAoY2h1bmspID0+IHtcblx0dmFyIG1vcmVNb2R1bGVzID0gY2h1bmsubW9kdWxlcywgY2h1bmtJZHMgPSBjaHVuay5pZHMsIHJ1bnRpbWUgPSBjaHVuay5ydW50aW1lO1xuXHRmb3IodmFyIG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcblx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG5cdFx0fVxuXHR9XG5cdGlmKHJ1bnRpbWUpIHJ1bnRpbWUoX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdGZvcih2YXIgaSA9IDA7IGkgPCBjaHVua0lkcy5sZW5ndGg7IGkrKylcblx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZHNbaV1dID0gMTtcblxufTtcblxuLy8gcmVxdWlyZSgpIGNodW5rIGxvYWRpbmcgZm9yIGphdmFzY3JpcHRcbl9fd2VicGFja19yZXF1aXJlX18uZi5yZXF1aXJlID0gKGNodW5rSWQsIHByb21pc2VzKSA9PiB7XG5cdC8vIFwiMVwiIGlzIHRoZSBzaWduYWwgZm9yIFwiYWxyZWFkeSBsb2FkZWRcIlxuXHRpZighaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKSB7XG5cdFx0aWYodHJ1ZSkgeyAvLyBhbGwgY2h1bmtzIGhhdmUgSlNcblx0XHRcdGluc3RhbGxDaHVuayhyZXF1aXJlKFwiLi9cIiArIF9fd2VicGFja19yZXF1aXJlX18udShjaHVua0lkKSkpO1xuXHRcdH0gZWxzZSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSAxO1xuXHR9XG59O1xuXG4vLyBubyBleHRlcm5hbCBpbnN0YWxsIGNodW5rXG5cbi8vIG5vIEhNUlxuXG4vLyBubyBITVIgbWFuaWZlc3QiLCJ2YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCBBcHAgZnJvbSBcIi4uL0FwcFwiO1xuaW1wb3J0IHsgU3RhdGljUm91dGVyIH0gZnJvbSBcInJlYWN0LXJvdXRlci1kb20vc2VydmVyXCI7XG5leHBvcnQgdmFyIFNzckFwcCA9IGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgIHJldHVybiAoX2pzeChTdGF0aWNSb3V0ZXIsIF9fYXNzaWduKHsgbG9jYXRpb246IHBhdGhuYW1lIH0sIHsgY2hpbGRyZW46IF9qc3goQXBwLCB7fSkgfSkpKTtcbn07XG4iXSwibmFtZXMiOlsiQWN0aW9uIiwiUG9wU3RhdGVFdmVudFR5cGUiLCJjcmVhdGVNZW1vcnlIaXN0b3J5Iiwib3B0aW9ucyIsImluaXRpYWxFbnRyaWVzIiwiaW5pdGlhbEluZGV4IiwidjVDb21wYXQiLCJlbnRyaWVzIiwibWFwIiwiZW50cnkiLCJpbmRleCIsImNyZWF0ZU1lbW9yeUxvY2F0aW9uIiwic3RhdGUiLCJ1bmRlZmluZWQiLCJjbGFtcEluZGV4IiwibGVuZ3RoIiwiYWN0aW9uIiwiUG9wIiwibGlzdGVuZXIiLCJuIiwiTWF0aCIsIm1pbiIsIm1heCIsImdldEN1cnJlbnRMb2NhdGlvbiIsInRvIiwia2V5IiwibG9jYXRpb24iLCJjcmVhdGVMb2NhdGlvbiIsInBhdGhuYW1lIiwid2FybmluZyQxIiwiY2hhckF0IiwiSlNPTiIsInN0cmluZ2lmeSIsImNyZWF0ZUhyZWYiLCJjcmVhdGVQYXRoIiwiaGlzdG9yeSIsImNyZWF0ZVVSTCIsIlVSTCIsImVuY29kZUxvY2F0aW9uIiwicGF0aCIsInBhcnNlUGF0aCIsInNlYXJjaCIsImhhc2giLCJwdXNoIiwiUHVzaCIsIm5leHRMb2NhdGlvbiIsInNwbGljZSIsImRlbHRhIiwicmVwbGFjZSIsIlJlcGxhY2UiLCJnbyIsIm5leHRJbmRleCIsImxpc3RlbiIsImZuIiwiY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJjcmVhdGVCcm93c2VyTG9jYXRpb24iLCJ3aW5kb3ciLCJnbG9iYWxIaXN0b3J5IiwidXNyIiwiY3JlYXRlQnJvd3NlckhyZWYiLCJnZXRVcmxCYXNlZEhpc3RvcnkiLCJjcmVhdGVIYXNoSGlzdG9yeSIsImNyZWF0ZUhhc2hMb2NhdGlvbiIsInN1YnN0ciIsImNyZWF0ZUhhc2hIcmVmIiwiYmFzZSIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImhyZWYiLCJnZXRBdHRyaWJ1dGUiLCJ1cmwiLCJoYXNoSW5kZXgiLCJpbmRleE9mIiwic2xpY2UiLCJ2YWxpZGF0ZUhhc2hMb2NhdGlvbiIsImludmFyaWFudCIsInZhbHVlIiwibWVzc2FnZSIsIkVycm9yIiwid2FybmluZyIsImNvbmQiLCJjb25zb2xlIiwid2FybiIsImUiLCJjcmVhdGVLZXkiLCJyYW5kb20iLCJ0b1N0cmluZyIsImdldEhpc3RvcnlTdGF0ZSIsImlkeCIsImN1cnJlbnQiLCJfZXh0ZW5kcyIsIl9yZWYiLCJwYXJzZWRQYXRoIiwic2VhcmNoSW5kZXgiLCJnZXRMb2NhdGlvbiIsInZhbGlkYXRlTG9jYXRpb24iLCJkZWZhdWx0VmlldyIsImdldEluZGV4IiwicmVwbGFjZVN0YXRlIiwiaGFuZGxlUG9wIiwiaGlzdG9yeVN0YXRlIiwicHVzaFN0YXRlIiwiZXJyb3IiLCJhc3NpZ24iLCJvcmlnaW4iLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIlJlc3VsdFR5cGUiLCJpc0luZGV4Um91dGUiLCJyb3V0ZSIsImNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMiLCJyb3V0ZXMiLCJwYXJlbnRQYXRoIiwiYWxsSWRzIiwiU2V0IiwidHJlZVBhdGgiLCJpZCIsImpvaW4iLCJjaGlsZHJlbiIsImhhcyIsImFkZCIsImluZGV4Um91dGUiLCJwYXRoT3JMYXlvdXRSb3V0ZSIsIm1hdGNoUm91dGVzIiwibG9jYXRpb25BcmciLCJiYXNlbmFtZSIsInN0cmlwQmFzZW5hbWUiLCJicmFuY2hlcyIsImZsYXR0ZW5Sb3V0ZXMiLCJyYW5rUm91dGVCcmFuY2hlcyIsIm1hdGNoZXMiLCJpIiwibWF0Y2hSb3V0ZUJyYW5jaCIsInNhZmVseURlY29kZVVSSSIsInBhcmVudHNNZXRhIiwiZmxhdHRlblJvdXRlIiwicmVsYXRpdmVQYXRoIiwibWV0YSIsImNhc2VTZW5zaXRpdmUiLCJjaGlsZHJlbkluZGV4Iiwic3RhcnRzV2l0aCIsImpvaW5QYXRocyIsInJvdXRlc01ldGEiLCJjb25jYXQiLCJzY29yZSIsImNvbXB1dGVTY29yZSIsImZvckVhY2giLCJfcm91dGUkcGF0aCIsImluY2x1ZGVzIiwiZXhwbG9kZWQiLCJleHBsb2RlT3B0aW9uYWxTZWdtZW50cyIsInNlZ21lbnRzIiwic3BsaXQiLCJmaXJzdCIsInJlc3QiLCJpc09wdGlvbmFsIiwiZW5kc1dpdGgiLCJyZXF1aXJlZCIsInJlc3RFeHBsb2RlZCIsInJlc3VsdCIsInN1YnBhdGgiLCJzb3J0IiwiYSIsImIiLCJjb21wYXJlSW5kZXhlcyIsInBhcmFtUmUiLCJkeW5hbWljU2VnbWVudFZhbHVlIiwiaW5kZXhSb3V0ZVZhbHVlIiwiZW1wdHlTZWdtZW50VmFsdWUiLCJzdGF0aWNTZWdtZW50VmFsdWUiLCJzcGxhdFBlbmFsdHkiLCJpc1NwbGF0IiwicyIsImluaXRpYWxTY29yZSIsInNvbWUiLCJmaWx0ZXIiLCJyZWR1Y2UiLCJzZWdtZW50IiwidGVzdCIsInNpYmxpbmdzIiwiZXZlcnkiLCJicmFuY2giLCJtYXRjaGVkUGFyYW1zIiwibWF0Y2hlZFBhdGhuYW1lIiwiZW5kIiwicmVtYWluaW5nUGF0aG5hbWUiLCJtYXRjaCIsIm1hdGNoUGF0aCIsIk9iamVjdCIsInBhcmFtcyIsInBhdGhuYW1lQmFzZSIsIm5vcm1hbGl6ZVBhdGhuYW1lIiwiZ2VuZXJhdGVQYXRoIiwib3JpZ2luYWxQYXRoIiwiXyIsIm9wdGlvbmFsIiwicGFyYW0iLCJwcmVmaXgiLCJfXyIsInN0ciIsInN0YXIiLCJwYXR0ZXJuIiwibWF0Y2hlciIsInBhcmFtTmFtZXMiLCJjb21waWxlUGF0aCIsImNhcHR1cmVHcm91cHMiLCJtZW1vIiwicGFyYW1OYW1lIiwic3BsYXRWYWx1ZSIsInNhZmVseURlY29kZVVSSUNvbXBvbmVudCIsInJlZ2V4cFNvdXJjZSIsIlJlZ0V4cCIsImRlY29kZVVSSSIsImRlY29kZVVSSUNvbXBvbmVudCIsInRvTG93ZXJDYXNlIiwic3RhcnRJbmRleCIsIm5leHRDaGFyIiwicmVzb2x2ZVBhdGgiLCJmcm9tUGF0aG5hbWUiLCJ0b1BhdGhuYW1lIiwicmVzb2x2ZVBhdGhuYW1lIiwibm9ybWFsaXplU2VhcmNoIiwibm9ybWFsaXplSGFzaCIsInJlbGF0aXZlU2VnbWVudHMiLCJwb3AiLCJnZXRJbnZhbGlkUGF0aEVycm9yIiwiY2hhciIsImZpZWxkIiwiZGVzdCIsImdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzIiwicmVzb2x2ZVRvIiwidG9BcmciLCJyb3V0ZVBhdGhuYW1lcyIsImxvY2F0aW9uUGF0aG5hbWUiLCJpc1BhdGhSZWxhdGl2ZSIsImlzRW1wdHlQYXRoIiwiZnJvbSIsInJvdXRlUGF0aG5hbWVJbmRleCIsInRvU2VnbWVudHMiLCJzaGlmdCIsImhhc0V4cGxpY2l0VHJhaWxpbmdTbGFzaCIsImhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoIiwiZ2V0VG9QYXRobmFtZSIsInBhdGhzIiwianNvbiIsImRhdGEiLCJpbml0IiwicmVzcG9uc2VJbml0Iiwic3RhdHVzIiwiaGVhZGVycyIsIkhlYWRlcnMiLCJzZXQiLCJSZXNwb25zZSIsIkFib3J0ZWREZWZlcnJlZEVycm9yIiwiRGVmZXJyZWREYXRhIiwiY29uc3RydWN0b3IiLCJwZW5kaW5nS2V5c1NldCIsInN1YnNjcmliZXJzIiwiZGVmZXJyZWRLZXlzIiwiQXJyYXkiLCJpc0FycmF5IiwicmVqZWN0IiwiYWJvcnRQcm9taXNlIiwiUHJvbWlzZSIsInIiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwib25BYm9ydCIsInVubGlzdGVuQWJvcnRTaWduYWwiLCJzaWduYWwiLCJhY2MiLCJ0cmFja1Byb21pc2UiLCJkb25lIiwicHJvbWlzZSIsInJhY2UiLCJ0aGVuIiwib25TZXR0bGUiLCJjYXRjaCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiYWJvcnRlZCIsImRlbGV0ZSIsImVtaXQiLCJzZXR0bGVkS2V5Iiwic3Vic2NyaWJlciIsInN1YnNjcmliZSIsImNhbmNlbCIsImFib3J0IiwidiIsImsiLCJyZXNvbHZlRGF0YSIsInJlc29sdmUiLCJzaXplIiwidW53cmFwcGVkRGF0YSIsIl9yZWYyIiwidW53cmFwVHJhY2tlZFByb21pc2UiLCJwZW5kaW5nS2V5cyIsImlzVHJhY2tlZFByb21pc2UiLCJfdHJhY2tlZCIsIl9lcnJvciIsIl9kYXRhIiwiZGVmZXIiLCJyZWRpcmVjdCIsIkVycm9yUmVzcG9uc2UiLCJzdGF0dXNUZXh0IiwiaW50ZXJuYWwiLCJpc1JvdXRlRXJyb3JSZXNwb25zZSIsInZhbGlkTXV0YXRpb25NZXRob2RzQXJyIiwidmFsaWRNdXRhdGlvbk1ldGhvZHMiLCJ2YWxpZFJlcXVlc3RNZXRob2RzQXJyIiwidmFsaWRSZXF1ZXN0TWV0aG9kcyIsInJlZGlyZWN0U3RhdHVzQ29kZXMiLCJyZWRpcmVjdFByZXNlcnZlTWV0aG9kU3RhdHVzQ29kZXMiLCJJRExFX05BVklHQVRJT04iLCJmb3JtTWV0aG9kIiwiZm9ybUFjdGlvbiIsImZvcm1FbmNUeXBlIiwiZm9ybURhdGEiLCJJRExFX0ZFVENIRVIiLCJJRExFX0JMT0NLRVIiLCJwcm9jZWVkIiwicmVzZXQiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJpc0Jyb3dzZXIiLCJjcmVhdGVFbGVtZW50IiwiaXNTZXJ2ZXIiLCJjcmVhdGVSb3V0ZXIiLCJkYXRhUm91dGVzIiwidW5saXN0ZW5IaXN0b3J5Iiwic2F2ZWRTY3JvbGxQb3NpdGlvbnMiLCJnZXRTY3JvbGxSZXN0b3JhdGlvbktleSIsImdldFNjcm9sbFBvc2l0aW9uIiwiaW5pdGlhbFNjcm9sbFJlc3RvcmVkIiwiaHlkcmF0aW9uRGF0YSIsImluaXRpYWxNYXRjaGVzIiwiaW5pdGlhbEVycm9ycyIsImdldEludGVybmFsUm91dGVyRXJyb3IiLCJnZXRTaG9ydENpcmN1aXRNYXRjaGVzIiwiaW5pdGlhbGl6ZWQiLCJtIiwibG9hZGVyIiwicm91dGVyIiwiaGlzdG9yeUFjdGlvbiIsIm5hdmlnYXRpb24iLCJyZXN0b3JlU2Nyb2xsUG9zaXRpb24iLCJwcmV2ZW50U2Nyb2xsUmVzZXQiLCJyZXZhbGlkYXRpb24iLCJsb2FkZXJEYXRhIiwiYWN0aW9uRGF0YSIsImVycm9ycyIsImZldGNoZXJzIiwiTWFwIiwiYmxvY2tlcnMiLCJwZW5kaW5nQWN0aW9uIiwicGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCIsInBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciIsImlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiIsImlzUmV2YWxpZGF0aW9uUmVxdWlyZWQiLCJjYW5jZWxsZWREZWZlcnJlZFJvdXRlcyIsImNhbmNlbGxlZEZldGNoZXJMb2FkcyIsImZldGNoQ29udHJvbGxlcnMiLCJpbmNyZW1lbnRpbmdMb2FkSWQiLCJwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCIsImZldGNoUmVsb2FkSWRzIiwiZmV0Y2hSZWRpcmVjdElkcyIsImZldGNoTG9hZE1hdGNoZXMiLCJhY3RpdmVEZWZlcnJlZHMiLCJibG9ja2VyRnVuY3Rpb25zIiwiaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUiLCJpbml0aWFsaXplIiwiYmxvY2tlcktleSIsInNob3VsZEJsb2NrTmF2aWdhdGlvbiIsImN1cnJlbnRMb2NhdGlvbiIsInVwZGF0ZUJsb2NrZXIiLCJkZWxldGVCbG9ja2VyIiwidXBkYXRlU3RhdGUiLCJzdGFydE5hdmlnYXRpb24iLCJkaXNwb3NlIiwiY2xlYXIiLCJkZWxldGVGZXRjaGVyIiwibmV3U3RhdGUiLCJjb21wbGV0ZU5hdmlnYXRpb24iLCJfbG9jYXRpb24kc3RhdGUiLCJfbG9jYXRpb24kc3RhdGUyIiwiaXNBY3Rpb25SZWxvYWQiLCJpc011dGF0aW9uTWV0aG9kIiwiX2lzUmVkaXJlY3QiLCJrZXlzIiwibWVyZ2VMb2FkZXJEYXRhIiwiZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbiIsIm5hdmlnYXRlIiwib3B0cyIsInN1Ym1pc3Npb24iLCJub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMiLCJ1c2VyUmVwbGFjZSIsInBlbmRpbmdFcnJvciIsInJldmFsaWRhdGUiLCJpbnRlcnJ1cHRBY3RpdmVMb2FkcyIsInN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiIsIm92ZXJyaWRlTmF2aWdhdGlvbiIsInNhdmVTY3JvbGxQb3NpdGlvbiIsImxvYWRpbmdOYXZpZ2F0aW9uIiwibm90Rm91bmRNYXRjaGVzIiwiY2FuY2VsQWN0aXZlRGVmZXJyZWRzIiwiaXNIYXNoQ2hhbmdlT25seSIsInJlcXVlc3QiLCJjcmVhdGVDbGllbnRTaWRlUmVxdWVzdCIsInBlbmRpbmdBY3Rpb25EYXRhIiwiZmluZE5lYXJlc3RCb3VuZGFyeSIsImFjdGlvbk91dHB1dCIsImhhbmRsZUFjdGlvbiIsInNob3J0Q2lyY3VpdGVkIiwicGVuZGluZ0FjdGlvbkVycm9yIiwiUmVxdWVzdCIsImhhbmRsZUxvYWRlcnMiLCJhY3Rpb25NYXRjaCIsImdldFRhcmdldE1hdGNoIiwidHlwZSIsIm1ldGhvZCIsInJvdXRlSWQiLCJjYWxsTG9hZGVyT3JBY3Rpb24iLCJpc1JlZGlyZWN0UmVzdWx0Iiwic3RhcnRSZWRpcmVjdE5hdmlnYXRpb24iLCJpc0Vycm9yUmVzdWx0IiwiYm91bmRhcnlNYXRjaCIsImlzRGVmZXJyZWRSZXN1bHQiLCJhY3RpdmVTdWJtaXNzaW9uIiwibWF0Y2hlc1RvTG9hZCIsInJldmFsaWRhdGluZ0ZldGNoZXJzIiwiZ2V0TWF0Y2hlc1RvTG9hZCIsInJmIiwiZmV0Y2hlciIsInJldmFsaWRhdGluZ0ZldGNoZXIiLCJyZXN1bHRzIiwibG9hZGVyUmVzdWx0cyIsImZldGNoZXJSZXN1bHRzIiwiY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhIiwiZmluZFJlZGlyZWN0IiwicHJvY2Vzc0xvYWRlckRhdGEiLCJkZWZlcnJlZERhdGEiLCJtYXJrRmV0Y2hSZWRpcmVjdHNEb25lIiwiZGlkQWJvcnRGZXRjaExvYWRzIiwiYWJvcnRTdGFsZUZldGNoTG9hZHMiLCJnZXRGZXRjaGVyIiwiZmV0Y2giLCJhYm9ydEZldGNoZXIiLCJzZXRGZXRjaGVyRXJyb3IiLCJoYW5kbGVGZXRjaGVyQWN0aW9uIiwiaGFuZGxlRmV0Y2hlckxvYWRlciIsInJlcXVlc3RNYXRjaGVzIiwiZXhpc3RpbmdGZXRjaGVyIiwiYWJvcnRDb250cm9sbGVyIiwiZmV0Y2hSZXF1ZXN0IiwiYWN0aW9uUmVzdWx0IiwibG9hZGluZ0ZldGNoZXIiLCJpc0ZldGNoQWN0aW9uUmVkaXJlY3QiLCJyZXZhbGlkYXRpb25SZXF1ZXN0IiwibG9hZElkIiwibG9hZEZldGNoZXIiLCJzdGFsZUtleSIsImRvbmVGZXRjaGVyIiwicmVzb2x2ZURlZmVycmVkRGF0YSIsIl90ZW1wIiwiX3dpbmRvdyIsInJlZGlyZWN0TG9jYXRpb24iLCJfaXNGZXRjaEFjdGlvblJlZGlyZWN0IiwibmV3T3JpZ2luIiwicmVkaXJlY3RIaXN0b3J5QWN0aW9uIiwiY3VycmVudE1hdGNoZXMiLCJmZXRjaGVyc1RvTG9hZCIsImFsbCIsImYiLCJyZXNvbHZlRGVmZXJyZWRSZXN1bHRzIiwibWFya0ZldGNoZXJzRG9uZSIsImRvbmVLZXlzIiwibGFuZGVkSWQiLCJ5ZWV0ZWRLZXlzIiwiZ2V0QmxvY2tlciIsImJsb2NrZXIiLCJuZXdCbG9ja2VyIiwiYmxvY2tlckZ1bmN0aW9uIiwicHJlZGljYXRlIiwiY2FuY2VsbGVkUm91dGVJZHMiLCJkZmQiLCJlbmFibGVTY3JvbGxSZXN0b3JhdGlvbiIsInBvc2l0aW9ucyIsImdldFBvc2l0aW9uIiwiZ2V0S2V5IiwieSIsInVzZXJNYXRjaGVzIiwiY3JlYXRlVXNlTWF0Y2hlc01hdGNoIiwiX2ludGVybmFsRmV0Y2hDb250cm9sbGVycyIsIl9pbnRlcm5hbEFjdGl2ZURlZmVycmVkcyIsIlVOU0FGRV9ERUZFUlJFRF9TWU1CT0wiLCJTeW1ib2wiLCJjcmVhdGVTdGF0aWNIYW5kbGVyIiwicXVlcnkiLCJfdGVtcDIiLCJyZXF1ZXN0Q29udGV4dCIsImlzVmFsaWRNZXRob2QiLCJtZXRob2ROb3RBbGxvd2VkTWF0Y2hlcyIsInN0YXR1c0NvZGUiLCJsb2FkZXJIZWFkZXJzIiwiYWN0aW9uSGVhZGVycyIsInF1ZXJ5SW1wbCIsImlzUmVzcG9uc2UiLCJxdWVyeVJvdXRlIiwiX3RlbXAzIiwiZmluZCIsInZhbHVlcyIsIl9yZXN1bHQkYWN0aXZlRGVmZXJyZSIsInJvdXRlTWF0Y2giLCJzdWJtaXQiLCJsb2FkUm91dGVEYXRhIiwiaXNRdWVyeVJvdXRlUmVzcG9uc2UiLCJpc1JlZGlyZWN0UmVzcG9uc2UiLCJyZXNwb25zZSIsImlzUm91dGVSZXF1ZXN0IiwiTG9jYXRpb24iLCJjb250ZXh0IiwibG9hZGVyUmVxdWVzdCIsImdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5IiwicHJvY2Vzc1JvdXRlTG9hZGVyRGF0YSIsImV4ZWN1dGVkTG9hZGVycyIsImZyb21FbnRyaWVzIiwiZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvciIsIm5ld0NvbnRleHQiLCJfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCIsImlzU3VibWlzc2lvbk5hdmlnYXRpb24iLCJpc0ZldGNoZXIiLCJzdHJpcEhhc2hGcm9tUGF0aCIsInNlYXJjaFBhcmFtcyIsImNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zIiwiaGFzTmFrZWRJbmRleFF1ZXJ5IiwiYXBwZW5kIiwiYm91bmRhcnlJZCIsImJvdW5kYXJ5TWF0Y2hlcyIsImZpbmRJbmRleCIsImN1cnJlbnRVcmwiLCJuZXh0VXJsIiwiZGVmYXVsdFNob3VsZFJldmFsaWRhdGUiLCJuYXZpZ2F0aW9uTWF0Y2hlcyIsImlzTmV3TG9hZGVyIiwiY3VycmVudFJvdXRlTWF0Y2giLCJuZXh0Um91dGVNYXRjaCIsInNob3VsZFJldmFsaWRhdGVMb2FkZXIiLCJjdXJyZW50UGFyYW1zIiwibmV4dFBhcmFtcyIsImlzTmV3Um91dGVJbnN0YW5jZSIsInNob3VsZFJldmFsaWRhdGUiLCJjdXJyZW50TG9hZGVyRGF0YSIsImN1cnJlbnRNYXRjaCIsImlzTmV3IiwiaXNNaXNzaW5nRGF0YSIsImN1cnJlbnRQYXRoIiwibG9hZGVyTWF0Y2giLCJhcmciLCJyb3V0ZUNob2ljZSIsImlzU3RhdGljUmVxdWVzdCIsInJlc3VsdFR5cGUiLCJvblJlamVjdCIsImhhbmRsZXIiLCJhY3RpdmVNYXRjaGVzIiwicmVzb2x2ZWRMb2NhdGlvbiIsInByb3RvY29sIiwiY29udGVudFR5cGUiLCJ0ZXh0IiwiZGVmZXJyZWQiLCJ0b1VwcGVyQ2FzZSIsImJvZHkiLCJVUkxTZWFyY2hQYXJhbXMiLCJGaWxlIiwibmFtZSIsImZvdW5kRXJyb3IiLCJuZXdMb2FkZXJEYXRhIiwibWVyZ2VkTG9hZGVyRGF0YSIsImhhc093blByb3BlcnR5IiwiZWxpZ2libGVNYXRjaGVzIiwicmV2ZXJzZSIsImhhc0Vycm9yQm91bmRhcnkiLCJfdGVtcDQiLCJlcnJvck1lc3NhZ2UiLCJvYmoiLCJpc1JldmFsaWRhdGluZ0xvYWRlciIsInVud3JhcCIsImdldEFsbCIsImhhbmRsZSIsInBhdGhNYXRjaGVzIiwiZGVmYXVsdE1ldGhvZCIsImRlZmF1bHRFbmNUeXBlIiwiaXNIdG1sRWxlbWVudCIsIm9iamVjdCIsInRhZ05hbWUiLCJpc0J1dHRvbkVsZW1lbnQiLCJpc0Zvcm1FbGVtZW50IiwiaXNJbnB1dEVsZW1lbnQiLCJpc01vZGlmaWVkRXZlbnQiLCJldmVudCIsIm1ldGFLZXkiLCJhbHRLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJzaG91bGRQcm9jZXNzTGlua0NsaWNrIiwidGFyZ2V0IiwiYnV0dG9uIiwiY3JlYXRlU2VhcmNoUGFyYW1zIiwiZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24iLCJsb2NhdGlvblNlYXJjaCIsImRlZmF1bHRTZWFyY2hQYXJhbXMiLCJnZXRGb3JtU3VibWlzc2lvbkluZm8iLCJkZWZhdWx0QWN0aW9uIiwiZW5jVHlwZSIsInN1Ym1pc3Npb25UcmlnZ2VyIiwiRm9ybURhdGEiLCJmb3JtIiwiaG9zdCIsImNyZWF0ZUJyb3dzZXJSb3V0ZXIiLCJwYXJzZUh5ZHJhdGlvbkRhdGEiLCJVTlNBRkVfZW5oYW5jZU1hbnVhbFJvdXRlT2JqZWN0cyIsImNyZWF0ZUhhc2hSb3V0ZXIiLCJfX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGEiLCJkZXNlcmlhbGl6ZUVycm9ycyIsInNlcmlhbGl6ZWQiLCJ2YWwiLCJfX3R5cGUiLCJzdGFjayIsIkJyb3dzZXJSb3V0ZXIiLCJoaXN0b3J5UmVmIiwiUmVhY3QiLCJ1c2VSZWYiLCJzZXRTdGF0ZSIsInVzZVN0YXRlIiwidXNlTGF5b3V0RWZmZWN0IiwiUm91dGVyIiwibmF2aWdhdGlvblR5cGUiLCJuYXZpZ2F0b3IiLCJIYXNoUm91dGVyIiwiSGlzdG9yeVJvdXRlciIsIl9yZWYzIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZGlzcGxheU5hbWUiLCJMaW5rIiwiZm9yd2FyZFJlZiIsIkxpbmtXaXRoUmVmIiwiX3JlZjQiLCJyZWYiLCJvbkNsaWNrIiwicmVsYXRpdmUiLCJyZWxvYWREb2N1bWVudCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiX2V4Y2x1ZGVkIiwiYWJzb2x1dGVIcmVmIiwiaXNFeHRlcm5hbCIsInRhcmdldFVybCIsInVzZUhyZWYiLCJpbnRlcm5hbE9uQ2xpY2siLCJ1c2VMaW5rQ2xpY2tIYW5kbGVyIiwiaGFuZGxlQ2xpY2siLCJkZWZhdWx0UHJldmVudGVkIiwiTmF2TGluayIsIk5hdkxpbmtXaXRoUmVmIiwiX3JlZjUiLCJhcmlhQ3VycmVudFByb3AiLCJjbGFzc05hbWUiLCJjbGFzc05hbWVQcm9wIiwic3R5bGUiLCJzdHlsZVByb3AiLCJfZXhjbHVkZWQyIiwidXNlUmVzb2x2ZWRQYXRoIiwidXNlTG9jYXRpb24iLCJyb3V0ZXJTdGF0ZSIsInVzZUNvbnRleHQiLCJVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCIsIlVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCIsIm5leHRMb2NhdGlvblBhdGhuYW1lIiwiaXNBY3RpdmUiLCJpc1BlbmRpbmciLCJhcmlhQ3VycmVudCIsIkJvb2xlYW4iLCJGb3JtIiwicHJvcHMiLCJGb3JtSW1wbCIsIl9yZWY2IiwiZm9yd2FyZGVkUmVmIiwib25TdWJtaXQiLCJmZXRjaGVyS2V5IiwiX2V4Y2x1ZGVkMyIsInVzZVN1Ym1pdEltcGwiLCJ1c2VGb3JtQWN0aW9uIiwic3VibWl0SGFuZGxlciIsInByZXZlbnREZWZhdWx0Iiwic3VibWl0dGVyIiwibmF0aXZlRXZlbnQiLCJzdWJtaXRNZXRob2QiLCJjdXJyZW50VGFyZ2V0IiwiU2Nyb2xsUmVzdG9yYXRpb24iLCJfcmVmNyIsInN0b3JhZ2VLZXkiLCJ1c2VTY3JvbGxSZXN0b3JhdGlvbiIsIkRhdGFSb3V0ZXJIb29rIiwiRGF0YVJvdXRlclN0YXRlSG9vayIsImdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IiLCJob29rTmFtZSIsInVzZURhdGFSb3V0ZXJDb250ZXh0IiwiY3R4IiwiVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0IiwidXNlRGF0YVJvdXRlclN0YXRlIiwicmVwbGFjZVByb3AiLCJ1c2VOYXZpZ2F0ZSIsInVzZUNhbGxiYWNrIiwidXNlU2VhcmNoUGFyYW1zIiwiZGVmYXVsdEluaXQiLCJkZWZhdWx0U2VhcmNoUGFyYW1zUmVmIiwiaGFzU2V0U2VhcmNoUGFyYW1zUmVmIiwidXNlTWVtbyIsInNldFNlYXJjaFBhcmFtcyIsIm5leHRJbml0IiwibmF2aWdhdGVPcHRpb25zIiwibmV3U2VhcmNoUGFyYW1zIiwidXNlU3VibWl0IiwiVXNlU3VibWl0SW1wbCIsInJvdXRlQ29udGV4dCIsIlVOU0FGRV9Sb3V0ZUNvbnRleHQiLCJjcmVhdGVGZXRjaGVyRm9ybSIsIkZldGNoZXJGb3JtIiwiZmV0Y2hlcklkIiwidXNlRmV0Y2hlciIsIl9yb3V0ZSRtYXRjaGVzIiwiVXNlRmV0Y2hlciIsIlN0cmluZyIsImxvYWQiLCJmZXRjaGVyV2l0aENvbXBvbmVudHMiLCJ1c2VFZmZlY3QiLCJ1c2VGZXRjaGVycyIsIlVzZUZldGNoZXJzIiwiU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZIiwiVXNlU2Nyb2xsUmVzdG9yYXRpb24iLCJ1c2VNYXRjaGVzIiwidXNlTmF2aWdhdGlvbiIsInNjcm9sbFJlc3RvcmF0aW9uIiwidXNlUGFnZUhpZGUiLCJzY3JvbGxZIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwic2Vzc2lvblBvc2l0aW9ucyIsImdldEl0ZW0iLCJwYXJzZSIsImRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiIsInNjcm9sbFRvIiwiZWwiLCJnZXRFbGVtZW50QnlJZCIsInNjcm9sbEludG9WaWV3IiwidXNlQmVmb3JlVW5sb2FkIiwiY2FsbGJhY2siLCJjYXB0dXJlIiwidXNlUHJvbXB0IiwiX3JlZjgiLCJ3aGVuIiwidW5zdGFibGVfdXNlQmxvY2tlciIsImNvbmZpcm0iLCJzZXRUaW1lb3V0IiwiZXhwb3J0cyIsInJlcXVpcmUiLCJyZWFjdFJvdXRlckRvbSIsIl9pbnRlcm9wTmFtZXNwYWNlIiwiX19lc01vZHVsZSIsImNyZWF0ZSIsImQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiZnJlZXplIiwiUmVhY3RfX25hbWVzcGFjZSIsIlN0YXRpY1JvdXRlciIsImxvY2F0aW9uUHJvcCIsInN0YXRpY05hdmlnYXRvciIsImdldFN0YXRlbGVzc05hdmlnYXRvciIsInN0YXRpYyIsIlN0YXRpY1JvdXRlclByb3ZpZGVyIiwicm91dGVyJDEiLCJoeWRyYXRlIiwibm9uY2UiLCJkYXRhUm91dGVyQ29udGV4dCIsInN0YXRpY0NvbnRleHQiLCJoeWRyYXRlU2NyaXB0Iiwic2VyaWFsaXplRXJyb3JzIiwiRnJhZ21lbnQiLCJQcm92aWRlciIsIlJvdXRlcyIsInN1cHByZXNzSHlkcmF0aW9uV2FybmluZyIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIiwiYmFjayIsImZvcndhcmQiLCJnZW5lcmF0ZU1hbmlmZXN0IiwibWFuaWZlc3QiLCJhcmd1bWVudHMiLCJjcmVhdGVTdGF0aWNSb3V0ZXIiLCJVTlNBRkVfY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyIsIm1zZyIsImlzUG9seWZpbGwiLCJ4IiwiaXMiLCJ1c2VEZWJ1Z1ZhbHVlIiwiZGlkV2Fybk9sZDE4QWxwaGEiLCJkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlJDIiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsImdldFNuYXBzaG90IiwiZ2V0U2VydmVyU25hcHNob3QiLCJjYWNoZWRWYWx1ZSIsImluc3QiLCJmb3JjZVVwZGF0ZSIsImNoZWNrSWZTbmFwc2hvdENoYW5nZWQiLCJoYW5kbGVTdG9yZUNoYW5nZSIsImxhdGVzdEdldFNuYXBzaG90IiwicHJldlZhbHVlIiwibmV4dFZhbHVlIiwidXNlU3luY0V4dGVybmFsU3RvcmUkMSIsImNhblVzZURPTSIsImlzU2VydmVyRW52aXJvbm1lbnQiLCJzaGltIiwibW9kdWxlIiwiRGF0YVJvdXRlckNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiRGF0YVJvdXRlclN0YXRlQ29udGV4dCIsIkF3YWl0Q29udGV4dCIsIk5hdmlnYXRpb25Db250ZXh0IiwiTG9jYXRpb25Db250ZXh0IiwiUm91dGVDb250ZXh0Iiwib3V0bGV0IiwiUm91dGVFcnJvckNvbnRleHQiLCJ1c2VJblJvdXRlckNvbnRleHQiLCJqb2luZWRQYXRobmFtZSIsInVzZU5hdmlnYXRpb25UeXBlIiwidXNlTWF0Y2giLCJyb3V0ZVBhdGhuYW1lc0pzb24iLCJVTlNBRkVfZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMiLCJhY3RpdmVSZWYiLCJPdXRsZXRDb250ZXh0IiwidXNlT3V0bGV0Q29udGV4dCIsInVzZU91dGxldCIsInVzZVBhcmFtcyIsInVzZVJvdXRlcyIsImRhdGFSb3V0ZXJTdGF0ZUNvbnRleHQiLCJwYXJlbnRNYXRjaGVzIiwicGFyZW50UGFyYW1zIiwicGFyZW50UGF0aG5hbWUiLCJwYXJlbnRQYXRobmFtZUJhc2UiLCJwYXJlbnRSb3V0ZSIsIndhcm5pbmdPbmNlIiwibG9jYXRpb25Gcm9tQ29udGV4dCIsIl9wYXJzZWRMb2NhdGlvbkFyZyRwYSIsInBhcnNlZExvY2F0aW9uQXJnIiwiZWxlbWVudCIsInJlbmRlcmVkTWF0Y2hlcyIsIl9yZW5kZXJNYXRjaGVzIiwiRGVmYXVsdEVycm9yRWxlbWVudCIsInVzZVJvdXRlRXJyb3IiLCJsaWdodGdyZXkiLCJwcmVTdHlsZXMiLCJwYWRkaW5nIiwiYmFja2dyb3VuZENvbG9yIiwiY29kZVN0eWxlcyIsImRldkluZm8iLCJmb250U3R5bGUiLCJSZW5kZXJFcnJvckJvdW5kYXJ5IiwiQ29tcG9uZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJlcnJvckluZm8iLCJyZW5kZXIiLCJjb21wb25lbnQiLCJSZW5kZXJlZFJvdXRlIiwiZXJyb3JFbGVtZW50IiwiZGF0YVJvdXRlclN0YXRlIiwiZXJyb3JJbmRleCIsInJlZHVjZVJpZ2h0IiwiZ2V0Q2hpbGRyZW4iLCJ1c2VSb3V0ZUNvbnRleHQiLCJ1c2VDdXJyZW50Um91dGVJZCIsInRoaXNSb3V0ZSIsIlVzZU5hdmlnYXRpb24iLCJ1c2VSZXZhbGlkYXRvciIsIlVzZVJldmFsaWRhdG9yIiwiVXNlTWF0Y2hlcyIsInVzZUxvYWRlckRhdGEiLCJVc2VMb2FkZXJEYXRhIiwidXNlUm91dGVMb2FkZXJEYXRhIiwiVXNlUm91dGVMb2FkZXJEYXRhIiwidXNlQWN0aW9uRGF0YSIsIlVzZUFjdGlvbkRhdGEiLCJfc3RhdGUkZXJyb3JzIiwiVXNlUm91dGVFcnJvciIsInVzZUFzeW5jVmFsdWUiLCJ1c2VBc3luY0Vycm9yIiwiYmxvY2tlcklkIiwidXNlQmxvY2tlciIsInNob3VsZEJsb2NrIiwiVXNlQmxvY2tlciIsImFyZ3MiLCJhbHJlYWR5V2FybmVkIiwiUm91dGVyUHJvdmlkZXIiLCJmYWxsYmFja0VsZW1lbnQiLCJNZW1vcnlSb3V0ZXIiLCJOYXZpZ2F0ZSIsIk91dGxldCIsIlJvdXRlIiwiX3Byb3BzIiwiYmFzZW5hbWVQcm9wIiwic3RhdGljUHJvcCIsIm5hdmlnYXRpb25Db250ZXh0IiwidHJhaWxpbmdQYXRobmFtZSIsImNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiIsIkF3YWl0IiwiQXdhaXRFcnJvckJvdW5kYXJ5IiwiUmVzb2x2ZUF3YWl0IiwiQXdhaXRSZW5kZXJTdGF0dXMiLCJuZXZlclNldHRsZWRQcm9taXNlIiwicGVuZGluZyIsInN1Y2Nlc3MiLCJyZW5kZXJFcnJvciIsInRvUmVuZGVyIiwiQ2hpbGRyZW4iLCJpc1ZhbGlkRWxlbWVudCIsImFwcGx5IiwicmVuZGVyTWF0Y2hlcyIsImVuaGFuY2VNYW51YWxSb3V0ZU9iamVjdHMiLCJyb3V0ZUNsb25lIiwiY3JlYXRlTWVtb3J5Um91dGVyIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiZm9yIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZm9ybWF0IiwiX2xlbjIiLCJfa2V5MiIsInByaW50V2FybmluZyIsImxldmVsIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSIsImdldFN0YWNrQWRkZW5kdW0iLCJhcmdzV2l0aEZvcm1hdCIsIml0ZW0iLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJjYWxsIiwiZW5hYmxlU2NvcGVBUEkiLCJlbmFibGVDYWNoZUVsZW1lbnQiLCJlbmFibGVUcmFuc2l0aW9uVHJhY2luZyIsImVuYWJsZUxlZ2FjeUhpZGRlbiIsImVuYWJsZURlYnVnVHJhY2luZyIsIlJFQUNUX01PRFVMRV9SRUZFUkVOQ0UiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCIkJHR5cGVvZiIsImdldE1vZHVsZUlkIiwiZ2V0V3JhcHBlZE5hbWUiLCJvdXRlclR5cGUiLCJpbm5lclR5cGUiLCJ3cmFwcGVyTmFtZSIsImZ1bmN0aW9uTmFtZSIsImdldENvbnRleHROYW1lIiwiZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlIiwidGFnIiwicHJvdmlkZXIiLCJfY29udGV4dCIsIm91dGVyTmFtZSIsImxhenlDb21wb25lbnQiLCJwYXlsb2FkIiwiX3BheWxvYWQiLCJfaW5pdCIsImRpc2FibGVkRGVwdGgiLCJwcmV2TG9nIiwicHJldkluZm8iLCJwcmV2V2FybiIsInByZXZFcnJvciIsInByZXZHcm91cCIsInByZXZHcm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImRpc2FibGVkTG9nIiwiX19yZWFjdERpc2FibGVkTG9nIiwiZGlzYWJsZUxvZ3MiLCJsb2ciLCJpbmZvIiwiZ3JvdXAiLCJncm91cENvbGxhcHNlZCIsImdyb3VwRW5kIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVlbmFibGVMb2dzIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwic291cmNlIiwib3duZXJGbiIsInRyaW0iLCJyZWVudHJ5IiwiY29tcG9uZW50RnJhbWVDYWNoZSIsIlBvc3NpYmx5V2Vha01hcCIsIldlYWtNYXAiLCJkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lIiwiY29uc3RydWN0IiwiZnJhbWUiLCJjb250cm9sIiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiRmFrZSIsIlJlZmxlY3QiLCJzYW1wbGUiLCJzYW1wbGVMaW5lcyIsImNvbnRyb2xMaW5lcyIsImMiLCJfZnJhbWUiLCJzeW50aGV0aWNGcmFtZSIsImRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSIsInNob3VsZENvbnN0cnVjdCIsImlzUmVhY3RDb21wb25lbnQiLCJkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwiY29tcG9uZW50TmFtZSIsImJpbmQiLCJ0eXBlU3BlY05hbWUiLCJlcnJvciQxIiwiZXJyIiwiZXgiLCJpc0FycmF5SW1wbCIsInR5cGVOYW1lIiwiaGFzVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsIndpbGxDb2VyY2lvblRocm93IiwidGVzdFN0cmluZ0NvZXJjaW9uIiwiY2hlY2tLZXlTdHJpbmdDb2VyY2lvbiIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJqc3hERVYiLCJtYXliZUtleSIsInByb3BOYW1lIiwiZGVmYXVsdFByb3BzIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSIsImdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwib3duZXJIYXNLZXlVc2VXYXJuaW5nIiwiZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsInBhcmVudFR5cGUiLCJwYXJlbnROYW1lIiwidmFsaWRhdGVFeHBsaWNpdEtleSIsInZhbGlkYXRlZCIsImN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJjaGlsZE93bmVyIiwidmFsaWRhdGVDaGlsZEtleXMiLCJub2RlIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwic3RlcCIsIm5leHQiLCJ2YWxpZGF0ZVByb3BUeXBlcyIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsIl9uYW1lIiwiZ2V0RGVmYXVsdFByb3BzIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJmcmFnbWVudCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwianN4V2l0aFZhbGlkYXRpb25TdGF0aWMiLCJqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWMiLCJqc3giLCJqc3hzIl0sInNvdXJjZVJvb3QiOiIifQ==