/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@remix-run/router/dist/router.js":
/*!*******************************************************!*\
  !*** ./node_modules/@remix-run/router/dist/router.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbortedDeferredError": () => (/* binding */ AbortedDeferredError),
/* harmony export */   "Action": () => (/* binding */ Action),
/* harmony export */   "ErrorResponse": () => (/* binding */ ErrorResponse),
/* harmony export */   "IDLE_BLOCKER": () => (/* binding */ IDLE_BLOCKER),
/* harmony export */   "IDLE_FETCHER": () => (/* binding */ IDLE_FETCHER),
/* harmony export */   "IDLE_NAVIGATION": () => (/* binding */ IDLE_NAVIGATION),
/* harmony export */   "UNSAFE_DEFERRED_SYMBOL": () => (/* binding */ UNSAFE_DEFERRED_SYMBOL),
/* harmony export */   "UNSAFE_DeferredData": () => (/* binding */ DeferredData),
/* harmony export */   "UNSAFE_convertRoutesToDataRoutes": () => (/* binding */ convertRoutesToDataRoutes),
/* harmony export */   "UNSAFE_getPathContributingMatches": () => (/* binding */ getPathContributingMatches),
/* harmony export */   "createBrowserHistory": () => (/* binding */ createBrowserHistory),
/* harmony export */   "createHashHistory": () => (/* binding */ createHashHistory),
/* harmony export */   "createMemoryHistory": () => (/* binding */ createMemoryHistory),
/* harmony export */   "createPath": () => (/* binding */ createPath),
/* harmony export */   "createRouter": () => (/* binding */ createRouter),
/* harmony export */   "createStaticHandler": () => (/* binding */ createStaticHandler),
/* harmony export */   "defer": () => (/* binding */ defer),
/* harmony export */   "generatePath": () => (/* binding */ generatePath),
/* harmony export */   "getStaticContextFromError": () => (/* binding */ getStaticContextFromError),
/* harmony export */   "getToPathname": () => (/* binding */ getToPathname),
/* harmony export */   "invariant": () => (/* binding */ invariant),
/* harmony export */   "isRouteErrorResponse": () => (/* binding */ isRouteErrorResponse),
/* harmony export */   "joinPaths": () => (/* binding */ joinPaths),
/* harmony export */   "json": () => (/* binding */ json),
/* harmony export */   "matchPath": () => (/* binding */ matchPath),
/* harmony export */   "matchRoutes": () => (/* binding */ matchRoutes),
/* harmony export */   "normalizePathname": () => (/* binding */ normalizePathname),
/* harmony export */   "parsePath": () => (/* binding */ parsePath),
/* harmony export */   "redirect": () => (/* binding */ redirect),
/* harmony export */   "resolvePath": () => (/* binding */ resolvePath),
/* harmony export */   "resolveTo": () => (/* binding */ resolveTo),
/* harmony export */   "stripBasename": () => (/* binding */ stripBasename),
/* harmony export */   "warning": () => (/* binding */ warning)
/* harmony export */ });
/**
 * @remix-run/router v1.3.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

////////////////////////////////////////////////////////////////////////////////
//#region Types and Constants
////////////////////////////////////////////////////////////////////////////////

/**
 * Actions represent the type of change to a location value.
 */
var Action;
(function (Action) {
  /**
   * A POP indicates a change to an arbitrary index in the history stack, such
   * as a back or forward navigation. It does not describe the direction of the
   * navigation, only that the current index changed.
   *
   * Note: This is the default action for newly created history objects.
   */
  Action["Pop"] = "POP";
  /**
   * A PUSH indicates a new entry being added to the history stack, such as when
   * a link is clicked and a new page loads. When this happens, all subsequent
   * entries in the stack are lost.
   */

  Action["Push"] = "PUSH";
  /**
   * A REPLACE indicates the entry at the current index in the history stack
   * being replaced by a new one.
   */

  Action["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
/**
 * Memory history stores the current location in memory. It is designed for use
 * in stateful non-browser environments like tests and React Native.
 */

function createMemoryHistory(options) {
  if (options === void 0) {
    options = {};
  }
  let {
    initialEntries = ["/"],
    initialIndex,
    v5Compat = false
  } = options;
  let entries; // Declare so we can access from createMemoryLocation

  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === "string" ? null : entry.state, index === 0 ? "default" : undefined));
  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);
  let action = Action.Pop;
  let listener = null;
  function clampIndex(n) {
    return Math.min(Math.max(n, 0), entries.length - 1);
  }
  function getCurrentLocation() {
    return entries[index];
  }
  function createMemoryLocation(to, state, key) {
    if (state === void 0) {
      state = null;
    }
    let location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key);
    warning$1(location.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(to));
    return location;
  }
  function createHref(to) {
    return typeof to === "string" ? to : createPath(to);
  }
  let history = {
    get index() {
      return index;
    },
    get action() {
      return action;
    },
    get location() {
      return getCurrentLocation();
    },
    createHref,
    createURL(to) {
      return new URL(createHref(to), "http://localhost");
    },
    encodeLocation(to) {
      let path = typeof to === "string" ? parsePath(to) : to;
      return {
        pathname: path.pathname || "",
        search: path.search || "",
        hash: path.hash || ""
      };
    },
    push(to, state) {
      action = Action.Push;
      let nextLocation = createMemoryLocation(to, state);
      index += 1;
      entries.splice(index, entries.length, nextLocation);
      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation,
          delta: 1
        });
      }
    },
    replace(to, state) {
      action = Action.Replace;
      let nextLocation = createMemoryLocation(to, state);
      entries[index] = nextLocation;
      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation,
          delta: 0
        });
      }
    },
    go(delta) {
      action = Action.Pop;
      let nextIndex = clampIndex(index + delta);
      let nextLocation = entries[nextIndex];
      index = nextIndex;
      if (listener) {
        listener({
          action,
          location: nextLocation,
          delta
        });
      }
    },
    listen(fn) {
      listener = fn;
      return () => {
        listener = null;
      };
    }
  };
  return history;
}
/**
 * Browser history stores the location in regular URLs. This is the standard for
 * most web apps, but it requires some configuration on the server to ensure you
 * serve the same app at multiple URLs.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
 */

function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window.location;
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createBrowserHref(window, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
/**
 * Hash history stores the location in window.location.hash. This makes it ideal
 * for situations where you don't want to send the location to the server for
 * some reason, either because you do cannot configure it or the URL space is
 * reserved for something else.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory
 */

function createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createHashLocation(window, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash = ""
    } = parsePath(window.location.hash.substr(1));
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createHashHref(window, to) {
    let base = window.document.querySelector("base");
    let href = "";
    if (base && base.getAttribute("href")) {
      let url = window.location.href;
      let hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href + "#" + (typeof to === "string" ? to : createPath(to));
  }
  function validateHashLocation(location, to) {
    warning$1(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
  }
  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning$1(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);
    try {
      // Welcome to debugging history!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
/**
 * For browser-based histories, we combine the state and key into an object
 */

function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
/**
 * Creates a Location object with a unique key from the given Path
 */

function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
/**
 * Creates a string URL path from the given pathname, search, and hash components.
 */

function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
/**
 * Parses a string URL path into its separate pathname, search, and hash components.
 */

function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window.history;
  let action = Action.Pop;
  let listener = null;
  let index = getIndex(); // Index should only be null when we initialize. If not, it's because the
  // user called history.pushState or history.replaceState directly, in which
  // case we should log a warning as it will result in bugs.

  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = Action.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location); // try...catch because iOS limits us to 100 pushState calls :/

    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      // They are going to lose state here, but there is no real
      // way to warn them about it since the page will refresh...
      window.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace(to, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    // window.location.origin is "null" (the literal string value) in Firefox
    // under certain conditions, notably when serving from a local HTML file
    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297
    let base = window.location.origin !== "null" ? window.location.origin : window.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window, to);
    },
    createURL,
    encodeLocation(to) {
      // Encode a Location the same way window.location would
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace,
    go(n) {
      return globalHistory.go(n);
    }
  };
  return history;
} //#endregion

var ResultType;
(function (ResultType) {
  ResultType["data"] = "data";
  ResultType["deferred"] = "deferred";
  ResultType["redirect"] = "redirect";
  ResultType["error"] = "error";
})(ResultType || (ResultType = {}));
function isIndexRoute(route) {
  return route.index === true;
} // Walk the route tree generating unique IDs where necessary so we are working
// solely with AgnosticDataRouteObject's within the Router

function convertRoutesToDataRoutes(routes, parentPath, allIds) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  if (allIds === void 0) {
    allIds = new Set();
  }
  return routes.map((route, index) => {
    let treePath = [...parentPath, index];
    let id = typeof route.id === "string" ? route.id : treePath.join("-");
    invariant(route.index !== true || !route.children, "Cannot specify children on an index route");
    invariant(!allIds.has(id), "Found a route id collision on id \"" + id + "\".  Route " + "id's must be globally unique within Data Router usages");
    allIds.add(id);
    if (isIndexRoute(route)) {
      let indexRoute = _extends({}, route, {
        id
      });
      return indexRoute;
    } else {
      let pathOrLayoutRoute = _extends({}, route, {
        id,
        children: route.children ? convertRoutesToDataRoutes(route.children, treePath, allIds) : undefined
      });
      return pathOrLayoutRoute;
    }
  });
}
/**
 * Matches the given routes to a location and returns the match data.
 *
 * @see https://reactrouter.com/utils/match-routes
 */

function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(branches[i],
    // Incoming pathnames are generally encoded from either window.location
    // or from router.navigate, but we want to match against the unencoded
    // paths in the route definitions.  Memory router locations won't be
    // encoded here but there also shouldn't be anything to decode so this
    // should be a safe operation.  This avoids needing matchRoutes to be
    // history-aware.
    safelyDecodeURI(pathname));
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === undefined ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), "Absolute route path \"" + meta.relativePath + "\" nested under path " + ("\"" + parentPath + "\" is not valid. An absolute child route path ") + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta); // Add the children before adding this route to the array so we traverse the
    // route tree depth-first and child routes appear before their parents in
    // the "flattened" version.

    if (route.children && route.children.length > 0) {
      invariant(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      route.index !== true, "Index routes must not have child routes. Please remove " + ("all child routes from route path \"" + path + "\"."));
      flattenRoutes(route.children, branches, routesMeta, path);
    } // Routes without a path shouldn't ever match by themselves unless they are
    // index routes, so don't add them to the list of possible branches.

    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    var _route$path;

    // coarse-grain check for optional params
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
/**
 * Computes all combinations of optional path segments for a given path,
 * excluding combinations that are ambiguous and of lower priority.
 *
 * For example, `/one/:two?/three/:four?/:five?` explodes to:
 * - `/one/three`
 * - `/one/:two/three`
 * - `/one/three/:four`
 * - `/one/three/:five`
 * - `/one/:two/three/:four`
 * - `/one/:two/three/:five`
 * - `/one/three/:four/:five`
 * - `/one/:two/three/:four/:five`
 */

function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments; // Optional path segments are denoted by a trailing `?`

  let isOptional = first.endsWith("?"); // Compute the corresponding required segment: `foo?` -> `foo`

  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    // Intepret empty string as omitting an optional segment
    // `["one", "", "three"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = []; // All child paths with the prefix.  Do this for all children before the
  // optional version for all children so we get consistent ordering where the
  // parent optional aspect is preferred as required.  Otherwise, we can get
  // child sections interspersed where deeper optional segments are higher than
  // parent optional segments, where for example, /:two would explodes _earlier_
  // then /:one.  By always including the parent as required _for all children_
  // first, we avoid this issue

  result.push(...restExploded.map(subpath => subpath === "" ? required : [required, subpath].join("/"))); // Then if this is an optional value, add all child versions without

  if (isOptional) {
    result.push(...restExploded);
  } // for absolute paths, ensure `/` instead of empty segment

  return result.map(exploded => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first
  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = s => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ?
  // If two routes are siblings, we should try to match the earlier sibling
  // first. This allows people to have fine-grained control over the matching
  // behavior by simply putting routes with identical paths in the order they
  // want them tried.
  a[a.length - 1] - b[b.length - 1] :
  // Otherwise, it doesn't really make sense to rank non-siblings by index,
  // so they sort equally.
  0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match) return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
/**
 * Returns a path with params interpolated.
 *
 * @see https://reactrouter.com/utils/generate-path
 */

function generatePath(originalPath, params) {
  if (params === void 0) {
    params = {};
  }
  let path = originalPath;
  if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) {
    warning(false, "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
    path = path.replace(/\*$/, "/*");
  }
  return path.replace(/^:(\w+)(\??)/g, (_, key, optional) => {
    let param = params[key];
    if (optional === "?") {
      return param == null ? "" : param;
    }
    if (param == null) {
      invariant(false, "Missing \":" + key + "\" param");
    }
    return param;
  }).replace(/\/:(\w+)(\??)/g, (_, key, optional) => {
    let param = params[key];
    if (optional === "?") {
      return param == null ? "" : "/" + param;
    }
    if (param == null) {
      invariant(false, "Missing \":" + key + "\" param");
    }
    return "/" + param;
  }) // Remove any optional markers from optional static segments
  .replace(/\?/g, "").replace(/(\/?)\*/, (_, prefix, __, str) => {
    const star = "*";
    if (params[star] == null) {
      // If no splat was provided, trim the trailing slash _unless_ it's
      // the entire path
      return str === "/*" ? "/" : "";
    } // Apply the splat

    return "" + prefix + params[star];
  });
}
/**
 * Performs pattern matching on a URL pathname and returns information about
 * the match.
 *
 * @see https://reactrouter.com/utils/match-path
 */

function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index) => {
    // We need to compute the pathnameBase here using the raw splat value
    // instead of using params["*"] later because it will be decoded then
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
  .replace(/^\/*/, "/") // Make sure it has a leading /
  .replace(/[\\.*+^$?{}|()[\]]/g, "\\$&") // Escape special regex chars
  .replace(/\/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName);
    return "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest
    : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
  } else if (end) {
    // When matching to the end, ignore trailing slashes
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    // If our path is non-empty and contains anything beyond an initial slash,
    // then we have _some_ form of path in our regex so we should expect to
    // match only if we find the end of this path segment.  Look for an optional
    // non-captured trailing slash (to match a portion of the URL) or the end
    // of the path (if we've matched to the end).  We used to do this with a
    // word boundary but that gives false positives on routes like
    // /user-preferences since `-` counts as a word boundary.
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
  return [matcher, paramNames];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error) {
    warning(false, "The URL path \"" + value + "\" could not be decoded because it is is a " + "malformed URL segment. This is probably due to a bad percent " + ("encoding (" + error + ")."));
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning(false, "The value for the URL param \"" + paramName + "\" will not be decoded because" + (" the string \"" + value + "\" is a malformed URL segment. This is probably") + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
/**
 * @private
 */

function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  } // We want to leave trailing slash behavior in the user's control, so if they
  // specify a basename with a trailing slash, we should support it

  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    // pathname does not start with basename/
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
/**
 * @private
 */

function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);
    try {
      // Welcome to debugging @remix-run/router!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}
/**
 * Returns a resolved path object relative to the given pathname.
 *
 * @see https://reactrouter.com/utils/resolve-path
 */

function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach(segment => {
    if (segment === "..") {
      // Keep the root "" segment so the pathname starts at /
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + "a string in <Link to=\"...\"> and the router will parse it for you.";
}
/**
 * @private
 *
 * When processing relative navigation we want to ignore ancestor routes that
 * do not contribute to the path, such that index/pathless layout routes don't
 * interfere.
 *
 * For example, when moving a route element into an index route and/or a
 * pathless layout route, relative link behavior contained within should stay
 * the same.  Both of the following examples should link back to the root:
 *
 *   <Route path="/">
 *     <Route path="accounts" element={<Link to=".."}>
 *   </Route>
 *
 *   <Route path="/">
 *     <Route path="accounts">
 *       <Route element={<AccountsLayout />}>       // <-- Does not contribute
 *         <Route index element={<Link to=".."} />  // <-- Does not contribute
 *       </Route
 *     </Route>
 *   </Route>
 */

function getPathContributingMatches(matches) {
  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
}
/**
 * @private
 */

function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from; // Routing is relative to the current pathname if explicitly requested.
  //
  // If a pathname is explicitly provided in `to`, it should be relative to the
  // route context. This is explained in `Note on `<Link to>` values` in our
  // migration guide from v5 as a means of disambiguation between `to` values
  // that begin with `/` and those that do not. However, this is problematic for
  // `to` values that do not provide a pathname. `to` can simply be a search or
  // hash string, in which case we should assume that the navigation is relative
  // to the current location's pathname and *not* the route pathname.

  if (isPathRelative || toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/"); // Each leading .. segment means "go up one route" instead of "go up one
      // URL segment".  This is a key difference from how <a href> works and a
      // major reason we call this a "to" value instead of a "href".

      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    } // If there are more ".." segments than parent routes, resolve relative to
    // the root / URL.

    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from); // Ensure the pathname has a trailing slash if the original "to" had one

  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/"); // Or if this was a link to the current path which has a trailing slash

  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
/**
 * @private
 */

function getToPathname(to) {
  // Empty strings should be treated the same as / paths
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? parsePath(to).pathname : to.pathname;
}
/**
 * @private
 */

const joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");
/**
 * @private
 */

const normalizePathname = pathname => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
/**
 * @private
 */

const normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
/**
 * @private
 */

const normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
/**
 * This is a shortcut for creating `application/json` responses. Converts `data`
 * to JSON and sets the `Content-Type` header.
 */

const json = function json(data, init) {
  if (init === void 0) {
    init = {};
  }
  let responseInit = typeof init === "number" ? {
    status: init
  } : init;
  let headers = new Headers(responseInit.headers);
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json; charset=utf-8");
  }
  return new Response(JSON.stringify(data), _extends({}, responseInit, {
    headers
  }));
};
class AbortedDeferredError extends Error {}
class DeferredData {
  constructor(data, responseInit) {
    this.pendingKeysSet = new Set();
    this.subscribers = new Set();
    this.deferredKeys = [];
    invariant(data && typeof data === "object" && !Array.isArray(data), "defer() only accepts plain objects"); // Set up an AbortController + Promise we can race against to exit early
    // cancellation

    let reject;
    this.abortPromise = new Promise((_, r) => reject = r);
    this.controller = new AbortController();
    let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));
    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort);
    this.controller.signal.addEventListener("abort", onAbort);
    this.data = Object.entries(data).reduce((acc, _ref) => {
      let [key, value] = _ref;
      return Object.assign(acc, {
        [key]: this.trackPromise(key, value)
      });
    }, {});
    if (this.done) {
      // All incoming values were resolved
      this.unlistenAbortSignal();
    }
    this.init = responseInit;
  }
  trackPromise(key, value) {
    if (!(value instanceof Promise)) {
      return value;
    }
    this.deferredKeys.push(key);
    this.pendingKeysSet.add(key); // We store a little wrapper promise that will be extended with
    // _data/_error props upon resolve/reject

    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, null, data), error => this.onSettle(promise, key, error)); // Register rejection listeners to avoid uncaught promise rejections on
    // errors or aborted deferred values

    promise.catch(() => {});
    Object.defineProperty(promise, "_tracked", {
      get: () => true
    });
    return promise;
  }
  onSettle(promise, key, error, data) {
    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {
      this.unlistenAbortSignal();
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      return Promise.reject(error);
    }
    this.pendingKeysSet.delete(key);
    if (this.done) {
      // Nothing left to abort!
      this.unlistenAbortSignal();
    }
    if (error) {
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      this.emit(false, key);
      return Promise.reject(error);
    }
    Object.defineProperty(promise, "_data", {
      get: () => data
    });
    this.emit(false, key);
    return data;
  }
  emit(aborted, settledKey) {
    this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));
  }
  subscribe(fn) {
    this.subscribers.add(fn);
    return () => this.subscribers.delete(fn);
  }
  cancel() {
    this.controller.abort();
    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));
    this.emit(true);
  }
  async resolveData(signal) {
    let aborted = false;
    if (!this.done) {
      let onAbort = () => this.cancel();
      signal.addEventListener("abort", onAbort);
      aborted = await new Promise(resolve => {
        this.subscribe(aborted => {
          signal.removeEventListener("abort", onAbort);
          if (aborted || this.done) {
            resolve(aborted);
          }
        });
      });
    }
    return aborted;
  }
  get done() {
    return this.pendingKeysSet.size === 0;
  }
  get unwrappedData() {
    invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds");
    return Object.entries(this.data).reduce((acc, _ref2) => {
      let [key, value] = _ref2;
      return Object.assign(acc, {
        [key]: unwrapTrackedPromise(value)
      });
    }, {});
  }
  get pendingKeys() {
    return Array.from(this.pendingKeysSet);
  }
}
function isTrackedPromise(value) {
  return value instanceof Promise && value._tracked === true;
}
function unwrapTrackedPromise(value) {
  if (!isTrackedPromise(value)) {
    return value;
  }
  if (value._error) {
    throw value._error;
  }
  return value._data;
}
const defer = function defer(data, init) {
  if (init === void 0) {
    init = {};
  }
  let responseInit = typeof init === "number" ? {
    status: init
  } : init;
  return new DeferredData(data, responseInit);
};
/**
 * A redirect response. Sets the status code and the `Location` header.
 * Defaults to "302 Found".
 */

const redirect = function redirect(url, init) {
  if (init === void 0) {
    init = 302;
  }
  let responseInit = init;
  if (typeof responseInit === "number") {
    responseInit = {
      status: responseInit
    };
  } else if (typeof responseInit.status === "undefined") {
    responseInit.status = 302;
  }
  let headers = new Headers(responseInit.headers);
  headers.set("Location", url);
  return new Response(null, _extends({}, responseInit, {
    headers
  }));
};
/**
 * @private
 * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies
 */

class ErrorResponse {
  constructor(status, statusText, data, internal) {
    if (internal === void 0) {
      internal = false;
    }
    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;
    if (data instanceof Error) {
      this.data = data.toString();
      this.error = data;
    } else {
      this.data = data;
    }
  }
}
/**
 * Check if the given error is an ErrorResponse generated from a 4xx/5xx
 * Response thrown from an action/loader
 */

function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
const validMutationMethods = new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
const validRequestMethods = new Set(validRequestMethodsArr);
const redirectStatusCodes = new Set([301, 302, 303, 307, 308]);
const redirectPreserveMethodStatusCodes = new Set([307, 308]);
const IDLE_NAVIGATION = {
  state: "idle",
  location: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined
};
const IDLE_FETCHER = {
  state: "idle",
  data: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined
};
const IDLE_BLOCKER = {
  state: "unblocked",
  proceed: undefined,
  reset: undefined,
  location: undefined
};
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const isServer = !isBrowser; //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region createRouter
////////////////////////////////////////////////////////////////////////////////

/**
 * Create a router and listen to history POP navigations
 */

function createRouter(init) {
  invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let dataRoutes = convertRoutesToDataRoutes(init.routes); // Cleanup function for history

  let unlistenHistory = null; // Externally-provided functions to call on all state changes

  let subscribers = new Set(); // Externally-provided object to hold scroll restoration locations during routing

  let savedScrollPositions = null; // Externally-provided function to get scroll restoration keys

  let getScrollRestorationKey = null; // Externally-provided function to get current scroll position

  let getScrollPosition = null; // One-time flag to control the initial hydration scroll restoration.  Because
  // we don't get the saved positions from <ScrollRestoration /> until _after_
  // the initial render, we need to manually trigger a separate updateState to
  // send along the restoreScrollPosition
  // Set to true if we have `hydrationData` since we assume we were SSR'd and that
  // SSR did the initial scroll restoration.

  let initialScrollRestored = init.hydrationData != null;
  let initialMatches = matchRoutes(dataRoutes, init.history.location, init.basename);
  let initialErrors = null;
  if (initialMatches == null) {
    // If we do not match a user-provided-route, fall back to the root
    // to allow the error boundary to take over
    let error = getInternalRouterError(404, {
      pathname: init.history.location.pathname
    });
    let {
      matches,
      route
    } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches;
    initialErrors = {
      [route.id]: error
    };
  }
  let initialized = !initialMatches.some(m => m.route.loader) || init.hydrationData != null;
  let router;
  let state = {
    historyAction: init.history.action,
    location: init.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init.hydrationData != null ? false : null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: init.hydrationData && init.hydrationData.loaderData || {},
    actionData: init.hydrationData && init.hydrationData.actionData || null,
    errors: init.hydrationData && init.hydrationData.errors || initialErrors,
    fetchers: new Map(),
    blockers: new Map()
  }; // -- Stateful internal variables to manage navigations --
  // Current navigation in progress (to be committed in completeNavigation)

  let pendingAction = Action.Pop; // Should the current navigation prevent the scroll reset if scroll cannot
  // be restored?

  let pendingPreventScrollReset = false; // AbortController for the active navigation

  let pendingNavigationController; // We use this to avoid touching history in completeNavigation if a
  // revalidation is entirely uninterrupted

  let isUninterruptedRevalidation = false; // Use this internal flag to force revalidation of all loaders:
  //  - submissions (completed or interrupted)
  //  - useRevalidate()
  //  - X-Remix-Revalidate (from redirect)

  let isRevalidationRequired = false; // Use this internal array to capture routes that require revalidation due
  // to a cancelled deferred on action submission

  let cancelledDeferredRoutes = []; // Use this internal array to capture fetcher loads that were cancelled by an
  // action navigation and require revalidation

  let cancelledFetcherLoads = []; // AbortControllers for any in-flight fetchers

  let fetchControllers = new Map(); // Track loads based on the order in which they started

  let incrementingLoadId = 0; // Track the outstanding pending navigation data load to be compared against
  // the globally incrementing load when a fetcher load lands after a completed
  // navigation

  let pendingNavigationLoadId = -1; // Fetchers that triggered data reloads as a result of their actions

  let fetchReloadIds = new Map(); // Fetchers that triggered redirect navigations from their actions

  let fetchRedirectIds = new Set(); // Most recent href/match for fetcher.load calls for fetchers

  let fetchLoadMatches = new Map(); // Store DeferredData instances for active route matches.  When a
  // route loader returns defer() we stick one in here.  Then, when a nested
  // promise resolves we update loaderData.  If a new navigation starts we
  // cancel active deferreds for eliminated routes.

  let activeDeferreds = new Map(); // Store blocker functions in a separate Map outside of router state since
  // we don't need to update UI state if they change

  let blockerFunctions = new Map(); // Flag to ignore the next history update, so we can revert the URL change on
  // a POP navigation that was blocked by the user without touching router state

  let ignoreNextHistoryUpdate = false; // Initialize the router, all side effects should be kicked off from here.
  // Implemented as a Fluent API for ease of:
  //   let router = createRouter(init).initialize();

  function initialize() {
    // If history informs us of a POP navigation, start the navigation but do not update
    // state.  We'll update our own state once the navigation completes
    unlistenHistory = init.history.listen(_ref => {
      let {
        action: historyAction,
        location,
        delta
      } = _ref;

      // Ignore this event if it was just us resetting the URL from a
      // blocked POP navigation
      if (ignoreNextHistoryUpdate) {
        ignoreNextHistoryUpdate = false;
        return;
      }
      warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location " + "that was not created by @remix-run/router. This will fail silently in " + "production. This can happen if you are navigating outside the router " + "via `window.history.pushState`/`window.location.hash` instead of using " + "router navigation APIs.  This can also happen if you are using " + "createHashRouter and the user manually changes the URL.");
      let blockerKey = shouldBlockNavigation({
        currentLocation: state.location,
        nextLocation: location,
        historyAction
      });
      if (blockerKey && delta != null) {
        // Restore the URL to match the current UI, but don't update router state
        ignoreNextHistoryUpdate = true;
        init.history.go(delta * -1); // Put the blocker into a blocked state

        updateBlocker(blockerKey, {
          state: "blocked",
          location,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: undefined,
              reset: undefined,
              location
            }); // Re-do the same POP navigation we just blocked

            init.history.go(delta);
          },
          reset() {
            deleteBlocker(blockerKey);
            updateState({
              blockers: new Map(router.state.blockers)
            });
          }
        });
        return;
      }
      return startNavigation(historyAction, location);
    }); // Kick off initial data load if needed.  Use Pop to avoid modifying history

    if (!state.initialized) {
      startNavigation(Action.Pop, state.location);
    }
    return router;
  } // Clean up a router and it's side effects

  function dispose() {
    if (unlistenHistory) {
      unlistenHistory();
    }
    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_, key) => deleteFetcher(key));
    state.blockers.forEach((_, key) => deleteBlocker(key));
  } // Subscribe to state updates for the router

  function subscribe(fn) {
    subscribers.add(fn);
    return () => subscribers.delete(fn);
  } // Update our state and notify the calling context of the change

  function updateState(newState) {
    state = _extends({}, state, newState);
    subscribers.forEach(subscriber => subscriber(state));
  } // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION
  // and setting state.[historyAction/location/matches] to the new route.
  // - Location is a required param
  // - Navigation will always be set to IDLE_NAVIGATION
  // - Can pass any other state in newState

  function completeNavigation(location, newState) {
    var _location$state, _location$state2;

    // Deduce if we're in a loading/actionReload state:
    // - We have committed actionData in the store
    // - The current navigation was a mutation submission
    // - We're past the submitting state and into the loading state
    // - The location being loaded is not the result of a redirect
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;
    let actionData;
    if (newState.actionData) {
      if (Object.keys(newState.actionData).length > 0) {
        actionData = newState.actionData;
      } else {
        // Empty actionData -> clear prior actionData due to an action error
        actionData = null;
      }
    } else if (isActionReload) {
      // Keep the current data if we're wrapping up the action reload
      actionData = state.actionData;
    } else {
      // Clear actionData on any other completed navigations
      actionData = null;
    } // Always preserve any existing loaderData from re-used routes

    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData; // On a successful navigation we can assume we got through all blockers
    // so we can start fresh

    for (let [key] of blockerFunctions) {
      deleteBlocker(key);
    } // Always respect the user flag.  Otherwise don't reset on mutation
    // submission navigations unless they redirect

    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;
    updateState(_extends({}, newState, {
      actionData,
      loaderData,
      historyAction: pendingAction,
      location,
      initialized: true,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
      preventScrollReset,
      blockers: new Map(state.blockers)
    }));
    if (isUninterruptedRevalidation) ;else if (pendingAction === Action.Pop) ;else if (pendingAction === Action.Push) {
      init.history.push(location, location.state);
    } else if (pendingAction === Action.Replace) {
      init.history.replace(location, location.state);
    } // Reset stateful navigation vars

    pendingAction = Action.Pop;
    pendingPreventScrollReset = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    cancelledDeferredRoutes = [];
    cancelledFetcherLoads = [];
  } // Trigger a navigation event, which can either be a numerical POP or a PUSH
  // replace with an optional submission

  async function navigate(to, opts) {
    if (typeof to === "number") {
      init.history.go(to);
      return;
    }
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(to, opts);
    let currentLocation = state.location;
    let nextLocation = createLocation(state.location, path, opts && opts.state); // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded
    // URL from window.location, so we need to encode it here so the behavior
    // remains the same as POP and non-data-router usages.  new URL() does all
    // the same encoding we'd get from a history.pushState/window.location read
    // without having to touch history

    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));
    let userReplace = opts && opts.replace != null ? opts.replace : undefined;
    let historyAction = Action.Push;
    if (userReplace === true) {
      historyAction = Action.Replace;
    } else if (userReplace === false) ;else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
      // By default on submissions to the current location we REPLACE so that
      // users don't have to double-click the back button to get to the prior
      // location.  If the user redirects to a different location from the
      // action/loader this will be ignored and the redirect will be a PUSH
      historyAction = Action.Replace;
    }
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : undefined;
    let blockerKey = shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    });
    if (blockerKey) {
      // Put the blocker into a blocked state
      updateBlocker(blockerKey, {
        state: "blocked",
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, {
            state: "proceeding",
            proceed: undefined,
            reset: undefined,
            location: nextLocation
          }); // Send the same navigation through

          navigate(to, opts);
        },
        reset() {
          deleteBlocker(blockerKey);
          updateState({
            blockers: new Map(state.blockers)
          });
        }
      });
      return;
    }
    return await startNavigation(historyAction, nextLocation, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace
    });
  } // Revalidate all current loaders.  If a navigation is in progress or if this
  // is interrupted by a navigation, allow this to "succeed" by calling all
  // loaders during the next loader round

  function revalidate() {
    interruptActiveLoads();
    updateState({
      revalidation: "loading"
    }); // If we're currently submitting an action, we don't need to start a new
    // navigation, we'll just let the follow up loader execution call all loaders

    if (state.navigation.state === "submitting") {
      return;
    } // If we're currently in an idle state, start a new navigation for the current
    // action/location and mark it as uninterrupted, which will skip the history
    // update in completeNavigation

    if (state.navigation.state === "idle") {
      startNavigation(state.historyAction, state.location, {
        startUninterruptedRevalidation: true
      });
      return;
    } // Otherwise, if we're currently in a loading state, just start a new
    // navigation to the navigation.location but do not trigger an uninterrupted
    // revalidation so that history correctly updates once the navigation completes

    startNavigation(pendingAction || state.historyAction, state.navigation.location, {
      overrideNavigation: state.navigation
    });
  } // Start a navigation to the given action/location.  Can optionally provide a
  // overrideNavigation which will override the normalLoad in the case of a redirect
  // navigation

  async function startNavigation(historyAction, location, opts) {
    // Abort any in-progress navigations and start a new one. Unset any ongoing
    // uninterrupted revalidations unless told otherwise, since we want this
    // new navigation to update history normally
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true; // Save the current scroll position every time we start a new navigation,
    // and track whether we should reset scroll on completion

    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    let loadingNavigation = opts && opts.overrideNavigation;
    let matches = matchRoutes(dataRoutes, location, init.basename); // Short circuit with a 404 on the root error boundary if we match nothing

    if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(dataRoutes); // Cancel all pending deferred on 404s since we don't keep any routes

      cancelActiveDeferreds();
      completeNavigation(location, {
        matches: notFoundMatches,
        loaderData: {},
        errors: {
          [route.id]: error
        }
      });
      return;
    } // Short circuit if it's only a hash change and not a mutation submission
    // For example, on /page#hash and submit a <Form method="post"> which will
    // default to a navigation to /page

    if (isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
      completeNavigation(location, {
        matches
      });
      return;
    } // Create a controller/Request for this navigation

    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);
    let pendingActionData;
    let pendingError;
    if (opts && opts.pendingError) {
      // If we have a pendingError, it means the user attempted a GET submission
      // with binary FormData so assign here and skip to handleLoaders.  That
      // way we handle calling loaders above the boundary etc.  It's not really
      // different from an actionError in that sense.
      pendingError = {
        [findNearestBoundary(matches).route.id]: opts.pendingError
      };
    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      // Call action if we received an action submission
      let actionOutput = await handleAction(request, location, opts.submission, matches, {
        replace: opts.replace
      });
      if (actionOutput.shortCircuited) {
        return;
      }
      pendingActionData = actionOutput.pendingActionData;
      pendingError = actionOutput.pendingActionError;
      let navigation = _extends({
        state: "loading",
        location
      }, opts.submission);
      loadingNavigation = navigation; // Create a GET request for the loaders

      request = new Request(request.url, {
        signal: request.signal
      });
    } // Call loaders

    let {
      shortCircuited,
      loaderData,
      errors
    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.replace, pendingActionData, pendingError);
    if (shortCircuited) {
      return;
    } // Clean up now that the action/loaders have completed.  Don't clean up if
    // we short circuited because pendingNavigationController will have already
    // been assigned to a new controller for the next navigation

    pendingNavigationController = null;
    completeNavigation(location, _extends({
      matches
    }, pendingActionData ? {
      actionData: pendingActionData
    } : {}, {
      loaderData,
      errors
    }));
  } // Call the action matched by the leaf route for this navigation and handle
  // redirects/errors

  async function handleAction(request, location, submission, matches, opts) {
    interruptActiveLoads(); // Put us in a submitting state

    let navigation = _extends({
      state: "submitting",
      location
    }, submission);
    updateState({
      navigation
    }); // Call our action and get the result

    let result;
    let actionMatch = getTargetMatch(matches, location);
    if (!actionMatch.route.action) {
      result = {
        type: ResultType.error,
        error: getInternalRouterError(405, {
          method: request.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id
        })
      };
    } else {
      result = await callLoaderOrAction("action", request, actionMatch, matches, router.basename);
      if (request.signal.aborted) {
        return {
          shortCircuited: true
        };
      }
    }
    if (isRedirectResult(result)) {
      let replace;
      if (opts && opts.replace != null) {
        replace = opts.replace;
      } else {
        // If the user didn't explicity indicate replace behavior, replace if
        // we redirected to the exact same location we're currently at to avoid
        // double back-buttons
        replace = result.location === state.location.pathname + state.location.search;
      }
      await startRedirectNavigation(state, result, {
        submission,
        replace
      });
      return {
        shortCircuited: true
      };
    }
    if (isErrorResult(result)) {
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id); // By default, all submissions are REPLACE navigations, but if the
      // action threw an error that'll be rendered in an errorElement, we fall
      // back to PUSH so that the user can use the back button to get back to
      // the pre-submission form location to try again

      if ((opts && opts.replace) !== true) {
        pendingAction = Action.Push;
      }
      return {
        // Send back an empty object we can use to clear out any prior actionData
        pendingActionData: {},
        pendingActionError: {
          [boundaryMatch.route.id]: result.error
        }
      };
    }
    if (isDeferredResult(result)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    return {
      pendingActionData: {
        [actionMatch.route.id]: result.data
      }
    };
  } // Call all applicable loaders for the given matches, handling redirects,
  // errors, etc.

  async function handleLoaders(request, location, matches, overrideNavigation, submission, replace, pendingActionData, pendingError) {
    // Figure out the right navigation we want to use for data loading
    let loadingNavigation = overrideNavigation;
    if (!loadingNavigation) {
      let navigation = _extends({
        state: "loading",
        location,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined
      }, submission);
      loadingNavigation = navigation;
    } // If this was a redirect from an action we don't have a "submission" but
    // we have it on the loading navigation so use that if available

    let activeSubmission = submission ? submission : loadingNavigation.formMethod && loadingNavigation.formAction && loadingNavigation.formData && loadingNavigation.formEncType ? {
      formMethod: loadingNavigation.formMethod,
      formAction: loadingNavigation.formAction,
      formData: loadingNavigation.formData,
      formEncType: loadingNavigation.formEncType
    } : undefined;
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, pendingActionData, pendingError, fetchLoadMatches); // Cancel pending deferreds for no-longer-matched routes or routes we're
    // about to reload.  Note that if this is an action reload we would have
    // already cancelled all pending deferreds so this would be a no-op

    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId)); // Short circuit if we have no loaders to run

    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      completeNavigation(location, _extends({
        matches,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: pendingError || null
      }, pendingActionData ? {
        actionData: pendingActionData
      } : {}));
      return {
        shortCircuited: true
      };
    } // If this is an uninterrupted revalidation, we remain in our current idle
    // state.  If not, we need to switch to our loading state and load data,
    // preserving any new action data or existing action data (in the case of
    // a revalidation interrupting an actionReload)

    if (!isUninterruptedRevalidation) {
      revalidatingFetchers.forEach(rf => {
        let fetcher = state.fetchers.get(rf.key);
        let revalidatingFetcher = {
          state: "loading",
          data: fetcher && fetcher.data,
          formMethod: undefined,
          formAction: undefined,
          formEncType: undefined,
          formData: undefined,
          " _hasFetcherDoneAnything ": true
        };
        state.fetchers.set(rf.key, revalidatingFetcher);
      });
      let actionData = pendingActionData || state.actionData;
      updateState(_extends({
        navigation: loadingNavigation
      }, actionData ? Object.keys(actionData).length === 0 ? {
        actionData: null
      } : {
        actionData
      } : {}, revalidatingFetchers.length > 0 ? {
        fetchers: new Map(state.fetchers)
      } : {}));
    }
    pendingNavigationLoadId = ++incrementingLoadId;
    revalidatingFetchers.forEach(rf => fetchControllers.set(rf.key, pendingNavigationController));
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);
    if (request.signal.aborted) {
      return {
        shortCircuited: true
      };
    } // Clean up _after_ loaders have completed.  Don't clean up if we short
    // circuited because fetchControllers would have been aborted and
    // reassigned to new controllers for the next navigation

    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key)); // If any loaders returned a redirect Response, start a new REPLACE navigation

    let redirect = findRedirect(results);
    if (redirect) {
      await startRedirectNavigation(state, redirect, {
        replace
      });
      return {
        shortCircuited: true
      };
    } // Process and commit output from loaders

    let {
      loaderData,
      errors
    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds); // Wire up subscribers to update loaderData as promises settle

    activeDeferreds.forEach((deferredData, routeId) => {
      deferredData.subscribe(aborted => {
        // Note: No need to updateState here since the TrackedPromise on
        // loaderData is stable across resolve/reject
        // Remove this instance if we were aborted or if promises have settled
        if (aborted || deferredData.done) {
          activeDeferreds.delete(routeId);
        }
      });
    });
    markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    return _extends({
      loaderData,
      errors
    }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {
      fetchers: new Map(state.fetchers)
    } : {});
  }
  function getFetcher(key) {
    return state.fetchers.get(key) || IDLE_FETCHER;
  } // Trigger a fetcher load/submit for the given fetcher key

  function fetch(key, routeId, href, opts) {
    if (isServer) {
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. " + "You are likely calling a useFetcher() method in the body of your component. " + "Try moving it to a useEffect or a callback.");
    }
    if (fetchControllers.has(key)) abortFetcher(key);
    let matches = matchRoutes(dataRoutes, href, init.basename);
    if (!matches) {
      setFetcherError(key, routeId, getInternalRouterError(404, {
        pathname: href
      }));
      return;
    }
    let {
      path,
      submission
    } = normalizeNavigateOptions(href, opts, true);
    let match = getTargetMatch(matches, path);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    if (submission && isMutationMethod(submission.formMethod)) {
      handleFetcherAction(key, routeId, path, match, matches, submission);
      return;
    } // Store off the match so we can call it's shouldRevalidate on subsequent
    // revalidations

    fetchLoadMatches.set(key, {
      routeId,
      path,
      match,
      matches
    });
    handleFetcherLoader(key, routeId, path, match, matches, submission);
  } // Call the action for the matched fetcher.submit(), and then handle redirects,
  // errors, and revalidation

  async function handleFetcherAction(key, routeId, path, match, requestMatches, submission) {
    interruptActiveLoads();
    fetchLoadMatches.delete(key);
    if (!match.route.action) {
      let error = getInternalRouterError(405, {
        method: submission.formMethod,
        pathname: path,
        routeId: routeId
      });
      setFetcherError(key, routeId, error);
      return;
    } // Put this fetcher into it's submitting state

    let existingFetcher = state.fetchers.get(key);
    let fetcher = _extends({
      state: "submitting"
    }, submission, {
      data: existingFetcher && existingFetcher.data,
      " _hasFetcherDoneAnything ": true
    });
    state.fetchers.set(key, fetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    }); // Call the action for the fetcher

    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);
    fetchControllers.set(key, abortController);
    let actionResult = await callLoaderOrAction("action", fetchRequest, match, requestMatches, router.basename);
    if (fetchRequest.signal.aborted) {
      // We can delete this so long as we weren't aborted by ou our own fetcher
      // re-submit which would have put _new_ controller is in fetchControllers
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      return;
    }
    if (isRedirectResult(actionResult)) {
      fetchControllers.delete(key);
      fetchRedirectIds.add(key);
      let loadingFetcher = _extends({
        state: "loading"
      }, submission, {
        data: undefined,
        " _hasFetcherDoneAnything ": true
      });
      state.fetchers.set(key, loadingFetcher);
      updateState({
        fetchers: new Map(state.fetchers)
      });
      return startRedirectNavigation(state, actionResult, {
        isFetchActionRedirect: true
      });
    } // Process any non-redirect errors thrown

    if (isErrorResult(actionResult)) {
      setFetcherError(key, routeId, actionResult.error);
      return;
    }
    if (isDeferredResult(actionResult)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    } // Start the data load for current matches, or the next location if we're
    // in the middle of a navigation

    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);
    let matches = state.navigation.state !== "idle" ? matchRoutes(dataRoutes, state.navigation.location, init.basename) : state.matches;
    invariant(matches, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let loadFetcher = _extends({
      state: "loading",
      data: actionResult.data
    }, submission, {
      " _hasFetcherDoneAnything ": true
    });
    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, {
      [match.route.id]: actionResult.data
    }, undefined,
    // No need to send through errors since we short circuit above
    fetchLoadMatches); // Put all revalidating fetchers into the loading state, except for the
    // current fetcher which we want to keep in it's current loading state which
    // contains it's action submission info + action data

    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {
      let staleKey = rf.key;
      let existingFetcher = state.fetchers.get(staleKey);
      let revalidatingFetcher = {
        state: "loading",
        data: existingFetcher && existingFetcher.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true
      };
      state.fetchers.set(staleKey, revalidatingFetcher);
      fetchControllers.set(staleKey, abortController);
    });
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
    if (abortController.signal.aborted) {
      return;
    }
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));
    let redirect = findRedirect(results);
    if (redirect) {
      return startRedirectNavigation(state, redirect);
    } // Process and commit output from loaders

    let {
      loaderData,
      errors
    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);
    let doneFetcher = {
      state: "idle",
      data: actionResult.data,
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      " _hasFetcherDoneAnything ": true
    };
    state.fetchers.set(key, doneFetcher);
    let didAbortFetchLoads = abortStaleFetchLoads(loadId); // If we are currently in a navigation loading state and this fetcher is
    // more recent than the navigation, we want the newer data so abort the
    // navigation and complete it with the fetcher data

    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
      invariant(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();
      completeNavigation(state.navigation.location, {
        matches,
        loaderData,
        errors,
        fetchers: new Map(state.fetchers)
      });
    } else {
      // otherwise just update with the fetcher data, preserving any existing
      // loaderData for loaders that did not need to reload.  We have to
      // manually merge here since we aren't going through completeNavigation
      updateState(_extends({
        errors,
        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors)
      }, didAbortFetchLoads ? {
        fetchers: new Map(state.fetchers)
      } : {}));
      isRevalidationRequired = false;
    }
  } // Call the matched loader for fetcher.load(), handling redirects, errors, etc.

  async function handleFetcherLoader(key, routeId, path, match, matches, submission) {
    let existingFetcher = state.fetchers.get(key); // Put this fetcher into it's loading state

    let loadingFetcher = _extends({
      state: "loading",
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined
    }, submission, {
      data: existingFetcher && existingFetcher.data,
      " _hasFetcherDoneAnything ": true
    });
    state.fetchers.set(key, loadingFetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    }); // Call the loader for this fetcher route match

    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);
    fetchControllers.set(key, abortController);
    let result = await callLoaderOrAction("loader", fetchRequest, match, matches, router.basename); // Deferred isn't supported for fetcher loads, await everything and treat it
    // as a normal load.  resolveDeferredData will return undefined if this
    // fetcher gets aborted, so we just leave result untouched and short circuit
    // below if that happens

    if (isDeferredResult(result)) {
      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;
    } // We can delete this so long as we weren't aborted by ou our own fetcher
    // re-load which would have put _new_ controller is in fetchControllers

    if (fetchControllers.get(key) === abortController) {
      fetchControllers.delete(key);
    }
    if (fetchRequest.signal.aborted) {
      return;
    } // If the loader threw a redirect Response, start a new REPLACE navigation

    if (isRedirectResult(result)) {
      await startRedirectNavigation(state, result);
      return;
    } // Process any non-redirect errors thrown

    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, routeId);
      state.fetchers.delete(key); // TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -
      // do we need to behave any differently with our non-redirect errors?
      // What if it was a non-redirect Response?

      updateState({
        fetchers: new Map(state.fetchers),
        errors: {
          [boundaryMatch.route.id]: result.error
        }
      });
      return;
    }
    invariant(!isDeferredResult(result), "Unhandled fetcher deferred data"); // Put the fetcher back into an idle state

    let doneFetcher = {
      state: "idle",
      data: result.data,
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      " _hasFetcherDoneAnything ": true
    };
    state.fetchers.set(key, doneFetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    });
  }
  /**
   * Utility function to handle redirects returned from an action or loader.
   * Normally, a redirect "replaces" the navigation that triggered it.  So, for
   * example:
   *
   *  - user is on /a
   *  - user clicks a link to /b
   *  - loader for /b redirects to /c
   *
   * In a non-JS app the browser would track the in-flight navigation to /b and
   * then replace it with /c when it encountered the redirect response.  In
   * the end it would only ever update the URL bar with /c.
   *
   * In client-side routing using pushState/replaceState, we aim to emulate
   * this behavior and we also do not update history until the end of the
   * navigation (including processed redirects).  This means that we never
   * actually touch history until we've processed redirects, so we just use
   * the history action from the original navigation (PUSH or REPLACE).
   */

  async function startRedirectNavigation(state, redirect, _temp) {
    var _window;
    let {
      submission,
      replace,
      isFetchActionRedirect
    } = _temp === void 0 ? {} : _temp;
    if (redirect.revalidate) {
      isRevalidationRequired = true;
    }
    let redirectLocation = createLocation(state.location, redirect.location,
    // TODO: This can be removed once we get rid of useTransition in Remix v2
    _extends({
      _isRedirect: true
    }, isFetchActionRedirect ? {
      _isFetchActionRedirect: true
    } : {}));
    invariant(redirectLocation, "Expected a location on the redirect navigation"); // Check if this an absolute external redirect that goes to a new origin

    if (ABSOLUTE_URL_REGEX.test(redirect.location) && isBrowser && typeof ((_window = window) == null ? void 0 : _window.location) !== "undefined") {
      let newOrigin = init.history.createURL(redirect.location).origin;
      if (window.location.origin !== newOrigin) {
        if (replace) {
          window.location.replace(redirect.location);
        } else {
          window.location.assign(redirect.location);
        }
        return;
      }
    } // There's no need to abort on redirects, since we don't detect the
    // redirect until the action/loaders have settled

    pendingNavigationController = null;
    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push; // Use the incoming submission if provided, fallback on the active one in
    // state.navigation

    let {
      formMethod,
      formAction,
      formEncType,
      formData
    } = state.navigation;
    if (!submission && formMethod && formAction && formData && formEncType) {
      submission = {
        formMethod,
        formAction,
        formEncType,
        formData
      };
    } // If this was a 307/308 submission we want to preserve the HTTP method and
    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the
    // redirected location

    if (redirectPreserveMethodStatusCodes.has(redirect.status) && submission && isMutationMethod(submission.formMethod)) {
      await startNavigation(redirectHistoryAction, redirectLocation, {
        submission: _extends({}, submission, {
          formAction: redirect.location
        }),
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    } else {
      // Otherwise, we kick off a new loading navigation, preserving the
      // submission info for the duration of this navigation
      await startNavigation(redirectHistoryAction, redirectLocation, {
        overrideNavigation: {
          state: "loading",
          location: redirectLocation,
          formMethod: submission ? submission.formMethod : undefined,
          formAction: submission ? submission.formAction : undefined,
          formEncType: submission ? submission.formEncType : undefined,
          formData: submission ? submission.formData : undefined
        },
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    }
  }
  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {
    // Call all navigation loaders and revalidating fetcher loaders in parallel,
    // then slice off the results into separate arrays so we can handle them
    // accordingly
    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, router.basename)), ...fetchersToLoad.map(f => callLoaderOrAction("loader", createClientSideRequest(init.history, f.path, request.signal), f.match, f.matches, router.basename))]);
    let loaderResults = results.slice(0, matchesToLoad.length);
    let fetcherResults = results.slice(matchesToLoad.length);
    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, request.signal, false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(f => f.match), fetcherResults, request.signal, true)]);
    return {
      results,
      loaderResults,
      fetcherResults
    };
  }
  function interruptActiveLoads() {
    // Every interruption triggers a revalidation
    isRevalidationRequired = true; // Cancel pending route-level deferreds and mark cancelled routes for
    // revalidation

    cancelledDeferredRoutes.push(...cancelActiveDeferreds()); // Abort in-flight fetcher loads

    fetchLoadMatches.forEach((_, key) => {
      if (fetchControllers.has(key)) {
        cancelledFetcherLoads.push(key);
        abortFetcher(key);
      }
    });
  }
  function setFetcherError(key, routeId, error) {
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState({
      errors: {
        [boundaryMatch.route.id]: error
      },
      fetchers: new Map(state.fetchers)
    });
  }
  function deleteFetcher(key) {
    if (fetchControllers.has(key)) abortFetcher(key);
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    state.fetchers.delete(key);
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant(controller, "Expected fetch controller: " + key);
    controller.abort();
    fetchControllers.delete(key);
  }
  function markFetchersDone(keys) {
    for (let key of keys) {
      let fetcher = getFetcher(key);
      let doneFetcher = {
        state: "idle",
        data: fetcher.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true
      };
      state.fetchers.set(key, doneFetcher);
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [];
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant(fetcher, "Expected fetcher: " + key);
      if (fetcher.state === "loading") {
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
      }
    }
    markFetchersDone(doneKeys);
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds) {
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, "Expected fetcher: " + key);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
  }
  function getBlocker(key, fn) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    if (blockerFunctions.get(key) !== fn) {
      blockerFunctions.set(key, fn);
    }
    return blocker;
  }
  function deleteBlocker(key) {
    state.blockers.delete(key);
    blockerFunctions.delete(key);
  } // Utility function to update blockers, ensuring valid state transitions

  function updateBlocker(key, newBlocker) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER; // Poor mans state machine :)
    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM

    invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
    state.blockers.set(key, newBlocker);
    updateState({
      blockers: new Map(state.blockers)
    });
  }
  function shouldBlockNavigation(_ref2) {
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = _ref2;
    if (blockerFunctions.size === 0) {
      return;
    } // We ony support a single active blocker at the moment since we don't have
    // any compelling use cases for multi-blocker yet

    if (blockerFunctions.size > 1) {
      warning(false, "A router only supports one blocker at a time");
    }
    let entries = Array.from(blockerFunctions.entries());
    let [blockerKey, blockerFunction] = entries[entries.length - 1];
    let blocker = state.blockers.get(blockerKey);
    if (blocker && blocker.state === "proceeding") {
      // If the blocker is currently proceeding, we don't need to re-check
      // it and can let this navigation continue
      return;
    } // At this point, we know we're unblocked/blocked so we need to check the
    // user-provided blocker function

    if (blockerFunction({
      currentLocation,
      nextLocation,
      historyAction
    })) {
      return blockerKey;
    }
  }
  function cancelActiveDeferreds(predicate) {
    let cancelledRouteIds = [];
    activeDeferreds.forEach((dfd, routeId) => {
      if (!predicate || predicate(routeId)) {
        // Cancel the deferred - but do not remove from activeDeferreds here -
        // we rely on the subscribers to do that so our tests can assert proper
        // cleanup via _internalActiveDeferreds
        dfd.cancel();
        cancelledRouteIds.push(routeId);
        activeDeferreds.delete(routeId);
      }
    });
    return cancelledRouteIds;
  } // Opt in to capturing and reporting scroll positions during navigations,
  // used by the <ScrollRestoration> component

  function enableScrollRestoration(positions, getPosition, getKey) {
    savedScrollPositions = positions;
    getScrollPosition = getPosition;
    getScrollRestorationKey = getKey || (location => location.key); // Perform initial hydration scroll restoration, since we miss the boat on
    // the initial updateState() because we've not yet rendered <ScrollRestoration/>
    // and therefore have no savedScrollPositions available

    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = true;
      let y = getSavedScrollPosition(state.location, state.matches);
      if (y != null) {
        updateState({
          restoreScrollPosition: y
        });
      }
    }
    return () => {
      savedScrollPositions = null;
      getScrollPosition = null;
      getScrollRestorationKey = null;
    };
  }
  function saveScrollPosition(location, matches) {
    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {
      let userMatches = matches.map(m => createUseMatchesMatch(m, state.loaderData));
      let key = getScrollRestorationKey(location, userMatches) || location.key;
      savedScrollPositions[key] = getScrollPosition();
    }
  }
  function getSavedScrollPosition(location, matches) {
    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {
      let userMatches = matches.map(m => createUseMatchesMatch(m, state.loaderData));
      let key = getScrollRestorationKey(location, userMatches) || location.key;
      let y = savedScrollPositions[key];
      if (typeof y === "number") {
        return y;
      }
    }
    return null;
  }
  router = {
    get basename() {
      return init.basename;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    initialize,
    subscribe,
    enableScrollRestoration,
    navigate,
    fetch,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: to => init.history.createHref(to),
    encodeLocation: to => init.history.encodeLocation(to),
    getFetcher,
    deleteFetcher,
    dispose,
    getBlocker,
    deleteBlocker,
    _internalFetchControllers: fetchControllers,
    _internalActiveDeferreds: activeDeferreds
  };
  return router;
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region createStaticHandler
////////////////////////////////////////////////////////////////////////////////

const UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");
function createStaticHandler(routes, opts) {
  invariant(routes.length > 0, "You must provide a non-empty routes array to createStaticHandler");
  let dataRoutes = convertRoutesToDataRoutes(routes);
  let basename = (opts ? opts.basename : null) || "/";
  /**
   * The query() method is intended for document requests, in which we want to
   * call an optional action and potentially multiple loaders for all nested
   * routes.  It returns a StaticHandlerContext object, which is very similar
   * to the router state (location, loaderData, actionData, errors, etc.) and
   * also adds SSR-specific information such as the statusCode and headers
   * from action/loaders Responses.
   *
   * It _should_ never throw and should report all errors through the
   * returned context.errors object, properly associating errors to their error
   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be
   * used to emulate React error boundaries during SSr by performing a second
   * pass only down to the boundaryId.
   *
   * The one exception where we do not return a StaticHandlerContext is when a
   * redirect response is returned or thrown from any action/loader.  We
   * propagate that out and return the raw Response so the HTTP server can
   * return it directly.
   */

  async function query(request, _temp2) {
    let {
      requestContext
    } = _temp2 === void 0 ? {} : _temp2;
    let url = new URL(request.url);
    let method = request.method.toLowerCase();
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename); // SSR supports HEAD requests while SPA doesn't

    if (!isValidMethod(method) && method !== "head") {
      let error = getInternalRouterError(405, {
        method
      });
      let {
        matches: methodNotAllowedMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: methodNotAllowedMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    } else if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: notFoundMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    let result = await queryImpl(request, location, matches, requestContext);
    if (isResponse(result)) {
      return result;
    } // When returning StaticHandlerContext, we patch back in the location here
    // since we need it for React Context.  But this helps keep our submit and
    // loadRouteData operating on a Request instead of a Location

    return _extends({
      location,
      basename
    }, result);
  }
  /**
   * The queryRoute() method is intended for targeted route requests, either
   * for fetch ?_data requests or resource route requests.  In this case, we
   * are only ever calling a single action or loader, and we are returning the
   * returned value directly.  In most cases, this will be a Response returned
   * from the action/loader, but it may be a primitive or other value as well -
   * and in such cases the calling context should handle that accordingly.
   *
   * We do respect the throw/return differentiation, so if an action/loader
   * throws, then this method will throw the value.  This is important so we
   * can do proper boundary identification in Remix where a thrown Response
   * must go to the Catch Boundary but a returned Response is happy-path.
   *
   * One thing to note is that any Router-initiated Errors that make sense
   * to associate with a status code will be thrown as an ErrorResponse
   * instance which include the raw Error, such that the calling context can
   * serialize the error as they see fit while including the proper response
   * code.  Examples here are 404 and 405 errors that occur prior to reaching
   * any user-defined loaders.
   */

  async function queryRoute(request, _temp3) {
    let {
      routeId,
      requestContext
    } = _temp3 === void 0 ? {} : _temp3;
    let url = new URL(request.url);
    let method = request.method.toLowerCase();
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename); // SSR supports HEAD requests while SPA doesn't

    if (!isValidMethod(method) && method !== "head" && method !== "options") {
      throw getInternalRouterError(405, {
        method
      });
    } else if (!matches) {
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }
    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);
    if (routeId && !match) {
      throw getInternalRouterError(403, {
        pathname: location.pathname,
        routeId
      });
    } else if (!match) {
      // This should never hit I don't think?
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }
    let result = await queryImpl(request, location, matches, requestContext, match);
    if (isResponse(result)) {
      return result;
    }
    let error = result.errors ? Object.values(result.errors)[0] : undefined;
    if (error !== undefined) {
      // If we got back result.errors, that means the loader/action threw
      // _something_ that wasn't a Response, but it's not guaranteed/required
      // to be an `instanceof Error` either, so we have to use throw here to
      // preserve the "error" state outside of queryImpl.
      throw error;
    } // Pick off the right state value to return

    if (result.actionData) {
      return Object.values(result.actionData)[0];
    }
    if (result.loaderData) {
      var _result$activeDeferre;
      let data = Object.values(result.loaderData)[0];
      if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {
        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];
      }
      return data;
    }
    return undefined;
  }
  async function queryImpl(request, location, matches, requestContext, routeMatch) {
    invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");
    try {
      if (isMutationMethod(request.method.toLowerCase())) {
        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);
        return result;
      }
      let result = await loadRouteData(request, matches, requestContext, routeMatch);
      return isResponse(result) ? result : _extends({}, result, {
        actionData: null,
        actionHeaders: {}
      });
    } catch (e) {
      // If the user threw/returned a Response in callLoaderOrAction, we throw
      // it to bail out and then return or throw here based on whether the user
      // returned or threw
      if (isQueryRouteResponse(e)) {
        if (e.type === ResultType.error && !isRedirectResponse(e.response)) {
          throw e.response;
        }
        return e.response;
      } // Redirects are always returned since they don't propagate to catch
      // boundaries

      if (isRedirectResponse(e)) {
        return e;
      }
      throw e;
    }
  }
  async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {
    let result;
    if (!actionMatch.route.action) {
      let error = getInternalRouterError(405, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: actionMatch.route.id
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: ResultType.error,
        error
      };
    } else {
      result = await callLoaderOrAction("action", request, actionMatch, matches, basename, true, isRouteRequest, requestContext);
      if (request.signal.aborted) {
        let method = isRouteRequest ? "queryRoute" : "query";
        throw new Error(method + "() call aborted");
      }
    }
    if (isRedirectResult(result)) {
      // Uhhhh - this should never happen, we should always throw these from
      // callLoaderOrAction, but the type narrowing here keeps TS happy and we
      // can get back on the "throw all redirect responses" train here should
      // this ever happen :/
      throw new Response(null, {
        status: result.status,
        headers: {
          Location: result.location
        }
      });
    }
    if (isDeferredResult(result)) {
      let error = getInternalRouterError(400, {
        type: "defer-action"
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: ResultType.error,
        error
      };
    }
    if (isRouteRequest) {
      // Note: This should only be non-Response values if we get here, since
      // isRouteRequest should throw any Response received in callLoaderOrAction
      if (isErrorResult(result)) {
        throw result.error;
      }
      return {
        matches: [actionMatch],
        loaderData: {},
        actionData: {
          [actionMatch.route.id]: result.data
        },
        errors: null,
        // Note: statusCode + headers are unused here since queryRoute will
        // return the raw Response or value
        statusCode: 200,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    if (isErrorResult(result)) {
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      let context = await loadRouteData(request, matches, requestContext, undefined, {
        [boundaryMatch.route.id]: result.error
      }); // action status codes take precedence over loader status codes

      return _extends({}, context, {
        statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,
        actionData: null,
        actionHeaders: _extends({}, result.headers ? {
          [actionMatch.route.id]: result.headers
        } : {})
      });
    } // Create a GET request for the loaders

    let loaderRequest = new Request(request.url, {
      headers: request.headers,
      redirect: request.redirect,
      signal: request.signal
    });
    let context = await loadRouteData(loaderRequest, matches, requestContext);
    return _extends({}, context, result.statusCode ? {
      statusCode: result.statusCode
    } : {}, {
      actionData: {
        [actionMatch.route.id]: result.data
      },
      actionHeaders: _extends({}, result.headers ? {
        [actionMatch.route.id]: result.headers
      } : {})
    });
  }
  async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {
    let isRouteRequest = routeMatch != null; // Short circuit if we have no loaders to run (queryRoute())

    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader)) {
      throw getInternalRouterError(400, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: routeMatch == null ? void 0 : routeMatch.route.id
      });
    }
    let requestMatches = routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);
    let matchesToLoad = requestMatches.filter(m => m.route.loader); // Short circuit if we have no loaders to run (query())

    if (matchesToLoad.length === 0) {
      return {
        matches,
        // Add a null for all matched routes for proper revalidation on the client
        loaderData: matches.reduce((acc, m) => Object.assign(acc, {
          [m.route.id]: null
        }), {}),
        errors: pendingActionError || null,
        statusCode: 200,
        loaderHeaders: {},
        activeDeferreds: null
      };
    }
    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, basename, true, isRouteRequest, requestContext))]);
    if (request.signal.aborted) {
      let method = isRouteRequest ? "queryRoute" : "query";
      throw new Error(method + "() call aborted");
    } // Process and commit output from loaders

    let activeDeferreds = new Map();
    let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds); // Add a null for any non-loader matches for proper revalidation on the client

    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));
    matches.forEach(match => {
      if (!executedLoaders.has(match.route.id)) {
        context.loaderData[match.route.id] = null;
      }
    });
    return _extends({}, context, {
      matches,
      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null
    });
  }
  return {
    dataRoutes,
    query,
    queryRoute
  };
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Helpers
////////////////////////////////////////////////////////////////////////////////

/**
 * Given an existing StaticHandlerContext and an error thrown at render time,
 * provide an updated StaticHandlerContext suitable for a second SSR render
 */

function getStaticContextFromError(routes, context, error) {
  let newContext = _extends({}, context, {
    statusCode: 500,
    errors: {
      [context._deepestRenderedBoundaryId || routes[0].id]: error
    }
  });
  return newContext;
}
function isSubmissionNavigation(opts) {
  return opts != null && "formData" in opts;
} // Normalize navigation options by converting formMethod=GET formData objects to
// URLSearchParams so they behave identically to links with query params

function normalizeNavigateOptions(to, opts, isFetcher) {
  if (isFetcher === void 0) {
    isFetcher = false;
  }
  let path = typeof to === "string" ? to : createPath(to); // Return location verbatim on non-submission navigations

  if (!opts || !isSubmissionNavigation(opts)) {
    return {
      path
    };
  }
  if (opts.formMethod && !isValidMethod(opts.formMethod)) {
    return {
      path,
      error: getInternalRouterError(405, {
        method: opts.formMethod
      })
    };
  } // Create a Submission on non-GET navigations

  let submission;
  if (opts.formData) {
    submission = {
      formMethod: opts.formMethod || "get",
      formAction: stripHashFromPath(path),
      formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
      formData: opts.formData
    };
    if (isMutationMethod(submission.formMethod)) {
      return {
        path,
        submission
      };
    }
  } // Flatten submission onto URLSearchParams for GET submissions

  let parsedPath = parsePath(path);
  let searchParams = convertFormDataToSearchParams(opts.formData); // Since fetcher GET submissions only run a single loader (as opposed to
  // navigation GET submissions which run all loaders), we need to preserve
  // any incoming ?index params

  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
    searchParams.append("index", "");
  }
  parsedPath.search = "?" + searchParams;
  return {
    path: createPath(parsedPath),
    submission
  };
} // Filter out all routes below any caught error as they aren't going to
// render so we don't need to load them

function getLoaderMatchesUntilBoundary(matches, boundaryId) {
  let boundaryMatches = matches;
  if (boundaryId) {
    let index = matches.findIndex(m => m.route.id === boundaryId);
    if (index >= 0) {
      boundaryMatches = matches.slice(0, index);
    }
  }
  return boundaryMatches;
}
function getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, pendingActionData, pendingError, fetchLoadMatches) {
  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;
  let currentUrl = history.createURL(state.location);
  let nextUrl = history.createURL(location);
  let defaultShouldRevalidate =
  // Forced revalidation due to submission, useRevalidate, or X-Remix-Revalidate
  isRevalidationRequired ||
  // Clicked the same link, resubmitted a GET form
  currentUrl.toString() === nextUrl.toString() ||
  // Search params affect all loaders
  currentUrl.search !== nextUrl.search; // Pick navigation matches that are net-new or qualify for revalidation

  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;
  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);
  let navigationMatches = boundaryMatches.filter((match, index) => {
    if (match.route.loader == null) {
      return false;
    } // Always call the loader on new route instances and pending defer cancellations

    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {
      return true;
    } // This is the default implementation for when we revalidate.  If the route
    // provides it's own implementation, then we give them full control but
    // provide this value so they can leverage it if needed after they check
    // their own specific use cases

    let currentRouteMatch = state.matches[index];
    let nextRouteMatch = match;
    return shouldRevalidateLoader(match, _extends({
      currentUrl,
      currentParams: currentRouteMatch.params,
      nextUrl,
      nextParams: nextRouteMatch.params
    }, submission, {
      actionResult,
      defaultShouldRevalidate: defaultShouldRevalidate || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
    }));
  }); // Pick fetcher.loads that need to be revalidated

  let revalidatingFetchers = [];
  fetchLoadMatches && fetchLoadMatches.forEach((f, key) => {
    if (!matches.some(m => m.route.id === f.routeId)) {
      // This fetcher is not going to be present in the subsequent render so
      // there's no need to revalidate it
      return;
    } else if (cancelledFetcherLoads.includes(key)) {
      // This fetcher was cancelled from a prior action submission - force reload
      revalidatingFetchers.push(_extends({
        key
      }, f));
    } else {
      // Revalidating fetchers are decoupled from the route matches since they
      // hit a static href, so they _always_ check shouldRevalidate and the
      // default is strictly if a revalidation is explicitly required (action
      // submissions, useRevalidator, X-Remix-Revalidate).
      let shouldRevalidate = shouldRevalidateLoader(f.match, _extends({
        currentUrl,
        currentParams: state.matches[state.matches.length - 1].params,
        nextUrl,
        nextParams: matches[matches.length - 1].params
      }, submission, {
        actionResult,
        defaultShouldRevalidate
      }));
      if (shouldRevalidate) {
        revalidatingFetchers.push(_extends({
          key
        }, f));
      }
    }
  });
  return [navigationMatches, revalidatingFetchers];
}
function isNewLoader(currentLoaderData, currentMatch, match) {
  let isNew =
  // [a] -> [a, b]
  !currentMatch ||
  // [a, b] -> [a, c]
  match.route.id !== currentMatch.route.id; // Handle the case that we don't have data for a re-used route, potentially
  // from a prior error or from a cancelled pending deferred

  let isMissingData = currentLoaderData[match.route.id] === undefined; // Always load if this is a net-new route or we don't yet have data

  return isNew || isMissingData;
}
function isNewRouteInstance(currentMatch, match) {
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match.pathname ||
    // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
  );
}
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg);
    if (typeof routeChoice === "boolean") {
      return routeChoice;
    }
  }
  return arg.defaultShouldRevalidate;
}
async function callLoaderOrAction(type, request, match, matches, basename, isStaticRequest, isRouteRequest, requestContext) {
  if (basename === void 0) {
    basename = "/";
  }
  if (isStaticRequest === void 0) {
    isStaticRequest = false;
  }
  if (isRouteRequest === void 0) {
    isRouteRequest = false;
  }
  let resultType;
  let result; // Setup a promise we can race against so that abort signals short circuit

  let reject;
  let abortPromise = new Promise((_, r) => reject = r);
  let onReject = () => reject();
  request.signal.addEventListener("abort", onReject);
  try {
    let handler = match.route[type];
    invariant(handler, "Could not find the " + type + " to run on the \"" + match.route.id + "\" route");
    result = await Promise.race([handler({
      request,
      params: match.params,
      context: requestContext
    }), abortPromise]);
    invariant(result !== undefined, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ("\"" + match.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
  } catch (e) {
    resultType = ResultType.error;
    result = e;
  } finally {
    request.signal.removeEventListener("abort", onReject);
  }
  if (isResponse(result)) {
    let status = result.status; // Process redirects

    if (redirectStatusCodes.has(status)) {
      let location = result.headers.get("Location");
      invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header"); // Support relative routing in internal redirects

      if (!ABSOLUTE_URL_REGEX.test(location)) {
        let activeMatches = matches.slice(0, matches.indexOf(match) + 1);
        let routePathnames = getPathContributingMatches(activeMatches).map(match => match.pathnameBase);
        let resolvedLocation = resolveTo(location, routePathnames, new URL(request.url).pathname);
        invariant(createPath(resolvedLocation), "Unable to resolve redirect location: " + location); // Prepend the basename to the redirect location if we have one

        if (basename) {
          let path = resolvedLocation.pathname;
          resolvedLocation.pathname = path === "/" ? basename : joinPaths([basename, path]);
        }
        location = createPath(resolvedLocation);
      } else if (!isStaticRequest) {
        // Strip off the protocol+origin for same-origin absolute redirects.
        // If this is a static reques, we can let it go back to the browser
        // as-is
        let currentUrl = new URL(request.url);
        let url = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location);
        if (url.origin === currentUrl.origin) {
          location = url.pathname + url.search + url.hash;
        }
      } // Don't process redirects in the router during static requests requests.
      // Instead, throw the Response and let the server handle it with an HTTP
      // redirect.  We also update the Location header in place in this flow so
      // basename and relative routing is taken into account

      if (isStaticRequest) {
        result.headers.set("Location", location);
        throw result;
      }
      return {
        type: ResultType.redirect,
        status,
        location,
        revalidate: result.headers.get("X-Remix-Revalidate") !== null
      };
    } // For SSR single-route requests, we want to hand Responses back directly
    // without unwrapping.  We do this with the QueryRouteResponse wrapper
    // interface so we can know whether it was returned or thrown

    if (isRouteRequest) {
      // eslint-disable-next-line no-throw-literal
      throw {
        type: resultType || ResultType.data,
        response: result
      };
    }
    let data;
    let contentType = result.headers.get("Content-Type"); // Check between word boundaries instead of startsWith() due to the last
    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type

    if (contentType && /\bapplication\/json\b/.test(contentType)) {
      data = await result.json();
    } else {
      data = await result.text();
    }
    if (resultType === ResultType.error) {
      return {
        type: resultType,
        error: new ErrorResponse(status, result.statusText, data),
        headers: result.headers
      };
    }
    return {
      type: ResultType.data,
      data,
      statusCode: result.status,
      headers: result.headers
    };
  }
  if (resultType === ResultType.error) {
    return {
      type: resultType,
      error: result
    };
  }
  if (result instanceof DeferredData) {
    return {
      type: ResultType.deferred,
      deferredData: result
    };
  }
  return {
    type: ResultType.data,
    data: result
  };
} // Utility method for creating the Request instances for loaders/actions during
// client-side navigations and fetches.  During SSR we will always have a
// Request instance from the static handler (query/queryRoute)

function createClientSideRequest(history, location, signal, submission) {
  let url = history.createURL(stripHashFromPath(location)).toString();
  let init = {
    signal
  };
  if (submission && isMutationMethod(submission.formMethod)) {
    let {
      formMethod,
      formEncType,
      formData
    } = submission;
    init.method = formMethod.toUpperCase();
    init.body = formEncType === "application/x-www-form-urlencoded" ? convertFormDataToSearchParams(formData) : formData;
  } // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)

  return new Request(url, init);
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key, value] of formData.entries()) {
    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs
    searchParams.append(key, value instanceof File ? value.name : value);
  }
  return searchParams;
}
function processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {
  // Fill in loaderData/errors from our loaders
  let loaderData = {};
  let errors = null;
  let statusCode;
  let foundError = false;
  let loaderHeaders = {}; // Process loader results into state.loaderData/state.errors

  results.forEach((result, index) => {
    let id = matchesToLoad[index].route.id;
    invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
    if (isErrorResult(result)) {
      // Look upwards from the matched route for the closest ancestor
      // error boundary, defaulting to the root match
      let boundaryMatch = findNearestBoundary(matches, id);
      let error = result.error; // If we have a pending action error, we report it at the highest-route
      // that throws a loader error, and then clear it out to indicate that
      // it was consumed

      if (pendingError) {
        error = Object.values(pendingError)[0];
        pendingError = undefined;
      }
      errors = errors || {}; // Prefer higher error values if lower errors bubble to the same boundary

      if (errors[boundaryMatch.route.id] == null) {
        errors[boundaryMatch.route.id] = error;
      } // Clear our any prior loaderData for the throwing route

      loaderData[id] = undefined; // Once we find our first (highest) error, we set the status code and
      // prevent deeper status codes from overriding

      if (!foundError) {
        foundError = true;
        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    } else {
      if (isDeferredResult(result)) {
        activeDeferreds.set(id, result.deferredData);
        loaderData[id] = result.deferredData.data;
      } else {
        loaderData[id] = result.data;
      } // Error status codes always override success status codes, but if all
      // loaders are successful we take the deepest status code.

      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
        statusCode = result.statusCode;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    }
  }); // If we didn't consume the pending action error (i.e., all loaders
  // resolved), then consume it here.  Also clear out any loaderData for the
  // throwing route

  if (pendingError) {
    errors = pendingError;
    loaderData[Object.keys(pendingError)[0]] = undefined;
  }
  return {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
function processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {
  let {
    loaderData,
    errors
  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds); // Process results from our revalidating fetchers

  for (let index = 0; index < revalidatingFetchers.length; index++) {
    let {
      key,
      match
    } = revalidatingFetchers[index];
    invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, "Did not find corresponding fetcher result");
    let result = fetcherResults[index]; // Process fetcher non-redirect errors

    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, match.route.id);
      if (!(errors && errors[boundaryMatch.route.id])) {
        errors = _extends({}, errors, {
          [boundaryMatch.route.id]: result.error
        });
      }
      state.fetchers.delete(key);
    } else if (isRedirectResult(result)) {
      // Should never get here, redirects should get processed above, but we
      // keep this to type narrow to a success result in the else
      invariant(false, "Unhandled fetcher revalidation redirect");
    } else if (isDeferredResult(result)) {
      // Should never get here, deferred data should be awaited for fetchers
      // in resolveDeferredResults
      invariant(false, "Unhandled fetcher deferred data");
    } else {
      let doneFetcher = {
        state: "idle",
        data: result.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true
      };
      state.fetchers.set(key, doneFetcher);
    }
  }
  return {
    loaderData,
    errors
  };
}
function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
  let mergedLoaderData = _extends({}, newLoaderData);
  for (let match of matches) {
    let id = match.route.id;
    if (newLoaderData.hasOwnProperty(id)) {
      if (newLoaderData[id] !== undefined) {
        mergedLoaderData[id] = newLoaderData[id];
      }
    } else if (loaderData[id] !== undefined) {
      mergedLoaderData[id] = loaderData[id];
    }
    if (errors && errors.hasOwnProperty(id)) {
      // Don't keep any loader data below the boundary
      break;
    }
  }
  return mergedLoaderData;
} // Find the nearest error boundary, looking upwards from the leaf route (or the
// route specified by routeId) for the closest ancestor error boundary,
// defaulting to the root match

function findNearestBoundary(matches, routeId) {
  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];
  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];
}
function getShortCircuitMatches(routes) {
  // Prefer a root layout route if present, otherwise shim in a route object
  let route = routes.find(r => r.index || !r.path || r.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route
    }],
    route
  };
}
function getInternalRouterError(status, _temp4) {
  let {
    pathname,
    routeId,
    method,
    type
  } = _temp4 === void 0 ? {} : _temp4;
  let statusText = "Unknown Server Error";
  let errorMessage = "Unknown @remix-run/router error";
  if (status === 400) {
    statusText = "Bad Request";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method + " request to \"" + pathname + "\" but " + ("did not provide a `loader` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    } else if (type === "defer-action") {
      errorMessage = "defer() is not supported in actions";
    }
  } else if (status === 403) {
    statusText = "Forbidden";
    errorMessage = "Route \"" + routeId + "\" does not match URL \"" + pathname + "\"";
  } else if (status === 404) {
    statusText = "Not Found";
    errorMessage = "No route matches URL \"" + pathname + "\"";
  } else if (status === 405) {
    statusText = "Method Not Allowed";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method.toUpperCase() + " request to \"" + pathname + "\" but " + ("did not provide an `action` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    } else if (method) {
      errorMessage = "Invalid request method \"" + method.toUpperCase() + "\"";
    }
  }
  return new ErrorResponse(status || 500, statusText, new Error(errorMessage), true);
} // Find any returned redirect errors, starting from the lowest match

function findRedirect(results) {
  for (let i = results.length - 1; i >= 0; i--) {
    let result = results[i];
    if (isRedirectResult(result)) {
      return result;
    }
  }
}
function stripHashFromPath(path) {
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return createPath(_extends({}, parsedPath, {
    hash: ""
  }));
}
function isHashChangeOnly(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash !== b.hash;
}
function isDeferredResult(result) {
  return result.type === ResultType.deferred;
}
function isErrorResult(result) {
  return result.type === ResultType.error;
}
function isRedirectResult(result) {
  return (result && result.type) === ResultType.redirect;
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
function isRedirectResponse(result) {
  if (!isResponse(result)) {
    return false;
  }
  let status = result.status;
  let location = result.headers.get("Location");
  return status >= 300 && status <= 399 && location != null;
}
function isQueryRouteResponse(obj) {
  return obj && isResponse(obj.response) && (obj.type === ResultType.data || ResultType.error);
}
function isValidMethod(method) {
  return validRequestMethods.has(method);
}
function isMutationMethod(method) {
  return validMutationMethods.has(method);
}
async function resolveDeferredResults(currentMatches, matchesToLoad, results, signal, isFetcher, currentLoaderData) {
  for (let index = 0; index < results.length; index++) {
    let result = results[index];
    let match = matchesToLoad[index];
    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);
    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;
    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {
      // Note: we do not have to touch activeDeferreds here since we race them
      // against the signal in resolveDeferredData and they'll get aborted
      // there if needed
      await resolveDeferredData(result, signal, isFetcher).then(result => {
        if (result) {
          results[index] = result || results[index];
        }
      });
    }
  }
}
async function resolveDeferredData(result, signal, unwrap) {
  if (unwrap === void 0) {
    unwrap = false;
  }
  let aborted = await result.deferredData.resolveData(signal);
  if (aborted) {
    return;
  }
  if (unwrap) {
    try {
      return {
        type: ResultType.data,
        data: result.deferredData.unwrappedData
      };
    } catch (e) {
      // Handle any TrackedPromise._error values encountered while unwrapping
      return {
        type: ResultType.error,
        error: e
      };
    }
  }
  return {
    type: ResultType.data,
    data: result.deferredData.data
  };
}
function hasNakedIndexQuery(search) {
  return new URLSearchParams(search).getAll("index").some(v => v === "");
} // Note: This should match the format exported by useMatches, so if you change
// this please also change that :)  Eventually we'll DRY this up

function createUseMatchesMatch(match, loaderData) {
  let {
    route,
    pathname,
    params
  } = match;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
function getTargetMatch(matches, location) {
  let search = typeof location === "string" ? parsePath(location).search : location.search;
  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
    // Return the leaf index route when index is present
    return matches[matches.length - 1];
  } // Otherwise grab the deepest "path contributing" match (ignoring index and
  // pathless layout routes)

  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
} //#endregion



/***/ }),

/***/ "./node_modules/react-router-dom/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-router-dom/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbortedDeferredError": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError),
/* harmony export */   "Await": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Await),
/* harmony export */   "BrowserRouter": () => (/* binding */ BrowserRouter),
/* harmony export */   "Form": () => (/* binding */ Form),
/* harmony export */   "HashRouter": () => (/* binding */ HashRouter),
/* harmony export */   "Link": () => (/* binding */ Link),
/* harmony export */   "MemoryRouter": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.MemoryRouter),
/* harmony export */   "NavLink": () => (/* binding */ NavLink),
/* harmony export */   "Navigate": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Navigate),
/* harmony export */   "NavigationType": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Action),
/* harmony export */   "Outlet": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Outlet),
/* harmony export */   "Route": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Route),
/* harmony export */   "Router": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Router),
/* harmony export */   "RouterProvider": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.RouterProvider),
/* harmony export */   "Routes": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Routes),
/* harmony export */   "ScrollRestoration": () => (/* binding */ ScrollRestoration),
/* harmony export */   "UNSAFE_DataRouterContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterContext),
/* harmony export */   "UNSAFE_DataRouterStateContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext),
/* harmony export */   "UNSAFE_LocationContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_LocationContext),
/* harmony export */   "UNSAFE_NavigationContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext),
/* harmony export */   "UNSAFE_RouteContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_RouteContext),
/* harmony export */   "UNSAFE_enhanceManualRouteObjects": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_enhanceManualRouteObjects),
/* harmony export */   "UNSAFE_useScrollRestoration": () => (/* binding */ useScrollRestoration),
/* harmony export */   "createBrowserRouter": () => (/* binding */ createBrowserRouter),
/* harmony export */   "createHashRouter": () => (/* binding */ createHashRouter),
/* harmony export */   "createMemoryRouter": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createMemoryRouter),
/* harmony export */   "createPath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.createPath),
/* harmony export */   "createRoutesFromChildren": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createRoutesFromChildren),
/* harmony export */   "createRoutesFromElements": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createRoutesFromElements),
/* harmony export */   "createSearchParams": () => (/* binding */ createSearchParams),
/* harmony export */   "defer": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.defer),
/* harmony export */   "generatePath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.generatePath),
/* harmony export */   "isRouteErrorResponse": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse),
/* harmony export */   "json": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.json),
/* harmony export */   "matchPath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.matchPath),
/* harmony export */   "matchRoutes": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes),
/* harmony export */   "parsePath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.parsePath),
/* harmony export */   "redirect": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.redirect),
/* harmony export */   "renderMatches": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.renderMatches),
/* harmony export */   "resolvePath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.resolvePath),
/* harmony export */   "unstable_HistoryRouter": () => (/* binding */ HistoryRouter),
/* harmony export */   "unstable_useBlocker": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.unstable_useBlocker),
/* harmony export */   "unstable_usePrompt": () => (/* binding */ usePrompt),
/* harmony export */   "useActionData": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useActionData),
/* harmony export */   "useAsyncError": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useAsyncError),
/* harmony export */   "useAsyncValue": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useAsyncValue),
/* harmony export */   "useBeforeUnload": () => (/* binding */ useBeforeUnload),
/* harmony export */   "useFetcher": () => (/* binding */ useFetcher),
/* harmony export */   "useFetchers": () => (/* binding */ useFetchers),
/* harmony export */   "useFormAction": () => (/* binding */ useFormAction),
/* harmony export */   "useHref": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useHref),
/* harmony export */   "useInRouterContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useInRouterContext),
/* harmony export */   "useLinkClickHandler": () => (/* binding */ useLinkClickHandler),
/* harmony export */   "useLoaderData": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useLoaderData),
/* harmony export */   "useLocation": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation),
/* harmony export */   "useMatch": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useMatch),
/* harmony export */   "useMatches": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useMatches),
/* harmony export */   "useNavigate": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigate),
/* harmony export */   "useNavigation": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigation),
/* harmony export */   "useNavigationType": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigationType),
/* harmony export */   "useOutlet": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useOutlet),
/* harmony export */   "useOutletContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useOutletContext),
/* harmony export */   "useParams": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useParams),
/* harmony export */   "useResolvedPath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath),
/* harmony export */   "useRevalidator": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRevalidator),
/* harmony export */   "useRouteError": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRouteError),
/* harmony export */   "useRouteLoaderData": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRouteLoaderData),
/* harmony export */   "useRoutes": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRoutes),
/* harmony export */   "useSearchParams": () => (/* binding */ useSearchParams),
/* harmony export */   "useSubmit": () => (/* binding */ useSubmit)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router */ "./node_modules/react-router/dist/index.js");
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @remix-run/router */ "./node_modules/@remix-run/router/dist/router.js");
/**
 * React Router DOM v6.8.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */




function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
const defaultMethod = "get";
const defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && (
  // Ignore everything but left clicks
  !target || target === "_self") &&
  // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event) // Ignore clicks with modifier keys
  ;
}
/**
 * Creates a URLSearchParams object using the given initializer.
 *
 * This is identical to `new URLSearchParams(init)` except it also
 * supports arrays as values in the object form of the initializer
 * instead of just strings. This is convenient when you need multiple
 * values for a given key, but don't want to use an array initializer.
 *
 * For example, instead of:
 *
 *   let searchParams = new URLSearchParams([
 *     ['sort', 'name'],
 *     ['sort', 'price']
 *   ]);
 *
 * you can do:
 *
 *   let searchParams = createSearchParams({
 *     sort: ['name', 'price']
 *   });
 */

function createSearchParams(init) {
  if (init === void 0) {
    init = "";
  }
  return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {
    let value = init[key];
    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);
  }, []));
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
  let searchParams = createSearchParams(locationSearch);
  if (defaultSearchParams) {
    for (let key of defaultSearchParams.keys()) {
      if (!searchParams.has(key)) {
        defaultSearchParams.getAll(key).forEach(value => {
          searchParams.append(key, value);
        });
      }
    }
  }
  return searchParams;
}
function getFormSubmissionInfo(target, defaultAction, options) {
  let method;
  let action;
  let encType;
  let formData;
  if (isFormElement(target)) {
    let submissionTrigger = options.submissionTrigger;
    method = options.method || target.getAttribute("method") || defaultMethod;
    action = options.action || target.getAttribute("action") || defaultAction;
    encType = options.encType || target.getAttribute("enctype") || defaultEncType;
    formData = new FormData(target);
    if (submissionTrigger && submissionTrigger.name) {
      formData.append(submissionTrigger.name, submissionTrigger.value);
    }
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error("Cannot submit a <button> or <input type=\"submit\"> without a <form>");
    } // <button>/<input type="submit"> may override attributes of <form>

    method = options.method || target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    action = options.action || target.getAttribute("formaction") || form.getAttribute("action") || defaultAction;
    encType = options.encType || target.getAttribute("formenctype") || form.getAttribute("enctype") || defaultEncType;
    formData = new FormData(form); // Include name + value from a <button>, appending in case the button name
    // matches an existing input name

    if (target.name) {
      formData.append(target.name, target.value);
    }
  } else if (isHtmlElement(target)) {
    throw new Error("Cannot submit element that is not <form>, <button>, or " + "<input type=\"submit|image\">");
  } else {
    method = options.method || defaultMethod;
    action = options.action || defaultAction;
    encType = options.encType || defaultEncType;
    if (target instanceof FormData) {
      formData = target;
    } else {
      formData = new FormData();
      if (target instanceof URLSearchParams) {
        for (let [name, value] of target) {
          formData.append(name, value);
        }
      } else if (target != null) {
        for (let name of Object.keys(target)) {
          formData.append(name, target[name]);
        }
      }
    }
  }
  let {
    protocol,
    host
  } = window.location;
  let url = new URL(action, protocol + "//" + host);
  return {
    url,
    method: method.toLowerCase(),
    encType,
    formData
  };
}
const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"],
  _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"],
  _excluded3 = ["reloadDocument", "replace", "method", "action", "onSubmit", "fetcherKey", "routeId", "relative", "preventScrollReset"];
//#region Routers
////////////////////////////////////////////////////////////////////////////////

function createBrowserRouter(routes, opts) {
  return (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createRouter)({
    basename: opts == null ? void 0 : opts.basename,
    history: (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createBrowserHistory)({
      window: opts == null ? void 0 : opts.window
    }),
    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
    routes: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_enhanceManualRouteObjects)(routes)
  }).initialize();
}
function createHashRouter(routes, opts) {
  return (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createRouter)({
    basename: opts == null ? void 0 : opts.basename,
    history: (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createHashHistory)({
      window: opts == null ? void 0 : opts.window
    }),
    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
    routes: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_enhanceManualRouteObjects)(routes)
  }).initialize();
}
function parseHydrationData() {
  var _window;
  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
  if (state && state.errors) {
    state = _extends({}, state, {
      errors: deserializeErrors(state.errors)
    });
  }
  return state;
}
function deserializeErrors(errors) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    // Hey you!  If you change this, please change the corresponding logic in
    // serializeErrors in react-router-dom/server.tsx :)
    if (val && val.__type === "RouteErrorResponse") {
      serialized[key] = new react_router__WEBPACK_IMPORTED_MODULE_1__.ErrorResponse(val.status, val.statusText, val.data, val.internal === true);
    } else if (val && val.__type === "Error") {
      let error = new Error(val.message); // Wipe away the client-side stack trace.  Nothing to fill it in with
      // because we don't serialize SSR stack traces for security reasons

      error.stack = "";
      serialized[key] = error;
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}
/**
 * A `<Router>` for use in web browsers. Provides the cleanest URLs.
 */

function BrowserRouter(_ref) {
  let {
    basename,
    children,
    window
  } = _ref;
  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  if (historyRef.current == null) {
    historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createBrowserHistory)({
      window,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
/**
 * A `<Router>` for use in web browsers. Stores the location in the hash
 * portion of the URL so it is not sent to the server.
 */

function HashRouter(_ref2) {
  let {
    basename,
    children,
    window
  } = _ref2;
  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  if (historyRef.current == null) {
    historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createHashHistory)({
      window,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
/**
 * A `<Router>` that accepts a pre-instantiated history object. It's important
 * to note that using your own history object is highly discouraged and may add
 * two versions of the history library to your bundles unless you use the same
 * version of the history library that React Router uses internally.
 */

function HistoryRouter(_ref3) {
  let {
    basename,
    children,
    history
  } = _ref3;
  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
if (true) {
  HistoryRouter.displayName = "unstable_HistoryRouter";
}
const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
/**
 * The public API for rendering a history-aware <a>.
 */

const Link = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function LinkWithRef(_ref4, ref) {
  let {
      onClick,
      relative,
      reloadDocument,
      replace,
      state,
      target,
      to,
      preventScrollReset
    } = _ref4,
    rest = _objectWithoutPropertiesLoose(_ref4, _excluded);

  // Rendered into <a href> for absolute URLs
  let absoluteHref;
  let isExternal = false;
  if (isBrowser && typeof to === "string" && /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i.test(to)) {
    absoluteHref = to;
    let currentUrl = new URL(window.location.href);
    let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
    if (targetUrl.origin === currentUrl.origin) {
      // Strip the protocol/origin for same-origin absolute URLs
      to = targetUrl.pathname + targetUrl.search + targetUrl.hash;
    } else {
      isExternal = true;
    }
  } // Rendered into <a href> for relative URLs

  let href = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useHref)(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event) {
    if (onClick) onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return /*#__PURE__*/(
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", _extends({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick,
      ref: ref,
      target: target
    }))
  );
});
if (true) {
  Link.displayName = "Link";
}
/**
 * A <Link> wrapper that knows if it's "active" or not.
 */

const NavLink = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function NavLinkWithRef(_ref5, ref) {
  let {
      "aria-current": ariaCurrentProp = "page",
      caseSensitive = false,
      className: classNameProp = "",
      end = false,
      style: styleProp,
      to,
      children
    } = _ref5,
    rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);
  let path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(to, {
    relative: rest.relative
  });
  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();
  let routerState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext);
  let {
    navigator
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext);
  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let ariaCurrent = isActive ? ariaCurrentProp : undefined;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive,
      isPending
    });
  } else {
    // If the className prop is not a function, we use a default `active`
    // class for <NavLink />s that are active. In v5 `active` was the default
    // value for `activeClassName`, but we are removing that API and can still
    // use the old default behavior for a cleaner upgrade path and keep the
    // simple styling rules working as they currently do.
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp({
    isActive,
    isPending
  }) : styleProp;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Link, _extends({}, rest, {
    "aria-current": ariaCurrent,
    className: className,
    ref: ref,
    style: style,
    to: to
  }), typeof children === "function" ? children({
    isActive,
    isPending
  }) : children);
});
if (true) {
  NavLink.displayName = "NavLink";
}
/**
 * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except
 * that the interaction with the server is with `fetch` instead of new document
 * requests, allowing components to add nicer UX to the page as the form is
 * submitted and returns with data.
 */

const Form = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FormImpl, _extends({}, props, {
    ref: ref
  }));
});
if (true) {
  Form.displayName = "Form";
}
const FormImpl = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((_ref6, forwardedRef) => {
  let {
      reloadDocument,
      replace,
      method = defaultMethod,
      action,
      onSubmit,
      fetcherKey,
      routeId,
      relative,
      preventScrollReset
    } = _ref6,
    props = _objectWithoutPropertiesLoose(_ref6, _excluded3);
  let submit = useSubmitImpl(fetcherKey, routeId);
  let formMethod = method.toLowerCase() === "get" ? "get" : "post";
  let formAction = useFormAction(action, {
    relative
  });
  let submitHandler = event => {
    onSubmit && onSubmit(event);
    if (event.defaultPrevented) return;
    event.preventDefault();
    let submitter = event.nativeEvent.submitter;
    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
    submit(submitter || event.currentTarget, {
      method: submitMethod,
      replace,
      relative,
      preventScrollReset
    });
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("form", _extends({
    ref: forwardedRef,
    method: formMethod,
    action: formAction,
    onSubmit: reloadDocument ? onSubmit : submitHandler
  }, props));
});
if (true) {
  FormImpl.displayName = "FormImpl";
}
/**
 * This component will emulate the browser's scroll restoration on location
 * changes.
 */

function ScrollRestoration(_ref7) {
  let {
    getKey,
    storageKey
  } = _ref7;
  useScrollRestoration({
    getKey,
    storageKey
  });
  return null;
}
if (true) {
  ScrollRestoration.displayName = "ScrollRestoration";
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Hooks
////////////////////////////////////////////////////////////////////////////////

var DataRouterHook;
(function (DataRouterHook) {
  DataRouterHook["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook["UseSubmitImpl"] = "useSubmitImpl";
  DataRouterHook["UseFetcher"] = "useFetcher";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function (DataRouterStateHook) {
  DataRouterStateHook["UseFetchers"] = "useFetchers";
  DataRouterStateHook["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function getDataRouterConsoleError(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function useDataRouterContext(hookName) {
  let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterContext);
  !ctx ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext);
  !state ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;
  return state;
}
/**
 * Handles the click behavior for router `<Link>` components. This is useful if
 * you need to create custom `<Link>` components with the same click behavior we
 * use in our exported `<Link>`.
 */

function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp;
  let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigate)();
  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();
  let path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(to, {
    relative
  });
  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of
      // a push, so do the same here unless the replace prop is explicitly set

      let replace = replaceProp !== undefined ? replaceProp : (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createPath)(location) === (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createPath)(path);
      navigate(to, {
        replace,
        state,
        preventScrollReset,
        relative
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative]);
}
/**
 * A convenient wrapper for reading and writing search parameters via the
 * URLSearchParams interface.
 */

function useSearchParams(defaultInit) {
   true ? warning(typeof URLSearchParams !== "undefined", "You cannot use the `useSearchParams` hook in a browser that does not " + "support the URLSearchParams API. If you need to support Internet " + "Explorer 11, we recommend you load a polyfill such as " + "https://github.com/ungap/url-search-params\n\n" + "If you're unsure how to load polyfills, we recommend you check out " + "https://polyfill.io/v3/ which provides some recommendations about how " + "to load polyfills only for users that need them, instead of for every " + "user.") : 0;
  let defaultSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(createSearchParams(defaultInit));
  let hasSetSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();
  let searchParams = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() =>
  // Only merge in the defaults if we haven't yet called setSearchParams.
  // Once we call that we want those to take precedence, otherwise you can't
  // remove a param with setSearchParams({}) if it has an initial value
  getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);
  let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigate)();
  let setSearchParams = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((nextInit, navigateOptions) => {
    const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
    hasSetSearchParamsRef.current = true;
    navigate("?" + newSearchParams, navigateOptions);
  }, [navigate, searchParams]);
  return [searchParams, setSearchParams];
}
/**
 * Returns a function that may be used to programmatically submit a form (or
 * some arbitrary data) to the server.
 */

function useSubmit() {
  return useSubmitImpl();
}
function useSubmitImpl(fetcherKey, routeId) {
  let {
    router
  } = useDataRouterContext(DataRouterHook.UseSubmitImpl);
  let defaultAction = useFormAction();
  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (target, options) {
    if (options === void 0) {
      options = {};
    }
    if (typeof document === "undefined") {
      throw new Error("You are calling submit during the server render. " + "Try calling submit within a `useEffect` or callback instead.");
    }
    let {
      method,
      encType,
      formData,
      url
    } = getFormSubmissionInfo(target, defaultAction, options);
    let href = url.pathname + url.search;
    let opts = {
      replace: options.replace,
      preventScrollReset: options.preventScrollReset,
      formData,
      formMethod: method,
      formEncType: encType
    };
    if (fetcherKey) {
      !(routeId != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, "No routeId available for useFetcher()") : 0 : void 0;
      router.fetch(fetcherKey, routeId, href, opts);
    } else {
      router.navigate(href, opts);
    }
  }, [defaultAction, router, fetcherKey, routeId]);
}
function useFormAction(action, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    basename
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext);
  let routeContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_RouteContext);
  !routeContext ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, "useFormAction must be used inside a RouteContext") : 0 : void 0;
  let [match] = routeContext.matches.slice(-1); // Shallow clone path so we can modify it below, otherwise we modify the
  // object referenced by useMemo inside useResolvedPath

  let path = _extends({}, (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(action ? action : ".", {
    relative
  })); // Previously we set the default action to ".". The problem with this is that
  // `useResolvedPath(".")` excludes search params and the hash of the resolved
  // URL. This is the intended behavior of when "." is specifically provided as
  // the form action, but inconsistent w/ browsers when the action is omitted.
  // https://github.com/remix-run/remix/issues/927

  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();
  if (action == null) {
    // Safe to write to these directly here since if action was undefined, we
    // would have called useResolvedPath(".") which will never include a search
    // or hash
    path.search = location.search;
    path.hash = location.hash; // When grabbing search params from the URL, remove the automatically
    // inserted ?index param so we match the useResolvedPath search behavior
    // which would not include ?index

    if (match.route.index) {
      let params = new URLSearchParams(path.search);
      params.delete("index");
      path.search = params.toString() ? "?" + params.toString() : "";
    }
  }
  if ((!action || action === ".") && match.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  } // If we're operating within a basename, prepend it to the pathname prior
  // to creating the form action.  If this is a root navigation, then just use
  // the raw basename which allows the basename to have full control over the
  // presence of a trailing slash on root actions

  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : (0,react_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([basename, path.pathname]);
  }
  return (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createPath)(path);
}
function createFetcherForm(fetcherKey, routeId) {
  let FetcherForm = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FormImpl, _extends({}, props, {
      ref: ref,
      fetcherKey: fetcherKey,
      routeId: routeId
    }));
  });
  if (true) {
    FetcherForm.displayName = "fetcher.Form";
  }
  return FetcherForm;
}
let fetcherId = 0;
/**
 * Interacts with route loaders and actions without causing a navigation. Great
 * for any interaction that stays on the same page.
 */

function useFetcher() {
  var _route$matches;
  let {
    router
  } = useDataRouterContext(DataRouterHook.UseFetcher);
  let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_RouteContext);
  !route ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, "useFetcher must be used inside a RouteContext") : 0 : void 0;
  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;
  !(routeId != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, "useFetcher can only be used on routes that contain a unique \"id\"") : 0 : void 0;
  let [fetcherKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => String(++fetcherId));
  let [Form] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {
    !routeId ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, "No routeId available for fetcher.Form()") : 0 : void 0;
    return createFetcherForm(fetcherKey, routeId);
  });
  let [load] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => href => {
    !router ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, "No router available for fetcher.load()") : 0 : void 0;
    !routeId ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, "No routeId available for fetcher.load()") : 0 : void 0;
    router.fetch(fetcherKey, routeId, href);
  });
  let submit = useSubmitImpl(fetcherKey, routeId);
  let fetcher = router.getFetcher(fetcherKey);
  let fetcherWithComponents = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => _extends({
    Form,
    submit,
    load
  }, fetcher), [fetcher, Form, submit, load]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    // Is this busted when the React team gets real weird and calls effects
    // twice on mount?  We really just need to garbage collect here when this
    // fetcher is no longer around.
    return () => {
      if (!router) {
        console.warn("No fetcher available to clean up from useFetcher()");
        return;
      }
      router.deleteFetcher(fetcherKey);
    };
  }, [router, fetcherKey]);
  return fetcherWithComponents;
}
/**
 * Provides all fetchers currently on the page. Useful for layouts and parent
 * routes that need to provide pending/optimistic UI regarding the fetch.
 */

function useFetchers() {
  let state = useDataRouterState(DataRouterStateHook.UseFetchers);
  return [...state.fetchers.values()];
}
const SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
let savedScrollPositions = {};
/**
 * When rendered inside a RouterProvider, will restore scroll positions on navigations
 */

function useScrollRestoration(_temp3) {
  let {
    getKey,
    storageKey
  } = _temp3 === void 0 ? {} : _temp3;
  let {
    router
  } = useDataRouterContext(DataRouterHook.UseScrollRestoration);
  let {
    restoreScrollPosition,
    preventScrollReset
  } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);
  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();
  let matches = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useMatches)();
  let navigation = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigation)(); // Trigger manual scroll restoration while we're active

  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    window.history.scrollRestoration = "manual";
    return () => {
      window.history.scrollRestoration = "auto";
    };
  }, []); // Save positions on pagehide

  usePageHide(react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    if (navigation.state === "idle") {
      let key = (getKey ? getKey(location, matches) : null) || location.key;
      savedScrollPositions[key] = window.scrollY;
    }
    sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
    window.history.scrollRestoration = "auto";
  }, [storageKey, getKey, navigation.state, location, matches])); // Read in any saved scroll locations

  if (typeof document !== "undefined") {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
      try {
        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);
        if (sessionPositions) {
          savedScrollPositions = JSON.parse(sessionPositions);
        }
      } catch (e) {// no-op, use default empty object
      }
    }, [storageKey]); // Enable scroll restoration in the router
    // eslint-disable-next-line react-hooks/rules-of-hooks

    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKey);
      return () => disableScrollRestoration && disableScrollRestoration();
    }, [router, getKey]); // Restore scrolling when state.restoreScrollPosition changes
    // eslint-disable-next-line react-hooks/rules-of-hooks

    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
      // Explicit false means don't do anything (used for submissions)
      if (restoreScrollPosition === false) {
        return;
      } // been here before, scroll to it

      if (typeof restoreScrollPosition === "number") {
        window.scrollTo(0, restoreScrollPosition);
        return;
      } // try to scroll to the hash

      if (location.hash) {
        let el = document.getElementById(location.hash.slice(1));
        if (el) {
          el.scrollIntoView();
          return;
        }
      } // Don't reset if this navigation opted out

      if (preventScrollReset === true) {
        return;
      } // otherwise go to the top on new locations

      window.scrollTo(0, 0);
    }, [location, restoreScrollPosition, preventScrollReset]);
  }
}
/**
 * Setup a callback to be fired on the window's `beforeunload` event. This is
 * useful for saving some data to `window.localStorage` just before the page
 * refreshes.
 *
 * Note: The `callback` argument should be a function created with
 * `React.useCallback()`.
 */

function useBeforeUnload(callback, options) {
  let {
    capture
  } = options || {};
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : undefined;
    window.addEventListener("beforeunload", callback, opts);
    return () => {
      window.removeEventListener("beforeunload", callback, opts);
    };
  }, [callback, capture]);
}
/**
 * Setup a callback to be fired on the window's `pagehide` event. This is
 * useful for saving some data to `window.localStorage` just before the page
 * refreshes.  This event is better supported than beforeunload across browsers.
 *
 * Note: The `callback` argument should be a function created with
 * `React.useCallback()`.
 */

function usePageHide(callback, options) {
  let {
    capture
  } = options || {};
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : undefined;
    window.addEventListener("pagehide", callback, opts);
    return () => {
      window.removeEventListener("pagehide", callback, opts);
    };
  }, [callback, capture]);
}
/**
 * Wrapper around useBlocker to show a window.confirm prompt to users instead
 * of building a custom UI with useBlocker.
 *
 * Warning: This has *a lot of rough edges* and behaves very differently (and
 * very incorrectly in some cases) across browsers if user click addition
 * back/forward navigations while the confirm is open.  Use at your own risk.
 */

function usePrompt(_ref8) {
  let {
    when,
    message
  } = _ref8;
  let blocker = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.unstable_useBlocker)(when);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (blocker.state === "blocked" && !when) {
      blocker.reset();
    }
  }, [blocker, when]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (blocker.state === "blocked") {
      let proceed = window.confirm(message);
      if (proceed) {
        setTimeout(blocker.proceed, 0);
      } else {
        blocker.reset();
      }
    }
  }, [blocker, message]);
}
////////////////////////////////////////////////////////////////////////////////
//#region Utils
////////////////////////////////////////////////////////////////////////////////

function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);
    try {
      // Welcome to debugging React Router!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
} //#endregion



/***/ }),

/***/ "./node_modules/react-router-dom/server.js":
/*!*************************************************!*\
  !*** ./node_modules/react-router-dom/server.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var React = __webpack_require__(/*! react */ "react");
var router = __webpack_require__(/*! @remix-run/router */ "./node_modules/@remix-run/router/dist/router.js");
var reactRouterDom = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router-dom/dist/index.js");
function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}
var React__namespace = /*#__PURE__*/_interopNamespace(React);

/**
 * A <Router> that may not navigate to any other location. This is useful
 * on the server where there is no stateful UI.
 */

function StaticRouter(_ref) {
  let {
    basename,
    children,
    location: locationProp = "/"
  } = _ref;
  if (typeof locationProp === "string") {
    locationProp = reactRouterDom.parsePath(locationProp);
  }
  let action = router.Action.Pop;
  let location = {
    pathname: locationProp.pathname || "/",
    search: locationProp.search || "",
    hash: locationProp.hash || "",
    state: locationProp.state || null,
    key: locationProp.key || "default"
  };
  let staticNavigator = getStatelessNavigator();
  return /*#__PURE__*/React__namespace.createElement(reactRouterDom.Router, {
    basename: basename,
    children: children,
    location: location,
    navigationType: action,
    navigator: staticNavigator,
    static: true
  });
}
/**
 * A Data Router that may not navigate to any other location. This is useful
 * on the server where there is no stateful UI.
 */

function StaticRouterProvider(_ref2) {
  let {
    context,
    router: router$1,
    hydrate = true,
    nonce
  } = _ref2;
  !(router$1 && context) ?  true ? router.invariant(false, "You must provide `router` and `context` to <StaticRouterProvider>") : 0 : void 0;
  let dataRouterContext = {
    router: router$1,
    navigator: getStatelessNavigator(),
    static: true,
    staticContext: context,
    basename: context.basename || "/"
  };
  let hydrateScript = "";
  if (hydrate !== false) {
    let data = {
      loaderData: context.loaderData,
      actionData: context.actionData,
      errors: serializeErrors(context.errors)
    }; // Use JSON.parse here instead of embedding a raw JS object here to speed
    // up parsing on the client.  Dual-stringify is needed to ensure all quotes
    // are properly escaped in the resulting string.  See:
    //   https://v8.dev/blog/cost-of-javascript-2019#json

    let json = JSON.stringify(JSON.stringify(data));
    hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;
  }
  return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(reactRouterDom.UNSAFE_DataRouterContext.Provider, {
    value: dataRouterContext
  }, /*#__PURE__*/React__namespace.createElement(reactRouterDom.UNSAFE_DataRouterStateContext.Provider, {
    value: dataRouterContext.router.state
  }, /*#__PURE__*/React__namespace.createElement(reactRouterDom.Router, {
    basename: dataRouterContext.basename,
    location: dataRouterContext.router.state.location,
    navigationType: dataRouterContext.router.state.historyAction,
    navigator: dataRouterContext.navigator
  }, /*#__PURE__*/React__namespace.createElement(reactRouterDom.Routes, null)))), hydrateScript ? /*#__PURE__*/React__namespace.createElement("script", {
    suppressHydrationWarning: true,
    nonce: nonce,
    dangerouslySetInnerHTML: {
      __html: hydrateScript
    }
  }) : null);
}
function serializeErrors(errors) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    // Hey you!  If you change this, please change the corresponding logic in
    // deserializeErrors in react-router-dom/index.tsx :)
    if (router.isRouteErrorResponse(val)) {
      serialized[key] = {
        ...val,
        __type: "RouteErrorResponse"
      };
    } else if (val instanceof Error) {
      // Do not serialize stack traces from SSR for security reasons
      serialized[key] = {
        message: val.message,
        __type: "Error"
      };
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}
function getStatelessNavigator() {
  return {
    createHref,
    encodeLocation,
    push(to) {
      throw new Error(`You cannot use navigator.push() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\`navigate(${JSON.stringify(to)})\` somewhere in your app.`);
    },
    replace(to) {
      throw new Error(`You cannot use navigator.replace() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere ` + `in your app.`);
    },
    go(delta) {
      throw new Error(`You cannot use navigator.go() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\`navigate(${delta})\` somewhere in your app.`);
    },
    back() {
      throw new Error(`You cannot use navigator.back() on the server because it is a stateless ` + `environment.`);
    },
    forward() {
      throw new Error(`You cannot use navigator.forward() on the server because it is a stateless ` + `environment.`);
    }
  };
} // Temporary manifest generation - we should optimize this by combining the
// tree-walks between convertRoutesToDataRoutes, enhanceManualRouteObjects,
// and generateManifest.
// Also look into getting rid of `route as AgnosticDataRouteObject` down below?

function generateManifest(routes) {
  let manifest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();
  routes.forEach(route => {
    manifest.set(route.id, route);
    if (route.children) {
      generateManifest(route.children, manifest);
    }
  });
  return manifest;
}
function createStaticRouter(routes, context) {
  let dataRoutes = router.UNSAFE_convertRoutesToDataRoutes(reactRouterDom.UNSAFE_enhanceManualRouteObjects(routes));
  let manifest = generateManifest(dataRoutes); // Because our context matches may be from a framework-agnostic set of
  // routes passed to createStaticHandler(), we update them here with our
  // newly created/enhanced data routes

  let matches = context.matches.map(match => {
    let route = manifest.get(match.route.id) || match.route;
    return {
      ...match,
      route: route
    };
  });
  let msg = method => `You cannot use router.${method}() on the server because it is a stateless environment`;
  return {
    get basename() {
      return context.basename;
    },
    get state() {
      return {
        historyAction: router.Action.Pop,
        location: context.location,
        matches,
        loaderData: context.loaderData,
        actionData: context.actionData,
        errors: context.errors,
        initialized: true,
        navigation: router.IDLE_NAVIGATION,
        restoreScrollPosition: null,
        preventScrollReset: false,
        revalidation: "idle",
        fetchers: new Map(),
        blockers: new Map()
      };
    },
    get routes() {
      return dataRoutes;
    },
    initialize() {
      throw msg("initialize");
    },
    subscribe() {
      throw msg("subscribe");
    },
    enableScrollRestoration() {
      throw msg("enableScrollRestoration");
    },
    navigate() {
      throw msg("navigate");
    },
    fetch() {
      throw msg("fetch");
    },
    revalidate() {
      throw msg("revalidate");
    },
    createHref,
    encodeLocation,
    getFetcher() {
      return router.IDLE_FETCHER;
    },
    deleteFetcher() {
      throw msg("deleteFetcher");
    },
    dispose() {
      throw msg("dispose");
    },
    getBlocker() {
      throw msg("getBlocker");
    },
    deleteBlocker() {
      throw msg("deleteBlocker");
    },
    _internalFetchControllers: new Map(),
    _internalActiveDeferreds: new Map()
  };
}
function createHref(to) {
  return typeof to === "string" ? to : reactRouterDom.createPath(to);
}
function encodeLocation(to) {
  // Locations should already be encoded on the server, so just return as-is
  let path = typeof to === "string" ? reactRouterDom.parsePath(to) : to;
  return {
    pathname: path.pathname || "",
    search: path.search || "",
    hash: path.hash || ""
  };
}
exports.StaticRouter = StaticRouter;
exports.StaticRouterProvider = StaticRouterProvider;
exports.createStaticRouter = createStaticRouter;

/***/ }),

/***/ "./node_modules/react-router/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/react-router/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbortedDeferredError": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.AbortedDeferredError),
/* harmony export */   "Await": () => (/* binding */ Await),
/* harmony export */   "MemoryRouter": () => (/* binding */ MemoryRouter),
/* harmony export */   "Navigate": () => (/* binding */ Navigate),
/* harmony export */   "NavigationType": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.Action),
/* harmony export */   "Outlet": () => (/* binding */ Outlet),
/* harmony export */   "Route": () => (/* binding */ Route),
/* harmony export */   "Router": () => (/* binding */ Router),
/* harmony export */   "RouterProvider": () => (/* binding */ RouterProvider),
/* harmony export */   "Routes": () => (/* binding */ Routes),
/* harmony export */   "UNSAFE_DataRouterContext": () => (/* binding */ DataRouterContext),
/* harmony export */   "UNSAFE_DataRouterStateContext": () => (/* binding */ DataRouterStateContext),
/* harmony export */   "UNSAFE_LocationContext": () => (/* binding */ LocationContext),
/* harmony export */   "UNSAFE_NavigationContext": () => (/* binding */ NavigationContext),
/* harmony export */   "UNSAFE_RouteContext": () => (/* binding */ RouteContext),
/* harmony export */   "UNSAFE_enhanceManualRouteObjects": () => (/* binding */ enhanceManualRouteObjects),
/* harmony export */   "createMemoryRouter": () => (/* binding */ createMemoryRouter),
/* harmony export */   "createPath": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.createPath),
/* harmony export */   "createRoutesFromChildren": () => (/* binding */ createRoutesFromChildren),
/* harmony export */   "createRoutesFromElements": () => (/* binding */ createRoutesFromChildren),
/* harmony export */   "defer": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.defer),
/* harmony export */   "generatePath": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.generatePath),
/* harmony export */   "isRouteErrorResponse": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.isRouteErrorResponse),
/* harmony export */   "json": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.json),
/* harmony export */   "matchPath": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.matchPath),
/* harmony export */   "matchRoutes": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.matchRoutes),
/* harmony export */   "parsePath": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.parsePath),
/* harmony export */   "redirect": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.redirect),
/* harmony export */   "renderMatches": () => (/* binding */ renderMatches),
/* harmony export */   "resolvePath": () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.resolvePath),
/* harmony export */   "unstable_useBlocker": () => (/* binding */ useBlocker),
/* harmony export */   "useActionData": () => (/* binding */ useActionData),
/* harmony export */   "useAsyncError": () => (/* binding */ useAsyncError),
/* harmony export */   "useAsyncValue": () => (/* binding */ useAsyncValue),
/* harmony export */   "useHref": () => (/* binding */ useHref),
/* harmony export */   "useInRouterContext": () => (/* binding */ useInRouterContext),
/* harmony export */   "useLoaderData": () => (/* binding */ useLoaderData),
/* harmony export */   "useLocation": () => (/* binding */ useLocation),
/* harmony export */   "useMatch": () => (/* binding */ useMatch),
/* harmony export */   "useMatches": () => (/* binding */ useMatches),
/* harmony export */   "useNavigate": () => (/* binding */ useNavigate),
/* harmony export */   "useNavigation": () => (/* binding */ useNavigation),
/* harmony export */   "useNavigationType": () => (/* binding */ useNavigationType),
/* harmony export */   "useOutlet": () => (/* binding */ useOutlet),
/* harmony export */   "useOutletContext": () => (/* binding */ useOutletContext),
/* harmony export */   "useParams": () => (/* binding */ useParams),
/* harmony export */   "useResolvedPath": () => (/* binding */ useResolvedPath),
/* harmony export */   "useRevalidator": () => (/* binding */ useRevalidator),
/* harmony export */   "useRouteError": () => (/* binding */ useRouteError),
/* harmony export */   "useRouteLoaderData": () => (/* binding */ useRouteLoaderData),
/* harmony export */   "useRoutes": () => (/* binding */ useRoutes)
/* harmony export */ });
/* harmony import */ var _remix_run_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @remix-run/router */ "./node_modules/@remix-run/router/dist/router.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/**
 * React Router v6.8.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */



function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */

function isPolyfill(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

const is = typeof Object.is === "function" ? Object.is : isPolyfill; // Intentionally not using named imports because Rollup uses dynamic
// dispatch for CommonJS interop named imports.

const {
  useState,
  useEffect,
  useLayoutEffect,
  useDebugValue
} = react__WEBPACK_IMPORTED_MODULE_1__;
let didWarnOld18Alpha = false;
let didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works
// because of a very particular set of implementation details and assumptions
// -- change any one of them and it will break. The most important assumption
// is that updates are always synchronous, because concurrent rendering is
// only available in versions of React that also have a built-in
// useSyncExternalStore API. And we only use this shim when the built-in API
// does not exist.
//
// Do not assume that the clever hacks used by this hook also work in general.
// The point of this shim is to replace the need for hacks by other libraries.

function useSyncExternalStore$2(subscribe, getSnapshot,
// Note: The shim does not use getServerSnapshot, because pre-18 versions of
// React do not expose a way to check if we're hydrating. So users of the shim
// will need to track that themselves and return the correct value
// from `getSnapshot`.
getServerSnapshot) {
  if (true) {
    if (!didWarnOld18Alpha) {
      if ("startTransition" in react__WEBPACK_IMPORTED_MODULE_1__) {
        didWarnOld18Alpha = true;
        console.error("You are using an outdated, pre-release alpha of React 18 that " + "does not support useSyncExternalStore. The " + "use-sync-external-store shim will not work correctly. Upgrade " + "to a newer pre-release.");
      }
    }
  } // Read the current snapshot from the store on every render. Again, this
  // breaks the rules of React, and only works here because of specific
  // implementation details, most importantly that updates are
  // always synchronous.

  const value = getSnapshot();
  if (true) {
    if (!didWarnUncachedGetSnapshot) {
      const cachedValue = getSnapshot();
      if (!is(value, cachedValue)) {
        console.error("The result of getSnapshot should be cached to avoid an infinite loop");
        didWarnUncachedGetSnapshot = true;
      }
    }
  } // Because updates are synchronous, we don't queue them. Instead we force a
  // re-render whenever the subscribed state changes by updating an some
  // arbitrary useState hook. Then, during render, we call getSnapshot to read
  // the current value.
  //
  // Because we don't actually use the state returned by the useState hook, we
  // can save a bit of memory by storing other stuff in that slot.
  //
  // To implement the early bailout, we need to track some things on a mutable
  // object. Usually, we would put that in a useRef hook, but we can stash it in
  // our useState hook instead.
  //
  // To force a re-render, we call forceUpdate({inst}). That works because the
  // new object always fails an equality check.

  const [{
    inst
  }, forceUpdate] = useState({
    inst: {
      value,
      getSnapshot
    }
  }); // Track the latest getSnapshot function with a ref. This needs to be updated
  // in the layout phase so we can access it during the tearing check that
  // happens on subscribe.

  useLayoutEffect(() => {
    inst.value = value;
    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the
    // commit phase if there was an interleaved mutation. In concurrent mode
    // this can happen all the time, but even in synchronous mode, an earlier
    // effect may have mutated the store.

    if (checkIfSnapshotChanged(inst)) {
      // Force a re-render.
      forceUpdate({
        inst
      });
    } // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [subscribe, value, getSnapshot]);
  useEffect(() => {
    // Check for changes right before subscribing. Subsequent changes will be
    // detected in the subscription handler.
    if (checkIfSnapshotChanged(inst)) {
      // Force a re-render.
      forceUpdate({
        inst
      });
    }
    const handleStoreChange = () => {
      // TODO: Because there is no cross-renderer API for batching updates, it's
      // up to the consumer of this library to wrap their subscription event
      // with unstable_batchedUpdates. Should we try to detect when this isn't
      // the case and print a warning in development?
      // The store changed. Check if the snapshot changed since the last time we
      // read from the store.
      if (checkIfSnapshotChanged(inst)) {
        // Force a re-render.
        forceUpdate({
          inst
        });
      }
    }; // Subscribe to the store and return a clean-up function.

    return subscribe(handleStoreChange); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [subscribe]);
  useDebugValue(value);
  return value;
}
function checkIfSnapshotChanged(inst) {
  const latestGetSnapshot = inst.getSnapshot;
  const prevValue = inst.value;
  try {
    const nextValue = latestGetSnapshot();
    return !is(prevValue, nextValue);
  } catch (error) {
    return true;
  }
}

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */
function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
  // Note: The shim does not use getServerSnapshot, because pre-18 versions of
  // React do not expose a way to check if we're hydrating. So users of the shim
  // will need to track that themselves and return the correct value
  // from `getSnapshot`.
  return getSnapshot();
}

/**
 * Inlined into the react-router repo since use-sync-external-store does not
 * provide a UMD-compatible package, so we need this to be able to distribute
 * UMD react-router bundles
 */
const canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const isServerEnvironment = !canUseDOM;
const shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
const useSyncExternalStore = "useSyncExternalStore" in react__WEBPACK_IMPORTED_MODULE_1__ ? (module => module.useSyncExternalStore)(react__WEBPACK_IMPORTED_MODULE_1__) : shim;
const DataRouterContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);
if (true) {
  DataRouterContext.displayName = "DataRouter";
}
const DataRouterStateContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);
if (true) {
  DataRouterStateContext.displayName = "DataRouterState";
}
const AwaitContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);
if (true) {
  AwaitContext.displayName = "Await";
}
const NavigationContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);
if (true) {
  NavigationContext.displayName = "Navigation";
}
const LocationContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);
if (true) {
  LocationContext.displayName = "Location";
}
const RouteContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createContext({
  outlet: null,
  matches: []
});
if (true) {
  RouteContext.displayName = "Route";
}
const RouteErrorContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);
if (true) {
  RouteErrorContext.displayName = "RouteError";
}

/**
 * Returns the full href for the given "to" value. This is useful for building
 * custom links that are also accessible and preserve right-click behavior.
 *
 * @see https://reactrouter.com/hooks/use-href
 */

function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false,
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useHref() may be used only in the context of a <Router> component.") : 0 : void 0;
  let {
    basename,
    navigator
  } = react__WEBPACK_IMPORTED_MODULE_1__.useContext(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname; // If we're operating within a basename, prepend it to the pathname prior
  // to creating the href.  If this is a root navigation, then just use the raw
  // basename which allows the basename to have full control over the presence
  // of a trailing slash on root links

  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.joinPaths)([basename, pathname]);
  }
  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
/**
 * Returns true if this component is a descendant of a <Router>.
 *
 * @see https://reactrouter.com/hooks/use-in-router-context
 */

function useInRouterContext() {
  return react__WEBPACK_IMPORTED_MODULE_1__.useContext(LocationContext) != null;
}
/**
 * Returns the current location object, which represents the current URL in web
 * browsers.
 *
 * Note: If you're using this it may mean you're doing some of your own
 * "routing" in your app, and we'd like to know what your use case is. We may
 * be able to provide something higher-level to better suit your needs.
 *
 * @see https://reactrouter.com/hooks/use-location
 */

function useLocation() {
  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false,
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useLocation() may be used only in the context of a <Router> component.") : 0 : void 0;
  return react__WEBPACK_IMPORTED_MODULE_1__.useContext(LocationContext).location;
}
/**
 * Returns the current navigation action which describes how the router came to
 * the current location, either by a pop, push, or replace on the history stack.
 *
 * @see https://reactrouter.com/hooks/use-navigation-type
 */

function useNavigationType() {
  return react__WEBPACK_IMPORTED_MODULE_1__.useContext(LocationContext).navigationType;
}
/**
 * Returns a PathMatch object if the given pattern matches the current URL.
 * This is useful for components that need to know "active" state, e.g.
 * <NavLink>.
 *
 * @see https://reactrouter.com/hooks/use-match
 */

function useMatch(pattern) {
  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false,
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useMatch() may be used only in the context of a <Router> component.") : 0 : void 0;
  let {
    pathname
  } = useLocation();
  return react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.matchPath)(pattern, pathname), [pathname, pattern]);
}
/**
 * The interface for the navigate() function returned from useNavigate().
 */

/**
 * Returns an imperative method for changing the location. Used by <Link>s, but
 * may also be used by other elements to change the location.
 *
 * @see https://reactrouter.com/hooks/use-navigate
 */
function useNavigate() {
  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false,
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useNavigate() may be used only in the context of a <Router> component.") : 0 : void 0;
  let {
    basename,
    navigator
  } = react__WEBPACK_IMPORTED_MODULE_1__.useContext(NavigationContext);
  let {
    matches
  } = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.UNSAFE_getPathContributingMatches)(matches).map(match => match.pathnameBase));
  let activeRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(false);
  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
    activeRef.current = true;
  });
  let navigate = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(function (to, options) {
    if (options === void 0) {
      options = {};
    }
     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.warning)(activeRef.current, "You should call navigate() in a React.useEffect(), not when " + "your component is first rendered.") : 0;
    if (!activeRef.current) return;
    if (typeof to === "number") {
      navigator.go(to);
      return;
    }
    let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path"); // If we're operating within a basename, prepend it to the pathname prior
    // to handing off to history.  If this is a root navigation, then we
    // navigate to the raw basename which allows the basename to have full
    // control over the presence of a trailing slash on root links

    if (basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.joinPaths)([basename, path.pathname]);
    }
    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);
  }, [basename, navigator, routePathnamesJson, locationPathname]);
  return navigate;
}
const OutletContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);
/**
 * Returns the context (if provided) for the child route at this level of the route
 * hierarchy.
 * @see https://reactrouter.com/hooks/use-outlet-context
 */

function useOutletContext() {
  return react__WEBPACK_IMPORTED_MODULE_1__.useContext(OutletContext);
}
/**
 * Returns the element for the child route at this level of the route
 * hierarchy. Used internally by <Outlet> to render child routes.
 *
 * @see https://reactrouter.com/hooks/use-outlet
 */

function useOutlet(context) {
  let outlet = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext).outlet;
  if (outlet) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(OutletContext.Provider, {
      value: context
    }, outlet);
  }
  return outlet;
}
/**
 * Returns an object of key/value pairs of the dynamic params from the current
 * URL that were matched by the route path.
 *
 * @see https://reactrouter.com/hooks/use-params
 */

function useParams() {
  let {
    matches
  } = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
/**
 * Resolves the pathname of the given `to` value against the current location.
 *
 * @see https://reactrouter.com/hooks/use-resolved-path
 */

function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    matches
  } = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.UNSAFE_getPathContributingMatches)(matches).map(match => match.pathnameBase));
  return react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
/**
 * Returns the element of the route that matched the current location, prepared
 * with the correct context to render the remainder of the route tree. Route
 * elements in the tree must render an <Outlet> to render their child route's
 * element.
 *
 * @see https://reactrouter.com/hooks/use-routes
 */

function useRoutes(routes, locationArg) {
  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false,
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useRoutes() may be used only in the context of a <Router> component.") : 0 : void 0;
  let {
    navigator
  } = react__WEBPACK_IMPORTED_MODULE_1__.useContext(NavigationContext);
  let dataRouterStateContext = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DataRouterStateContext);
  let {
    matches: parentMatches
  } = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  if (true) {
    // You won't get a warning about 2 different <Routes> under a <Route>
    // without a trailing *, but this is a best-effort warning anyway since we
    // cannot even give the warning unless they land at the parent route.
    //
    // Example:
    //
    // <Routes>
    //   {/* This route path MUST end with /* because otherwise
    //       it will never match /blog/post/123 */}
    //   <Route path="blog" element={<Blog />} />
    //   <Route path="blog/feed" element={<BlogFeed />} />
    // </Routes>
    //
    // function Blog() {
    //   return (
    //     <Routes>
    //       <Route path="post/:id" element={<Post />} />
    //     </Routes>
    //   );
    // }
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ("\"" + parentPathname + "\" (under <Route path=\"" + parentPath + "\">) but the ") + "parent route path has no trailing \"*\". This means if you navigate " + "deeper, the parent won't match anymore and therefore the child " + "routes will never render.\n\n" + ("Please change the parent <Route path=\"" + parentPath + "\"> to <Route ") + ("path=\"" + (parentPath === "/" ? "*" : parentPath + "/*") + "\">."));
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.parsePath)(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, " + "the location pathname must begin with the portion of the URL pathname that was " + ("matched by all parent routes. The current pathname base is \"" + parentPathnameBase + "\" ") + ("but pathname \"" + parsedLocationArg.pathname + "\" was given in the `location` prop.")) : 0 : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.matchRoutes)(routes, {
    pathname: remainingPathname
  });
  if (true) {
     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.warning)(parentRoute || matches != null, "No routes matched location \"" + location.pathname + location.search + location.hash + "\" ") : 0;
     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.warning)(matches == null || matches[matches.length - 1].route.element !== undefined, "Matched leaf route at location \"" + location.pathname + location.search + location.hash + "\" does not have an element. " + "This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.") : 0;
  }
  let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.joinPaths)([parentPathnameBase,
    // Re-encode pathnames that were decoded inside matchRoutes
    navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.joinPaths)([parentPathnameBase,
    // Re-encode pathnames that were decoded inside matchRoutes
    navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])
  })), parentMatches, dataRouterStateContext || undefined); // When a user passes in a `locationArg`, the associated routes need to
  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`
  // to use the scoped location instead of the global location.

  if (locationArg && renderedMatches) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(LocationContext.Provider, {
      value: {
        location: _extends({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorElement() {
  let error = useRouteError();
  let message = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.isRouteErrorResponse)(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  if (true) {
    devInfo = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("p", null, "\uD83D\uDCBF Hey developer \uD83D\uDC4B"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own\xA0", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("code", {
      style: codeStyles
    }, "errorElement"), " props on\xA0", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("code", {
      style: codeStyles
    }, "<Route>")));
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("h2", null, "Unexpected Application Error!"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
class RenderErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_1__.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error: error
    };
  }
  static getDerivedStateFromProps(props, state) {
    // When we get into an error state, the user will likely click "back" to the
    // previous page that didn't have an error. Because this wraps the entire
    // application, that will have no effect--the error page continues to display.
    // This gives us a mechanism to recover from the error when the location changes.
    //
    // Whether we're in an error state or not, we update the location in state
    // so that when we are in an error state, it gets reset when a new location
    // comes in and the user recovers from the error.
    if (state.location !== props.location) {
      return {
        error: props.error,
        location: props.location
      };
    } // If we're not changing locations, preserve the location but still surface
    // any new errors that may come through. We retain the existing error, we do
    // this because the error provided from the app state may be cleared without
    // the location changing.

    return {
      error: props.error || state.error,
      location: state.location
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match,
    children
  } = _ref;
  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DataRouterContext); // Track how deep we got in our render pass to emulate SSR componentDidCatch
  // in a DataStaticRouter

  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && match.route.errorElement) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null) {
    if (dataRouterState != null && dataRouterState.errors) {
      // Don't bail if we have data router errors so we can render them in the
      // boundary.  Use the pre-matched (or shimmed) matches
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches; // If we have data errors, trim matches to the highest error boundary

  let errors = dataRouterState == null ? void 0 : dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]));
    !(errorIndex >= 0) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, "Could not find a matching route for the current errors: " + errors) : 0 : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match, index) => {
    let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null; // Only data routers handle errors

    let errorElement = dataRouterState ? match.route.errorElement || /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(DefaultErrorElement, null) : null;
    let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));
    let getChildren = () => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(RenderedRoute, {
      match: match,
      routeContext: {
        outlet,
        matches
      }
    }, error ? errorElement : match.route.element !== undefined ? match.route.element : outlet); // Only wrap in an error boundary within data router usages when we have an
    // errorElement on this route.  Otherwise let it bubble up to an ancestor
    // errorElement

    return dataRouterState && (match.route.errorElement || index === 0) ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      component: errorElement,
      error: error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook;
(function (DataRouterHook) {
  DataRouterHook["UseBlocker"] = "useBlocker";
  DataRouterHook["UseRevalidator"] = "useRevalidator";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function (DataRouterStateHook) {
  DataRouterStateHook["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook["UseActionData"] = "useActionData";
  DataRouterStateHook["UseRouteError"] = "useRouteError";
  DataRouterStateHook["UseNavigation"] = "useNavigation";
  DataRouterStateHook["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook["UseMatches"] = "useMatches";
  DataRouterStateHook["UseRevalidator"] = "useRevalidator";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function getDataRouterConsoleError(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function useDataRouterContext(hookName) {
  let ctx = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DataRouterContext);
  !ctx ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DataRouterStateContext);
  !state ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext);
  !route ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, hookName + " can only be used on routes that contain a unique \"id\"") : 0 : void 0;
  return thisRoute.route.id;
}
/**
 * Returns the current navigation, defaulting to an "idle" navigation when
 * no navigation is in progress
 */

function useNavigation() {
  let state = useDataRouterState(DataRouterStateHook.UseNavigation);
  return state.navigation;
}
/**
 * Returns a revalidate function for manually triggering revalidation, as well
 * as the current state of any manual revalidations
 */

function useRevalidator() {
  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);
  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);
  return {
    revalidate: dataRouterContext.router.revalidate,
    state: state.revalidation
  };
}
/**
 * Returns the active route matches, useful for accessing loaderData for
 * parent/child routes or the route "handle" property
 */

function useMatches() {
  let {
    matches,
    loaderData
  } = useDataRouterState(DataRouterStateHook.UseMatches);
  return react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => matches.map(match => {
    let {
      pathname,
      params
    } = match; // Note: This structure matches that created by createUseMatchesMatch
    // in the @remix-run/router , so if you change this please also change
    // that :)  Eventually we'll DRY this up

    return {
      id: match.route.id,
      pathname,
      params,
      data: loaderData[match.route.id],
      handle: match.route.handle
    };
  }), [matches, loaderData]);
}
/**
 * Returns the loader data for the nearest ancestor Route loader
 */

function useLoaderData() {
  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);
  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);
  if (state.errors && state.errors[routeId] != null) {
    console.error("You cannot `useLoaderData` in an errorElement (routeId: " + routeId + ")");
    return undefined;
  }
  return state.loaderData[routeId];
}
/**
 * Returns the loaderData for the given routeId
 */

function useRouteLoaderData(routeId) {
  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);
  return state.loaderData[routeId];
}
/**
 * Returns the action data for the nearest ancestor Route action
 */

function useActionData() {
  let state = useDataRouterState(DataRouterStateHook.UseActionData);
  let route = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteContext);
  !route ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, "useActionData must be used inside a RouteContext") : 0 : void 0;
  return Object.values((state == null ? void 0 : state.actionData) || {})[0];
}
/**
 * Returns the nearest ancestor Route error, which could be a loader/action
 * error or a render error.  This is intended to be called from your
 * errorElement to display a proper error message.
 */

function useRouteError() {
  var _state$errors;
  let error = react__WEBPACK_IMPORTED_MODULE_1__.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError); // If this was a render error, we put it in a RouteError context inside
  // of RenderErrorBoundary

  if (error) {
    return error;
  } // Otherwise look for errors from our data router state

  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
/**
 * Returns the happy-path data from the nearest ancestor <Await /> value
 */

function useAsyncValue() {
  let value = react__WEBPACK_IMPORTED_MODULE_1__.useContext(AwaitContext);
  return value == null ? void 0 : value._data;
}
/**
 * Returns the error from the nearest ancestor <Await /> value
 */

function useAsyncError() {
  let value = react__WEBPACK_IMPORTED_MODULE_1__.useContext(AwaitContext);
  return value == null ? void 0 : value._error;
}
let blockerId = 0;
/**
 * Allow the application to block navigations within the SPA and present the
 * user a confirmation dialog to confirm the navigation.  Mostly used to avoid
 * using half-filled form data.  This does not handle hard-reloads or
 * cross-origin navigations.
 */

function useBlocker(shouldBlock) {
  let {
    router
  } = useDataRouterContext(DataRouterHook.UseBlocker);
  let [blockerKey] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => String(++blockerId));
  let blockerFunction = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(args => {
    return typeof shouldBlock === "function" ? !!shouldBlock(args) : !!shouldBlock;
  }, [shouldBlock]);
  let blocker = router.getBlocker(blockerKey, blockerFunction); // Cleanup on unmount

  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => () => router.deleteBlocker(blockerKey), [router, blockerKey]);
  return blocker;
}
const alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.warning)(false, message) : 0;
  }
}

/**
 * Given a Remix Router instance, render the appropriate UI
 */
function RouterProvider(_ref) {
  let {
    fallbackElement,
    router
  } = _ref;
  // Sync router state to our component state to force re-renders
  let state = useSyncExternalStore(router.subscribe, () => router.state,
  // We have to provide this so React@18 doesn't complain during hydration,
  // but we pass our serialized hydration data into the router so state here
  // is already synced with what the server saw
  () => router.state);
  let navigator = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {
    return {
      createHref: router.createHref,
      encodeLocation: router.encodeLocation,
      go: n => router.navigate(n),
      push: (to, state, opts) => router.navigate(to, {
        state,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      }),
      replace: (to, state, opts) => router.navigate(to, {
        replace: true,
        state,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      })
    };
  }, [router]);
  let basename = router.basename || "/"; // The fragment and {null} here are important!  We need them to keep React 18's
  // useId happy when we are server-rendering since we may have a <script> here
  // containing the hydrated server-side staticContext (from StaticRouterProvider).
  // useId relies on the component tree structure to generate deterministic id's
  // so we need to ensure it remains the same on the client even though
  // we don't need the <script> tag

  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(DataRouterContext.Provider, {
    value: {
      router,
      navigator,
      static: false,
      // Do we need this?
      basename
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(DataRouterStateContext.Provider, {
    value: state
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Router, {
    basename: router.basename,
    location: router.state.location,
    navigationType: router.state.historyAction,
    navigator: navigator
  }, router.state.initialized ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Routes, null) : fallbackElement))), null);
}

/**
 * A <Router> that stores all entries in memory.
 *
 * @see https://reactrouter.com/router-components/memory-router
 */
function MemoryRouter(_ref2) {
  let {
    basename,
    children,
    initialEntries,
    initialIndex
  } = _ref2;
  let historyRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef();
  if (historyRef.current == null) {
    historyRef.current = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.createMemoryHistory)({
      initialEntries,
      initialIndex,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setState] = react__WEBPACK_IMPORTED_MODULE_1__.useState({
    action: history.action,
    location: history.location
  });
  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => history.listen(setState), [history]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}

/**
 * Changes the current location.
 *
 * Note: This API is mostly useful in React.Component subclasses that are not
 * able to use hooks. In functional components, we recommend you use the
 * `useNavigate` hook instead.
 *
 * @see https://reactrouter.com/components/navigate
 */
function Navigate(_ref3) {
  let {
    to,
    replace,
    state,
    relative
  } = _ref3;
  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false,
  // TODO: This error is probably because they somehow have 2 versions of
  // the router loaded. We can help them understand how to avoid that.
  "<Navigate> may be used only in the context of a <Router> component.") : 0 : void 0;
   true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.warning)(!react__WEBPACK_IMPORTED_MODULE_1__.useContext(NavigationContext).static, "<Navigate> must not be used on the initial render in a <StaticRouter>. " + "This is a no-op, but you should modify your code so the <Navigate> is " + "only ever rendered in response to some user interaction or state change.") : 0;
  let dataRouterState = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DataRouterStateContext);
  let navigate = useNavigate();
  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
    // Avoid kicking off multiple navigations if we're in the middle of a
    // data-router navigation, since components get re-rendered when we enter
    // a submitting/loading state
    if (dataRouterState && dataRouterState.navigation.state !== "idle") {
      return;
    }
    navigate(to, {
      replace,
      state,
      relative
    });
  });
  return null;
}

/**
 * Renders the child route's element, if there is one.
 *
 * @see https://reactrouter.com/components/outlet
 */
function Outlet(props) {
  return useOutlet(props.context);
}

/**
 * Declares an element that should be rendered at a certain URL path.
 *
 * @see https://reactrouter.com/components/route
 */
function Route(_props) {
   true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, "A <Route> is only ever to be used as the child of <Routes> element, " + "never rendered directly. Please wrap your <Route> in a <Routes>.") : 0;
}

/**
 * Provides location context for the rest of the app.
 *
 * Note: You usually won't render a <Router> directly. Instead, you'll render a
 * router that is more specific to your environment such as a <BrowserRouter>
 * in web browsers or a <StaticRouter> for server rendering.
 *
 * @see https://reactrouter.com/router-components/router
 */
function Router(_ref4) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.Action.Pop,
    navigator,
    static: staticProp = false
  } = _ref4;
  !!useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, "You cannot render a <Router> inside another <Router>." + " You should never have more than one in your app.") : 0 : void 0; // Preserve trailing slashes on basename, so we can let the user control
  // the enforcement of trailing slashes throughout the app

  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => ({
    basename,
    navigator,
    static: staticProp
  }), [basename, navigator, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.parsePath)(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let location = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {
    let trailingPathname = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.stripBasename)(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
    };
  }, [basename, pathname, search, hash, state, key]);
   true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.warning)(location != null, "<Router basename=\"" + basename + "\"> is not able to match the URL " + ("\"" + pathname + search + hash + "\" because it does not start with the ") + "basename, so the <Router> won't render anything.") : 0;
  if (location == null) {
    return null;
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(LocationContext.Provider, {
    children: children,
    value: {
      location,
      navigationType
    }
  }));
}

/**
 * A container for a nested tree of <Route> elements that renders the branch
 * that best matches the current location.
 *
 * @see https://reactrouter.com/components/routes
 */
function Routes(_ref5) {
  let {
    children,
    location
  } = _ref5;
  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DataRouterContext); // When in a DataRouterContext _without_ children, we use the router routes
  // directly.  If we have children, then we're in a descendant tree and we
  // need to use child routes.

  let routes = dataRouterContext && !children ? dataRouterContext.router.routes : createRoutesFromChildren(children);
  return useRoutes(routes, location);
}

/**
 * Component to use for rendering lazily loaded data from returning defer()
 * in a loader function
 */
function Await(_ref6) {
  let {
    children,
    errorElement,
    resolve
  } = _ref6;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(AwaitErrorBoundary, {
    resolve: resolve,
    errorElement: errorElement
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(ResolveAwait, null, children));
}
var AwaitRenderStatus;
(function (AwaitRenderStatus) {
  AwaitRenderStatus[AwaitRenderStatus["pending"] = 0] = "pending";
  AwaitRenderStatus[AwaitRenderStatus["success"] = 1] = "success";
  AwaitRenderStatus[AwaitRenderStatus["error"] = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));
const neverSettledPromise = new Promise(() => {});
class AwaitErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_1__.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: null
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("<Await> caught the following error during render", error, errorInfo);
  }
  render() {
    let {
      children,
      errorElement,
      resolve
    } = this.props;
    let promise = null;
    let status = AwaitRenderStatus.pending;
    if (!(resolve instanceof Promise)) {
      // Didn't get a promise - provide as a resolved promise
      status = AwaitRenderStatus.success;
      promise = Promise.resolve();
      Object.defineProperty(promise, "_tracked", {
        get: () => true
      });
      Object.defineProperty(promise, "_data", {
        get: () => resolve
      });
    } else if (this.state.error) {
      // Caught a render error, provide it as a rejected promise
      status = AwaitRenderStatus.error;
      let renderError = this.state.error;
      promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings

      Object.defineProperty(promise, "_tracked", {
        get: () => true
      });
      Object.defineProperty(promise, "_error", {
        get: () => renderError
      });
    } else if (resolve._tracked) {
      // Already tracked promise - check contents
      promise = resolve;
      status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;
    } else {
      // Raw (untracked) promise - track it
      status = AwaitRenderStatus.pending;
      Object.defineProperty(resolve, "_tracked", {
        get: () => true
      });
      promise = resolve.then(data => Object.defineProperty(resolve, "_data", {
        get: () => data
      }), error => Object.defineProperty(resolve, "_error", {
        get: () => error
      }));
    }
    if (status === AwaitRenderStatus.error && promise._error instanceof _remix_run_router__WEBPACK_IMPORTED_MODULE_0__.AbortedDeferredError) {
      // Freeze the UI by throwing a never resolved promise
      throw neverSettledPromise;
    }
    if (status === AwaitRenderStatus.error && !errorElement) {
      // No errorElement, throw to the nearest route-level error boundary
      throw promise._error;
    }
    if (status === AwaitRenderStatus.error) {
      // Render via our errorElement
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(AwaitContext.Provider, {
        value: promise,
        children: errorElement
      });
    }
    if (status === AwaitRenderStatus.success) {
      // Render children with resolved value
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(AwaitContext.Provider, {
        value: promise,
        children: children
      });
    } // Throw to the suspense boundary

    throw promise;
  }
}
/**
 * @private
 * Indirection to leverage useAsyncValue for a render-prop API on <Await>
 */

function ResolveAwait(_ref7) {
  let {
    children
  } = _ref7;
  let data = useAsyncValue();
  let toRender = typeof children === "function" ? children(data) : children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, toRender);
} ///////////////////////////////////////////////////////////////////////////////
// UTILS
///////////////////////////////////////////////////////////////////////////////

/**
 * Creates a route config from a React "children" object, which is usually
 * either a `<Route>` element or an array of them. Used internally by
 * `<Routes>` to create a route config from its children.
 *
 * @see https://reactrouter.com/utils/create-routes-from-children
 */

function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  react__WEBPACK_IMPORTED_MODULE_1__.Children.forEach(children, (element, index) => {
    if (! /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.isValidElement(element)) {
      // Ignore non-elements. This allows people to more easily inline
      // conditionals in their route config.
      return;
    }
    if (element.type === react__WEBPACK_IMPORTED_MODULE_1__.Fragment) {
      // Transparently support React.Fragment and its children.
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, parentPath));
      return;
    }
    !(element.type === Route) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, "[" + (typeof element.type === "string" ? element.type : element.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : 0 : void 0;
    !(!element.props.index || !element.props.children) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.invariant)(false, "An index route cannot have child routes.") : 0 : void 0;
    let treePath = [...parentPath, index];
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      hasErrorBoundary: element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
/**
 * Renders the result of `matchRoutes()` into a React element.
 */

function renderMatches(matches) {
  return _renderMatches(matches);
}
/**
 * @private
 * Walk the route tree and add hasErrorBoundary if it's not provided, so that
 * users providing manual route arrays can just specify errorElement
 */

function enhanceManualRouteObjects(routes) {
  return routes.map(route => {
    let routeClone = _extends({}, route);
    if (routeClone.hasErrorBoundary == null) {
      routeClone.hasErrorBoundary = routeClone.errorElement != null;
    }
    if (routeClone.children) {
      routeClone.children = enhanceManualRouteObjects(routeClone.children);
    }
    return routeClone;
  });
}
function createMemoryRouter(routes, opts) {
  return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.createRouter)({
    basename: opts == null ? void 0 : opts.basename,
    history: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_0__.createMemoryHistory)({
      initialEntries: opts == null ? void 0 : opts.initialEntries,
      initialIndex: opts == null ? void 0 : opts.initialIndex
    }),
    hydrationData: opts == null ? void 0 : opts.hydrationData,
    routes: enhanceManualRouteObjects(routes)
  }).initialize();
} ///////////////////////////////////////////////////////////////////////////////



/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function () {
    'use strict';

    var React = __webpack_require__(/*! react */ "react");

    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types.
    var REACT_ELEMENT_TYPE = Symbol.for('react.element');
    var REACT_PORTAL_TYPE = Symbol.for('react.portal');
    var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
    var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
    var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
    var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
    var REACT_CONTEXT_TYPE = Symbol.for('react.context');
    var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
    var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
    var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
    var REACT_MEMO_TYPE = Symbol.for('react.memo');
    var REACT_LAZY_TYPE = Symbol.for('react.lazy');
    var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';
    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable !== 'object') {
        return null;
      }
      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
      if (typeof maybeIterator === 'function') {
        return maybeIterator;
      }
      return null;
    }
    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function error(format) {
      {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          printWarning('error', format, args);
        }
      }
    }
    function printWarning(level, format, args) {
      // When changing this logic, you might want to also
      // update consoleWithStackDev.www.js as well.
      {
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();
        if (stack !== '') {
          format += '%s';
          args = args.concat([stack]);
        } // eslint-disable-next-line react-internal/safe-string-coercion

        var argsWithFormat = args.map(function (item) {
          return String(item);
        }); // Careful: RN currently depends on this prefix

        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
        // breaks IE9: https://github.com/facebook/react/issues/13610
        // eslint-disable-next-line react-internal/no-production-logging

        Function.prototype.apply.call(console[level], console, argsWithFormat);
      }
    }

    // -----------------------------------------------------------------------------

    var enableScopeAPI = false; // Experimental Create Event Handle API.
    var enableCacheElement = false;
    var enableTransitionTracing = false; // No known bugs, but needs performance testing

    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
    // stuff. Intended to enable React core members to more easily debug scheduling
    // issues in DEV builds.

    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

    var REACT_MODULE_REFERENCE;
    {
      REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
    }
    function isValidElementType(type) {
      if (typeof type === 'string' || typeof type === 'function') {
        return true;
      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).

      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
        return true;
      }
      if (typeof type === 'object' && type !== null) {
        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||
        // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
          return true;
        }
      }
      return false;
    }
    function getWrappedName(outerType, innerType, wrapperName) {
      var displayName = outerType.displayName;
      if (displayName) {
        return displayName;
      }
      var functionName = innerType.displayName || innerType.name || '';
      return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
    } // Keep in sync with react-reconciler/getComponentNameFromFiber

    function getContextName(type) {
      return type.displayName || 'Context';
    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.

    function getComponentNameFromType(type) {
      if (type == null) {
        // Host root, text node or just invalid type.
        return null;
      }
      {
        if (typeof type.tag === 'number') {
          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
        }
      }
      if (typeof type === 'function') {
        return type.displayName || type.name || null;
      }
      if (typeof type === 'string') {
        return type;
      }
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return 'Fragment';
        case REACT_PORTAL_TYPE:
          return 'Portal';
        case REACT_PROFILER_TYPE:
          return 'Profiler';
        case REACT_STRICT_MODE_TYPE:
          return 'StrictMode';
        case REACT_SUSPENSE_TYPE:
          return 'Suspense';
        case REACT_SUSPENSE_LIST_TYPE:
          return 'SuspenseList';
      }
      if (typeof type === 'object') {
        switch (type.$$typeof) {
          case REACT_CONTEXT_TYPE:
            var context = type;
            return getContextName(context) + '.Consumer';
          case REACT_PROVIDER_TYPE:
            var provider = type;
            return getContextName(provider._context) + '.Provider';
          case REACT_FORWARD_REF_TYPE:
            return getWrappedName(type, type.render, 'ForwardRef');
          case REACT_MEMO_TYPE:
            var outerName = type.displayName || null;
            if (outerName !== null) {
              return outerName;
            }
            return getComponentNameFromType(type.type) || 'Memo';
          case REACT_LAZY_TYPE:
            {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }

          // eslint-disable-next-line no-fallthrough
        }
      }

      return null;
    }
    var assign = Object.assign;

    // Helpers to patch console.logs to avoid logging during side-effect free
    // replaying on render function. This currently only patches the object
    // lazily which won't cover if the log function was extracted eagerly.
    // We could also eagerly patch the method.
    var disabledDepth = 0;
    var prevLog;
    var prevInfo;
    var prevWarn;
    var prevError;
    var prevGroup;
    var prevGroupCollapsed;
    var prevGroupEnd;
    function disabledLog() {}
    disabledLog.__reactDisabledLog = true;
    function disableLogs() {
      {
        if (disabledDepth === 0) {
          /* eslint-disable react-internal/no-production-logging */
          prevLog = console.log;
          prevInfo = console.info;
          prevWarn = console.warn;
          prevError = console.error;
          prevGroup = console.group;
          prevGroupCollapsed = console.groupCollapsed;
          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

          var props = {
            configurable: true,
            enumerable: true,
            value: disabledLog,
            writable: true
          }; // $FlowFixMe Flow thinks console is immutable.

          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
          /* eslint-enable react-internal/no-production-logging */
        }

        disabledDepth++;
      }
    }
    function reenableLogs() {
      {
        disabledDepth--;
        if (disabledDepth === 0) {
          /* eslint-disable react-internal/no-production-logging */
          var props = {
            configurable: true,
            enumerable: true,
            writable: true
          }; // $FlowFixMe Flow thinks console is immutable.

          Object.defineProperties(console, {
            log: assign({}, props, {
              value: prevLog
            }),
            info: assign({}, props, {
              value: prevInfo
            }),
            warn: assign({}, props, {
              value: prevWarn
            }),
            error: assign({}, props, {
              value: prevError
            }),
            group: assign({}, props, {
              value: prevGroup
            }),
            groupCollapsed: assign({}, props, {
              value: prevGroupCollapsed
            }),
            groupEnd: assign({}, props, {
              value: prevGroupEnd
            })
          });
          /* eslint-enable react-internal/no-production-logging */
        }

        if (disabledDepth < 0) {
          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
        }
      }
    }
    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
    var prefix;
    function describeBuiltInComponentFrame(name, source, ownerFn) {
      {
        if (prefix === undefined) {
          // Extract the VM specific prefix used by each line.
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || '';
          }
        } // We use the prefix to ensure our stacks line up with native stack frames.

        return '\n' + prefix + name;
      }
    }
    var reentry = false;
    var componentFrameCache;
    {
      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
      componentFrameCache = new PossiblyWeakMap();
    }
    function describeNativeComponentFrame(fn, construct) {
      // If something asked for a stack inside a fake render, it should get ignored.
      if (!fn || reentry) {
        return '';
      }
      {
        var frame = componentFrameCache.get(fn);
        if (frame !== undefined) {
          return frame;
        }
      }
      var control;
      reentry = true;
      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

      Error.prepareStackTrace = undefined;
      var previousDispatcher;
      {
        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
        // for warnings.

        ReactCurrentDispatcher.current = null;
        disableLogs();
      }
      try {
        // This should throw.
        if (construct) {
          // Something should be setting the props in the constructor.
          var Fake = function () {
            throw Error();
          }; // $FlowFixMe

          Object.defineProperty(Fake.prototype, 'props', {
            set: function () {
              // We use a throwing setter instead of frozen or non-writable props
              // because that won't throw in a non-strict mode function.
              throw Error();
            }
          });
          if (typeof Reflect === 'object' && Reflect.construct) {
            // We construct a different control for this case to include any extra
            // frames added by the construct call.
            try {
              Reflect.construct(Fake, []);
            } catch (x) {
              control = x;
            }
            Reflect.construct(fn, [], Fake);
          } else {
            try {
              Fake.call();
            } catch (x) {
              control = x;
            }
            fn.call(Fake.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (x) {
            control = x;
          }
          fn();
        }
      } catch (sample) {
        // This is inlined manually because closure doesn't do it for us.
        if (sample && control && typeof sample.stack === 'string') {
          // This extracts the first frame from the sample that isn't also in the control.
          // Skipping one frame that we assume is the frame that calls the two.
          var sampleLines = sample.stack.split('\n');
          var controlLines = control.stack.split('\n');
          var s = sampleLines.length - 1;
          var c = controlLines.length - 1;
          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
            // We expect at least one stack frame to be shared.
            // Typically this will be the root most one. However, stack frames may be
            // cut off due to maximum stack limits. In this case, one maybe cut off
            // earlier than the other. We assume that the sample is longer or the same
            // and there for cut off earlier. So we should find the root most frame in
            // the sample somewhere in the control.
            c--;
          }
          for (; s >= 1 && c >= 0; s--, c--) {
            // Next we find the first one that isn't the same which should be the
            // frame that called our sample function and the control.
            if (sampleLines[s] !== controlLines[c]) {
              // In V8, the first line is describing the message but other VMs don't.
              // If we're about to return the first line, and the control is also on the same
              // line, that's a pretty good indicator that our sample threw at same line as
              // the control. I.e. before we entered the sample frame. So we ignore this result.
              // This can happen if you passed a class to function component, or non-function.
              if (s !== 1 || c !== 1) {
                do {
                  s--;
                  c--; // We may still have similar intermediate frames from the construct call.
                  // The next one that isn't the same should be our match though.

                  if (c < 0 || sampleLines[s] !== controlLines[c]) {
                    // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                    var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
                    // but we have a user-provided "displayName"
                    // splice it in to make the stack more readable.

                    if (fn.displayName && _frame.includes('<anonymous>')) {
                      _frame = _frame.replace('<anonymous>', fn.displayName);
                    }
                    {
                      if (typeof fn === 'function') {
                        componentFrameCache.set(fn, _frame);
                      }
                    } // Return the line we found.

                    return _frame;
                  }
                } while (s >= 1 && c >= 0);
              }
              break;
            }
          }
        }
      } finally {
        reentry = false;
        {
          ReactCurrentDispatcher.current = previousDispatcher;
          reenableLogs();
        }
        Error.prepareStackTrace = previousPrepareStackTrace;
      } // Fallback to just using the name if we couldn't make it throw.

      var name = fn ? fn.displayName || fn.name : '';
      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
      {
        if (typeof fn === 'function') {
          componentFrameCache.set(fn, syntheticFrame);
        }
      }
      return syntheticFrame;
    }
    function describeFunctionComponentFrame(fn, source, ownerFn) {
      {
        return describeNativeComponentFrame(fn, false);
      }
    }
    function shouldConstruct(Component) {
      var prototype = Component.prototype;
      return !!(prototype && prototype.isReactComponent);
    }
    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
      if (type == null) {
        return '';
      }
      if (typeof type === 'function') {
        {
          return describeNativeComponentFrame(type, shouldConstruct(type));
        }
      }
      if (typeof type === 'string') {
        return describeBuiltInComponentFrame(type);
      }
      switch (type) {
        case REACT_SUSPENSE_TYPE:
          return describeBuiltInComponentFrame('Suspense');
        case REACT_SUSPENSE_LIST_TYPE:
          return describeBuiltInComponentFrame('SuspenseList');
      }
      if (typeof type === 'object') {
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            return describeFunctionComponentFrame(type.render);
          case REACT_MEMO_TYPE:
            // Memo may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
          case REACT_LAZY_TYPE:
            {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                // Lazy may contain any component type so we recursively resolve it.
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {}
            }
        }
      }
      return '';
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var loggedTypeFailures = {};
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement(element) {
      {
        if (element) {
          var owner = element._owner;
          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame.setExtraStackFrame(stack);
        } else {
          ReactDebugCurrentFrame.setExtraStackFrame(null);
        }
      }
    }
    function checkPropTypes(typeSpecs, values, location, componentName, element) {
      {
        // $FlowFixMe This is okay but Flow doesn't know it.
        var has = Function.call.bind(hasOwnProperty);
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
            // fail the render phase where it didn't fail before. So we log it.
            // After these have been cleaned up, we'll let them throw.

            try {
              // This is intentionally an invariant that gets caught. It's the same
              // behavior as without this statement except with a better message.
              if (typeof typeSpecs[typeSpecName] !== 'function') {
                // eslint-disable-next-line react-internal/prod-error-codes
                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                err.name = 'Invariant Violation';
                throw err;
              }
              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
            } catch (ex) {
              error$1 = ex;
            }
            if (error$1 && !(error$1 instanceof Error)) {
              setCurrentlyValidatingElement(element);
              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);
              setCurrentlyValidatingElement(null);
            }
            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
              // Only monitor this failure once because there tends to be a lot of the
              // same error.
              loggedTypeFailures[error$1.message] = true;
              setCurrentlyValidatingElement(element);
              error('Failed %s type: %s', location, error$1.message);
              setCurrentlyValidatingElement(null);
            }
          }
        }
      }
    }
    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

    function isArray(a) {
      return isArrayImpl(a);
    }

    /*
     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
     *
     * The functions in this module will throw an easier-to-understand,
     * easier-to-debug exception with a clear errors message message explaining the
     * problem. (Instead of a confusing exception thrown inside the implementation
     * of the `value` object).
     */
    // $FlowFixMe only called in DEV, so void return is not possible.
    function typeName(value) {
      {
        // toStringTag is needed for namespaced types like Temporal.Instant
        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
        return type;
      }
    } // $FlowFixMe only called in DEV, so void return is not possible.

    function willCoercionThrow(value) {
      {
        try {
          testStringCoercion(value);
          return false;
        } catch (e) {
          return true;
        }
      }
    }
    function testStringCoercion(value) {
      // If you ended up here by following an exception call stack, here's what's
      // happened: you supplied an object or symbol value to React (as a prop, key,
      // DOM attribute, CSS property, string ref, etc.) and when React tried to
      // coerce it to a string using `'' + value`, an exception was thrown.
      //
      // The most common types that will cause this exception are `Symbol` instances
      // and Temporal objects like `Temporal.Instant`. But any object that has a
      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
      // exception. (Library authors do this to prevent users from using built-in
      // numeric operators like `+` or comparison operators like `>=` because custom
      // methods are needed to perform accurate arithmetic or comparison.)
      //
      // To fix the problem, coerce this object or symbol value to a string before
      // passing it to React. The most reliable way is usually `String(value)`.
      //
      // To find which value is throwing, check the browser or debugger console.
      // Before this exception was thrown, there should be `console.error` output
      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
      // problem and how that type was used: key, atrribute, input value prop, etc.
      // In most cases, this console output also shows the component and its
      // ancestor components where the exception happened.
      //
      // eslint-disable-next-line react-internal/safe-string-coercion
      return '' + value;
    }
    function checkKeyStringCoercion(value) {
      {
        if (willCoercionThrow(value)) {
          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
        }
      }
    }

    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };
    var specialPropKeyWarningShown;
    var specialPropRefWarningShown;
    var didWarnAboutStringRefs;
    {
      didWarnAboutStringRefs = {};
    }
    function hasValidRef(config) {
      {
        if (hasOwnProperty.call(config, 'ref')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.ref !== undefined;
    }
    function hasValidKey(config) {
      {
        if (hasOwnProperty.call(config, 'key')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.key !== undefined;
    }
    function warnIfStringRefCannotBeAutoConverted(config, self) {
      {
        if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
          if (!didWarnAboutStringRefs[componentName]) {
            error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
            didWarnAboutStringRefs[componentName] = true;
          }
        }
      }
    }
    function defineKeyPropWarningGetter(props, displayName) {
      {
        var warnAboutAccessingKey = function () {
          if (!specialPropKeyWarningShown) {
            specialPropKeyWarningShown = true;
            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
          }
        };
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, 'key', {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
    }
    function defineRefPropWarningGetter(props, displayName) {
      {
        var warnAboutAccessingRef = function () {
          if (!specialPropRefWarningShown) {
            specialPropRefWarningShown = true;
            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
          }
        };
        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, 'ref', {
          get: warnAboutAccessingRef,
          configurable: true
        });
      }
    }
    /**
     * Factory method to create a new React element. This no longer adheres to
     * the class pattern, so do not use new to call it. Also, instanceof check
     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
     * if something is a React Element.
     *
     * @param {*} type
     * @param {*} props
     * @param {*} key
     * @param {string|object} ref
     * @param {*} owner
     * @param {*} self A *temporary* helper to detect places where `this` is
     * different from the `owner` when React.createElement is called, so that we
     * can warn. We want to get rid of owner and replace string `ref`s with arrow
     * functions, and as long as `this` and owner are the same, there will be no
     * change in behavior.
     * @param {*} source An annotation object (added by a transpiler or otherwise)
     * indicating filename, line number, and/or other information.
     * @internal
     */

    var ReactElement = function (type, key, ref, self, source, owner, props) {
      var element = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: REACT_ELEMENT_TYPE,
        // Built-in properties that belong on the element
        type: type,
        key: key,
        ref: ref,
        props: props,
        // Record the component responsible for creating this element.
        _owner: owner
      };
      {
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.

        Object.defineProperty(element._store, 'validated', {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        }); // self and source are DEV only properties.

        Object.defineProperty(element, '_self', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        }); // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.

        Object.defineProperty(element, '_source', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });
        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }
      return element;
    };
    /**
     * https://github.com/reactjs/rfcs/pull/107
     * @param {*} type
     * @param {object} props
     * @param {string} key
     */

    function jsxDEV(type, config, maybeKey, source, self) {
      {
        var propName; // Reserved names are extracted

        var props = {};
        var key = null;
        var ref = null; // Currently, key can be spread in as a prop. This causes a potential
        // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
        // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
        // but as an intermediary step, we will use jsxDEV for everything except
        // <div {...props} key="Hi" />, because we aren't currently able to tell if
        // key is explicitly declared to be undefined or not.

        if (maybeKey !== undefined) {
          {
            checkKeyStringCoercion(maybeKey);
          }
          key = '' + maybeKey;
        }
        if (hasValidKey(config)) {
          {
            checkKeyStringCoercion(config.key);
          }
          key = '' + config.key;
        }
        if (hasValidRef(config)) {
          ref = config.ref;
          warnIfStringRefCannotBeAutoConverted(config, self);
        } // Remaining properties are added to a new props object

        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        } // Resolve default props

        if (type && type.defaultProps) {
          var defaultProps = type.defaultProps;
          for (propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
        }
        if (key || ref) {
          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
          if (key) {
            defineKeyPropWarningGetter(props, displayName);
          }
          if (ref) {
            defineRefPropWarningGetter(props, displayName);
          }
        }
        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
      }
    }
    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement$1(element) {
      {
        if (element) {
          var owner = element._owner;
          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else {
          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
        }
      }
    }
    var propTypesMisspellWarningShown;
    {
      propTypesMisspellWarningShown = false;
    }
    /**
     * Verifies the object is a ReactElement.
     * See https://reactjs.org/docs/react-api.html#isvalidelement
     * @param {?object} object
     * @return {boolean} True if `object` is a ReactElement.
     * @final
     */

    function isValidElement(object) {
      {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
    }
    function getDeclarationErrorAddendum() {
      {
        if (ReactCurrentOwner$1.current) {
          var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
          if (name) {
            return '\n\nCheck the render method of `' + name + '`.';
          }
        }
        return '';
      }
    }
    function getSourceInfoErrorAddendum(source) {
      {
        if (source !== undefined) {
          var fileName = source.fileName.replace(/^.*[\\\/]/, '');
          var lineNumber = source.lineNumber;
          return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
        }
        return '';
      }
    }
    /**
     * Warn if there's no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */

    var ownerHasKeyUseWarning = {};
    function getCurrentComponentErrorInfo(parentType) {
      {
        var info = getDeclarationErrorAddendum();
        if (!info) {
          var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
          if (parentName) {
            info = "\n\nCheck the top-level render call using <" + parentName + ">.";
          }
        }
        return info;
      }
    }
    /**
     * Warn if the element doesn't have an explicit key assigned to it.
     * This element is in an array. The array could grow and shrink or be
     * reordered. All children that haven't already been validated are required to
     * have a "key" property assigned to it. Error statuses are cached so a warning
     * will only be shown once.
     *
     * @internal
     * @param {ReactElement} element Element that requires a key.
     * @param {*} parentType element's parent's type.
     */

    function validateExplicitKey(element, parentType) {
      {
        if (!element._store || element._store.validated || element.key != null) {
          return;
        }
        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
          return;
        }
        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
        // property, it may be the creator of the child that's responsible for
        // assigning it a key.

        var childOwner = '';
        if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
          // Give the component that originally created this child.
          childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
        }
        setCurrentlyValidatingElement$1(element);
        error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
        setCurrentlyValidatingElement$1(null);
      }
    }
    /**
     * Ensure that every element either is passed in a static location, in an
     * array with an explicit keys property defined, or in an object literal
     * with valid key property.
     *
     * @internal
     * @param {ReactNode} node Statically passed child of any type.
     * @param {*} parentType node's parent's type.
     */

    function validateChildKeys(node, parentType) {
      {
        if (typeof node !== 'object') {
          return;
        }
        if (isArray(node)) {
          for (var i = 0; i < node.length; i++) {
            var child = node[i];
            if (isValidElement(child)) {
              validateExplicitKey(child, parentType);
            }
          }
        } else if (isValidElement(node)) {
          // This element was passed in a valid location.
          if (node._store) {
            node._store.validated = true;
          }
        } else if (node) {
          var iteratorFn = getIteratorFn(node);
          if (typeof iteratorFn === 'function') {
            // Entry iterators used to provide implicit keys,
            // but now we print a separate warning for them later.
            if (iteratorFn !== node.entries) {
              var iterator = iteratorFn.call(node);
              var step;
              while (!(step = iterator.next()).done) {
                if (isValidElement(step.value)) {
                  validateExplicitKey(step.value, parentType);
                }
              }
            }
          }
        }
      }
    }
    /**
     * Given an element, validate that its props follow the propTypes definition,
     * provided by the type.
     *
     * @param {ReactElement} element
     */

    function validatePropTypes(element) {
      {
        var type = element.type;
        if (type === null || type === undefined || typeof type === 'string') {
          return;
        }
        var propTypes;
        if (typeof type === 'function') {
          propTypes = type.propTypes;
        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE ||
        // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        type.$$typeof === REACT_MEMO_TYPE)) {
          propTypes = type.propTypes;
        } else {
          return;
        }
        if (propTypes) {
          // Intentionally inside to avoid triggering lazy initializers:
          var name = getComponentNameFromType(type);
          checkPropTypes(propTypes, element.props, 'prop', name, element);
        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

          var _name = getComponentNameFromType(type);
          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
        }
        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
        }
      }
    }
    /**
     * Given a fragment, validate that it can only be provided with fragment props
     * @param {ReactElement} fragment
     */

    function validateFragmentProps(fragment) {
      {
        var keys = Object.keys(fragment.props);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (key !== 'children' && key !== 'key') {
            setCurrentlyValidatingElement$1(fragment);
            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
            setCurrentlyValidatingElement$1(null);
            break;
          }
        }
        if (fragment.ref !== null) {
          setCurrentlyValidatingElement$1(fragment);
          error('Invalid attribute `ref` supplied to `React.Fragment`.');
          setCurrentlyValidatingElement$1(null);
        }
      }
    }
    function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
      {
        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
        // succeed and there will likely be errors in render.

        if (!validType) {
          var info = '';
          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
            info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
          }
          var sourceInfo = getSourceInfoErrorAddendum(source);
          if (sourceInfo) {
            info += sourceInfo;
          } else {
            info += getDeclarationErrorAddendum();
          }
          var typeString;
          if (type === null) {
            typeString = 'null';
          } else if (isArray(type)) {
            typeString = 'array';
          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
            typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
            info = ' Did you accidentally export a JSX literal instead of a component?';
          } else {
            typeString = typeof type;
          }
          error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
        }
        var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
        // TODO: Drop this when these are no longer allowed as the type argument.

        if (element == null) {
          return element;
        } // Skip key warning if the type isn't valid since our key validation logic
        // doesn't expect a non-string/function type and can throw confusing errors.
        // We don't want exception behavior to differ between dev and prod.
        // (Rendering will throw with a helpful message and as soon as the type is
        // fixed, the key warnings will appear.)

        if (validType) {
          var children = props.children;
          if (children !== undefined) {
            if (isStaticChildren) {
              if (isArray(children)) {
                for (var i = 0; i < children.length; i++) {
                  validateChildKeys(children[i], type);
                }
                if (Object.freeze) {
                  Object.freeze(children);
                }
              } else {
                error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
              }
            } else {
              validateChildKeys(children, type);
            }
          }
        }
        if (type === REACT_FRAGMENT_TYPE) {
          validateFragmentProps(element);
        } else {
          validatePropTypes(element);
        }
        return element;
      }
    } // These two functions exist to still get child warnings in dev
    // even with the prod transform. This means that jsxDEV is purely
    // opt-in behavior for better messages but that we won't stop
    // giving you warnings if you use production apis.

    function jsxWithValidationStatic(type, props, key) {
      {
        return jsxWithValidation(type, props, key, true);
      }
    }
    function jsxWithValidationDynamic(type, props, key) {
      {
        return jsxWithValidation(type, props, key, false);
      }
    }
    var jsx = jsxWithValidationDynamic; // we may want to special case jsxs internally to take advantage of static children.
    // for now we can ship identical prod functions

    var jsxs = jsxWithValidationStatic;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsx = jsx;
    exports.jsxs = jsxs;
  })();
}

/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ "./node_modules/react/cjs/react-jsx-runtime.development.js");
}

/***/ }),

/***/ "./src/_partials/Header/Header.module.scss":
/*!*************************************************!*\
  !*** ./src/_partials/Header/Header.module.scss ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"Header":"YYMraRsm_j1dUiyvELk3","HeaderTitle":"l1mTSl5BzOI7kzFmUQOa"});

/***/ }),

/***/ "./src/_partials/Header/HeaderLink/HeaderLink.module.scss":
/*!****************************************************************!*\
  !*** ./src/_partials/Header/HeaderLink/HeaderLink.module.scss ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"HeaderLink":"CIA1ZLvkHTD6pXZ3XHbc"});

/***/ }),

/***/ "./src/components/PageLayout/PageLayout.module.scss":
/*!**********************************************************!*\
  !*** ./src/components/PageLayout/PageLayout.module.scss ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"TodoList":"bukwXY7YX_6aNlwg8qyk"});

/***/ }),

/***/ "./src/styles/_base.scss":
/*!*******************************!*\
  !*** ./src/styles/_base.scss ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/App.tsx":
/*!*********************!*\
  !*** ./src/App.tsx ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _styles_base_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles/_base.scss */ "./src/styles/_base.scss");
/* harmony import */ var _partials_Header_Header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_partials/Header/Header */ "./src/_partials/Header/Header.tsx");
/* harmony import */ var _hoc_useAppState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hoc/useAppState */ "./src/hoc/useAppState.tsx");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/dist/index.js");
/* harmony import */ var _hoc_withSuspense__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hoc/withSuspense */ "./src/hoc/withSuspense.tsx");
/* harmony import */ var _components_PageLayout_PageLayout__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/PageLayout/PageLayout */ "./src/components/PageLayout/PageLayout.tsx");







var AsyncTodoContainer = (0,_hoc_withSuspense__WEBPACK_IMPORTED_MODULE_4__.withSuspense)(function () { return __webpack_require__.e(/*! import() */ "src_containers_TodoContainer_index_tsx").then(__webpack_require__.bind(__webpack_require__, /*! ./containers/TodoContainer */ "./src/containers/TodoContainer/index.tsx")); });
var AsyncEditTodoItem = (0,_hoc_withSuspense__WEBPACK_IMPORTED_MODULE_4__.withSuspense)(function () { return __webpack_require__.e(/*! import() */ "src_containers_TodoContainer_EditTodoItem_index_tsx").then(__webpack_require__.bind(__webpack_require__, /*! ./containers/TodoContainer/EditTodoItem */ "./src/containers/TodoContainer/EditTodoItem/index.tsx")); });
var AsyncStatsContainer = (0,_hoc_withSuspense__WEBPACK_IMPORTED_MODULE_4__.withSuspense)(function () { return __webpack_require__.e(/*! import() */ "src_containers_StatsContainer_index_tsx").then(__webpack_require__.bind(__webpack_require__, /*! ./containers/StatsContainer */ "./src/containers/StatsContainer/index.tsx")); });
var AsyncAboutContainer = (0,_hoc_withSuspense__WEBPACK_IMPORTED_MODULE_4__.withSuspense)(function () { return Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_react-markdown_lib_react-markdown_js"), __webpack_require__.e("src_containers_AboutContainer_index_tsx")]).then(__webpack_require__.bind(__webpack_require__, /*! ./containers/AboutContainer */ "./src/containers/AboutContainer/index.tsx")); });
function App() {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_hoc_useAppState__WEBPACK_IMPORTED_MODULE_3__.AppStateProvider, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_partials_Header_Header__WEBPACK_IMPORTED_MODULE_2__["default"], {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_PageLayout_PageLayout__WEBPACK_IMPORTED_MODULE_5__.PageLayout, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_router_dom__WEBPACK_IMPORTED_MODULE_6__.Routes, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_router_dom__WEBPACK_IMPORTED_MODULE_6__.Route, { path: "/", element: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [AsyncTodoContainer, AsyncEditTodoItem] }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_router_dom__WEBPACK_IMPORTED_MODULE_6__.Route, { path: "/stats", element: AsyncStatsContainer }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_router_dom__WEBPACK_IMPORTED_MODULE_6__.Route, { path: "/about", element: AsyncAboutContainer })] }) })] }) }));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (App);


/***/ }),

/***/ "./src/_partials/Header/Header.tsx":
/*!*****************************************!*\
  !*** ./src/_partials/Header/Header.tsx ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _Header_module_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Header.module.scss */ "./src/_partials/Header/Header.module.scss");
/* harmony import */ var _HeaderLink_HeaderLink__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HeaderLink/HeaderLink */ "./src/_partials/Header/HeaderLink/HeaderLink.tsx");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};



var Header = function () {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("header", __assign({ className: _Header_module_scss__WEBPACK_IMPORTED_MODULE_1__["default"].Header }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("h1", __assign({ className: _Header_module_scss__WEBPACK_IMPORTED_MODULE_1__["default"].HeaderTitle }, { children: "Todo Pro Max App" })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("nav", __assign({ className: "m-auto" }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_HeaderLink_HeaderLink__WEBPACK_IMPORTED_MODULE_2__["default"], __assign({ url: "/" }, { children: "Home" })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_HeaderLink_HeaderLink__WEBPACK_IMPORTED_MODULE_2__["default"], __assign({ url: "/stats" }, { children: "Stats" })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_HeaderLink_HeaderLink__WEBPACK_IMPORTED_MODULE_2__["default"], __assign({ url: "/about" }, { children: "About" }))] }))] })));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Header);


/***/ }),

/***/ "./src/_partials/Header/HeaderLink/HeaderLink.tsx":
/*!********************************************************!*\
  !*** ./src/_partials/Header/HeaderLink/HeaderLink.tsx ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router-dom/dist/index.js");
/* harmony import */ var _HeaderLink_module_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HeaderLink.module.scss */ "./src/_partials/Header/HeaderLink/HeaderLink.module.scss");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};



var HeaderLink = function (_a) {
    var url = _a.url, children = _a.children;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_router_dom__WEBPACK_IMPORTED_MODULE_2__.Link, __assign({ to: "".concat(url), className: _HeaderLink_module_scss__WEBPACK_IMPORTED_MODULE_1__["default"].HeaderLink + " mr-2 mr-2" }, { children: children })));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HeaderLink);


/***/ }),

/***/ "./src/components/PageLayout/PageLayout.tsx":
/*!**************************************************!*\
  !*** ./src/components/PageLayout/PageLayout.tsx ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PageLayout": () => (/* binding */ PageLayout)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _PageLayout_module_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PageLayout.module.scss */ "./src/components/PageLayout/PageLayout.module.scss");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};


var PageLayout = function (_a) {
    var children = _a.children;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", __assign({ className: _PageLayout_module_scss__WEBPACK_IMPORTED_MODULE_1__["default"].TodoList + " mr-auto ml-auto" }, { children: children })));
};


/***/ }),

/***/ "./src/hoc/useAppState.tsx":
/*!*********************************!*\
  !*** ./src/hoc/useAppState.tsx ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AppSate": () => (/* binding */ AppSate),
/* harmony export */   "AppStateProvider": () => (/* binding */ AppStateProvider),
/* harmony export */   "useAppState": () => (/* binding */ useAppState)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};


var AppSate = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({
    appState: { editTodoId: -1, isDrawerOpen: false },
    setAppState: function () { },
});
var useAppState = function () { return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AppSate); };
var AppStateProvider = function (_a) {
    var children = _a.children;
    var _b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({
        editTodoId: -1,
        isDrawerOpen: false,
    }), appState = _b[0], setAppState = _b[1];
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AppSate.Provider, __assign({ value: { appState: appState, setAppState: setAppState } }, { children: children })));
};


/***/ }),

/***/ "./src/hoc/withSuspense.tsx":
/*!**********************************!*\
  !*** ./src/hoc/withSuspense.tsx ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "withSuspense": () => (/* binding */ withSuspense)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};


var Loading = function () { return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { children: "Loading..." }); };
var withSuspense = function (ComponentImportCallback) {
    var AsyncComponent = react__WEBPACK_IMPORTED_MODULE_1___default().lazy(ComponentImportCallback);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react__WEBPACK_IMPORTED_MODULE_1__.Suspense, __assign({ fallback: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Loading, {}) }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AsyncComponent, {}) })));
};


/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

module.exports = require("react");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "process":
/*!**************************!*\
  !*** external "process" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("process");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".css";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/css loading */
/******/ 	(() => {
/******/ 		if (typeof document === "undefined") return;
/******/ 		var createStylesheet = (chunkId, fullhref, oldTag, resolve, reject) => {
/******/ 			var linkTag = document.createElement("link");
/******/ 		
/******/ 			linkTag.rel = "stylesheet";
/******/ 			linkTag.type = "text/css";
/******/ 			var onLinkComplete = (event) => {
/******/ 				// avoid mem leaks.
/******/ 				linkTag.onerror = linkTag.onload = null;
/******/ 				if (event.type === 'load') {
/******/ 					resolve();
/******/ 				} else {
/******/ 					var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 					var realHref = event && event.target && event.target.href || fullhref;
/******/ 					var err = new Error("Loading CSS chunk " + chunkId + " failed.\n(" + realHref + ")");
/******/ 					err.code = "CSS_CHUNK_LOAD_FAILED";
/******/ 					err.type = errorType;
/******/ 					err.request = realHref;
/******/ 					linkTag.parentNode.removeChild(linkTag)
/******/ 					reject(err);
/******/ 				}
/******/ 			}
/******/ 			linkTag.onerror = linkTag.onload = onLinkComplete;
/******/ 			linkTag.href = fullhref;
/******/ 		
/******/ 			if (oldTag) {
/******/ 				oldTag.parentNode.insertBefore(linkTag, oldTag.nextSibling);
/******/ 			} else {
/******/ 				document.head.appendChild(linkTag);
/******/ 			}
/******/ 			return linkTag;
/******/ 		};
/******/ 		var findStylesheet = (href, fullhref) => {
/******/ 			var existingLinkTags = document.getElementsByTagName("link");
/******/ 			for(var i = 0; i < existingLinkTags.length; i++) {
/******/ 				var tag = existingLinkTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");
/******/ 				if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return tag;
/******/ 			}
/******/ 			var existingStyleTags = document.getElementsByTagName("style");
/******/ 			for(var i = 0; i < existingStyleTags.length; i++) {
/******/ 				var tag = existingStyleTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href");
/******/ 				if(dataHref === href || dataHref === fullhref) return tag;
/******/ 			}
/******/ 		};
/******/ 		var loadStylesheet = (chunkId) => {
/******/ 			return new Promise((resolve, reject) => {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				if(findStylesheet(href, fullhref)) return resolve();
/******/ 				createStylesheet(chunkId, fullhref, null, resolve, reject);
/******/ 			});
/******/ 		}
/******/ 		// object to store loaded CSS chunks
/******/ 		var installedCssChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.miniCss = (chunkId, promises) => {
/******/ 			var cssChunks = {"src_containers_TodoContainer_index_tsx":1,"src_containers_TodoContainer_EditTodoItem_index_tsx":1,"src_containers_StatsContainer_index_tsx":1};
/******/ 			if(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);
/******/ 			else if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {
/******/ 				promises.push(installedCssChunks[chunkId] = loadStylesheet(chunkId).then(() => {
/******/ 					installedCssChunks[chunkId] = 0;
/******/ 				}, (e) => {
/******/ 					delete installedCssChunks[chunkId];
/******/ 					throw e;
/******/ 				}));
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no hmr
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/require chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "loaded", otherwise not loaded yet
/******/ 		var installedChunks = {
/******/ 			"main": 1
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		var installChunk = (chunk) => {
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 1;
/******/ 		
/******/ 		};
/******/ 		
/******/ 		// require() chunk loading for javascript
/******/ 		__webpack_require__.f.require = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					installChunk(require("./" + __webpack_require__.u(chunkId)));
/******/ 				} else installedChunks[chunkId] = 1;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no external install chunk
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!****************************!*\
  !*** ./src/ssr/SsrApp.tsx ***!
  \****************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SsrApp": () => (/* binding */ SsrApp)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../App */ "./src/App.tsx");
/* harmony import */ var react_router_dom_server__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router-dom/server */ "./node_modules/react-router-dom/server.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};



var SsrApp = function (pathname) {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_router_dom_server__WEBPACK_IMPORTED_MODULE_2__.StaticRouter, __assign({ location: pathname }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_App__WEBPACK_IMPORTED_MODULE_1__["default"], {}) })));
};

})();

module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLElBQUk7V0FDSjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxnQkFBZ0IsNkJBQTZCO1dBQzdDO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxnQkFBZ0IsOEJBQThCO1dBQzlDO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFQUFFO1dBQ0Y7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBLGtCQUFrQjtXQUNsQjtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7O1dBRUE7Ozs7O1dDeEVBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGdCQUFnQixxQkFBcUI7V0FDckM7O1dBRUE7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxhQUFhO1dBQ2I7V0FDQSxJQUFJO1dBQ0o7V0FDQTs7V0FFQTs7V0FFQTs7V0FFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyQ0EsZ0JBQWdCLFNBQUksSUFBSSxTQUFJO0FBQzVCO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRDtBQUN2QjtBQUM4QjtBQUNoRDtBQUNQLFlBQVksc0RBQUksQ0FBQyxpRUFBWSxhQUFhLG9CQUFvQixJQUFJLFVBQVUsc0RBQUksQ0FBQyw0Q0FBRyxJQUFJLEdBQUc7QUFDM0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLXByby1tYXgvLi4vaGlzdG9yeS50cyIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvLi4vdXRpbHMudHMiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4uL3JvdXRlci50cyIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvLi4vZG9tLnRzIiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uLi9pbmRleC50c3giLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vc2VydmVyLmpzIiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uLi9saWIvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS91c2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1DbGllbnQudHMiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4uL2xpYi91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3VzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbVNlcnZlci50cyIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvLi4vbGliL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4uL2xpYi9jb250ZXh0LnRzIiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uLi9saWIvaG9va3MudHN4Iiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uLi9saWIvY29tcG9uZW50cy50c3giLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4uL2luZGV4LnRzIiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1ydW50aW1lLmpzIiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uL3NyYy9fcGFydGlhbHMvSGVhZGVyL0hlYWRlci5tb2R1bGUuc2Nzcz8zZGVlIiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uL3NyYy9fcGFydGlhbHMvSGVhZGVyL0hlYWRlckxpbmsvSGVhZGVyTGluay5tb2R1bGUuc2Nzcz9hM2IyIiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uL3NyYy9jb21wb25lbnRzL1BhZ2VMYXlvdXQvUGFnZUxheW91dC5tb2R1bGUuc2Nzcz8zYWUyIiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uL3NyYy9zdHlsZXMvX2Jhc2Uuc2Nzcz8xNDIxIiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uL3NyYy9BcHAudHN4Iiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uL3NyYy9fcGFydGlhbHMvSGVhZGVyL0hlYWRlci50c3giLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4Ly4vc3JjL19wYXJ0aWFscy9IZWFkZXIvSGVhZGVyTGluay9IZWFkZXJMaW5rLnRzeCIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvLi9zcmMvY29tcG9uZW50cy9QYWdlTGF5b3V0L1BhZ2VMYXlvdXQudHN4Iiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uL3NyYy9ob2MvdXNlQXBwU3RhdGUudHN4Iiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uL3NyYy9ob2Mvd2l0aFN1c3BlbnNlLnRzeCIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvZXh0ZXJuYWwgY29tbW9uanMyIFwicmVhY3RcIiIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcIm9zXCIiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4L2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJwYXRoXCIiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4L2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJwcm9jZXNzXCIiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4L2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJ0dHlcIiIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInVybFwiIiwid2VicGFjazovL3RvZG8tcHJvLW1heC9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwidXRpbFwiIiwid2VicGFjazovL3RvZG8tcHJvLW1heC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vdG9kby1wcm8tbWF4L3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvd2VicGFjay9ydW50aW1lL2Vuc3VyZSBjaHVuayIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvd2VicGFjay9ydW50aW1lL2dldCBqYXZhc2NyaXB0IGNodW5rIGZpbGVuYW1lIiwid2VicGFjazovL3RvZG8tcHJvLW1heC93ZWJwYWNrL3J1bnRpbWUvZ2V0IG1pbmktY3NzIGNodW5rIGZpbGVuYW1lIiwid2VicGFjazovL3RvZG8tcHJvLW1heC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3RvZG8tcHJvLW1heC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3RvZG8tcHJvLW1heC93ZWJwYWNrL3J1bnRpbWUvcHVibGljUGF0aCIsIndlYnBhY2s6Ly90b2RvLXByby1tYXgvd2VicGFjay9ydW50aW1lL2NzcyBsb2FkaW5nIiwid2VicGFjazovL3RvZG8tcHJvLW1heC93ZWJwYWNrL3J1bnRpbWUvcmVxdWlyZSBjaHVuayBsb2FkaW5nIiwid2VicGFjazovL3RvZG8tcHJvLW1heC8uL3NyYy9zc3IvU3NyQXBwLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIFR5cGVzIGFuZCBDb25zdGFudHNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQWN0aW9ucyByZXByZXNlbnQgdGhlIHR5cGUgb2YgY2hhbmdlIHRvIGEgbG9jYXRpb24gdmFsdWUuXG4gKi9cbmV4cG9ydCBlbnVtIEFjdGlvbiB7XG4gIC8qKlxuICAgKiBBIFBPUCBpbmRpY2F0ZXMgYSBjaGFuZ2UgdG8gYW4gYXJiaXRyYXJ5IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrLCBzdWNoXG4gICAqIGFzIGEgYmFjayBvciBmb3J3YXJkIG5hdmlnYXRpb24uIEl0IGRvZXMgbm90IGRlc2NyaWJlIHRoZSBkaXJlY3Rpb24gb2YgdGhlXG4gICAqIG5hdmlnYXRpb24sIG9ubHkgdGhhdCB0aGUgY3VycmVudCBpbmRleCBjaGFuZ2VkLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGlzIHRoZSBkZWZhdWx0IGFjdGlvbiBmb3IgbmV3bHkgY3JlYXRlZCBoaXN0b3J5IG9iamVjdHMuXG4gICAqL1xuICBQb3AgPSBcIlBPUFwiLFxuXG4gIC8qKlxuICAgKiBBIFBVU0ggaW5kaWNhdGVzIGEgbmV3IGVudHJ5IGJlaW5nIGFkZGVkIHRvIHRoZSBoaXN0b3J5IHN0YWNrLCBzdWNoIGFzIHdoZW5cbiAgICogYSBsaW5rIGlzIGNsaWNrZWQgYW5kIGEgbmV3IHBhZ2UgbG9hZHMuIFdoZW4gdGhpcyBoYXBwZW5zLCBhbGwgc3Vic2VxdWVudFxuICAgKiBlbnRyaWVzIGluIHRoZSBzdGFjayBhcmUgbG9zdC5cbiAgICovXG4gIFB1c2ggPSBcIlBVU0hcIixcblxuICAvKipcbiAgICogQSBSRVBMQUNFIGluZGljYXRlcyB0aGUgZW50cnkgYXQgdGhlIGN1cnJlbnQgaW5kZXggaW4gdGhlIGhpc3Rvcnkgc3RhY2tcbiAgICogYmVpbmcgcmVwbGFjZWQgYnkgYSBuZXcgb25lLlxuICAgKi9cbiAgUmVwbGFjZSA9IFwiUkVQTEFDRVwiLFxufVxuXG4vKipcbiAqIFRoZSBwYXRobmFtZSwgc2VhcmNoLCBhbmQgaGFzaCB2YWx1ZXMgb2YgYSBVUkwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aCB7XG4gIC8qKlxuICAgKiBBIFVSTCBwYXRobmFtZSwgYmVnaW5uaW5nIHdpdGggYSAvLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogQSBVUkwgc2VhcmNoIHN0cmluZywgYmVnaW5uaW5nIHdpdGggYSA/LlxuICAgKi9cbiAgc2VhcmNoOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgVVJMIGZyYWdtZW50IGlkZW50aWZpZXIsIGJlZ2lubmluZyB3aXRoIGEgIy5cbiAgICovXG4gIGhhc2g6IHN0cmluZztcbn1cblxuLyoqXG4gKiBBbiBlbnRyeSBpbiBhIGhpc3Rvcnkgc3RhY2suIEEgbG9jYXRpb24gY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG4gKiBVUkwgcGF0aCwgYXMgd2VsbCBhcyBwb3NzaWJseSBzb21lIGFyYml0cmFyeSBzdGF0ZSBhbmQgYSBrZXkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYXRpb24gZXh0ZW5kcyBQYXRoIHtcbiAgLyoqXG4gICAqIEEgdmFsdWUgb2YgYXJiaXRyYXJ5IGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbG9jYXRpb24uXG4gICAqL1xuICBzdGF0ZTogYW55O1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbG9jYXRpb24uIE1heSBiZSB1c2VkIHRvIHNhZmVseSBzdG9yZVxuICAgKiBhbmQgcmV0cmlldmUgZGF0YSBpbiBzb21lIG90aGVyIHN0b3JhZ2UgQVBJLCBsaWtlIGBsb2NhbFN0b3JhZ2VgLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIHZhbHVlIGlzIGFsd2F5cyBcImRlZmF1bHRcIiBvbiB0aGUgaW5pdGlhbCBsb2NhdGlvbi5cbiAgICovXG4gIGtleTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgY2hhbmdlIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZSB7XG4gIC8qKlxuICAgKiBUaGUgYWN0aW9uIHRoYXQgdHJpZ2dlcmVkIHRoZSBjaGFuZ2UuXG4gICAqL1xuICBhY3Rpb246IEFjdGlvbjtcblxuICAvKipcbiAgICogVGhlIG5ldyBsb2NhdGlvbi5cbiAgICovXG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcblxuICAvKipcbiAgICogVGhlIGRlbHRhIGJldHdlZW4gdGhpcyBsb2NhdGlvbiBhbmQgdGhlIGZvcm1lciBsb2NhdGlvbiBpbiB0aGUgaGlzdG9yeSBzdGFja1xuICAgKi9cbiAgZGVsdGE6IG51bWJlciB8IG51bGw7XG59XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIG5vdGlmaWNhdGlvbnMgYWJvdXQgbG9jYXRpb24gY2hhbmdlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMaXN0ZW5lciB7XG4gICh1cGRhdGU6IFVwZGF0ZSk6IHZvaWQ7XG59XG5cbi8qKlxuICogRGVzY3JpYmVzIGEgbG9jYXRpb24gdGhhdCBpcyB0aGUgZGVzdGluYXRpb24gb2Ygc29tZSBuYXZpZ2F0aW9uLCBlaXRoZXIgdmlhXG4gKiBgaGlzdG9yeS5wdXNoYCBvciBgaGlzdG9yeS5yZXBsYWNlYC4gTWF5IGJlIGVpdGhlciBhIFVSTCBvciB0aGUgcGllY2VzIG9mIGFcbiAqIFVSTCBwYXRoLlxuICovXG5leHBvcnQgdHlwZSBUbyA9IHN0cmluZyB8IFBhcnRpYWw8UGF0aD47XG5cbi8qKlxuICogQSBoaXN0b3J5IGlzIGFuIGludGVyZmFjZSB0byB0aGUgbmF2aWdhdGlvbiBzdGFjay4gVGhlIGhpc3Rvcnkgc2VydmVzIGFzIHRoZVxuICogc291cmNlIG9mIHRydXRoIGZvciB0aGUgY3VycmVudCBsb2NhdGlvbiwgYXMgd2VsbCBhcyBwcm92aWRlcyBhIHNldCBvZlxuICogbWV0aG9kcyB0aGF0IG1heSBiZSB1c2VkIHRvIGNoYW5nZSBpdC5cbiAqXG4gKiBJdCBpcyBzaW1pbGFyIHRvIHRoZSBET00ncyBgd2luZG93Lmhpc3RvcnlgIG9iamVjdCwgYnV0IHdpdGggYSBzbWFsbGVyLCBtb3JlXG4gKiBmb2N1c2VkIEFQSS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIaXN0b3J5IHtcbiAgLyoqXG4gICAqIFRoZSBsYXN0IGFjdGlvbiB0aGF0IG1vZGlmaWVkIHRoZSBjdXJyZW50IGxvY2F0aW9uLiBUaGlzIHdpbGwgYWx3YXlzIGJlXG4gICAqIEFjdGlvbi5Qb3Agd2hlbiBhIGhpc3RvcnkgaW5zdGFuY2UgaXMgZmlyc3QgY3JlYXRlZC4gVGhpcyB2YWx1ZSBpcyBtdXRhYmxlLlxuICAgKi9cbiAgcmVhZG9ubHkgYWN0aW9uOiBBY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGxvY2F0aW9uLiBUaGlzIHZhbHVlIGlzIG11dGFibGUuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbjogTG9jYXRpb247XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2YWxpZCBocmVmIGZvciB0aGUgZ2l2ZW4gYHRvYCB2YWx1ZSB0aGF0IG1heSBiZSB1c2VkIGFzXG4gICAqIHRoZSB2YWx1ZSBvZiBhbiA8YSBocmVmPiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBwYXJhbSB0byAtIFRoZSBkZXN0aW5hdGlvbiBVUkxcbiAgICovXG4gIGNyZWF0ZUhyZWYodG86IFRvKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgVVJMIGZvciB0aGUgZ2l2ZW4gYHRvYCB2YWx1ZVxuICAgKlxuICAgKiBAcGFyYW0gdG8gLSBUaGUgZGVzdGluYXRpb24gVVJMXG4gICAqL1xuICBjcmVhdGVVUkwodG86IFRvKTogVVJMO1xuXG4gIC8qKlxuICAgKiBFbmNvZGUgYSBsb2NhdGlvbiB0aGUgc2FtZSB3YXkgd2luZG93Lmhpc3Rvcnkgd291bGQgZG8gKG5vLW9wIGZvciBtZW1vcnlcbiAgICogaGlzdG9yeSkgc28gd2UgZW5zdXJlIG91ciBQVVNIL1JFUExBQ0UgbmF2aWdhdGlvbnMgZm9yIGRhdGEgcm91dGVyc1xuICAgKiBiZWhhdmUgdGhlIHNhbWUgYXMgUE9QXG4gICAqXG4gICAqIEBwYXJhbSB0byBVbmVuY29kZWQgcGF0aFxuICAgKi9cbiAgZW5jb2RlTG9jYXRpb24odG86IFRvKTogUGF0aDtcblxuICAvKipcbiAgICogUHVzaGVzIGEgbmV3IGxvY2F0aW9uIG9udG8gdGhlIGhpc3Rvcnkgc3RhY2ssIGluY3JlYXNpbmcgaXRzIGxlbmd0aCBieSBvbmUuXG4gICAqIElmIHRoZXJlIHdlcmUgYW55IGVudHJpZXMgaW4gdGhlIHN0YWNrIGFmdGVyIHRoZSBjdXJyZW50IG9uZSwgdGhleSBhcmVcbiAgICogbG9zdC5cbiAgICpcbiAgICogQHBhcmFtIHRvIC0gVGhlIG5ldyBVUkxcbiAgICogQHBhcmFtIHN0YXRlIC0gRGF0YSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbmV3IGxvY2F0aW9uXG4gICAqL1xuICBwdXNoKHRvOiBUbywgc3RhdGU/OiBhbnkpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiB0aGUgaGlzdG9yeSBzdGFjayB3aXRoIGEgbmV3IG9uZS4gIFRoZVxuICAgKiBsb2NhdGlvbiB0aGF0IHdhcyByZXBsYWNlZCB3aWxsIG5vIGxvbmdlciBiZSBhdmFpbGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB0byAtIFRoZSBuZXcgVVJMXG4gICAqIEBwYXJhbSBzdGF0ZSAtIERhdGEgdG8gYXNzb2NpYXRlIHdpdGggdGhlIG5ldyBsb2NhdGlvblxuICAgKi9cbiAgcmVwbGFjZSh0bzogVG8sIHN0YXRlPzogYW55KTogdm9pZDtcblxuICAvKipcbiAgICogTmF2aWdhdGVzIGBuYCBlbnRyaWVzIGJhY2t3YXJkL2ZvcndhcmQgaW4gdGhlIGhpc3Rvcnkgc3RhY2sgcmVsYXRpdmUgdG8gdGhlXG4gICAqIGN1cnJlbnQgaW5kZXguIEZvciBleGFtcGxlLCBhIFwiYmFja1wiIG5hdmlnYXRpb24gd291bGQgdXNlIGdvKC0xKS5cbiAgICpcbiAgICogQHBhcmFtIGRlbHRhIC0gVGhlIGRlbHRhIGluIHRoZSBzdGFjayBpbmRleFxuICAgKi9cbiAgZ28oZGVsdGE6IG51bWJlcik6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAqIGNoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBsb2NhdGlvbiBjaGFuZ2VzXG4gICAqIEByZXR1cm5zIHVubGlzdGVuIC0gQSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIHN0b3AgbGlzdGVuaW5nXG4gICAqL1xuICBsaXN0ZW4obGlzdGVuZXI6IExpc3RlbmVyKTogKCkgPT4gdm9pZDtcbn1cblxudHlwZSBIaXN0b3J5U3RhdGUgPSB7XG4gIHVzcjogYW55O1xuICBrZXk/OiBzdHJpbmc7XG4gIGlkeDogbnVtYmVyO1xufTtcblxuY29uc3QgUG9wU3RhdGVFdmVudFR5cGUgPSBcInBvcHN0YXRlXCI7XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBNZW1vcnkgSGlzdG9yeVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIHVzZXItc3VwcGxpZWQgb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgbG9jYXRpb24uIFVzZWQgd2hlbiBwcm92aWRpbmdcbiAqIGVudHJpZXMgdG8gYGNyZWF0ZU1lbW9yeUhpc3RvcnlgIHZpYSBpdHMgYGluaXRpYWxFbnRyaWVzYCBvcHRpb24uXG4gKi9cbmV4cG9ydCB0eXBlIEluaXRpYWxFbnRyeSA9IHN0cmluZyB8IFBhcnRpYWw8TG9jYXRpb24+O1xuXG5leHBvcnQgdHlwZSBNZW1vcnlIaXN0b3J5T3B0aW9ucyA9IHtcbiAgaW5pdGlhbEVudHJpZXM/OiBJbml0aWFsRW50cnlbXTtcbiAgaW5pdGlhbEluZGV4PzogbnVtYmVyO1xuICB2NUNvbXBhdD86IGJvb2xlYW47XG59O1xuXG4vKipcbiAqIEEgbWVtb3J5IGhpc3Rvcnkgc3RvcmVzIGxvY2F0aW9ucyBpbiBtZW1vcnkuIFRoaXMgaXMgdXNlZnVsIGluIHN0YXRlZnVsXG4gKiBlbnZpcm9ubWVudHMgd2hlcmUgdGhlcmUgaXMgbm8gd2ViIGJyb3dzZXIsIHN1Y2ggYXMgbm9kZSB0ZXN0cyBvciBSZWFjdFxuICogTmF0aXZlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1lbW9yeUhpc3RvcnkgZXh0ZW5kcyBIaXN0b3J5IHtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrLlxuICAgKi9cbiAgcmVhZG9ubHkgaW5kZXg6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBNZW1vcnkgaGlzdG9yeSBzdG9yZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gbWVtb3J5LiBJdCBpcyBkZXNpZ25lZCBmb3IgdXNlXG4gKiBpbiBzdGF0ZWZ1bCBub24tYnJvd3NlciBlbnZpcm9ubWVudHMgbGlrZSB0ZXN0cyBhbmQgUmVhY3QgTmF0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShcbiAgb3B0aW9uczogTWVtb3J5SGlzdG9yeU9wdGlvbnMgPSB7fVxuKTogTWVtb3J5SGlzdG9yeSB7XG4gIGxldCB7IGluaXRpYWxFbnRyaWVzID0gW1wiL1wiXSwgaW5pdGlhbEluZGV4LCB2NUNvbXBhdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBsZXQgZW50cmllczogTG9jYXRpb25bXTsgLy8gRGVjbGFyZSBzbyB3ZSBjYW4gYWNjZXNzIGZyb20gY3JlYXRlTWVtb3J5TG9jYXRpb25cbiAgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcCgoZW50cnksIGluZGV4KSA9PlxuICAgIGNyZWF0ZU1lbW9yeUxvY2F0aW9uKFxuICAgICAgZW50cnksXG4gICAgICB0eXBlb2YgZW50cnkgPT09IFwic3RyaW5nXCIgPyBudWxsIDogZW50cnkuc3RhdGUsXG4gICAgICBpbmRleCA9PT0gMCA/IFwiZGVmYXVsdFwiIDogdW5kZWZpbmVkXG4gICAgKVxuICApO1xuICBsZXQgaW5kZXggPSBjbGFtcEluZGV4KFxuICAgIGluaXRpYWxJbmRleCA9PSBudWxsID8gZW50cmllcy5sZW5ndGggLSAxIDogaW5pdGlhbEluZGV4XG4gICk7XG4gIGxldCBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICBsZXQgbGlzdGVuZXI6IExpc3RlbmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gY2xhbXBJbmRleChuOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCAwKSwgZW50cmllcy5sZW5ndGggLSAxKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKTogTG9jYXRpb24ge1xuICAgIHJldHVybiBlbnRyaWVzW2luZGV4XTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVNZW1vcnlMb2NhdGlvbihcbiAgICB0bzogVG8sXG4gICAgc3RhdGU6IGFueSA9IG51bGwsXG4gICAga2V5Pzogc3RyaW5nXG4gICk6IExvY2F0aW9uIHtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcbiAgICAgIGVudHJpZXMgPyBnZXRDdXJyZW50TG9jYXRpb24oKS5wYXRobmFtZSA6IFwiL1wiLFxuICAgICAgdG8sXG4gICAgICBzdGF0ZSxcbiAgICAgIGtleVxuICAgICk7XG4gICAgd2FybmluZyhcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gXCIvXCIsXG4gICAgICBgcmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIG1lbW9yeSBoaXN0b3J5OiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICB0b1xuICAgICAgKX1gXG4gICAgKTtcbiAgICByZXR1cm4gbG9jYXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKHRvOiBUbykge1xuICAgIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICB9XG5cbiAgbGV0IGhpc3Rvcnk6IE1lbW9yeUhpc3RvcnkgPSB7XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0Q3VycmVudExvY2F0aW9uKCk7XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmLFxuICAgIGNyZWF0ZVVSTCh0bykge1xuICAgICAgcmV0dXJuIG5ldyBVUkwoY3JlYXRlSHJlZih0byksIFwiaHR0cDovL2xvY2FsaG9zdFwiKTtcbiAgICB9LFxuICAgIGVuY29kZUxvY2F0aW9uKHRvOiBUbykge1xuICAgICAgbGV0IHBhdGggPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG87XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRobmFtZTogcGF0aC5wYXRobmFtZSB8fCBcIlwiLFxuICAgICAgICBzZWFyY2g6IHBhdGguc2VhcmNoIHx8IFwiXCIsXG4gICAgICAgIGhhc2g6IHBhdGguaGFzaCB8fCBcIlwiLFxuICAgICAgfTtcbiAgICB9LFxuICAgIHB1c2godG8sIHN0YXRlKSB7XG4gICAgICBhY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICAgIGxldCBuZXh0TG9jYXRpb24gPSBjcmVhdGVNZW1vcnlMb2NhdGlvbih0bywgc3RhdGUpO1xuICAgICAgaW5kZXggKz0gMTtcbiAgICAgIGVudHJpZXMuc3BsaWNlKGluZGV4LCBlbnRyaWVzLmxlbmd0aCwgbmV4dExvY2F0aW9uKTtcbiAgICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IG5leHRMb2NhdGlvbiwgZGVsdGE6IDEgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZXBsYWNlKHRvLCBzdGF0ZSkge1xuICAgICAgYWN0aW9uID0gQWN0aW9uLlJlcGxhY2U7XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlKTtcbiAgICAgIGVudHJpZXNbaW5kZXhdID0gbmV4dExvY2F0aW9uO1xuICAgICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbmV4dExvY2F0aW9uLCBkZWx0YTogMCB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdvKGRlbHRhKSB7XG4gICAgICBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICAgICAgbGV0IG5leHRJbmRleCA9IGNsYW1wSW5kZXgoaW5kZXggKyBkZWx0YSk7XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gZW50cmllc1tuZXh0SW5kZXhdO1xuICAgICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sIGRlbHRhIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGlzdGVuKGZuOiBMaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIgPSBmbjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn1cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIEJyb3dzZXIgSGlzdG9yeVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIGJyb3dzZXIgaGlzdG9yeSBzdG9yZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gcmVndWxhciBVUkxzIGluIGEgd2ViXG4gKiBicm93c2VyIGVudmlyb25tZW50LiBUaGlzIGlzIHRoZSBzdGFuZGFyZCBmb3IgbW9zdCB3ZWIgYXBwcyBhbmQgcHJvdmlkZXMgdGhlXG4gKiBjbGVhbmVzdCBVUkxzIHRoZSBicm93c2VyJ3MgYWRkcmVzcyBiYXIuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNicm93c2VyaGlzdG9yeVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJyb3dzZXJIaXN0b3J5IGV4dGVuZHMgVXJsSGlzdG9yeSB7fVxuXG5leHBvcnQgdHlwZSBCcm93c2VySGlzdG9yeU9wdGlvbnMgPSBVcmxIaXN0b3J5T3B0aW9ucztcblxuLyoqXG4gKiBCcm93c2VyIGhpc3Rvcnkgc3RvcmVzIHRoZSBsb2NhdGlvbiBpbiByZWd1bGFyIFVSTHMuIFRoaXMgaXMgdGhlIHN0YW5kYXJkIGZvclxuICogbW9zdCB3ZWIgYXBwcywgYnV0IGl0IHJlcXVpcmVzIHNvbWUgY29uZmlndXJhdGlvbiBvbiB0aGUgc2VydmVyIHRvIGVuc3VyZSB5b3VcbiAqIHNlcnZlIHRoZSBzYW1lIGFwcCBhdCBtdWx0aXBsZSBVUkxzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjY3JlYXRlYnJvd3Nlcmhpc3RvcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KFxuICBvcHRpb25zOiBCcm93c2VySGlzdG9yeU9wdGlvbnMgPSB7fVxuKTogQnJvd3Nlckhpc3Rvcnkge1xuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VyTG9jYXRpb24oXG4gICAgd2luZG93OiBXaW5kb3csXG4gICAgZ2xvYmFsSGlzdG9yeTogV2luZG93W1wiaGlzdG9yeVwiXVxuICApIHtcbiAgICBsZXQgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKFxuICAgICAgXCJcIixcbiAgICAgIHsgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9LFxuICAgICAgLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXG4gICAgICAoZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLnVzcikgfHwgbnVsbCxcbiAgICAgIChnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUua2V5KSB8fCBcImRlZmF1bHRcIlxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VySHJlZih3aW5kb3c6IFdpbmRvdywgdG86IFRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH1cblxuICByZXR1cm4gZ2V0VXJsQmFzZWRIaXN0b3J5KFxuICAgIGNyZWF0ZUJyb3dzZXJMb2NhdGlvbixcbiAgICBjcmVhdGVCcm93c2VySHJlZixcbiAgICBudWxsLFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIEhhc2ggSGlzdG9yeVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIGhhc2ggaGlzdG9yeSBzdG9yZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gdGhlIGZyYWdtZW50IGlkZW50aWZpZXIgcG9ydGlvblxuICogb2YgdGhlIFVSTCBpbiBhIHdlYiBicm93c2VyIGVudmlyb25tZW50LlxuICpcbiAqIFRoaXMgaXMgaWRlYWwgZm9yIGFwcHMgdGhhdCBkbyBub3QgY29udHJvbCB0aGUgc2VydmVyIGZvciBzb21lIHJlYXNvblxuICogKGJlY2F1c2UgdGhlIGZyYWdtZW50IGlkZW50aWZpZXIgaXMgbmV2ZXIgc2VudCB0byB0aGUgc2VydmVyKSwgaW5jbHVkaW5nIHNvbWVcbiAqIHNoYXJlZCBob3N0aW5nIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBwcm92aWRlIGZpbmUtZ3JhaW5lZCBjb250cm9scyBvdmVyXG4gKiB3aGljaCBwYWdlcyBhcmUgc2VydmVkIGF0IHdoaWNoIFVSTHMuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNoYXNoaGlzdG9yeVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhhc2hIaXN0b3J5IGV4dGVuZHMgVXJsSGlzdG9yeSB7fVxuXG5leHBvcnQgdHlwZSBIYXNoSGlzdG9yeU9wdGlvbnMgPSBVcmxIaXN0b3J5T3B0aW9ucztcblxuLyoqXG4gKiBIYXNoIGhpc3Rvcnkgc3RvcmVzIHRoZSBsb2NhdGlvbiBpbiB3aW5kb3cubG9jYXRpb24uaGFzaC4gVGhpcyBtYWtlcyBpdCBpZGVhbFxuICogZm9yIHNpdHVhdGlvbnMgd2hlcmUgeW91IGRvbid0IHdhbnQgdG8gc2VuZCB0aGUgbG9jYXRpb24gdG8gdGhlIHNlcnZlciBmb3JcbiAqIHNvbWUgcmVhc29uLCBlaXRoZXIgYmVjYXVzZSB5b3UgZG8gY2Fubm90IGNvbmZpZ3VyZSBpdCBvciB0aGUgVVJMIHNwYWNlIGlzXG4gKiByZXNlcnZlZCBmb3Igc29tZXRoaW5nIGVsc2UuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNjcmVhdGVoYXNoaGlzdG9yeVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoXG4gIG9wdGlvbnM6IEhhc2hIaXN0b3J5T3B0aW9ucyA9IHt9XG4pOiBIYXNoSGlzdG9yeSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUhhc2hMb2NhdGlvbihcbiAgICB3aW5kb3c6IFdpbmRvdyxcbiAgICBnbG9iYWxIaXN0b3J5OiBXaW5kb3dbXCJoaXN0b3J5XCJdXG4gICkge1xuICAgIGxldCB7XG4gICAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgICAgc2VhcmNoID0gXCJcIixcbiAgICAgIGhhc2ggPSBcIlwiLFxuICAgIH0gPSBwYXJzZVBhdGgod2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyKDEpKTtcbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24oXG4gICAgICBcIlwiLFxuICAgICAgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0sXG4gICAgICAvLyBzdGF0ZSBkZWZhdWx0cyB0byBgbnVsbGAgYmVjYXVzZSBgd2luZG93Lmhpc3Rvcnkuc3RhdGVgIGRvZXNcbiAgICAgIChnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUudXNyKSB8fCBudWxsLFxuICAgICAgKGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS5rZXkpIHx8IFwiZGVmYXVsdFwiXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhhc2hIcmVmKHdpbmRvdzogV2luZG93LCB0bzogVG8pIHtcbiAgICBsZXQgYmFzZSA9IHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYmFzZVwiKTtcbiAgICBsZXQgaHJlZiA9IFwiXCI7XG5cbiAgICBpZiAoYmFzZSAmJiBiYXNlLmdldEF0dHJpYnV0ZShcImhyZWZcIikpIHtcbiAgICAgIGxldCB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgIGxldCBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZihcIiNcIik7XG4gICAgICBocmVmID0gaGFzaEluZGV4ID09PSAtMSA/IHVybCA6IHVybC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBocmVmICsgXCIjXCIgKyAodHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKSk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUhhc2hMb2NhdGlvbihsb2NhdGlvbjogTG9jYXRpb24sIHRvOiBUbykge1xuICAgIHdhcm5pbmcoXG4gICAgICBsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09IFwiL1wiLFxuICAgICAgYHJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBoYXNoIGhpc3RvcnkucHVzaCgke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICB0b1xuICAgICAgKX0pYFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gZ2V0VXJsQmFzZWRIaXN0b3J5KFxuICAgIGNyZWF0ZUhhc2hMb2NhdGlvbixcbiAgICBjcmVhdGVIYXNoSHJlZixcbiAgICB2YWxpZGF0ZUhhc2hMb2NhdGlvbixcbiAgICBvcHRpb25zXG4gICk7XG59XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBVVElMU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YXJpYW50KHZhbHVlOiBib29sZWFuLCBtZXNzYWdlPzogc3RyaW5nKTogYXNzZXJ0cyB2YWx1ZTtcbmV4cG9ydCBmdW5jdGlvbiBpbnZhcmlhbnQ8VD4oXG4gIHZhbHVlOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgbWVzc2FnZT86IHN0cmluZ1xuKTogYXNzZXJ0cyB2YWx1ZSBpcyBUO1xuZXhwb3J0IGZ1bmN0aW9uIGludmFyaWFudCh2YWx1ZTogYW55LCBtZXNzYWdlPzogc3RyaW5nKSB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5pbmcoY29uZDogYW55LCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUud2FybihtZXNzYWdlKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBXZWxjb21lIHRvIGRlYnVnZ2luZyBoaXN0b3J5IVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28geW91IGNhbiBtb3JlIGVhc2lseVxuICAgICAgLy8gZmluZCB0aGUgc291cmNlIGZvciBhIHdhcm5pbmcgdGhhdCBhcHBlYXJzIGluIHRoZSBjb25zb2xlIGJ5XG4gICAgICAvLyBlbmFibGluZyBcInBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIEphdmFTY3JpcHQgZGVidWdnZXIuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA4KTtcbn1cblxuLyoqXG4gKiBGb3IgYnJvd3Nlci1iYXNlZCBoaXN0b3JpZXMsIHdlIGNvbWJpbmUgdGhlIHN0YXRlIGFuZCBrZXkgaW50byBhbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uOiBMb2NhdGlvbiwgaW5kZXg6IG51bWJlcik6IEhpc3RvcnlTdGF0ZSB7XG4gIHJldHVybiB7XG4gICAgdXNyOiBsb2NhdGlvbi5zdGF0ZSxcbiAgICBrZXk6IGxvY2F0aW9uLmtleSxcbiAgICBpZHg6IGluZGV4LFxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBMb2NhdGlvbiBvYmplY3Qgd2l0aCBhIHVuaXF1ZSBrZXkgZnJvbSB0aGUgZ2l2ZW4gUGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24oXG4gIGN1cnJlbnQ6IHN0cmluZyB8IExvY2F0aW9uLFxuICB0bzogVG8sXG4gIHN0YXRlOiBhbnkgPSBudWxsLFxuICBrZXk/OiBzdHJpbmdcbik6IFJlYWRvbmx5PExvY2F0aW9uPiB7XG4gIGxldCBsb2NhdGlvbjogUmVhZG9ubHk8TG9jYXRpb24+ID0ge1xuICAgIHBhdGhuYW1lOiB0eXBlb2YgY3VycmVudCA9PT0gXCJzdHJpbmdcIiA/IGN1cnJlbnQgOiBjdXJyZW50LnBhdGhuYW1lLFxuICAgIHNlYXJjaDogXCJcIixcbiAgICBoYXNoOiBcIlwiLFxuICAgIC4uLih0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG8pLFxuICAgIHN0YXRlLFxuICAgIC8vIFRPRE86IFRoaXMgY291bGQgYmUgY2xlYW5lZCB1cC4gIHB1c2gvcmVwbGFjZSBzaG91bGQgcHJvYmFibHkganVzdCB0YWtlXG4gICAgLy8gZnVsbCBMb2NhdGlvbnMgbm93IGFuZCBhdm9pZCB0aGUgbmVlZCB0byBydW4gdGhyb3VnaCB0aGlzIGZsb3cgYXQgYWxsXG4gICAgLy8gQnV0IHRoYXQncyBhIHByZXR0eSBiaWcgcmVmYWN0b3IgdG8gdGhlIGN1cnJlbnQgdGVzdCBzdWl0ZSBzbyBnb2luZyB0b1xuICAgIC8vIGtlZXAgYXMgaXMgZm9yIHRoZSB0aW1lIGJlaW5nIGFuZCBqdXN0IGxldCBhbnkgaW5jb21pbmcga2V5cyB0YWtlIHByZWNlZGVuY2VcbiAgICBrZXk6ICh0byAmJiAodG8gYXMgTG9jYXRpb24pLmtleSkgfHwga2V5IHx8IGNyZWF0ZUtleSgpLFxuICB9O1xuICByZXR1cm4gbG9jYXRpb247XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyBVUkwgcGF0aCBmcm9tIHRoZSBnaXZlbiBwYXRobmFtZSwgc2VhcmNoLCBhbmQgaGFzaCBjb21wb25lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGF0aCh7XG4gIHBhdGhuYW1lID0gXCIvXCIsXG4gIHNlYXJjaCA9IFwiXCIsXG4gIGhhc2ggPSBcIlwiLFxufTogUGFydGlhbDxQYXRoPikge1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaCAhPT0gXCI/XCIpXG4gICAgcGF0aG5hbWUgKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gXCI/XCIgPyBzZWFyY2ggOiBcIj9cIiArIHNlYXJjaDtcbiAgaWYgKGhhc2ggJiYgaGFzaCAhPT0gXCIjXCIpXG4gICAgcGF0aG5hbWUgKz0gaGFzaC5jaGFyQXQoMCkgPT09IFwiI1wiID8gaGFzaCA6IFwiI1wiICsgaGFzaDtcbiAgcmV0dXJuIHBhdGhuYW1lO1xufVxuXG4vKipcbiAqIFBhcnNlcyBhIHN0cmluZyBVUkwgcGF0aCBpbnRvIGl0cyBzZXBhcmF0ZSBwYXRobmFtZSwgc2VhcmNoLCBhbmQgaGFzaCBjb21wb25lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGg6IHN0cmluZyk6IFBhcnRpYWw8UGF0aD4ge1xuICBsZXQgcGFyc2VkUGF0aDogUGFydGlhbDxQYXRoPiA9IHt9O1xuXG4gIGlmIChwYXRoKSB7XG4gICAgbGV0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIik7XG4gICAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLmhhc2ggPSBwYXRoLnN1YnN0cihoYXNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIGhhc2hJbmRleCk7XG4gICAgfVxuXG4gICAgbGV0IHNlYXJjaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKTtcbiAgICBpZiAoc2VhcmNoSW5kZXggPj0gMCkge1xuICAgICAgcGFyc2VkUGF0aC5zZWFyY2ggPSBwYXRoLnN1YnN0cihzZWFyY2hJbmRleCk7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgc2VhcmNoSW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChwYXRoKSB7XG4gICAgICBwYXJzZWRQYXRoLnBhdGhuYW1lID0gcGF0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFyc2VkUGF0aDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVcmxIaXN0b3J5IGV4dGVuZHMgSGlzdG9yeSB7fVxuXG5leHBvcnQgdHlwZSBVcmxIaXN0b3J5T3B0aW9ucyA9IHtcbiAgd2luZG93PzogV2luZG93O1xuICB2NUNvbXBhdD86IGJvb2xlYW47XG59O1xuXG5mdW5jdGlvbiBnZXRVcmxCYXNlZEhpc3RvcnkoXG4gIGdldExvY2F0aW9uOiAod2luZG93OiBXaW5kb3csIGdsb2JhbEhpc3Rvcnk6IFdpbmRvd1tcImhpc3RvcnlcIl0pID0+IExvY2F0aW9uLFxuICBjcmVhdGVIcmVmOiAod2luZG93OiBXaW5kb3csIHRvOiBUbykgPT4gc3RyaW5nLFxuICB2YWxpZGF0ZUxvY2F0aW9uOiAoKGxvY2F0aW9uOiBMb2NhdGlvbiwgdG86IFRvKSA9PiB2b2lkKSB8IG51bGwsXG4gIG9wdGlvbnM6IFVybEhpc3RvcnlPcHRpb25zID0ge31cbik6IFVybEhpc3Rvcnkge1xuICBsZXQgeyB3aW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldyEsIHY1Q29tcGF0ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGxldCBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIGxldCBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICBsZXQgbGlzdGVuZXI6IExpc3RlbmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgbGV0IGluZGV4ID0gZ2V0SW5kZXgoKSE7XG4gIC8vIEluZGV4IHNob3VsZCBvbmx5IGJlIG51bGwgd2hlbiB3ZSBpbml0aWFsaXplLiBJZiBub3QsIGl0J3MgYmVjYXVzZSB0aGVcbiAgLy8gdXNlciBjYWxsZWQgaGlzdG9yeS5wdXNoU3RhdGUgb3IgaGlzdG9yeS5yZXBsYWNlU3RhdGUgZGlyZWN0bHksIGluIHdoaWNoXG4gIC8vIGNhc2Ugd2Ugc2hvdWxkIGxvZyBhIHdhcm5pbmcgYXMgaXQgd2lsbCByZXN1bHQgaW4gYnVncy5cbiAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICBpbmRleCA9IDA7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoeyAuLi5nbG9iYWxIaXN0b3J5LnN0YXRlLCBpZHg6IGluZGV4IH0sIFwiXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW5kZXgoKTogbnVtYmVyIHtcbiAgICBsZXQgc3RhdGUgPSBnbG9iYWxIaXN0b3J5LnN0YXRlIHx8IHsgaWR4OiBudWxsIH07XG4gICAgcmV0dXJuIHN0YXRlLmlkeDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVBvcCgpIHtcbiAgICBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICAgIGxldCBuZXh0SW5kZXggPSBnZXRJbmRleCgpO1xuICAgIGxldCBkZWx0YSA9IG5leHRJbmRleCA9PSBudWxsID8gbnVsbCA6IG5leHRJbmRleCAtIGluZGV4O1xuICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLCBkZWx0YSB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKHRvOiBUbywgc3RhdGU/OiBhbnkpIHtcbiAgICBhY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xuICAgIGlmICh2YWxpZGF0ZUxvY2F0aW9uKSB2YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB0byk7XG5cbiAgICBpbmRleCA9IGdldEluZGV4KCkgKyAxO1xuICAgIGxldCBoaXN0b3J5U3RhdGUgPSBnZXRIaXN0b3J5U3RhdGUobG9jYXRpb24sIGluZGV4KTtcbiAgICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVIcmVmKGxvY2F0aW9uKTtcblxuICAgIC8vIHRyeS4uLmNhdGNoIGJlY2F1c2UgaU9TIGxpbWl0cyB1cyB0byAxMDAgcHVzaFN0YXRlIGNhbGxzIDovXG4gICAgdHJ5IHtcbiAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKGhpc3RvcnlTdGF0ZSwgXCJcIiwgdXJsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gVGhleSBhcmUgZ29pbmcgdG8gbG9zZSBzdGF0ZSBoZXJlLCBidXQgdGhlcmUgaXMgbm8gcmVhbFxuICAgICAgLy8gd2F5IHRvIHdhcm4gdGhlbSBhYm91dCBpdCBzaW5jZSB0aGUgcGFnZSB3aWxsIHJlZnJlc2guLi5cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICB9XG5cbiAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbiwgZGVsdGE6IDEgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZSh0bzogVG8sIHN0YXRlPzogYW55KSB7XG4gICAgYWN0aW9uID0gQWN0aW9uLlJlcGxhY2U7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oaGlzdG9yeS5sb2NhdGlvbiwgdG8sIHN0YXRlKTtcbiAgICBpZiAodmFsaWRhdGVMb2NhdGlvbikgdmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbiwgdG8pO1xuXG4gICAgaW5kZXggPSBnZXRJbmRleCgpO1xuICAgIGxldCBoaXN0b3J5U3RhdGUgPSBnZXRIaXN0b3J5U3RhdGUobG9jYXRpb24sIGluZGV4KTtcbiAgICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsIFwiXCIsIHVybCk7XG5cbiAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbiwgZGVsdGE6IDAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVVJMKHRvOiBUbyk6IFVSTCB7XG4gICAgLy8gd2luZG93LmxvY2F0aW9uLm9yaWdpbiBpcyBcIm51bGxcIiAodGhlIGxpdGVyYWwgc3RyaW5nIHZhbHVlKSBpbiBGaXJlZm94XG4gICAgLy8gdW5kZXIgY2VydGFpbiBjb25kaXRpb25zLCBub3RhYmx5IHdoZW4gc2VydmluZyBmcm9tIGEgbG9jYWwgSFRNTCBmaWxlXG4gICAgLy8gU2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg3ODI5N1xuICAgIGxldCBiYXNlID1cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gIT09IFwibnVsbFwiXG4gICAgICAgID8gd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICAgICAgICA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuXG4gICAgbGV0IGhyZWYgPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICAgIGludmFyaWFudChcbiAgICAgIGJhc2UsXG4gICAgICBgTm8gd2luZG93LmxvY2F0aW9uLihvcmlnaW58aHJlZikgYXZhaWxhYmxlIHRvIGNyZWF0ZSBVUkwgZm9yIGhyZWY6ICR7aHJlZn1gXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IFVSTChocmVmLCBiYXNlKTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5OiBIaXN0b3J5ID0ge1xuICAgIGdldCBhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH0sXG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIGdldExvY2F0aW9uKHdpbmRvdywgZ2xvYmFsSGlzdG9yeSk7XG4gICAgfSxcbiAgICBsaXN0ZW4oZm46IExpc3RlbmVyKSB7XG4gICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBoaXN0b3J5IG9ubHkgYWNjZXB0cyBvbmUgYWN0aXZlIGxpc3RlbmVyXCIpO1xuICAgICAgfVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudFR5cGUsIGhhbmRsZVBvcCk7XG4gICAgICBsaXN0ZW5lciA9IGZuO1xuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTtcbiAgICAgICAgbGlzdGVuZXIgPSBudWxsO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGNyZWF0ZUhyZWYodG8pIHtcbiAgICAgIHJldHVybiBjcmVhdGVIcmVmKHdpbmRvdywgdG8pO1xuICAgIH0sXG4gICAgY3JlYXRlVVJMLFxuICAgIGVuY29kZUxvY2F0aW9uKHRvKSB7XG4gICAgICAvLyBFbmNvZGUgYSBMb2NhdGlvbiB0aGUgc2FtZSB3YXkgd2luZG93LmxvY2F0aW9uIHdvdWxkXG4gICAgICBsZXQgdXJsID0gY3JlYXRlVVJMKHRvKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaDogdXJsLnNlYXJjaCxcbiAgICAgICAgaGFzaDogdXJsLmhhc2gsXG4gICAgICB9O1xuICAgIH0sXG4gICAgcHVzaCxcbiAgICByZXBsYWNlLFxuICAgIGdvKG4pIHtcbiAgICAgIHJldHVybiBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5cbi8vI2VuZHJlZ2lvblxuIiwiaW1wb3J0IHR5cGUgeyBMb2NhdGlvbiwgUGF0aCwgVG8gfSBmcm9tIFwiLi9oaXN0b3J5XCI7XG5pbXBvcnQgeyBpbnZhcmlhbnQsIHBhcnNlUGF0aCB9IGZyb20gXCIuL2hpc3RvcnlcIjtcblxuLyoqXG4gKiBNYXAgb2Ygcm91dGVJZCAtPiBkYXRhIHJldHVybmVkIGZyb20gYSBsb2FkZXIvYWN0aW9uL2Vycm9yXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVEYXRhIHtcbiAgW3JvdXRlSWQ6IHN0cmluZ106IGFueTtcbn1cblxuZXhwb3J0IGVudW0gUmVzdWx0VHlwZSB7XG4gIGRhdGEgPSBcImRhdGFcIixcbiAgZGVmZXJyZWQgPSBcImRlZmVycmVkXCIsXG4gIHJlZGlyZWN0ID0gXCJyZWRpcmVjdFwiLFxuICBlcnJvciA9IFwiZXJyb3JcIixcbn1cblxuLyoqXG4gKiBTdWNjZXNzZnVsIHJlc3VsdCBmcm9tIGEgbG9hZGVyIG9yIGFjdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN1Y2Nlc3NSZXN1bHQge1xuICB0eXBlOiBSZXN1bHRUeXBlLmRhdGE7XG4gIGRhdGE6IGFueTtcbiAgc3RhdHVzQ29kZT86IG51bWJlcjtcbiAgaGVhZGVycz86IEhlYWRlcnM7XG59XG5cbi8qKlxuICogU3VjY2Vzc2Z1bCBkZWZlcigpIHJlc3VsdCBmcm9tIGEgbG9hZGVyIG9yIGFjdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIERlZmVycmVkUmVzdWx0IHtcbiAgdHlwZTogUmVzdWx0VHlwZS5kZWZlcnJlZDtcbiAgZGVmZXJyZWREYXRhOiBEZWZlcnJlZERhdGE7XG4gIHN0YXR1c0NvZGU/OiBudW1iZXI7XG4gIGhlYWRlcnM/OiBIZWFkZXJzO1xufVxuXG4vKipcbiAqIFJlZGlyZWN0IHJlc3VsdCBmcm9tIGEgbG9hZGVyIG9yIGFjdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlZGlyZWN0UmVzdWx0IHtcbiAgdHlwZTogUmVzdWx0VHlwZS5yZWRpcmVjdDtcbiAgc3RhdHVzOiBudW1iZXI7XG4gIGxvY2F0aW9uOiBzdHJpbmc7XG4gIHJldmFsaWRhdGU6IGJvb2xlYW47XG59XG5cbi8qKlxuICogVW5zdWNjZXNzZnVsIHJlc3VsdCBmcm9tIGEgbG9hZGVyIG9yIGFjdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yUmVzdWx0IHtcbiAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcjtcbiAgZXJyb3I6IGFueTtcbiAgaGVhZGVycz86IEhlYWRlcnM7XG59XG5cbi8qKlxuICogUmVzdWx0IGZyb20gYSBsb2FkZXIgb3IgYWN0aW9uIC0gcG90ZW50aWFsbHkgc3VjY2Vzc2Z1bCBvciB1bnN1Y2Nlc3NmdWxcbiAqL1xuZXhwb3J0IHR5cGUgRGF0YVJlc3VsdCA9XG4gIHwgU3VjY2Vzc1Jlc3VsdFxuICB8IERlZmVycmVkUmVzdWx0XG4gIHwgUmVkaXJlY3RSZXN1bHRcbiAgfCBFcnJvclJlc3VsdDtcblxuZXhwb3J0IHR5cGUgTXV0YXRpb25Gb3JtTWV0aG9kID0gXCJwb3N0XCIgfCBcInB1dFwiIHwgXCJwYXRjaFwiIHwgXCJkZWxldGVcIjtcbmV4cG9ydCB0eXBlIEZvcm1NZXRob2QgPSBcImdldFwiIHwgTXV0YXRpb25Gb3JtTWV0aG9kO1xuXG5leHBvcnQgdHlwZSBGb3JtRW5jVHlwZSA9XG4gIHwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxuICB8IFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBJbnRlcm5hbCBpbnRlcmZhY2UgdG8gcGFzcyBhcm91bmQgZm9yIGFjdGlvbiBzdWJtaXNzaW9ucywgbm90IGludGVuZGVkIGZvclxuICogZXh0ZXJuYWwgY29uc3VtcHRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdWJtaXNzaW9uIHtcbiAgZm9ybU1ldGhvZDogRm9ybU1ldGhvZDtcbiAgZm9ybUFjdGlvbjogc3RyaW5nO1xuICBmb3JtRW5jVHlwZTogRm9ybUVuY1R5cGU7XG4gIGZvcm1EYXRhOiBGb3JtRGF0YTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQXJndW1lbnRzIHBhc3NlZCB0byByb3V0ZSBsb2FkZXIvYWN0aW9uIGZ1bmN0aW9ucy4gIFNhbWUgZm9yIG5vdyBidXQgd2Uga2VlcFxuICogdGhpcyBhcyBhIHByaXZhdGUgaW1wbGVtZW50YXRpb24gZGV0YWlsIGluIGNhc2UgdGhleSBkaXZlcmdlIGluIHRoZSBmdXR1cmUuXG4gKi9cbmludGVyZmFjZSBEYXRhRnVuY3Rpb25BcmdzIHtcbiAgcmVxdWVzdDogUmVxdWVzdDtcbiAgcGFyYW1zOiBQYXJhbXM7XG4gIGNvbnRleHQ/OiBhbnk7XG59XG5cbi8qKlxuICogQXJndW1lbnRzIHBhc3NlZCB0byBsb2FkZXIgZnVuY3Rpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVyRnVuY3Rpb25BcmdzIGV4dGVuZHMgRGF0YUZ1bmN0aW9uQXJncyB7fVxuXG4vKipcbiAqIEFyZ3VtZW50cyBwYXNzZWQgdG8gYWN0aW9uIGZ1bmN0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkZ1bmN0aW9uQXJncyBleHRlbmRzIERhdGFGdW5jdGlvbkFyZ3Mge31cblxuLyoqXG4gKiBSb3V0ZSBsb2FkZXIgZnVuY3Rpb24gc2lnbmF0dXJlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVyRnVuY3Rpb24ge1xuICAoYXJnczogTG9hZGVyRnVuY3Rpb25BcmdzKTogUHJvbWlzZTxSZXNwb25zZT4gfCBSZXNwb25zZSB8IFByb21pc2U8YW55PiB8IGFueTtcbn1cblxuLyoqXG4gKiBSb3V0ZSBhY3Rpb24gZnVuY3Rpb24gc2lnbmF0dXJlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uRnVuY3Rpb24ge1xuICAoYXJnczogQWN0aW9uRnVuY3Rpb25BcmdzKTogUHJvbWlzZTxSZXNwb25zZT4gfCBSZXNwb25zZSB8IFByb21pc2U8YW55PiB8IGFueTtcbn1cblxuLyoqXG4gKiBSb3V0ZSBzaG91bGRSZXZhbGlkYXRlIGZ1bmN0aW9uIHNpZ25hdHVyZS4gIFRoaXMgcnVucyBhZnRlciBhbnkgc3VibWlzc2lvblxuICogKG5hdmlnYXRpb24gb3IgZmV0Y2hlciksIHNvIHdlIGZsYXR0ZW4gdGhlIG5hdmlnYXRpb24vZmV0Y2hlciBzdWJtaXNzaW9uXG4gKiBvbnRvIHRoZSBhcmd1bWVudHMuICBJdCBzaG91bGRuJ3QgbWF0dGVyIHdoZXRoZXIgaXQgY2FtZSBmcm9tIGEgbmF2aWdhdGlvblxuICogb3IgYSBmZXRjaGVyLCB3aGF0IHJlYWxseSBtYXR0ZXJzIGlzIHRoZSBVUkxzIGFuZCB0aGUgZm9ybURhdGEgc2luY2UgbG9hZGVyc1xuICogaGF2ZSB0byByZS1ydW4gYmFzZWQgb24gdGhlIGRhdGEgbW9kZWxzIHRoYXQgd2VyZSBwb3RlbnRpYWxseSBtdXRhdGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbiB7XG4gIChhcmdzOiB7XG4gICAgY3VycmVudFVybDogVVJMO1xuICAgIGN1cnJlbnRQYXJhbXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXCJwYXJhbXNcIl07XG4gICAgbmV4dFVybDogVVJMO1xuICAgIG5leHRQYXJhbXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXCJwYXJhbXNcIl07XG4gICAgZm9ybU1ldGhvZD86IFN1Ym1pc3Npb25bXCJmb3JtTWV0aG9kXCJdO1xuICAgIGZvcm1BY3Rpb24/OiBTdWJtaXNzaW9uW1wiZm9ybUFjdGlvblwiXTtcbiAgICBmb3JtRW5jVHlwZT86IFN1Ym1pc3Npb25bXCJmb3JtRW5jVHlwZVwiXTtcbiAgICBmb3JtRGF0YT86IFN1Ym1pc3Npb25bXCJmb3JtRGF0YVwiXTtcbiAgICBhY3Rpb25SZXN1bHQ/OiBEYXRhUmVzdWx0O1xuICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOiBib29sZWFuO1xuICB9KTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBCYXNlIFJvdXRlT2JqZWN0IHdpdGggY29tbW9uIHByb3BzIHNoYXJlZCBieSBhbGwgdHlwZXMgb2Ygcm91dGVzXG4gKi9cbnR5cGUgQWdub3N0aWNCYXNlUm91dGVPYmplY3QgPSB7XG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICBwYXRoPzogc3RyaW5nO1xuICBpZD86IHN0cmluZztcbiAgbG9hZGVyPzogTG9hZGVyRnVuY3Rpb247XG4gIGFjdGlvbj86IEFjdGlvbkZ1bmN0aW9uO1xuICBoYXNFcnJvckJvdW5kYXJ5PzogYm9vbGVhbjtcbiAgc2hvdWxkUmV2YWxpZGF0ZT86IFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbjtcbiAgaGFuZGxlPzogYW55O1xufTtcblxuLyoqXG4gKiBJbmRleCByb3V0ZXMgbXVzdCBub3QgaGF2ZSBjaGlsZHJlblxuICovXG5leHBvcnQgdHlwZSBBZ25vc3RpY0luZGV4Um91dGVPYmplY3QgPSBBZ25vc3RpY0Jhc2VSb3V0ZU9iamVjdCAmIHtcbiAgY2hpbGRyZW4/OiB1bmRlZmluZWQ7XG4gIGluZGV4OiB0cnVlO1xufTtcblxuLyoqXG4gKiBOb24taW5kZXggcm91dGVzIG1heSBoYXZlIGNoaWxkcmVuLCBidXQgY2Fubm90IGhhdmUgaW5kZXhcbiAqL1xuZXhwb3J0IHR5cGUgQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0ID0gQWdub3N0aWNCYXNlUm91dGVPYmplY3QgJiB7XG4gIGNoaWxkcmVuPzogQWdub3N0aWNSb3V0ZU9iamVjdFtdO1xuICBpbmRleD86IGZhbHNlO1xufTtcblxuLyoqXG4gKiBBIHJvdXRlIG9iamVjdCByZXByZXNlbnRzIGEgbG9naWNhbCByb3V0ZSwgd2l0aCAob3B0aW9uYWxseSkgaXRzIGNoaWxkXG4gKiByb3V0ZXMgb3JnYW5pemVkIGluIGEgdHJlZS1saWtlIHN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IHR5cGUgQWdub3N0aWNSb3V0ZU9iamVjdCA9XG4gIHwgQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0XG4gIHwgQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0O1xuXG5leHBvcnQgdHlwZSBBZ25vc3RpY0RhdGFJbmRleFJvdXRlT2JqZWN0ID0gQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0ICYge1xuICBpZDogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgQWdub3N0aWNEYXRhTm9uSW5kZXhSb3V0ZU9iamVjdCA9IEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdCAmIHtcbiAgY2hpbGRyZW4/OiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdO1xuICBpZDogc3RyaW5nO1xufTtcblxuLyoqXG4gKiBBIGRhdGEgcm91dGUgb2JqZWN0LCB3aGljaCBpcyBqdXN0IGEgUm91dGVPYmplY3Qgd2l0aCBhIHJlcXVpcmVkIHVuaXF1ZSBJRFxuICovXG5leHBvcnQgdHlwZSBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdCA9XG4gIHwgQWdub3N0aWNEYXRhSW5kZXhSb3V0ZU9iamVjdFxuICB8IEFnbm9zdGljRGF0YU5vbkluZGV4Um91dGVPYmplY3Q7XG5cbi8vIFJlY3Vyc2l2ZSBoZWxwZXIgZm9yIGZpbmRpbmcgcGF0aCBwYXJhbWV0ZXJzIGluIHRoZSBhYnNlbmNlIG9mIHdpbGRjYXJkc1xudHlwZSBfUGF0aFBhcmFtPFBhdGggZXh0ZW5kcyBzdHJpbmc+ID1cbiAgLy8gc3BsaXQgcGF0aCBpbnRvIGluZGl2aWR1YWwgcGF0aCBzZWdtZW50c1xuICBQYXRoIGV4dGVuZHMgYCR7aW5mZXIgTH0vJHtpbmZlciBSfWBcbiAgICA/IF9QYXRoUGFyYW08TD4gfCBfUGF0aFBhcmFtPFI+XG4gICAgOiAvLyBmaW5kIHBhcmFtcyBhZnRlciBgOmBcbiAgICBQYXRoIGV4dGVuZHMgYDoke2luZmVyIFBhcmFtfWBcbiAgICA/IFBhcmFtIGV4dGVuZHMgYCR7aW5mZXIgT3B0aW9uYWx9P2BcbiAgICAgID8gT3B0aW9uYWxcbiAgICAgIDogUGFyYW1cbiAgICA6IC8vIG90aGVyd2lzZSwgdGhlcmUgYXJlbid0IGFueSBwYXJhbXMgcHJlc2VudFxuICAgICAgbmV2ZXI7XG5cbi8qKlxuICogRXhhbXBsZXM6XG4gKiBcIi9hL2IvKlwiIC0+IFwiKlwiXG4gKiBcIjphXCIgLT4gXCJhXCJcbiAqIFwiL2EvOmJcIiAtPiBcImJcIlxuICogXCIvYS9ibGFoYmxhaGJsYWg6YlwiIC0+IFwiYlwiXG4gKiBcIi86YS86YlwiIC0+IFwiYVwiIHwgXCJiXCJcbiAqIFwiLzphL2IvOmMvKlwiIC0+IFwiYVwiIHwgXCJjXCIgfCBcIipcIlxuICovXG50eXBlIFBhdGhQYXJhbTxQYXRoIGV4dGVuZHMgc3RyaW5nPiA9XG4gIC8vIGNoZWNrIGlmIHBhdGggaXMganVzdCBhIHdpbGRjYXJkXG4gIFBhdGggZXh0ZW5kcyBcIipcIlxuICAgID8gXCIqXCJcbiAgICA6IC8vIGxvb2sgZm9yIHdpbGRjYXJkIGF0IHRoZSBlbmQgb2YgdGhlIHBhdGhcbiAgICBQYXRoIGV4dGVuZHMgYCR7aW5mZXIgUmVzdH0vKmBcbiAgICA/IFwiKlwiIHwgX1BhdGhQYXJhbTxSZXN0PlxuICAgIDogLy8gbG9vayBmb3IgcGFyYW1zIGluIHRoZSBhYnNlbmNlIG9mIHdpbGRjYXJkc1xuICAgICAgX1BhdGhQYXJhbTxQYXRoPjtcblxuLy8gQXR0ZW1wdCB0byBwYXJzZSB0aGUgZ2l2ZW4gc3RyaW5nIHNlZ21lbnQuIElmIGl0IGZhaWxzLCB0aGVuIGp1c3QgcmV0dXJuIHRoZVxuLy8gcGxhaW4gc3RyaW5nIHR5cGUgYXMgYSBkZWZhdWx0IGZhbGxiYWNrLiBPdGhlcndpc2UgcmV0dXJuIHRoZSB1bmlvbiBvZiB0aGVcbi8vIHBhcnNlZCBzdHJpbmcgbGl0ZXJhbHMgdGhhdCB3ZXJlIHJlZmVyZW5jZWQgYXMgZHluYW1pYyBzZWdtZW50cyBpbiB0aGUgcm91dGUuXG5leHBvcnQgdHlwZSBQYXJhbVBhcnNlS2V5PFNlZ21lbnQgZXh0ZW5kcyBzdHJpbmc+ID1cbiAgLy8gaWYgY291bGQgbm90IGZpbmQgcGF0aCBwYXJhbXMsIGZhbGxiYWNrIHRvIGBzdHJpbmdgXG4gIFtQYXRoUGFyYW08U2VnbWVudD5dIGV4dGVuZHMgW25ldmVyXSA/IHN0cmluZyA6IFBhdGhQYXJhbTxTZWdtZW50PjtcblxuLyoqXG4gKiBUaGUgcGFyYW1ldGVycyB0aGF0IHdlcmUgcGFyc2VkIGZyb20gdGhlIFVSTCBwYXRoLlxuICovXG5leHBvcnQgdHlwZSBQYXJhbXM8S2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiA9IHtcbiAgcmVhZG9ubHkgW2tleSBpbiBLZXldOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEEgUm91dGVNYXRjaCBjb250YWlucyBpbmZvIGFib3V0IGhvdyBhIHJvdXRlIG1hdGNoZWQgYSBVUkwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWdub3N0aWNSb3V0ZU1hdGNoPFxuICBQYXJhbUtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4ge1xuICAvKipcbiAgICogVGhlIG5hbWVzIGFuZCB2YWx1ZXMgb2YgZHluYW1pYyBwYXJhbWV0ZXJzIGluIHRoZSBVUkwuXG4gICAqL1xuICBwYXJhbXM6IFBhcmFtczxQYXJhbUtleT47XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkIGJlZm9yZSBjaGlsZCByb3V0ZXMuXG4gICAqL1xuICBwYXRobmFtZUJhc2U6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSByb3V0ZSBvYmplY3QgdGhhdCB3YXMgdXNlZCB0byBtYXRjaC5cbiAgICovXG4gIHJvdXRlOiBSb3V0ZU9iamVjdFR5cGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWdub3N0aWNEYXRhUm91dGVNYXRjaFxuICBleHRlbmRzIEFnbm9zdGljUm91dGVNYXRjaDxzdHJpbmcsIEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0PiB7fVxuXG5mdW5jdGlvbiBpc0luZGV4Um91dGUoXG4gIHJvdXRlOiBBZ25vc3RpY1JvdXRlT2JqZWN0XG4pOiByb3V0ZSBpcyBBZ25vc3RpY0luZGV4Um91dGVPYmplY3Qge1xuICByZXR1cm4gcm91dGUuaW5kZXggPT09IHRydWU7XG59XG5cbi8vIFdhbGsgdGhlIHJvdXRlIHRyZWUgZ2VuZXJhdGluZyB1bmlxdWUgSURzIHdoZXJlIG5lY2Vzc2FyeSBzbyB3ZSBhcmUgd29ya2luZ1xuLy8gc29sZWx5IHdpdGggQWdub3N0aWNEYXRhUm91dGVPYmplY3QncyB3aXRoaW4gdGhlIFJvdXRlclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gIHJvdXRlczogQWdub3N0aWNSb3V0ZU9iamVjdFtdLFxuICBwYXJlbnRQYXRoOiBudW1iZXJbXSA9IFtdLFxuICBhbGxJZHM6IFNldDxzdHJpbmc+ID0gbmV3IFNldDxzdHJpbmc+KClcbik6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W10ge1xuICByZXR1cm4gcm91dGVzLm1hcCgocm91dGUsIGluZGV4KSA9PiB7XG4gICAgbGV0IHRyZWVQYXRoID0gWy4uLnBhcmVudFBhdGgsIGluZGV4XTtcbiAgICBsZXQgaWQgPSB0eXBlb2Ygcm91dGUuaWQgPT09IFwic3RyaW5nXCIgPyByb3V0ZS5pZCA6IHRyZWVQYXRoLmpvaW4oXCItXCIpO1xuICAgIGludmFyaWFudChcbiAgICAgIHJvdXRlLmluZGV4ICE9PSB0cnVlIHx8ICFyb3V0ZS5jaGlsZHJlbixcbiAgICAgIGBDYW5ub3Qgc3BlY2lmeSBjaGlsZHJlbiBvbiBhbiBpbmRleCByb3V0ZWBcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICFhbGxJZHMuaGFzKGlkKSxcbiAgICAgIGBGb3VuZCBhIHJvdXRlIGlkIGNvbGxpc2lvbiBvbiBpZCBcIiR7aWR9XCIuICBSb3V0ZSBgICtcbiAgICAgICAgXCJpZCdzIG11c3QgYmUgZ2xvYmFsbHkgdW5pcXVlIHdpdGhpbiBEYXRhIFJvdXRlciB1c2FnZXNcIlxuICAgICk7XG4gICAgYWxsSWRzLmFkZChpZCk7XG5cbiAgICBpZiAoaXNJbmRleFJvdXRlKHJvdXRlKSkge1xuICAgICAgbGV0IGluZGV4Um91dGU6IEFnbm9zdGljRGF0YUluZGV4Um91dGVPYmplY3QgPSB7IC4uLnJvdXRlLCBpZCB9O1xuICAgICAgcmV0dXJuIGluZGV4Um91dGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXRoT3JMYXlvdXRSb3V0ZTogQWdub3N0aWNEYXRhTm9uSW5kZXhSb3V0ZU9iamVjdCA9IHtcbiAgICAgICAgLi4ucm91dGUsXG4gICAgICAgIGlkLFxuICAgICAgICBjaGlsZHJlbjogcm91dGUuY2hpbGRyZW5cbiAgICAgICAgICA/IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMocm91dGUuY2hpbGRyZW4sIHRyZWVQYXRoLCBhbGxJZHMpXG4gICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHBhdGhPckxheW91dFJvdXRlO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogTWF0Y2hlcyB0aGUgZ2l2ZW4gcm91dGVzIHRvIGEgbG9jYXRpb24gYW5kIHJldHVybnMgdGhlIG1hdGNoIGRhdGEuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9tYXRjaC1yb3V0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoUm91dGVzPFxuICBSb3V0ZU9iamVjdFR5cGUgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0ID0gQWdub3N0aWNSb3V0ZU9iamVjdFxuPihcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFR5cGVbXSxcbiAgbG9jYXRpb25Bcmc6IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nLFxuICBiYXNlbmFtZSA9IFwiL1wiXG4pOiBBZ25vc3RpY1JvdXRlTWF0Y2g8c3RyaW5nLCBSb3V0ZU9iamVjdFR5cGU+W10gfCBudWxsIHtcbiAgbGV0IGxvY2F0aW9uID1cbiAgICB0eXBlb2YgbG9jYXRpb25BcmcgPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb25BcmcpIDogbG9jYXRpb25Bcmc7XG5cbiAgbGV0IHBhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIiwgYmFzZW5hbWUpO1xuXG4gIGlmIChwYXRobmFtZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZXQgYnJhbmNoZXMgPSBmbGF0dGVuUm91dGVzKHJvdXRlcyk7XG4gIHJhbmtSb3V0ZUJyYW5jaGVzKGJyYW5jaGVzKTtcblxuICBsZXQgbWF0Y2hlcyA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBtYXRjaGVzID09IG51bGwgJiYgaSA8IGJyYW5jaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgbWF0Y2hlcyA9IG1hdGNoUm91dGVCcmFuY2g8c3RyaW5nLCBSb3V0ZU9iamVjdFR5cGU+KFxuICAgICAgYnJhbmNoZXNbaV0sXG4gICAgICAvLyBJbmNvbWluZyBwYXRobmFtZXMgYXJlIGdlbmVyYWxseSBlbmNvZGVkIGZyb20gZWl0aGVyIHdpbmRvdy5sb2NhdGlvblxuICAgICAgLy8gb3IgZnJvbSByb3V0ZXIubmF2aWdhdGUsIGJ1dCB3ZSB3YW50IHRvIG1hdGNoIGFnYWluc3QgdGhlIHVuZW5jb2RlZFxuICAgICAgLy8gcGF0aHMgaW4gdGhlIHJvdXRlIGRlZmluaXRpb25zLiAgTWVtb3J5IHJvdXRlciBsb2NhdGlvbnMgd29uJ3QgYmVcbiAgICAgIC8vIGVuY29kZWQgaGVyZSBidXQgdGhlcmUgYWxzbyBzaG91bGRuJ3QgYmUgYW55dGhpbmcgdG8gZGVjb2RlIHNvIHRoaXNcbiAgICAgIC8vIHNob3VsZCBiZSBhIHNhZmUgb3BlcmF0aW9uLiAgVGhpcyBhdm9pZHMgbmVlZGluZyBtYXRjaFJvdXRlcyB0byBiZVxuICAgICAgLy8gaGlzdG9yeS1hd2FyZS5cbiAgICAgIHNhZmVseURlY29kZVVSSShwYXRobmFtZSlcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbmludGVyZmFjZSBSb3V0ZU1ldGE8XG4gIFJvdXRlT2JqZWN0VHlwZSBleHRlbmRzIEFnbm9zdGljUm91dGVPYmplY3QgPSBBZ25vc3RpY1JvdXRlT2JqZWN0XG4+IHtcbiAgcmVsYXRpdmVQYXRoOiBzdHJpbmc7XG4gIGNhc2VTZW5zaXRpdmU6IGJvb2xlYW47XG4gIGNoaWxkcmVuSW5kZXg6IG51bWJlcjtcbiAgcm91dGU6IFJvdXRlT2JqZWN0VHlwZTtcbn1cblxuaW50ZXJmYWNlIFJvdXRlQnJhbmNoPFxuICBSb3V0ZU9iamVjdFR5cGUgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0ID0gQWdub3N0aWNSb3V0ZU9iamVjdFxuPiB7XG4gIHBhdGg6IHN0cmluZztcbiAgc2NvcmU6IG51bWJlcjtcbiAgcm91dGVzTWV0YTogUm91dGVNZXRhPFJvdXRlT2JqZWN0VHlwZT5bXTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlblJvdXRlczxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4oXG4gIHJvdXRlczogUm91dGVPYmplY3RUeXBlW10sXG4gIGJyYW5jaGVzOiBSb3V0ZUJyYW5jaDxSb3V0ZU9iamVjdFR5cGU+W10gPSBbXSxcbiAgcGFyZW50c01ldGE6IFJvdXRlTWV0YTxSb3V0ZU9iamVjdFR5cGU+W10gPSBbXSxcbiAgcGFyZW50UGF0aCA9IFwiXCJcbik6IFJvdXRlQnJhbmNoPFJvdXRlT2JqZWN0VHlwZT5bXSB7XG4gIGxldCBmbGF0dGVuUm91dGUgPSAoXG4gICAgcm91dGU6IFJvdXRlT2JqZWN0VHlwZSxcbiAgICBpbmRleDogbnVtYmVyLFxuICAgIHJlbGF0aXZlUGF0aD86IHN0cmluZ1xuICApID0+IHtcbiAgICBsZXQgbWV0YTogUm91dGVNZXRhPFJvdXRlT2JqZWN0VHlwZT4gPSB7XG4gICAgICByZWxhdGl2ZVBhdGg6XG4gICAgICAgIHJlbGF0aXZlUGF0aCA9PT0gdW5kZWZpbmVkID8gcm91dGUucGF0aCB8fCBcIlwiIDogcmVsYXRpdmVQYXRoLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogcm91dGUuY2FzZVNlbnNpdGl2ZSA9PT0gdHJ1ZSxcbiAgICAgIGNoaWxkcmVuSW5kZXg6IGluZGV4LFxuICAgICAgcm91dGUsXG4gICAgfTtcblxuICAgIGlmIChtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKHBhcmVudFBhdGgpLFxuICAgICAgICBgQWJzb2x1dGUgcm91dGUgcGF0aCBcIiR7bWV0YS5yZWxhdGl2ZVBhdGh9XCIgbmVzdGVkIHVuZGVyIHBhdGggYCArXG4gICAgICAgICAgYFwiJHtwYXJlbnRQYXRofVwiIGlzIG5vdCB2YWxpZC4gQW4gYWJzb2x1dGUgY2hpbGQgcm91dGUgcGF0aCBgICtcbiAgICAgICAgICBgbXVzdCBzdGFydCB3aXRoIHRoZSBjb21iaW5lZCBwYXRoIG9mIGFsbCBpdHMgcGFyZW50IHJvdXRlcy5gXG4gICAgICApO1xuXG4gICAgICBtZXRhLnJlbGF0aXZlUGF0aCA9IG1ldGEucmVsYXRpdmVQYXRoLnNsaWNlKHBhcmVudFBhdGgubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBsZXQgcGF0aCA9IGpvaW5QYXRocyhbcGFyZW50UGF0aCwgbWV0YS5yZWxhdGl2ZVBhdGhdKTtcbiAgICBsZXQgcm91dGVzTWV0YSA9IHBhcmVudHNNZXRhLmNvbmNhdChtZXRhKTtcblxuICAgIC8vIEFkZCB0aGUgY2hpbGRyZW4gYmVmb3JlIGFkZGluZyB0aGlzIHJvdXRlIHRvIHRoZSBhcnJheSBzbyB3ZSB0cmF2ZXJzZSB0aGVcbiAgICAvLyByb3V0ZSB0cmVlIGRlcHRoLWZpcnN0IGFuZCBjaGlsZCByb3V0ZXMgYXBwZWFyIGJlZm9yZSB0aGVpciBwYXJlbnRzIGluXG4gICAgLy8gdGhlIFwiZmxhdHRlbmVkXCIgdmVyc2lvbi5cbiAgICBpZiAocm91dGUuY2hpbGRyZW4gJiYgcm91dGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICAvLyBPdXIgdHlwZXMga25vdyBiZXR0ZXIsIGJ1dCBydW50aW1lIEpTIG1heSBub3QhXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgcm91dGUuaW5kZXggIT09IHRydWUsXG4gICAgICAgIGBJbmRleCByb3V0ZXMgbXVzdCBub3QgaGF2ZSBjaGlsZCByb3V0ZXMuIFBsZWFzZSByZW1vdmUgYCArXG4gICAgICAgICAgYGFsbCBjaGlsZCByb3V0ZXMgZnJvbSByb3V0ZSBwYXRoIFwiJHtwYXRofVwiLmBcbiAgICAgICk7XG5cbiAgICAgIGZsYXR0ZW5Sb3V0ZXMocm91dGUuY2hpbGRyZW4sIGJyYW5jaGVzLCByb3V0ZXNNZXRhLCBwYXRoKTtcbiAgICB9XG5cbiAgICAvLyBSb3V0ZXMgd2l0aG91dCBhIHBhdGggc2hvdWxkbid0IGV2ZXIgbWF0Y2ggYnkgdGhlbXNlbHZlcyB1bmxlc3MgdGhleSBhcmVcbiAgICAvLyBpbmRleCByb3V0ZXMsIHNvIGRvbid0IGFkZCB0aGVtIHRvIHRoZSBsaXN0IG9mIHBvc3NpYmxlIGJyYW5jaGVzLlxuICAgIGlmIChyb3V0ZS5wYXRoID09IG51bGwgJiYgIXJvdXRlLmluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYnJhbmNoZXMucHVzaCh7XG4gICAgICBwYXRoLFxuICAgICAgc2NvcmU6IGNvbXB1dGVTY29yZShwYXRoLCByb3V0ZS5pbmRleCksXG4gICAgICByb3V0ZXNNZXRhLFxuICAgIH0pO1xuICB9O1xuICByb3V0ZXMuZm9yRWFjaCgocm91dGUsIGluZGV4KSA9PiB7XG4gICAgLy8gY29hcnNlLWdyYWluIGNoZWNrIGZvciBvcHRpb25hbCBwYXJhbXNcbiAgICBpZiAocm91dGUucGF0aCA9PT0gXCJcIiB8fCAhcm91dGUucGF0aD8uaW5jbHVkZXMoXCI/XCIpKSB7XG4gICAgICBmbGF0dGVuUm91dGUocm91dGUsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZXhwbG9kZWQgb2YgZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocm91dGUucGF0aCkpIHtcbiAgICAgICAgZmxhdHRlblJvdXRlKHJvdXRlLCBpbmRleCwgZXhwbG9kZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGJyYW5jaGVzO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFsbCBjb21iaW5hdGlvbnMgb2Ygb3B0aW9uYWwgcGF0aCBzZWdtZW50cyBmb3IgYSBnaXZlbiBwYXRoLFxuICogZXhjbHVkaW5nIGNvbWJpbmF0aW9ucyB0aGF0IGFyZSBhbWJpZ3VvdXMgYW5kIG9mIGxvd2VyIHByaW9yaXR5LlxuICpcbiAqIEZvciBleGFtcGxlLCBgL29uZS86dHdvPy90aHJlZS86Zm91cj8vOmZpdmU/YCBleHBsb2RlcyB0bzpcbiAqIC0gYC9vbmUvdGhyZWVgXG4gKiAtIGAvb25lLzp0d28vdGhyZWVgXG4gKiAtIGAvb25lL3RocmVlLzpmb3VyYFxuICogLSBgL29uZS90aHJlZS86Zml2ZWBcbiAqIC0gYC9vbmUvOnR3by90aHJlZS86Zm91cmBcbiAqIC0gYC9vbmUvOnR3by90aHJlZS86Zml2ZWBcbiAqIC0gYC9vbmUvdGhyZWUvOmZvdXIvOmZpdmVgXG4gKiAtIGAvb25lLzp0d28vdGhyZWUvOmZvdXIvOmZpdmVgXG4gKi9cbmZ1bmN0aW9uIGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHBhdGg6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcblxuICBsZXQgW2ZpcnN0LCAuLi5yZXN0XSA9IHNlZ21lbnRzO1xuXG4gIC8vIE9wdGlvbmFsIHBhdGggc2VnbWVudHMgYXJlIGRlbm90ZWQgYnkgYSB0cmFpbGluZyBgP2BcbiAgbGV0IGlzT3B0aW9uYWwgPSBmaXJzdC5lbmRzV2l0aChcIj9cIik7XG4gIC8vIENvbXB1dGUgdGhlIGNvcnJlc3BvbmRpbmcgcmVxdWlyZWQgc2VnbWVudDogYGZvbz9gIC0+IGBmb29gXG4gIGxldCByZXF1aXJlZCA9IGZpcnN0LnJlcGxhY2UoL1xcPyQvLCBcIlwiKTtcblxuICBpZiAocmVzdC5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJbnRlcHJldCBlbXB0eSBzdHJpbmcgYXMgb21pdHRpbmcgYW4gb3B0aW9uYWwgc2VnbWVudFxuICAgIC8vIGBbXCJvbmVcIiwgXCJcIiwgXCJ0aHJlZVwiXWAgY29ycmVzcG9uZHMgdG8gb21pdHRpbmcgYDp0d29gIGZyb20gYC9vbmUvOnR3bz8vdGhyZWVgIC0+IGAvb25lL3RocmVlYFxuICAgIHJldHVybiBpc09wdGlvbmFsID8gW3JlcXVpcmVkLCBcIlwiXSA6IFtyZXF1aXJlZF07XG4gIH1cblxuICBsZXQgcmVzdEV4cGxvZGVkID0gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocmVzdC5qb2luKFwiL1wiKSk7XG5cbiAgbGV0IHJlc3VsdDogc3RyaW5nW10gPSBbXTtcblxuICAvLyBBbGwgY2hpbGQgcGF0aHMgd2l0aCB0aGUgcHJlZml4LiAgRG8gdGhpcyBmb3IgYWxsIGNoaWxkcmVuIGJlZm9yZSB0aGVcbiAgLy8gb3B0aW9uYWwgdmVyc2lvbiBmb3IgYWxsIGNoaWxkcmVuIHNvIHdlIGdldCBjb25zaXN0ZW50IG9yZGVyaW5nIHdoZXJlIHRoZVxuICAvLyBwYXJlbnQgb3B0aW9uYWwgYXNwZWN0IGlzIHByZWZlcnJlZCBhcyByZXF1aXJlZC4gIE90aGVyd2lzZSwgd2UgY2FuIGdldFxuICAvLyBjaGlsZCBzZWN0aW9ucyBpbnRlcnNwZXJzZWQgd2hlcmUgZGVlcGVyIG9wdGlvbmFsIHNlZ21lbnRzIGFyZSBoaWdoZXIgdGhhblxuICAvLyBwYXJlbnQgb3B0aW9uYWwgc2VnbWVudHMsIHdoZXJlIGZvciBleGFtcGxlLCAvOnR3byB3b3VsZCBleHBsb2RlcyBfZWFybGllcl9cbiAgLy8gdGhlbiAvOm9uZS4gIEJ5IGFsd2F5cyBpbmNsdWRpbmcgdGhlIHBhcmVudCBhcyByZXF1aXJlZCBfZm9yIGFsbCBjaGlsZHJlbl9cbiAgLy8gZmlyc3QsIHdlIGF2b2lkIHRoaXMgaXNzdWVcbiAgcmVzdWx0LnB1c2goXG4gICAgLi4ucmVzdEV4cGxvZGVkLm1hcCgoc3VicGF0aCkgPT5cbiAgICAgIHN1YnBhdGggPT09IFwiXCIgPyByZXF1aXJlZCA6IFtyZXF1aXJlZCwgc3VicGF0aF0uam9pbihcIi9cIilcbiAgICApXG4gICk7XG5cbiAgLy8gVGhlbiBpZiB0aGlzIGlzIGFuIG9wdGlvbmFsIHZhbHVlLCBhZGQgYWxsIGNoaWxkIHZlcnNpb25zIHdpdGhvdXRcbiAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICByZXN1bHQucHVzaCguLi5yZXN0RXhwbG9kZWQpO1xuICB9XG5cbiAgLy8gZm9yIGFic29sdXRlIHBhdGhzLCBlbnN1cmUgYC9gIGluc3RlYWQgb2YgZW1wdHkgc2VnbWVudFxuICByZXR1cm4gcmVzdWx0Lm1hcCgoZXhwbG9kZWQpID0+XG4gICAgcGF0aC5zdGFydHNXaXRoKFwiL1wiKSAmJiBleHBsb2RlZCA9PT0gXCJcIiA/IFwiL1wiIDogZXhwbG9kZWRcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXM6IFJvdXRlQnJhbmNoW10pOiB2b2lkIHtcbiAgYnJhbmNoZXMuc29ydCgoYSwgYikgPT5cbiAgICBhLnNjb3JlICE9PSBiLnNjb3JlXG4gICAgICA/IGIuc2NvcmUgLSBhLnNjb3JlIC8vIEhpZ2hlciBzY29yZSBmaXJzdFxuICAgICAgOiBjb21wYXJlSW5kZXhlcyhcbiAgICAgICAgICBhLnJvdXRlc01ldGEubWFwKChtZXRhKSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpLFxuICAgICAgICAgIGIucm91dGVzTWV0YS5tYXAoKG1ldGEpID0+IG1ldGEuY2hpbGRyZW5JbmRleClcbiAgICAgICAgKVxuICApO1xufVxuXG5jb25zdCBwYXJhbVJlID0gL146XFx3KyQvO1xuY29uc3QgZHluYW1pY1NlZ21lbnRWYWx1ZSA9IDM7XG5jb25zdCBpbmRleFJvdXRlVmFsdWUgPSAyO1xuY29uc3QgZW1wdHlTZWdtZW50VmFsdWUgPSAxO1xuY29uc3Qgc3RhdGljU2VnbWVudFZhbHVlID0gMTA7XG5jb25zdCBzcGxhdFBlbmFsdHkgPSAtMjtcbmNvbnN0IGlzU3BsYXQgPSAoczogc3RyaW5nKSA9PiBzID09PSBcIipcIjtcblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKHBhdGg6IHN0cmluZywgaW5kZXg6IGJvb2xlYW4gfCB1bmRlZmluZWQpOiBudW1iZXIge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgbGV0IGluaXRpYWxTY29yZSA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgaWYgKHNlZ21lbnRzLnNvbWUoaXNTcGxhdCkpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gc3BsYXRQZW5hbHR5O1xuICB9XG5cbiAgaWYgKGluZGV4KSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IGluZGV4Um91dGVWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50c1xuICAgIC5maWx0ZXIoKHMpID0+ICFpc1NwbGF0KHMpKVxuICAgIC5yZWR1Y2UoXG4gICAgICAoc2NvcmUsIHNlZ21lbnQpID0+XG4gICAgICAgIHNjb3JlICtcbiAgICAgICAgKHBhcmFtUmUudGVzdChzZWdtZW50KVxuICAgICAgICAgID8gZHluYW1pY1NlZ21lbnRWYWx1ZVxuICAgICAgICAgIDogc2VnbWVudCA9PT0gXCJcIlxuICAgICAgICAgID8gZW1wdHlTZWdtZW50VmFsdWVcbiAgICAgICAgICA6IHN0YXRpY1NlZ21lbnRWYWx1ZSksXG4gICAgICBpbml0aWFsU2NvcmVcbiAgICApO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlSW5kZXhlcyhhOiBudW1iZXJbXSwgYjogbnVtYmVyW10pOiBudW1iZXIge1xuICBsZXQgc2libGluZ3MgPVxuICAgIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLnNsaWNlKDAsIC0xKS5ldmVyeSgobiwgaSkgPT4gbiA9PT0gYltpXSk7XG5cbiAgcmV0dXJuIHNpYmxpbmdzXG4gICAgPyAvLyBJZiB0d28gcm91dGVzIGFyZSBzaWJsaW5ncywgd2Ugc2hvdWxkIHRyeSB0byBtYXRjaCB0aGUgZWFybGllciBzaWJsaW5nXG4gICAgICAvLyBmaXJzdC4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIGhhdmUgZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlciB0aGUgbWF0Y2hpbmdcbiAgICAgIC8vIGJlaGF2aW9yIGJ5IHNpbXBseSBwdXR0aW5nIHJvdXRlcyB3aXRoIGlkZW50aWNhbCBwYXRocyBpbiB0aGUgb3JkZXIgdGhleVxuICAgICAgLy8gd2FudCB0aGVtIHRyaWVkLlxuICAgICAgYVthLmxlbmd0aCAtIDFdIC0gYltiLmxlbmd0aCAtIDFdXG4gICAgOiAvLyBPdGhlcndpc2UsIGl0IGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2UgdG8gcmFuayBub24tc2libGluZ3MgYnkgaW5kZXgsXG4gICAgICAvLyBzbyB0aGV5IHNvcnQgZXF1YWxseS5cbiAgICAgIDA7XG59XG5cbmZ1bmN0aW9uIG1hdGNoUm91dGVCcmFuY2g8XG4gIFBhcmFtS2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLFxuICBSb3V0ZU9iamVjdFR5cGUgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0ID0gQWdub3N0aWNSb3V0ZU9iamVjdFxuPihcbiAgYnJhbmNoOiBSb3V0ZUJyYW5jaDxSb3V0ZU9iamVjdFR5cGU+LFxuICBwYXRobmFtZTogc3RyaW5nXG4pOiBBZ25vc3RpY1JvdXRlTWF0Y2g8UGFyYW1LZXksIFJvdXRlT2JqZWN0VHlwZT5bXSB8IG51bGwge1xuICBsZXQgeyByb3V0ZXNNZXRhIH0gPSBicmFuY2g7XG5cbiAgbGV0IG1hdGNoZWRQYXJhbXMgPSB7fTtcbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IFwiL1wiO1xuICBsZXQgbWF0Y2hlczogQWdub3N0aWNSb3V0ZU1hdGNoPFBhcmFtS2V5LCBSb3V0ZU9iamVjdFR5cGU+W10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZXNNZXRhLmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IG1ldGEgPSByb3V0ZXNNZXRhW2ldO1xuICAgIGxldCBlbmQgPSBpID09PSByb3V0ZXNNZXRhLmxlbmd0aCAtIDE7XG4gICAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID1cbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9PT0gXCIvXCJcbiAgICAgICAgPyBwYXRobmFtZVxuICAgICAgICA6IHBhdGhuYW1lLnNsaWNlKG1hdGNoZWRQYXRobmFtZS5sZW5ndGgpIHx8IFwiL1wiO1xuICAgIGxldCBtYXRjaCA9IG1hdGNoUGF0aChcbiAgICAgIHsgcGF0aDogbWV0YS5yZWxhdGl2ZVBhdGgsIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSwgZW5kIH0sXG4gICAgICByZW1haW5pbmdQYXRobmFtZVxuICAgICk7XG5cbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICAgIE9iamVjdC5hc3NpZ24obWF0Y2hlZFBhcmFtcywgbWF0Y2gucGFyYW1zKTtcblxuICAgIGxldCByb3V0ZSA9IG1ldGEucm91dGU7XG5cbiAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgLy8gVE9ETzogQ2FuIHRoaXMgYXMgYmUgYXZvaWRlZD9cbiAgICAgIHBhcmFtczogbWF0Y2hlZFBhcmFtcyBhcyBQYXJhbXM8UGFyYW1LZXk+LFxuICAgICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZV0pLFxuICAgICAgcGF0aG5hbWVCYXNlOiBub3JtYWxpemVQYXRobmFtZShcbiAgICAgICAgam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pXG4gICAgICApLFxuICAgICAgcm91dGUsXG4gICAgfSk7XG5cbiAgICBpZiAobWF0Y2gucGF0aG5hbWVCYXNlICE9PSBcIi9cIikge1xuICAgICAgbWF0Y2hlZFBhdGhuYW1lID0gam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBwYXRoIHdpdGggcGFyYW1zIGludGVycG9sYXRlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL2dlbmVyYXRlLXBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUGF0aDxQYXRoIGV4dGVuZHMgc3RyaW5nPihcbiAgb3JpZ2luYWxQYXRoOiBQYXRoLFxuICBwYXJhbXM6IHtcbiAgICBba2V5IGluIFBhdGhQYXJhbTxQYXRoPl06IHN0cmluZyB8IG51bGw7XG4gIH0gPSB7fSBhcyBhbnlcbik6IHN0cmluZyB7XG4gIGxldCBwYXRoID0gb3JpZ2luYWxQYXRoO1xuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikgJiYgcGF0aCAhPT0gXCIqXCIgJiYgIXBhdGguZW5kc1dpdGgoXCIvKlwiKSkge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBSb3V0ZSBwYXRoIFwiJHtwYXRofVwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIGAgK1xuICAgICAgICBgXCIke3BhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIil9XCIgYmVjYXVzZSB0aGUgXFxgKlxcYCBjaGFyYWN0ZXIgbXVzdCBgICtcbiAgICAgICAgYGFsd2F5cyBmb2xsb3cgYSBcXGAvXFxgIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgYCArXG4gICAgICAgIGBwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiLmBcbiAgICApO1xuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpIGFzIFBhdGg7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIHBhdGhcbiAgICAgIC5yZXBsYWNlKFxuICAgICAgICAvXjooXFx3KykoXFw/PykvZyxcbiAgICAgICAgKF8sIGtleTogUGF0aFBhcmFtPFBhdGg+LCBvcHRpb25hbDogc3RyaW5nIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgICAgbGV0IHBhcmFtID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgaWYgKG9wdGlvbmFsID09PSBcIj9cIikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtID09IG51bGwgPyBcIlwiIDogcGFyYW07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsIGBNaXNzaW5nIFwiOiR7a2V5fVwiIHBhcmFtYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgLnJlcGxhY2UoXG4gICAgICAgIC9cXC86KFxcdyspKFxcPz8pL2csXG4gICAgICAgIChfLCBrZXk6IFBhdGhQYXJhbTxQYXRoPiwgb3B0aW9uYWw6IHN0cmluZyB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICAgIGxldCBwYXJhbSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgIGlmIChvcHRpb25hbCA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbSA9PSBudWxsID8gXCJcIiA6IGAvJHtwYXJhbX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyYW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgaW52YXJpYW50KGZhbHNlLCBgTWlzc2luZyBcIjoke2tleX1cIiBwYXJhbWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYC8ke3BhcmFtfWA7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIC8vIFJlbW92ZSBhbnkgb3B0aW9uYWwgbWFya2VycyBmcm9tIG9wdGlvbmFsIHN0YXRpYyBzZWdtZW50c1xuICAgICAgLnJlcGxhY2UoL1xcPy9nLCBcIlwiKVxuICAgICAgLnJlcGxhY2UoLyhcXC8/KVxcKi8sIChfLCBwcmVmaXgsIF9fLCBzdHIpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhciA9IFwiKlwiIGFzIFBhdGhQYXJhbTxQYXRoPjtcblxuICAgICAgICBpZiAocGFyYW1zW3N0YXJdID09IG51bGwpIHtcbiAgICAgICAgICAvLyBJZiBubyBzcGxhdCB3YXMgcHJvdmlkZWQsIHRyaW0gdGhlIHRyYWlsaW5nIHNsYXNoIF91bmxlc3NfIGl0J3NcbiAgICAgICAgICAvLyB0aGUgZW50aXJlIHBhdGhcbiAgICAgICAgICByZXR1cm4gc3RyID09PSBcIi8qXCIgPyBcIi9cIiA6IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSB0aGUgc3BsYXRcbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0ke3BhcmFtc1tzdGFyXX1gO1xuICAgICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBBIFBhdGhQYXR0ZXJuIGlzIHVzZWQgdG8gbWF0Y2ggb24gc29tZSBwb3J0aW9uIG9mIGEgVVJMIHBhdGhuYW1lLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhdGhQYXR0ZXJuPFBhdGggZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgLyoqXG4gICAqIEEgc3RyaW5nIHRvIG1hdGNoIGFnYWluc3QgYSBVUkwgcGF0aG5hbWUuIE1heSBjb250YWluIGA6aWRgLXN0eWxlIHNlZ21lbnRzXG4gICAqIHRvIGluZGljYXRlIHBsYWNlaG9sZGVycyBmb3IgZHluYW1pYyBwYXJhbWV0ZXJzLiBNYXkgYWxzbyBlbmQgd2l0aCBgLypgIHRvXG4gICAqIGluZGljYXRlIG1hdGNoaW5nIHRoZSByZXN0IG9mIHRoZSBVUkwgcGF0aG5hbWUuXG4gICAqL1xuICBwYXRoOiBQYXRoO1xuICAvKipcbiAgICogU2hvdWxkIGJlIGB0cnVlYCBpZiB0aGUgc3RhdGljIHBvcnRpb25zIG9mIHRoZSBgcGF0aGAgc2hvdWxkIGJlIG1hdGNoZWQgaW5cbiAgICogdGhlIHNhbWUgY2FzZS5cbiAgICovXG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICAvKipcbiAgICogU2hvdWxkIGJlIGB0cnVlYCBpZiB0aGlzIHBhdHRlcm4gc2hvdWxkIG1hdGNoIHRoZSBlbnRpcmUgVVJMIHBhdGhuYW1lLlxuICAgKi9cbiAgZW5kPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBIFBhdGhNYXRjaCBjb250YWlucyBpbmZvIGFib3V0IGhvdyBhIFBhdGhQYXR0ZXJuIG1hdGNoZWQgb24gYSBVUkwgcGF0aG5hbWUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aE1hdGNoPFBhcmFtS2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZXMgYW5kIHZhbHVlcyBvZiBkeW5hbWljIHBhcmFtZXRlcnMgaW4gdGhlIFVSTC5cbiAgICovXG4gIHBhcmFtczogUGFyYW1zPFBhcmFtS2V5PjtcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZC5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQgYmVmb3JlIGNoaWxkIHJvdXRlcy5cbiAgICovXG4gIHBhdGhuYW1lQmFzZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHBhdHRlcm4gdGhhdCB3YXMgdXNlZCB0byBtYXRjaC5cbiAgICovXG4gIHBhdHRlcm46IFBhdGhQYXR0ZXJuO1xufVxuXG50eXBlIE11dGFibGU8VD4gPSB7XG4gIC1yZWFkb25seSBbUCBpbiBrZXlvZiBUXTogVFtQXTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgcGF0dGVybiBtYXRjaGluZyBvbiBhIFVSTCBwYXRobmFtZSBhbmQgcmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dFxuICogdGhlIG1hdGNoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvbWF0Y2gtcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hQYXRoPFxuICBQYXJhbUtleSBleHRlbmRzIFBhcmFtUGFyc2VLZXk8UGF0aD4sXG4gIFBhdGggZXh0ZW5kcyBzdHJpbmdcbj4oXG4gIHBhdHRlcm46IFBhdGhQYXR0ZXJuPFBhdGg+IHwgUGF0aCxcbiAgcGF0aG5hbWU6IHN0cmluZ1xuKTogUGF0aE1hdGNoPFBhcmFtS2V5PiB8IG51bGwge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIpIHtcbiAgICBwYXR0ZXJuID0geyBwYXRoOiBwYXR0ZXJuLCBjYXNlU2Vuc2l0aXZlOiBmYWxzZSwgZW5kOiB0cnVlIH07XG4gIH1cblxuICBsZXQgW21hdGNoZXIsIHBhcmFtTmFtZXNdID0gY29tcGlsZVBhdGgoXG4gICAgcGF0dGVybi5wYXRoLFxuICAgIHBhdHRlcm4uY2FzZVNlbnNpdGl2ZSxcbiAgICBwYXR0ZXJuLmVuZFxuICApO1xuXG4gIGxldCBtYXRjaCA9IHBhdGhuYW1lLm1hdGNoKG1hdGNoZXIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gbWF0Y2hbMF07XG4gIGxldCBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWUucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICBsZXQgY2FwdHVyZUdyb3VwcyA9IG1hdGNoLnNsaWNlKDEpO1xuICBsZXQgcGFyYW1zOiBQYXJhbXMgPSBwYXJhbU5hbWVzLnJlZHVjZTxNdXRhYmxlPFBhcmFtcz4+KFxuICAgIChtZW1vLCBwYXJhbU5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGNvbXB1dGUgdGhlIHBhdGhuYW1lQmFzZSBoZXJlIHVzaW5nIHRoZSByYXcgc3BsYXQgdmFsdWVcbiAgICAgIC8vIGluc3RlYWQgb2YgdXNpbmcgcGFyYW1zW1wiKlwiXSBsYXRlciBiZWNhdXNlIGl0IHdpbGwgYmUgZGVjb2RlZCB0aGVuXG4gICAgICBpZiAocGFyYW1OYW1lID09PSBcIipcIikge1xuICAgICAgICBsZXQgc3BsYXRWYWx1ZSA9IGNhcHR1cmVHcm91cHNbaW5kZXhdIHx8IFwiXCI7XG4gICAgICAgIHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZVxuICAgICAgICAgIC5zbGljZSgwLCBtYXRjaGVkUGF0aG5hbWUubGVuZ3RoIC0gc3BsYXRWYWx1ZS5sZW5ndGgpXG4gICAgICAgICAgLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgICAgIH1cblxuICAgICAgbWVtb1twYXJhbU5hbWVdID0gc2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICBjYXB0dXJlR3JvdXBzW2luZGV4XSB8fCBcIlwiLFxuICAgICAgICBwYXJhbU5hbWVcbiAgICAgICk7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LFxuICAgIHt9XG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcGF0aG5hbWU6IG1hdGNoZWRQYXRobmFtZSxcbiAgICBwYXRobmFtZUJhc2UsXG4gICAgcGF0dGVybixcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZVBhdGgoXG4gIHBhdGg6IHN0cmluZyxcbiAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLFxuICBlbmQgPSB0cnVlXG4pOiBbUmVnRXhwLCBzdHJpbmdbXV0ge1xuICB3YXJuaW5nKFxuICAgIHBhdGggPT09IFwiKlwiIHx8ICFwYXRoLmVuZHNXaXRoKFwiKlwiKSB8fCBwYXRoLmVuZHNXaXRoKFwiLypcIiksXG4gICAgYFJvdXRlIHBhdGggXCIke3BhdGh9XCIgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIGl0IHdlcmUgYCArXG4gICAgICBgXCIke3BhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIil9XCIgYmVjYXVzZSB0aGUgXFxgKlxcYCBjaGFyYWN0ZXIgbXVzdCBgICtcbiAgICAgIGBhbHdheXMgZm9sbG93IGEgXFxgL1xcYCBpbiB0aGUgcGF0dGVybi4gVG8gZ2V0IHJpZCBvZiB0aGlzIHdhcm5pbmcsIGAgK1xuICAgICAgYHBsZWFzZSBjaGFuZ2UgdGhlIHJvdXRlIHBhdGggdG8gXCIke3BhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIil9XCIuYFxuICApO1xuXG4gIGxldCBwYXJhbU5hbWVzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgcmVnZXhwU291cmNlID1cbiAgICBcIl5cIiArXG4gICAgcGF0aFxuICAgICAgLnJlcGxhY2UoL1xcLypcXCo/JC8sIFwiXCIpIC8vIElnbm9yZSB0cmFpbGluZyAvIGFuZCAvKiwgd2UnbGwgaGFuZGxlIGl0IGJlbG93XG4gICAgICAucmVwbGFjZSgvXlxcLyovLCBcIi9cIikgLy8gTWFrZSBzdXJlIGl0IGhhcyBhIGxlYWRpbmcgL1xuICAgICAgLnJlcGxhY2UoL1tcXFxcLiorXiQ/e318KClbXFxdXS9nLCBcIlxcXFwkJlwiKSAvLyBFc2NhcGUgc3BlY2lhbCByZWdleCBjaGFyc1xuICAgICAgLnJlcGxhY2UoL1xcLzooXFx3KykvZywgKF86IHN0cmluZywgcGFyYW1OYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgcGFyYW1OYW1lcy5wdXNoKHBhcmFtTmFtZSk7XG4gICAgICAgIHJldHVybiBcIi8oW15cXFxcL10rKVwiO1xuICAgICAgfSk7XG5cbiAgaWYgKHBhdGguZW5kc1dpdGgoXCIqXCIpKSB7XG4gICAgcGFyYW1OYW1lcy5wdXNoKFwiKlwiKTtcbiAgICByZWdleHBTb3VyY2UgKz1cbiAgICAgIHBhdGggPT09IFwiKlwiIHx8IHBhdGggPT09IFwiLypcIlxuICAgICAgICA/IFwiKC4qKSRcIiAvLyBBbHJlYWR5IG1hdGNoZWQgdGhlIGluaXRpYWwgLywganVzdCBtYXRjaCB0aGUgcmVzdFxuICAgICAgICA6IFwiKD86XFxcXC8oLispfFxcXFwvKikkXCI7IC8vIERvbid0IGluY2x1ZGUgdGhlIC8gaW4gcGFyYW1zW1wiKlwiXVxuICB9IGVsc2UgaWYgKGVuZCkge1xuICAgIC8vIFdoZW4gbWF0Y2hpbmcgdG8gdGhlIGVuZCwgaWdub3JlIHRyYWlsaW5nIHNsYXNoZXNcbiAgICByZWdleHBTb3VyY2UgKz0gXCJcXFxcLyokXCI7XG4gIH0gZWxzZSBpZiAocGF0aCAhPT0gXCJcIiAmJiBwYXRoICE9PSBcIi9cIikge1xuICAgIC8vIElmIG91ciBwYXRoIGlzIG5vbi1lbXB0eSBhbmQgY29udGFpbnMgYW55dGhpbmcgYmV5b25kIGFuIGluaXRpYWwgc2xhc2gsXG4gICAgLy8gdGhlbiB3ZSBoYXZlIF9zb21lXyBmb3JtIG9mIHBhdGggaW4gb3VyIHJlZ2V4IHNvIHdlIHNob3VsZCBleHBlY3QgdG9cbiAgICAvLyBtYXRjaCBvbmx5IGlmIHdlIGZpbmQgdGhlIGVuZCBvZiB0aGlzIHBhdGggc2VnbWVudC4gIExvb2sgZm9yIGFuIG9wdGlvbmFsXG4gICAgLy8gbm9uLWNhcHR1cmVkIHRyYWlsaW5nIHNsYXNoICh0byBtYXRjaCBhIHBvcnRpb24gb2YgdGhlIFVSTCkgb3IgdGhlIGVuZFxuICAgIC8vIG9mIHRoZSBwYXRoIChpZiB3ZSd2ZSBtYXRjaGVkIHRvIHRoZSBlbmQpLiAgV2UgdXNlZCB0byBkbyB0aGlzIHdpdGggYVxuICAgIC8vIHdvcmQgYm91bmRhcnkgYnV0IHRoYXQgZ2l2ZXMgZmFsc2UgcG9zaXRpdmVzIG9uIHJvdXRlcyBsaWtlXG4gICAgLy8gL3VzZXItcHJlZmVyZW5jZXMgc2luY2UgYC1gIGNvdW50cyBhcyBhIHdvcmQgYm91bmRhcnkuXG4gICAgcmVnZXhwU291cmNlICs9IFwiKD86KD89XFxcXC98JCkpXCI7XG4gIH0gZWxzZSB7XG4gICAgLy8gTm90aGluZyB0byBtYXRjaCBmb3IgXCJcIiBvciBcIi9cIlxuICB9XG5cbiAgbGV0IG1hdGNoZXIgPSBuZXcgUmVnRXhwKHJlZ2V4cFNvdXJjZSwgY2FzZVNlbnNpdGl2ZSA/IHVuZGVmaW5lZCA6IFwiaVwiKTtcblxuICByZXR1cm4gW21hdGNoZXIsIHBhcmFtTmFtZXNdO1xufVxuXG5mdW5jdGlvbiBzYWZlbHlEZWNvZGVVUkkodmFsdWU6IHN0cmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUkkodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBUaGUgVVJMIHBhdGggXCIke3ZhbHVlfVwiIGNvdWxkIG5vdCBiZSBkZWNvZGVkIGJlY2F1c2UgaXQgaXMgaXMgYSBgICtcbiAgICAgICAgYG1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseSBkdWUgdG8gYSBiYWQgcGVyY2VudCBgICtcbiAgICAgICAgYGVuY29kaW5nICgke2Vycm9yfSkuYFxuICAgICk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlOiBzdHJpbmcsIHBhcmFtTmFtZTogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgYFRoZSB2YWx1ZSBmb3IgdGhlIFVSTCBwYXJhbSBcIiR7cGFyYW1OYW1lfVwiIHdpbGwgbm90IGJlIGRlY29kZWQgYmVjYXVzZWAgK1xuICAgICAgICBgIHRoZSBzdHJpbmcgXCIke3ZhbHVlfVwiIGlzIGEgbWFsZm9ybWVkIFVSTCBzZWdtZW50LiBUaGlzIGlzIHByb2JhYmx5YCArXG4gICAgICAgIGAgZHVlIHRvIGEgYmFkIHBlcmNlbnQgZW5jb2RpbmcgKCR7ZXJyb3J9KS5gXG4gICAgKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcEJhc2VuYW1lKFxuICBwYXRobmFtZTogc3RyaW5nLFxuICBiYXNlbmFtZTogc3RyaW5nXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKGJhc2VuYW1lID09PSBcIi9cIikgcmV0dXJuIHBhdGhuYW1lO1xuXG4gIGlmICghcGF0aG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGJhc2VuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBXZSB3YW50IHRvIGxlYXZlIHRyYWlsaW5nIHNsYXNoIGJlaGF2aW9yIGluIHRoZSB1c2VyJ3MgY29udHJvbCwgc28gaWYgdGhleVxuICAvLyBzcGVjaWZ5IGEgYmFzZW5hbWUgd2l0aCBhIHRyYWlsaW5nIHNsYXNoLCB3ZSBzaG91bGQgc3VwcG9ydCBpdFxuICBsZXQgc3RhcnRJbmRleCA9IGJhc2VuYW1lLmVuZHNXaXRoKFwiL1wiKVxuICAgID8gYmFzZW5hbWUubGVuZ3RoIC0gMVxuICAgIDogYmFzZW5hbWUubGVuZ3RoO1xuICBsZXQgbmV4dENoYXIgPSBwYXRobmFtZS5jaGFyQXQoc3RhcnRJbmRleCk7XG4gIGlmIChuZXh0Q2hhciAmJiBuZXh0Q2hhciAhPT0gXCIvXCIpIHtcbiAgICAvLyBwYXRobmFtZSBkb2VzIG5vdCBzdGFydCB3aXRoIGJhc2VuYW1lL1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lLnNsaWNlKHN0YXJ0SW5kZXgpIHx8IFwiL1wiO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3YXJuaW5nKGNvbmQ6IGFueSwgbWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gIGlmICghY29uZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gV2VsY29tZSB0byBkZWJ1Z2dpbmcgQHJlbWl4LXJ1bi9yb3V0ZXIhXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB5b3UgY2FuIG1vcmUgZWFzaWx5XG4gICAgICAvLyBmaW5kIHRoZSBzb3VyY2UgZm9yIGEgd2FybmluZyB0aGF0IGFwcGVhcnMgaW4gdGhlIGNvbnNvbGUgYnlcbiAgICAgIC8vIGVuYWJsaW5nIFwicGF1c2Ugb24gZXhjZXB0aW9uc1wiIGluIHlvdXIgSmF2YVNjcmlwdCBkZWJ1Z2dlci5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmVzb2x2ZWQgcGF0aCBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGdpdmVuIHBhdGhuYW1lLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvcmVzb2x2ZS1wYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUGF0aCh0bzogVG8sIGZyb21QYXRobmFtZSA9IFwiL1wiKTogUGF0aCB7XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IHRvUGF0aG5hbWUsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIixcbiAgfSA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bztcblxuICBsZXQgcGF0aG5hbWUgPSB0b1BhdGhuYW1lXG4gICAgPyB0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpXG4gICAgICA/IHRvUGF0aG5hbWVcbiAgICAgIDogcmVzb2x2ZVBhdGhuYW1lKHRvUGF0aG5hbWUsIGZyb21QYXRobmFtZSlcbiAgICA6IGZyb21QYXRobmFtZTtcblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lLFxuICAgIHNlYXJjaDogbm9ybWFsaXplU2VhcmNoKHNlYXJjaCksXG4gICAgaGFzaDogbm9ybWFsaXplSGFzaChoYXNoKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVBhdGhuYW1lKHJlbGF0aXZlUGF0aDogc3RyaW5nLCBmcm9tUGF0aG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCBzZWdtZW50cyA9IGZyb21QYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgbGV0IHJlbGF0aXZlU2VnbWVudHMgPSByZWxhdGl2ZVBhdGguc3BsaXQoXCIvXCIpO1xuXG4gIHJlbGF0aXZlU2VnbWVudHMuZm9yRWFjaCgoc2VnbWVudCkgPT4ge1xuICAgIGlmIChzZWdtZW50ID09PSBcIi4uXCIpIHtcbiAgICAgIC8vIEtlZXAgdGhlIHJvb3QgXCJcIiBzZWdtZW50IHNvIHRoZSBwYXRobmFtZSBzdGFydHMgYXQgL1xuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHNlZ21lbnRzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gXCIuXCIpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc2VnbWVudHMubGVuZ3RoID4gMSA/IHNlZ21lbnRzLmpvaW4oXCIvXCIpIDogXCIvXCI7XG59XG5cbmZ1bmN0aW9uIGdldEludmFsaWRQYXRoRXJyb3IoXG4gIGNoYXI6IHN0cmluZyxcbiAgZmllbGQ6IHN0cmluZyxcbiAgZGVzdDogc3RyaW5nLFxuICBwYXRoOiBQYXJ0aWFsPFBhdGg+XG4pIHtcbiAgcmV0dXJuIChcbiAgICBgQ2Fubm90IGluY2x1ZGUgYSAnJHtjaGFyfScgY2hhcmFjdGVyIGluIGEgbWFudWFsbHkgc3BlY2lmaWVkIGAgK1xuICAgIGBcXGB0by4ke2ZpZWxkfVxcYCBmaWVsZCBbJHtKU09OLnN0cmluZ2lmeShcbiAgICAgIHBhdGhcbiAgICApfV0uICBQbGVhc2Ugc2VwYXJhdGUgaXQgb3V0IHRvIHRoZSBgICtcbiAgICBgXFxgdG8uJHtkZXN0fVxcYCBmaWVsZC4gQWx0ZXJuYXRpdmVseSB5b3UgbWF5IHByb3ZpZGUgdGhlIGZ1bGwgcGF0aCBhcyBgICtcbiAgICBgYSBzdHJpbmcgaW4gPExpbmsgdG89XCIuLi5cIj4gYW5kIHRoZSByb3V0ZXIgd2lsbCBwYXJzZSBpdCBmb3IgeW91LmBcbiAgKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIFdoZW4gcHJvY2Vzc2luZyByZWxhdGl2ZSBuYXZpZ2F0aW9uIHdlIHdhbnQgdG8gaWdub3JlIGFuY2VzdG9yIHJvdXRlcyB0aGF0XG4gKiBkbyBub3QgY29udHJpYnV0ZSB0byB0aGUgcGF0aCwgc3VjaCB0aGF0IGluZGV4L3BhdGhsZXNzIGxheW91dCByb3V0ZXMgZG9uJ3RcbiAqIGludGVyZmVyZS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgd2hlbiBtb3ZpbmcgYSByb3V0ZSBlbGVtZW50IGludG8gYW4gaW5kZXggcm91dGUgYW5kL29yIGFcbiAqIHBhdGhsZXNzIGxheW91dCByb3V0ZSwgcmVsYXRpdmUgbGluayBiZWhhdmlvciBjb250YWluZWQgd2l0aGluIHNob3VsZCBzdGF5XG4gKiB0aGUgc2FtZS4gIEJvdGggb2YgdGhlIGZvbGxvd2luZyBleGFtcGxlcyBzaG91bGQgbGluayBiYWNrIHRvIHRoZSByb290OlxuICpcbiAqICAgPFJvdXRlIHBhdGg9XCIvXCI+XG4gKiAgICAgPFJvdXRlIHBhdGg9XCJhY2NvdW50c1wiIGVsZW1lbnQ9ezxMaW5rIHRvPVwiLi5cIn0+XG4gKiAgIDwvUm91dGU+XG4gKlxuICogICA8Um91dGUgcGF0aD1cIi9cIj5cbiAqICAgICA8Um91dGUgcGF0aD1cImFjY291bnRzXCI+XG4gKiAgICAgICA8Um91dGUgZWxlbWVudD17PEFjY291bnRzTGF5b3V0IC8+fT4gICAgICAgLy8gPC0tIERvZXMgbm90IGNvbnRyaWJ1dGVcbiAqICAgICAgICAgPFJvdXRlIGluZGV4IGVsZW1lbnQ9ezxMaW5rIHRvPVwiLi5cIn0gLz4gIC8vIDwtLSBEb2VzIG5vdCBjb250cmlidXRlXG4gKiAgICAgICA8L1JvdXRlXG4gKiAgICAgPC9Sb3V0ZT5cbiAqICAgPC9Sb3V0ZT5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzPFxuICBUIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU1hdGNoID0gQWdub3N0aWNSb3V0ZU1hdGNoXG4+KG1hdGNoZXM6IFRbXSkge1xuICByZXR1cm4gbWF0Y2hlcy5maWx0ZXIoXG4gICAgKG1hdGNoLCBpbmRleCkgPT5cbiAgICAgIGluZGV4ID09PSAwIHx8IChtYXRjaC5yb3V0ZS5wYXRoICYmIG1hdGNoLnJvdXRlLnBhdGgubGVuZ3RoID4gMClcbiAgKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVRvKFxuICB0b0FyZzogVG8sXG4gIHJvdXRlUGF0aG5hbWVzOiBzdHJpbmdbXSxcbiAgbG9jYXRpb25QYXRobmFtZTogc3RyaW5nLFxuICBpc1BhdGhSZWxhdGl2ZSA9IGZhbHNlXG4pOiBQYXRoIHtcbiAgbGV0IHRvOiBQYXJ0aWFsPFBhdGg+O1xuICBpZiAodHlwZW9mIHRvQXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgdG8gPSBwYXJzZVBhdGgodG9BcmcpO1xuICB9IGVsc2Uge1xuICAgIHRvID0geyAuLi50b0FyZyB9O1xuXG4gICAgaW52YXJpYW50KFxuICAgICAgIXRvLnBhdGhuYW1lIHx8ICF0by5wYXRobmFtZS5pbmNsdWRlcyhcIj9cIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiP1wiLCBcInBhdGhuYW1lXCIsIFwic2VhcmNoXCIsIHRvKVxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgIXRvLnBhdGhuYW1lIHx8ICF0by5wYXRobmFtZS5pbmNsdWRlcyhcIiNcIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInBhdGhuYW1lXCIsIFwiaGFzaFwiLCB0bylcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICF0by5zZWFyY2ggfHwgIXRvLnNlYXJjaC5pbmNsdWRlcyhcIiNcIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInNlYXJjaFwiLCBcImhhc2hcIiwgdG8pXG4gICAgKTtcbiAgfVxuXG4gIGxldCBpc0VtcHR5UGF0aCA9IHRvQXJnID09PSBcIlwiIHx8IHRvLnBhdGhuYW1lID09PSBcIlwiO1xuICBsZXQgdG9QYXRobmFtZSA9IGlzRW1wdHlQYXRoID8gXCIvXCIgOiB0by5wYXRobmFtZTtcblxuICBsZXQgZnJvbTogc3RyaW5nO1xuXG4gIC8vIFJvdXRpbmcgaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcGF0aG5hbWUgaWYgZXhwbGljaXRseSByZXF1ZXN0ZWQuXG4gIC8vXG4gIC8vIElmIGEgcGF0aG5hbWUgaXMgZXhwbGljaXRseSBwcm92aWRlZCBpbiBgdG9gLCBpdCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlXG4gIC8vIHJvdXRlIGNvbnRleHQuIFRoaXMgaXMgZXhwbGFpbmVkIGluIGBOb3RlIG9uIGA8TGluayB0bz5gIHZhbHVlc2AgaW4gb3VyXG4gIC8vIG1pZ3JhdGlvbiBndWlkZSBmcm9tIHY1IGFzIGEgbWVhbnMgb2YgZGlzYW1iaWd1YXRpb24gYmV0d2VlbiBgdG9gIHZhbHVlc1xuICAvLyB0aGF0IGJlZ2luIHdpdGggYC9gIGFuZCB0aG9zZSB0aGF0IGRvIG5vdC4gSG93ZXZlciwgdGhpcyBpcyBwcm9ibGVtYXRpYyBmb3JcbiAgLy8gYHRvYCB2YWx1ZXMgdGhhdCBkbyBub3QgcHJvdmlkZSBhIHBhdGhuYW1lLiBgdG9gIGNhbiBzaW1wbHkgYmUgYSBzZWFyY2ggb3JcbiAgLy8gaGFzaCBzdHJpbmcsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIGFzc3VtZSB0aGF0IHRoZSBuYXZpZ2F0aW9uIGlzIHJlbGF0aXZlXG4gIC8vIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uJ3MgcGF0aG5hbWUgYW5kICpub3QqIHRoZSByb3V0ZSBwYXRobmFtZS5cbiAgaWYgKGlzUGF0aFJlbGF0aXZlIHx8IHRvUGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIGZyb20gPSBsb2NhdGlvblBhdGhuYW1lO1xuICB9IGVsc2Uge1xuICAgIGxldCByb3V0ZVBhdGhuYW1lSW5kZXggPSByb3V0ZVBhdGhuYW1lcy5sZW5ndGggLSAxO1xuXG4gICAgaWYgKHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi4uXCIpKSB7XG4gICAgICBsZXQgdG9TZWdtZW50cyA9IHRvUGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuXG4gICAgICAvLyBFYWNoIGxlYWRpbmcgLi4gc2VnbWVudCBtZWFucyBcImdvIHVwIG9uZSByb3V0ZVwiIGluc3RlYWQgb2YgXCJnbyB1cCBvbmVcbiAgICAgIC8vIFVSTCBzZWdtZW50XCIuICBUaGlzIGlzIGEga2V5IGRpZmZlcmVuY2UgZnJvbSBob3cgPGEgaHJlZj4gd29ya3MgYW5kIGFcbiAgICAgIC8vIG1ham9yIHJlYXNvbiB3ZSBjYWxsIHRoaXMgYSBcInRvXCIgdmFsdWUgaW5zdGVhZCBvZiBhIFwiaHJlZlwiLlxuICAgICAgd2hpbGUgKHRvU2VnbWVudHNbMF0gPT09IFwiLi5cIikge1xuICAgICAgICB0b1NlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgIHJvdXRlUGF0aG5hbWVJbmRleCAtPSAxO1xuICAgICAgfVxuXG4gICAgICB0by5wYXRobmFtZSA9IHRvU2VnbWVudHMuam9pbihcIi9cIik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgYXJlIG1vcmUgXCIuLlwiIHNlZ21lbnRzIHRoYW4gcGFyZW50IHJvdXRlcywgcmVzb2x2ZSByZWxhdGl2ZSB0b1xuICAgIC8vIHRoZSByb290IC8gVVJMLlxuICAgIGZyb20gPSByb3V0ZVBhdGhuYW1lSW5kZXggPj0gMCA/IHJvdXRlUGF0aG5hbWVzW3JvdXRlUGF0aG5hbWVJbmRleF0gOiBcIi9cIjtcbiAgfVxuXG4gIGxldCBwYXRoID0gcmVzb2x2ZVBhdGgodG8sIGZyb20pO1xuXG4gIC8vIEVuc3VyZSB0aGUgcGF0aG5hbWUgaGFzIGEgdHJhaWxpbmcgc2xhc2ggaWYgdGhlIG9yaWdpbmFsIFwidG9cIiBoYWQgb25lXG4gIGxldCBoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2ggPVxuICAgIHRvUGF0aG5hbWUgJiYgdG9QYXRobmFtZSAhPT0gXCIvXCIgJiYgdG9QYXRobmFtZS5lbmRzV2l0aChcIi9cIik7XG4gIC8vIE9yIGlmIHRoaXMgd2FzIGEgbGluayB0byB0aGUgY3VycmVudCBwYXRoIHdoaWNoIGhhcyBhIHRyYWlsaW5nIHNsYXNoXG4gIGxldCBoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCA9XG4gICAgKGlzRW1wdHlQYXRoIHx8IHRvUGF0aG5hbWUgPT09IFwiLlwiKSAmJiBsb2NhdGlvblBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgaWYgKFxuICAgICFwYXRoLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSAmJlxuICAgIChoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2ggfHwgaGFzQ3VycmVudFRyYWlsaW5nU2xhc2gpXG4gICkge1xuICAgIHBhdGgucGF0aG5hbWUgKz0gXCIvXCI7XG4gIH1cblxuICByZXR1cm4gcGF0aDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9QYXRobmFtZSh0bzogVG8pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAvLyBFbXB0eSBzdHJpbmdzIHNob3VsZCBiZSB0cmVhdGVkIHRoZSBzYW1lIGFzIC8gcGF0aHNcbiAgcmV0dXJuIHRvID09PSBcIlwiIHx8ICh0byBhcyBQYXRoKS5wYXRobmFtZSA9PT0gXCJcIlxuICAgID8gXCIvXCJcbiAgICA6IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIlxuICAgID8gcGFyc2VQYXRoKHRvKS5wYXRobmFtZVxuICAgIDogdG8ucGF0aG5hbWU7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGpvaW5QYXRocyA9IChwYXRoczogc3RyaW5nW10pOiBzdHJpbmcgPT5cbiAgcGF0aHMuam9pbihcIi9cIikucmVwbGFjZSgvXFwvXFwvKy9nLCBcIi9cIik7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVBhdGhuYW1lID0gKHBhdGhuYW1lOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgcGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplU2VhcmNoID0gKHNlYXJjaDogc3RyaW5nKTogc3RyaW5nID0+XG4gICFzZWFyY2ggfHwgc2VhcmNoID09PSBcIj9cIlxuICAgID8gXCJcIlxuICAgIDogc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpXG4gICAgPyBzZWFyY2hcbiAgICA6IFwiP1wiICsgc2VhcmNoO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVIYXNoID0gKGhhc2g6IHN0cmluZyk6IHN0cmluZyA9PlxuICAhaGFzaCB8fCBoYXNoID09PSBcIiNcIiA/IFwiXCIgOiBoYXNoLnN0YXJ0c1dpdGgoXCIjXCIpID8gaGFzaCA6IFwiI1wiICsgaGFzaDtcblxuZXhwb3J0IHR5cGUgSnNvbkZ1bmN0aW9uID0gPERhdGE+KFxuICBkYXRhOiBEYXRhLFxuICBpbml0PzogbnVtYmVyIHwgUmVzcG9uc2VJbml0XG4pID0+IFJlc3BvbnNlO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3IgY3JlYXRpbmcgYGFwcGxpY2F0aW9uL2pzb25gIHJlc3BvbnNlcy4gQ29udmVydHMgYGRhdGFgXG4gKiB0byBKU09OIGFuZCBzZXRzIHRoZSBgQ29udGVudC1UeXBlYCBoZWFkZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBqc29uOiBKc29uRnVuY3Rpb24gPSAoZGF0YSwgaW5pdCA9IHt9KSA9PiB7XG4gIGxldCByZXNwb25zZUluaXQgPSB0eXBlb2YgaW5pdCA9PT0gXCJudW1iZXJcIiA/IHsgc3RhdHVzOiBpbml0IH0gOiBpbml0O1xuXG4gIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2VJbml0LmhlYWRlcnMpO1xuICBpZiAoIWhlYWRlcnMuaGFzKFwiQ29udGVudC1UeXBlXCIpKSB7XG4gICAgaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShkYXRhKSwge1xuICAgIC4uLnJlc3BvbnNlSW5pdCxcbiAgICBoZWFkZXJzLFxuICB9KTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhY2tlZFByb21pc2UgZXh0ZW5kcyBQcm9taXNlPGFueT4ge1xuICBfdHJhY2tlZD86IGJvb2xlYW47XG4gIF9kYXRhPzogYW55O1xuICBfZXJyb3I/OiBhbnk7XG59XG5cbmV4cG9ydCBjbGFzcyBBYm9ydGVkRGVmZXJyZWRFcnJvciBleHRlbmRzIEVycm9yIHt9XG5cbmV4cG9ydCBjbGFzcyBEZWZlcnJlZERhdGEge1xuICBwcml2YXRlIHBlbmRpbmdLZXlzU2V0OiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBwcml2YXRlIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcjtcbiAgcHJpdmF0ZSBhYm9ydFByb21pc2U6IFByb21pc2U8dm9pZD47XG4gIHByaXZhdGUgdW5saXN0ZW5BYm9ydFNpZ25hbDogKCkgPT4gdm9pZDtcbiAgcHJpdmF0ZSBzdWJzY3JpYmVyczogU2V0PChhYm9ydGVkOiBib29sZWFuLCBzZXR0bGVkS2V5Pzogc3RyaW5nKSA9PiB2b2lkPiA9XG4gICAgbmV3IFNldCgpO1xuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgaW5pdD86IFJlc3BvbnNlSW5pdDtcbiAgZGVmZXJyZWRLZXlzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LCByZXNwb25zZUluaXQ/OiBSZXNwb25zZUluaXQpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBkYXRhICYmIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGRhdGEpLFxuICAgICAgXCJkZWZlcigpIG9ubHkgYWNjZXB0cyBwbGFpbiBvYmplY3RzXCJcbiAgICApO1xuXG4gICAgLy8gU2V0IHVwIGFuIEFib3J0Q29udHJvbGxlciArIFByb21pc2Ugd2UgY2FuIHJhY2UgYWdhaW5zdCB0byBleGl0IGVhcmx5XG4gICAgLy8gY2FuY2VsbGF0aW9uXG4gICAgbGV0IHJlamVjdDogKGU6IEFib3J0ZWREZWZlcnJlZEVycm9yKSA9PiB2b2lkO1xuICAgIHRoaXMuYWJvcnRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHIpID0+IChyZWplY3QgPSByKSk7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBvbkFib3J0ID0gKCkgPT5cbiAgICAgIHJlamVjdChuZXcgQWJvcnRlZERlZmVycmVkRXJyb3IoXCJEZWZlcnJlZCBkYXRhIGFib3J0ZWRcIikpO1xuICAgIHRoaXMudW5saXN0ZW5BYm9ydFNpZ25hbCA9ICgpID0+XG4gICAgICB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcblxuICAgIHRoaXMuZGF0YSA9IE9iamVjdC5lbnRyaWVzKGRhdGEpLnJlZHVjZShcbiAgICAgIChhY2MsIFtrZXksIHZhbHVlXSkgPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihhY2MsIHtcbiAgICAgICAgICBba2V5XTogdGhpcy50cmFja1Byb21pc2Uoa2V5LCB2YWx1ZSksXG4gICAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuXG4gICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgLy8gQWxsIGluY29taW5nIHZhbHVlcyB3ZXJlIHJlc29sdmVkXG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXQgPSByZXNwb25zZUluaXQ7XG4gIH1cblxuICBwcml2YXRlIHRyYWNrUHJvbWlzZShcbiAgICBrZXk6IHN0cmluZyxcbiAgICB2YWx1ZTogUHJvbWlzZTx1bmtub3duPiB8IHVua25vd25cbiAgKTogVHJhY2tlZFByb21pc2UgfCB1bmtub3duIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5kZWZlcnJlZEtleXMucHVzaChrZXkpO1xuICAgIHRoaXMucGVuZGluZ0tleXNTZXQuYWRkKGtleSk7XG5cbiAgICAvLyBXZSBzdG9yZSBhIGxpdHRsZSB3cmFwcGVyIHByb21pc2UgdGhhdCB3aWxsIGJlIGV4dGVuZGVkIHdpdGhcbiAgICAvLyBfZGF0YS9fZXJyb3IgcHJvcHMgdXBvbiByZXNvbHZlL3JlamVjdFxuICAgIGxldCBwcm9taXNlOiBUcmFja2VkUHJvbWlzZSA9IFByb21pc2UucmFjZShbdmFsdWUsIHRoaXMuYWJvcnRQcm9taXNlXSkudGhlbihcbiAgICAgIChkYXRhKSA9PiB0aGlzLm9uU2V0dGxlKHByb21pc2UsIGtleSwgbnVsbCwgZGF0YSBhcyB1bmtub3duKSxcbiAgICAgIChlcnJvcikgPT4gdGhpcy5vblNldHRsZShwcm9taXNlLCBrZXksIGVycm9yIGFzIHVua25vd24pXG4gICAgKTtcblxuICAgIC8vIFJlZ2lzdGVyIHJlamVjdGlvbiBsaXN0ZW5lcnMgdG8gYXZvaWQgdW5jYXVnaHQgcHJvbWlzZSByZWplY3Rpb25zIG9uXG4gICAgLy8gZXJyb3JzIG9yIGFib3J0ZWQgZGVmZXJyZWQgdmFsdWVzXG4gICAgcHJvbWlzZS5jYXRjaCgoKSA9PiB7fSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7IGdldDogKCkgPT4gdHJ1ZSB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHByaXZhdGUgb25TZXR0bGUoXG4gICAgcHJvbWlzZTogVHJhY2tlZFByb21pc2UsXG4gICAga2V5OiBzdHJpbmcsXG4gICAgZXJyb3I6IHVua25vd24sXG4gICAgZGF0YT86IHVua25vd25cbiAgKTogdW5rbm93biB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5jb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkICYmXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEFib3J0ZWREZWZlcnJlZEVycm9yXG4gICAgKSB7XG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7IGdldDogKCkgPT4gZXJyb3IgfSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIHRoaXMucGVuZGluZ0tleXNTZXQuZGVsZXRlKGtleSk7XG5cbiAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAvLyBOb3RoaW5nIGxlZnQgdG8gYWJvcnQhXG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7IGdldDogKCkgPT4gZXJyb3IgfSk7XG4gICAgICB0aGlzLmVtaXQoZmFsc2UsIGtleSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9kYXRhXCIsIHsgZ2V0OiAoKSA9PiBkYXRhIH0pO1xuICAgIHRoaXMuZW1pdChmYWxzZSwga2V5KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdChhYm9ydGVkOiBib29sZWFuLCBzZXR0bGVkS2V5Pzogc3RyaW5nKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiBzdWJzY3JpYmVyKGFib3J0ZWQsIHNldHRsZWRLZXkpKTtcbiAgfVxuXG4gIHN1YnNjcmliZShmbjogKGFib3J0ZWQ6IGJvb2xlYW4sIHNldHRsZWRLZXk/OiBzdHJpbmcpID0+IHZvaWQpIHtcbiAgICB0aGlzLnN1YnNjcmliZXJzLmFkZChmbik7XG4gICAgcmV0dXJuICgpID0+IHRoaXMuc3Vic2NyaWJlcnMuZGVsZXRlKGZuKTtcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0LmZvckVhY2goKHYsIGspID0+IHRoaXMucGVuZGluZ0tleXNTZXQuZGVsZXRlKGspKTtcbiAgICB0aGlzLmVtaXQodHJ1ZSk7XG4gIH1cblxuICBhc3luYyByZXNvbHZlRGF0YShzaWduYWw6IEFib3J0U2lnbmFsKSB7XG4gICAgbGV0IGFib3J0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuZG9uZSkge1xuICAgICAgbGV0IG9uQWJvcnQgPSAoKSA9PiB0aGlzLmNhbmNlbCgpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICAgIGFib3J0ZWQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aGlzLnN1YnNjcmliZSgoYWJvcnRlZCkgPT4ge1xuICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICAgICAgaWYgKGFib3J0ZWQgfHwgdGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXNvbHZlKGFib3J0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFib3J0ZWQ7XG4gIH1cblxuICBnZXQgZG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nS2V5c1NldC5zaXplID09PSAwO1xuICB9XG5cbiAgZ2V0IHVud3JhcHBlZERhdGEoKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgdGhpcy5kYXRhICE9PSBudWxsICYmIHRoaXMuZG9uZSxcbiAgICAgIFwiQ2FuIG9ubHkgdW53cmFwIGRhdGEgb24gaW5pdGlhbGl6ZWQgYW5kIHNldHRsZWQgZGVmZXJyZWRzXCJcbiAgICApO1xuXG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMuZGF0YSkucmVkdWNlKFxuICAgICAgKGFjYywgW2tleSwgdmFsdWVdKSA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKGFjYywge1xuICAgICAgICAgIFtrZXldOiB1bndyYXBUcmFja2VkUHJvbWlzZSh2YWx1ZSksXG4gICAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICB9XG5cbiAgZ2V0IHBlbmRpbmdLZXlzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucGVuZGluZ0tleXNTZXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVHJhY2tlZFByb21pc2UodmFsdWU6IGFueSk6IHZhbHVlIGlzIFRyYWNrZWRQcm9taXNlIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UgJiYgKHZhbHVlIGFzIFRyYWNrZWRQcm9taXNlKS5fdHJhY2tlZCA9PT0gdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiB1bndyYXBUcmFja2VkUHJvbWlzZSh2YWx1ZTogYW55KSB7XG4gIGlmICghaXNUcmFja2VkUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAodmFsdWUuX2Vycm9yKSB7XG4gICAgdGhyb3cgdmFsdWUuX2Vycm9yO1xuICB9XG4gIHJldHVybiB2YWx1ZS5fZGF0YTtcbn1cblxuZXhwb3J0IHR5cGUgRGVmZXJGdW5jdGlvbiA9IChcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIGluaXQ/OiBudW1iZXIgfCBSZXNwb25zZUluaXRcbikgPT4gRGVmZXJyZWREYXRhO1xuXG5leHBvcnQgY29uc3QgZGVmZXI6IERlZmVyRnVuY3Rpb24gPSAoZGF0YSwgaW5pdCA9IHt9KSA9PiB7XG4gIGxldCByZXNwb25zZUluaXQgPSB0eXBlb2YgaW5pdCA9PT0gXCJudW1iZXJcIiA/IHsgc3RhdHVzOiBpbml0IH0gOiBpbml0O1xuXG4gIHJldHVybiBuZXcgRGVmZXJyZWREYXRhKGRhdGEsIHJlc3BvbnNlSW5pdCk7XG59O1xuXG5leHBvcnQgdHlwZSBSZWRpcmVjdEZ1bmN0aW9uID0gKFxuICB1cmw6IHN0cmluZyxcbiAgaW5pdD86IG51bWJlciB8IFJlc3BvbnNlSW5pdFxuKSA9PiBSZXNwb25zZTtcblxuLyoqXG4gKiBBIHJlZGlyZWN0IHJlc3BvbnNlLiBTZXRzIHRoZSBzdGF0dXMgY29kZSBhbmQgdGhlIGBMb2NhdGlvbmAgaGVhZGVyLlxuICogRGVmYXVsdHMgdG8gXCIzMDIgRm91bmRcIi5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlZGlyZWN0OiBSZWRpcmVjdEZ1bmN0aW9uID0gKHVybCwgaW5pdCA9IDMwMikgPT4ge1xuICBsZXQgcmVzcG9uc2VJbml0ID0gaW5pdDtcbiAgaWYgKHR5cGVvZiByZXNwb25zZUluaXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXNwb25zZUluaXQgPSB7IHN0YXR1czogcmVzcG9uc2VJbml0IH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlc3BvbnNlSW5pdC5zdGF0dXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXNwb25zZUluaXQuc3RhdHVzID0gMzAyO1xuICB9XG5cbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG4gIGhlYWRlcnMuc2V0KFwiTG9jYXRpb25cIiwgdXJsKTtcblxuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAuLi5yZXNwb25zZUluaXQsXG4gICAgaGVhZGVycyxcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBVdGlsaXR5IGNsYXNzIHdlIHVzZSB0byBob2xkIGF1dG8tdW53cmFwcGVkIDR4eC81eHggUmVzcG9uc2UgYm9kaWVzXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvclJlc3BvbnNlIHtcbiAgc3RhdHVzOiBudW1iZXI7XG4gIHN0YXR1c1RleHQ6IHN0cmluZztcbiAgZGF0YTogYW55O1xuICBlcnJvcj86IEVycm9yO1xuICBpbnRlcm5hbDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBzdGF0dXM6IG51bWJlcixcbiAgICBzdGF0dXNUZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgZGF0YTogYW55LFxuICAgIGludGVybmFsID0gZmFsc2VcbiAgKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCB8fCBcIlwiO1xuICAgIHRoaXMuaW50ZXJuYWwgPSBpbnRlcm5hbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICB0aGlzLmVycm9yID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgYW4gRXJyb3JSZXNwb25zZSBnZW5lcmF0ZWQgZnJvbSBhIDR4eC81eHhcbiAqIFJlc3BvbnNlIHRocm93biBmcm9tIGFuIGFjdGlvbi9sb2FkZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yOiBhbnkpOiBlcnJvciBpcyBFcnJvclJlc3BvbnNlIHtcbiAgcmV0dXJuIChcbiAgICBlcnJvciAhPSBudWxsICYmXG4gICAgdHlwZW9mIGVycm9yLnN0YXR1cyA9PT0gXCJudW1iZXJcIiAmJlxuICAgIHR5cGVvZiBlcnJvci5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmXG4gICAgdHlwZW9mIGVycm9yLmludGVybmFsID09PSBcImJvb2xlYW5cIiAmJlxuICAgIFwiZGF0YVwiIGluIGVycm9yXG4gICk7XG59XG4iLCJpbXBvcnQgdHlwZSB7IEhpc3RvcnksIExvY2F0aW9uLCBQYXRoLCBUbyB9IGZyb20gXCIuL2hpc3RvcnlcIjtcbmltcG9ydCB7XG4gIEFjdGlvbiBhcyBIaXN0b3J5QWN0aW9uLFxuICBjcmVhdGVMb2NhdGlvbixcbiAgY3JlYXRlUGF0aCxcbiAgaW52YXJpYW50LFxuICBwYXJzZVBhdGgsXG59IGZyb20gXCIuL2hpc3RvcnlcIjtcbmltcG9ydCB0eXBlIHtcbiAgRGF0YVJlc3VsdCxcbiAgQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgQWdub3N0aWNEYXRhUm91dGVPYmplY3QsXG4gIERlZmVycmVkUmVzdWx0LFxuICBFcnJvclJlc3VsdCxcbiAgRm9ybUVuY1R5cGUsXG4gIEZvcm1NZXRob2QsXG4gIFJlZGlyZWN0UmVzdWx0LFxuICBSb3V0ZURhdGEsXG4gIEFnbm9zdGljUm91dGVPYmplY3QsXG4gIFN1Ym1pc3Npb24sXG4gIFN1Y2Nlc3NSZXN1bHQsXG4gIEFnbm9zdGljUm91dGVNYXRjaCxcbiAgTXV0YXRpb25Gb3JtTWV0aG9kLFxuICBTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb24sXG59IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQge1xuICBEZWZlcnJlZERhdGEsXG4gIEVycm9yUmVzcG9uc2UsXG4gIFJlc3VsdFR5cGUsXG4gIGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMsXG4gIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzLFxuICBpc1JvdXRlRXJyb3JSZXNwb25zZSxcbiAgam9pblBhdGhzLFxuICBtYXRjaFJvdXRlcyxcbiAgcmVzb2x2ZVRvLFxuICB3YXJuaW5nLFxufSBmcm9tIFwiLi91dGlsc1wiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIFR5cGVzIGFuZCBDb25zdGFudHNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQSBSb3V0ZXIgaW5zdGFuY2UgbWFuYWdlcyBhbGwgbmF2aWdhdGlvbiBhbmQgZGF0YSBsb2FkaW5nL211dGF0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlciB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogUmV0dXJuIHRoZSBiYXNlbmFtZSBmb3IgdGhlIHJvdXRlclxuICAgKi9cbiAgZ2V0IGJhc2VuYW1lKCk6IFJvdXRlckluaXRbXCJiYXNlbmFtZVwiXTtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFJldHVybiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcm91dGVyXG4gICAqL1xuICBnZXQgc3RhdGUoKTogUm91dGVyU3RhdGU7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBSZXR1cm4gdGhlIHJvdXRlcyBmb3IgdGhpcyByb3V0ZXIgaW5zdGFuY2VcbiAgICovXG4gIGdldCByb3V0ZXMoKTogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXTtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEluaXRpYWxpemUgdGhlIHJvdXRlciwgaW5jbHVkaW5nIGFkZGluZyBoaXN0b3J5IGxpc3RlbmVycyBhbmQga2lja2luZyBvZmZcbiAgICogaW5pdGlhbCBkYXRhIGZldGNoZXMuICBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gY2xlYW51cCBsaXN0ZW5lcnMgYW5kIGFib3J0XG4gICAqIGFueSBpbi1wcm9ncmVzcyBsb2Fkc1xuICAgKi9cbiAgaW5pdGlhbGl6ZSgpOiBSb3V0ZXI7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBTdWJzY3JpYmUgdG8gcm91dGVyLnN0YXRlIHVwZGF0ZXNcbiAgICpcbiAgICogQHBhcmFtIGZuIGZ1bmN0aW9uIHRvIGNhbGwgd2l0aCB0aGUgbmV3IHN0YXRlXG4gICAqL1xuICBzdWJzY3JpYmUoZm46IFJvdXRlclN1YnNjcmliZXIpOiAoKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogRW5hYmxlIHNjcm9sbCByZXN0b3JhdGlvbiBiZWhhdmlvciBpbiB0aGUgcm91dGVyXG4gICAqXG4gICAqIEBwYXJhbSBzYXZlZFNjcm9sbFBvc2l0aW9ucyBPYmplY3QgdGhhdCB3aWxsIG1hbmFnZSBwb3NpdGlvbnMsIGluIGNhc2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0J3MgYmVpbmcgcmVzdG9yZWQgZnJvbSBzZXNzaW9uU3RvcmFnZVxuICAgKiBAcGFyYW0gZ2V0U2Nyb2xsUG9zaXRpb24gICAgRnVuY3Rpb24gdG8gZ2V0IHRoZSBhY3RpdmUgWSBzY3JvbGwgcG9zaXRpb25cbiAgICogQHBhcmFtIGdldEtleSAgICAgICAgICAgICAgIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IHRvIHVzZSBmb3IgcmVzdG9yYXRpb25cbiAgICovXG4gIGVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uKFxuICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LFxuICAgIGdldFNjcm9sbFBvc2l0aW9uOiBHZXRTY3JvbGxQb3NpdGlvbkZ1bmN0aW9uLFxuICAgIGdldEtleT86IEdldFNjcm9sbFJlc3RvcmF0aW9uS2V5RnVuY3Rpb25cbiAgKTogKCkgPT4gdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIE5hdmlnYXRlIGZvcndhcmQvYmFja3dhcmQgaW4gdGhlIGhpc3Rvcnkgc3RhY2tcbiAgICogQHBhcmFtIHRvIERlbHRhIHRvIG1vdmUgaW4gdGhlIGhpc3Rvcnkgc3RhY2tcbiAgICovXG4gIG5hdmlnYXRlKHRvOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBOYXZpZ2F0ZSB0byB0aGUgZ2l2ZW4gcGF0aFxuICAgKiBAcGFyYW0gdG8gUGF0aCB0byBuYXZpZ2F0ZSB0b1xuICAgKiBAcGFyYW0gb3B0cyBOYXZpZ2F0aW9uIG9wdGlvbnMgKG1ldGhvZCwgc3VibWlzc2lvbiwgZXRjLilcbiAgICovXG4gIG5hdmlnYXRlKHRvOiBUbywgb3B0cz86IFJvdXRlck5hdmlnYXRlT3B0aW9ucyk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBUcmlnZ2VyIGEgZmV0Y2hlciBsb2FkL3N1Ym1pc3Npb25cbiAgICpcbiAgICogQHBhcmFtIGtleSAgICAgRmV0Y2hlciBrZXlcbiAgICogQHBhcmFtIHJvdXRlSWQgUm91dGUgdGhhdCBvd25zIHRoZSBmZXRjaGVyXG4gICAqIEBwYXJhbSBocmVmICAgIGhyZWYgdG8gZmV0Y2hcbiAgICogQHBhcmFtIG9wdHMgICAgRmV0Y2hlciBvcHRpb25zLCAobWV0aG9kLCBzdWJtaXNzaW9uLCBldGMuKVxuICAgKi9cbiAgZmV0Y2goXG4gICAga2V5OiBzdHJpbmcsXG4gICAgcm91dGVJZDogc3RyaW5nLFxuICAgIGhyZWY6IHN0cmluZyxcbiAgICBvcHRzPzogUm91dGVyTmF2aWdhdGVPcHRpb25zXG4gICk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBUcmlnZ2VyIGEgcmV2YWxpZGF0aW9uIG9mIGFsbCBjdXJyZW50IHJvdXRlIGxvYWRlcnMgYW5kIGZldGNoZXIgbG9hZHNcbiAgICovXG4gIHJldmFsaWRhdGUoKTogdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gY3JlYXRlIGFuIGhyZWYgZm9yIHRoZSBnaXZlbiBsb2NhdGlvblxuICAgKiBAcGFyYW0gbG9jYXRpb25cbiAgICovXG4gIGNyZWF0ZUhyZWYobG9jYXRpb246IExvY2F0aW9uIHwgVVJMKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBVUkwgZW5jb2RlIGEgZGVzdGluYXRpb24gcGF0aCBhY2NvcmRpbmcgdG8gdGhlIGludGVybmFsXG4gICAqIGhpc3RvcnkgaW1wbGVtZW50YXRpb25cbiAgICogQHBhcmFtIHRvXG4gICAqL1xuICBlbmNvZGVMb2NhdGlvbih0bzogVG8pOiBQYXRoO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogR2V0L2NyZWF0ZSBhIGZldGNoZXIgZm9yIHRoZSBnaXZlbiBrZXlcbiAgICogQHBhcmFtIGtleVxuICAgKi9cbiAgZ2V0RmV0Y2hlcjxURGF0YSA9IGFueT4oa2V5Pzogc3RyaW5nKTogRmV0Y2hlcjxURGF0YT47XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBEZWxldGUgdGhlIGZldGNoZXIgZm9yIGEgZ2l2ZW4ga2V5XG4gICAqIEBwYXJhbSBrZXlcbiAgICovXG4gIGRlbGV0ZUZldGNoZXIoa2V5Pzogc3RyaW5nKTogdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIENsZWFudXAgbGlzdGVuZXJzIGFuZCBhYm9ydCBhbnkgaW4tcHJvZ3Jlc3MgbG9hZHNcbiAgICovXG4gIGRpc3Bvc2UoKTogdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEdldCBhIG5hdmlnYXRpb24gYmxvY2tlclxuICAgKiBAcGFyYW0ga2V5IFRoZSBpZGVudGlmaWVyIGZvciB0aGUgYmxvY2tlclxuICAgKiBAcGFyYW0gZm4gVGhlIGJsb2NrZXIgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25cbiAgICovXG4gIGdldEJsb2NrZXIoa2V5OiBzdHJpbmcsIGZuOiBCbG9ja2VyRnVuY3Rpb24pOiBCbG9ja2VyO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogRGVsZXRlIGEgbmF2aWdhdGlvbiBibG9ja2VyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGlkZW50aWZpZXIgZm9yIHRoZSBibG9ja2VyXG4gICAqL1xuICBkZWxldGVCbG9ja2VyKGtleTogc3RyaW5nKTogdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEludGVybmFsIGZldGNoIEFib3J0Q29udHJvbGxlcnMgYWNjZXNzZWQgYnkgdW5pdCB0ZXN0c1xuICAgKi9cbiAgX2ludGVybmFsRmV0Y2hDb250cm9sbGVyczogTWFwPHN0cmluZywgQWJvcnRDb250cm9sbGVyPjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEludGVybmFsIHBlbmRpbmcgRGVmZXJyZWREYXRhIGluc3RhbmNlcyBhY2Nlc3NlZCBieSB1bml0IHRlc3RzXG4gICAqL1xuICBfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHM6IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT47XG59XG5cbi8qKlxuICogU3RhdGUgbWFpbnRhaW5lZCBpbnRlcm5hbGx5IGJ5IHRoZSByb3V0ZXIuICBEdXJpbmcgYSBuYXZpZ2F0aW9uLCBhbGwgc3RhdGVzXG4gKiByZWZsZWN0IHRoZSB0aGUgXCJvbGRcIiBsb2NhdGlvbiB1bmxlc3Mgb3RoZXJ3aXNlIG5vdGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlclN0YXRlIHtcbiAgLyoqXG4gICAqIFRoZSBhY3Rpb24gb2YgdGhlIG1vc3QgcmVjZW50IG5hdmlnYXRpb25cbiAgICovXG4gIGhpc3RvcnlBY3Rpb246IEhpc3RvcnlBY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGxvY2F0aW9uIHJlZmxlY3RlZCBieSB0aGUgcm91dGVyXG4gICAqL1xuICBsb2NhdGlvbjogTG9jYXRpb247XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHNldCBvZiByb3V0ZSBtYXRjaGVzXG4gICAqL1xuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW107XG5cbiAgLyoqXG4gICAqIFRyYWNrcyB3aGV0aGVyIHdlJ3ZlIGNvbXBsZXRlZCBvdXIgaW5pdGlhbCBkYXRhIGxvYWRcbiAgICovXG4gIGluaXRpYWxpemVkOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IHNjcm9sbCBwb3NpdGlvbiB3ZSBzaG91bGQgc3RhcnQgYXQgZm9yIGEgbmV3IHZpZXdcbiAgICogIC0gbnVtYmVyIC0+IHNjcm9sbCBwb3NpdGlvbiB0byByZXN0b3JlIHRvXG4gICAqICAtIGZhbHNlIC0+IGRvIG5vdCByZXN0b3JlIHNjcm9sbCBhdCBhbGwgKHVzZWQgZHVyaW5nIHN1Ym1pc3Npb25zKVxuICAgKiAgLSBudWxsIC0+IGRvbid0IGhhdmUgYSBzYXZlZCBwb3NpdGlvbiwgc2Nyb2xsIHRvIGhhc2ggb3IgdG9wIG9mIHBhZ2VcbiAgICovXG4gIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogbnVtYmVyIHwgZmFsc2UgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHRoaXMgbmF2aWdhdGlvbiBzaG91bGQgc2tpcCByZXNldHRpbmcgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgKiBpZiB3ZSBhcmUgdW5hYmxlIHRvIHJlc3RvcmUgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgKi9cbiAgcHJldmVudFNjcm9sbFJlc2V0OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUcmFja3MgdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IG5hdmlnYXRpb25cbiAgICovXG4gIG5hdmlnYXRpb246IE5hdmlnYXRpb247XG5cbiAgLyoqXG4gICAqIFRyYWNrcyBhbnkgaW4tcHJvZ3Jlc3MgcmV2YWxpZGF0aW9uc1xuICAgKi9cbiAgcmV2YWxpZGF0aW9uOiBSZXZhbGlkYXRpb25TdGF0ZTtcblxuICAvKipcbiAgICogRGF0YSBmcm9tIHRoZSBsb2FkZXJzIGZvciB0aGUgY3VycmVudCBtYXRjaGVzXG4gICAqL1xuICBsb2FkZXJEYXRhOiBSb3V0ZURhdGE7XG5cbiAgLyoqXG4gICAqIERhdGEgZnJvbSB0aGUgYWN0aW9uIGZvciB0aGUgY3VycmVudCBtYXRjaGVzXG4gICAqL1xuICBhY3Rpb25EYXRhOiBSb3V0ZURhdGEgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBFcnJvcnMgY2F1Z2h0IGZyb20gbG9hZGVycyBmb3IgdGhlIGN1cnJlbnQgbWF0Y2hlc1xuICAgKi9cbiAgZXJyb3JzOiBSb3V0ZURhdGEgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgY3VycmVudCBmZXRjaGVyc1xuICAgKi9cbiAgZmV0Y2hlcnM6IE1hcDxzdHJpbmcsIEZldGNoZXI+O1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgY3VycmVudCBibG9ja2Vyc1xuICAgKi9cbiAgYmxvY2tlcnM6IE1hcDxzdHJpbmcsIEJsb2NrZXI+O1xufVxuXG4vKipcbiAqIERhdGEgdGhhdCBjYW4gYmUgcGFzc2VkIGludG8gaHlkcmF0ZSBhIFJvdXRlciBmcm9tIFNTUlxuICovXG5leHBvcnQgdHlwZSBIeWRyYXRpb25TdGF0ZSA9IFBhcnRpYWw8XG4gIFBpY2s8Um91dGVyU3RhdGUsIFwibG9hZGVyRGF0YVwiIHwgXCJhY3Rpb25EYXRhXCIgfCBcImVycm9yc1wiPlxuPjtcblxuLyoqXG4gKiBJbml0aWFsaXphdGlvbiBvcHRpb25zIGZvciBjcmVhdGVSb3V0ZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJJbml0IHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIHJvdXRlczogQWdub3N0aWNSb3V0ZU9iamVjdFtdO1xuICBoaXN0b3J5OiBIaXN0b3J5O1xuICBoeWRyYXRpb25EYXRhPzogSHlkcmF0aW9uU3RhdGU7XG59XG5cbi8qKlxuICogU3RhdGUgcmV0dXJuZWQgZnJvbSBhIHNlcnZlci1zaWRlIHF1ZXJ5KCkgY2FsbFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpY0hhbmRsZXJDb250ZXh0IHtcbiAgYmFzZW5hbWU6IFJvdXRlcltcImJhc2VuYW1lXCJdO1xuICBsb2NhdGlvbjogUm91dGVyU3RhdGVbXCJsb2NhdGlvblwiXTtcbiAgbWF0Y2hlczogUm91dGVyU3RhdGVbXCJtYXRjaGVzXCJdO1xuICBsb2FkZXJEYXRhOiBSb3V0ZXJTdGF0ZVtcImxvYWRlckRhdGFcIl07XG4gIGFjdGlvbkRhdGE6IFJvdXRlclN0YXRlW1wiYWN0aW9uRGF0YVwiXTtcbiAgZXJyb3JzOiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXTtcbiAgc3RhdHVzQ29kZTogbnVtYmVyO1xuICBsb2FkZXJIZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBIZWFkZXJzPjtcbiAgYWN0aW9uSGVhZGVyczogUmVjb3JkPHN0cmluZywgSGVhZGVycz47XG4gIGFjdGl2ZURlZmVycmVkczogUmVjb3JkPHN0cmluZywgRGVmZXJyZWREYXRhPiB8IG51bGw7XG4gIF9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkPzogc3RyaW5nIHwgbnVsbDtcbn1cblxuLyoqXG4gKiBBIFN0YXRpY0hhbmRsZXIgaW5zdGFuY2UgbWFuYWdlcyBhIHNpbmd1bGFyIFNTUiBuYXZpZ2F0aW9uL2ZldGNoIGV2ZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGljSGFuZGxlciB7XG4gIGRhdGFSb3V0ZXM6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W107XG4gIHF1ZXJ5KFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgb3B0cz86IHsgcmVxdWVzdENvbnRleHQ/OiB1bmtub3duIH1cbiAgKTogUHJvbWlzZTxTdGF0aWNIYW5kbGVyQ29udGV4dCB8IFJlc3BvbnNlPjtcbiAgcXVlcnlSb3V0ZShcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIG9wdHM/OiB7IHJvdXRlSWQ/OiBzdHJpbmc7IHJlcXVlc3RDb250ZXh0PzogdW5rbm93biB9XG4gICk6IFByb21pc2U8YW55Pjtcbn1cblxuLyoqXG4gKiBTdWJzY3JpYmVyIGZ1bmN0aW9uIHNpZ25hdHVyZSBmb3IgY2hhbmdlcyB0byByb3V0ZXIgc3RhdGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJTdWJzY3JpYmVyIHtcbiAgKHN0YXRlOiBSb3V0ZXJTdGF0ZSk6IHZvaWQ7XG59XG5cbmludGVyZmFjZSBVc2VNYXRjaGVzTWF0Y2gge1xuICBpZDogc3RyaW5nO1xuICBwYXRobmFtZTogc3RyaW5nO1xuICBwYXJhbXM6IEFnbm9zdGljUm91dGVNYXRjaFtcInBhcmFtc1wiXTtcbiAgZGF0YTogdW5rbm93bjtcbiAgaGFuZGxlOiB1bmtub3duO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHNpZ25hdHVyZSBmb3IgZGV0ZXJtaW5pbmcgdGhlIGtleSB0byBiZSB1c2VkIGluIHNjcm9sbCByZXN0b3JhdGlvblxuICogZm9yIGEgZ2l2ZW4gbG9jYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uIHtcbiAgKGxvY2F0aW9uOiBMb2NhdGlvbiwgbWF0Y2hlczogVXNlTWF0Y2hlc01hdGNoW10pOiBzdHJpbmcgfCBudWxsO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHNpZ25hdHVyZSBmb3IgZGV0ZXJtaW5pbmcgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2V0U2Nyb2xsUG9zaXRpb25GdW5jdGlvbiB7XG4gICgpOiBudW1iZXI7XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYSBuYXZpZ2F0ZSgpIGNhbGwgZm9yIGEgTGluayBuYXZpZ2F0aW9uXG4gKi9cbnR5cGUgTGlua05hdmlnYXRlT3B0aW9ucyA9IHtcbiAgcmVwbGFjZT86IGJvb2xlYW47XG4gIHN0YXRlPzogYW55O1xuICBwcmV2ZW50U2Nyb2xsUmVzZXQ/OiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBPcHRpb25zIGZvciBhIG5hdmlnYXRlKCkgY2FsbCBmb3IgYSBGb3JtIG5hdmlnYXRpb25cbiAqL1xudHlwZSBTdWJtaXNzaW9uTmF2aWdhdGVPcHRpb25zID0ge1xuICByZXBsYWNlPzogYm9vbGVhbjtcbiAgc3RhdGU/OiBhbnk7XG4gIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG4gIGZvcm1NZXRob2Q/OiBGb3JtTWV0aG9kO1xuICBmb3JtRW5jVHlwZT86IEZvcm1FbmNUeXBlO1xuICBmb3JtRGF0YTogRm9ybURhdGE7XG59O1xuXG4vKipcbiAqIE9wdGlvbnMgdG8gcGFzcyB0byBuYXZpZ2F0ZSgpIGZvciBlaXRoZXIgYSBMaW5rIG9yIEZvcm0gbmF2aWdhdGlvblxuICovXG5leHBvcnQgdHlwZSBSb3V0ZXJOYXZpZ2F0ZU9wdGlvbnMgPVxuICB8IExpbmtOYXZpZ2F0ZU9wdGlvbnNcbiAgfCBTdWJtaXNzaW9uTmF2aWdhdGVPcHRpb25zO1xuXG4vKipcbiAqIE9wdGlvbnMgdG8gcGFzcyB0byBmZXRjaCgpXG4gKi9cbmV4cG9ydCB0eXBlIFJvdXRlckZldGNoT3B0aW9ucyA9XG4gIHwgT21pdDxMaW5rTmF2aWdhdGVPcHRpb25zLCBcInJlcGxhY2VcIj5cbiAgfCBPbWl0PFN1Ym1pc3Npb25OYXZpZ2F0ZU9wdGlvbnMsIFwicmVwbGFjZVwiPjtcblxuLyoqXG4gKiBQb3RlbnRpYWwgc3RhdGVzIGZvciBzdGF0ZS5uYXZpZ2F0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIE5hdmlnYXRpb25TdGF0ZXMgPSB7XG4gIElkbGU6IHtcbiAgICBzdGF0ZTogXCJpZGxlXCI7XG4gICAgbG9jYXRpb246IHVuZGVmaW5lZDtcbiAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQ7XG4gICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkO1xuICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQ7XG4gICAgZm9ybURhdGE6IHVuZGVmaW5lZDtcbiAgfTtcbiAgTG9hZGluZzoge1xuICAgIHN0YXRlOiBcImxvYWRpbmdcIjtcbiAgICBsb2NhdGlvbjogTG9jYXRpb247XG4gICAgZm9ybU1ldGhvZDogRm9ybU1ldGhvZCB8IHVuZGVmaW5lZDtcbiAgICBmb3JtQWN0aW9uOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgZm9ybUVuY1R5cGU6IEZvcm1FbmNUeXBlIHwgdW5kZWZpbmVkO1xuICAgIGZvcm1EYXRhOiBGb3JtRGF0YSB8IHVuZGVmaW5lZDtcbiAgfTtcbiAgU3VibWl0dGluZzoge1xuICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIjtcbiAgICBsb2NhdGlvbjogTG9jYXRpb247XG4gICAgZm9ybU1ldGhvZDogRm9ybU1ldGhvZDtcbiAgICBmb3JtQWN0aW9uOiBzdHJpbmc7XG4gICAgZm9ybUVuY1R5cGU6IEZvcm1FbmNUeXBlO1xuICAgIGZvcm1EYXRhOiBGb3JtRGF0YTtcbiAgfTtcbn07XG5cbmV4cG9ydCB0eXBlIE5hdmlnYXRpb24gPSBOYXZpZ2F0aW9uU3RhdGVzW2tleW9mIE5hdmlnYXRpb25TdGF0ZXNdO1xuXG5leHBvcnQgdHlwZSBSZXZhbGlkYXRpb25TdGF0ZSA9IFwiaWRsZVwiIHwgXCJsb2FkaW5nXCI7XG5cbi8qKlxuICogUG90ZW50aWFsIHN0YXRlcyBmb3IgZmV0Y2hlcnNcbiAqL1xudHlwZSBGZXRjaGVyU3RhdGVzPFREYXRhID0gYW55PiA9IHtcbiAgSWRsZToge1xuICAgIHN0YXRlOiBcImlkbGVcIjtcbiAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQ7XG4gICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkO1xuICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQ7XG4gICAgZm9ybURhdGE6IHVuZGVmaW5lZDtcbiAgICBkYXRhOiBURGF0YSB8IHVuZGVmaW5lZDtcbiAgICBcIiBfaGFzRmV0Y2hlckRvbmVBbnl0aGluZyBcIj86IGJvb2xlYW47XG4gIH07XG4gIExvYWRpbmc6IHtcbiAgICBzdGF0ZTogXCJsb2FkaW5nXCI7XG4gICAgZm9ybU1ldGhvZDogRm9ybU1ldGhvZCB8IHVuZGVmaW5lZDtcbiAgICBmb3JtQWN0aW9uOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgZm9ybUVuY1R5cGU6IEZvcm1FbmNUeXBlIHwgdW5kZWZpbmVkO1xuICAgIGZvcm1EYXRhOiBGb3JtRGF0YSB8IHVuZGVmaW5lZDtcbiAgICBkYXRhOiBURGF0YSB8IHVuZGVmaW5lZDtcbiAgICBcIiBfaGFzRmV0Y2hlckRvbmVBbnl0aGluZyBcIj86IGJvb2xlYW47XG4gIH07XG4gIFN1Ym1pdHRpbmc6IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCI7XG4gICAgZm9ybU1ldGhvZDogRm9ybU1ldGhvZDtcbiAgICBmb3JtQWN0aW9uOiBzdHJpbmc7XG4gICAgZm9ybUVuY1R5cGU6IEZvcm1FbmNUeXBlO1xuICAgIGZvcm1EYXRhOiBGb3JtRGF0YTtcbiAgICBkYXRhOiBURGF0YSB8IHVuZGVmaW5lZDtcbiAgICBcIiBfaGFzRmV0Y2hlckRvbmVBbnl0aGluZyBcIj86IGJvb2xlYW47XG4gIH07XG59O1xuXG5leHBvcnQgdHlwZSBGZXRjaGVyPFREYXRhID0gYW55PiA9XG4gIEZldGNoZXJTdGF0ZXM8VERhdGE+W2tleW9mIEZldGNoZXJTdGF0ZXM8VERhdGE+XTtcblxuaW50ZXJmYWNlIEJsb2NrZXJCbG9ja2VkIHtcbiAgc3RhdGU6IFwiYmxvY2tlZFwiO1xuICByZXNldCgpOiB2b2lkO1xuICBwcm9jZWVkKCk6IHZvaWQ7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbn1cblxuaW50ZXJmYWNlIEJsb2NrZXJVbmJsb2NrZWQge1xuICBzdGF0ZTogXCJ1bmJsb2NrZWRcIjtcbiAgcmVzZXQ6IHVuZGVmaW5lZDtcbiAgcHJvY2VlZDogdW5kZWZpbmVkO1xuICBsb2NhdGlvbjogdW5kZWZpbmVkO1xufVxuXG5pbnRlcmZhY2UgQmxvY2tlclByb2NlZWRpbmcge1xuICBzdGF0ZTogXCJwcm9jZWVkaW5nXCI7XG4gIHJlc2V0OiB1bmRlZmluZWQ7XG4gIHByb2NlZWQ6IHVuZGVmaW5lZDtcbiAgbG9jYXRpb246IExvY2F0aW9uO1xufVxuXG5leHBvcnQgdHlwZSBCbG9ja2VyID0gQmxvY2tlclVuYmxvY2tlZCB8IEJsb2NrZXJCbG9ja2VkIHwgQmxvY2tlclByb2NlZWRpbmc7XG5cbmV4cG9ydCB0eXBlIEJsb2NrZXJGdW5jdGlvbiA9IChhcmdzOiB7XG4gIGN1cnJlbnRMb2NhdGlvbjogTG9jYXRpb247XG4gIG5leHRMb2NhdGlvbjogTG9jYXRpb247XG4gIGhpc3RvcnlBY3Rpb246IEhpc3RvcnlBY3Rpb247XG59KSA9PiBib29sZWFuO1xuXG5pbnRlcmZhY2UgU2hvcnRDaXJjdWl0YWJsZSB7XG4gIC8qKlxuICAgKiBzdGFydE5hdmlnYXRpb24gZG9lcyBub3QgbmVlZCB0byBjb21wbGV0ZSB0aGUgbmF2aWdhdGlvbiBiZWNhdXNlIHdlXG4gICAqIHJlZGlyZWN0ZWQgb3IgZ290IGludGVycnVwdGVkXG4gICAqL1xuICBzaG9ydENpcmN1aXRlZD86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBIYW5kbGVBY3Rpb25SZXN1bHQgZXh0ZW5kcyBTaG9ydENpcmN1aXRhYmxlIHtcbiAgLyoqXG4gICAqIEVycm9yIHRocm93biBmcm9tIHRoZSBjdXJyZW50IGFjdGlvbiwga2V5ZWQgYnkgdGhlIHJvdXRlIGNvbnRhaW5pbmcgdGhlXG4gICAqIGVycm9yIGJvdW5kYXJ5IHRvIHJlbmRlciB0aGUgZXJyb3IuICBUbyBiZSBjb21taXR0ZWQgdG8gdGhlIHN0YXRlIGFmdGVyXG4gICAqIGxvYWRlcnMgaGF2ZSBjb21wbGV0ZWRcbiAgICovXG4gIHBlbmRpbmdBY3Rpb25FcnJvcj86IFJvdXRlRGF0YTtcbiAgLyoqXG4gICAqIERhdGEgcmV0dXJuZWQgZnJvbSB0aGUgY3VycmVudCBhY3Rpb24sIGtleWVkIGJ5IHRoZSByb3V0ZSBvd25pbmcgdGhlIGFjdGlvbi5cbiAgICogVG8gYmUgY29tbWl0dGVkIHRvIHRoZSBzdGF0ZSBhZnRlciBsb2FkZXJzIGhhdmUgY29tcGxldGVkXG4gICAqL1xuICBwZW5kaW5nQWN0aW9uRGF0YT86IFJvdXRlRGF0YTtcbn1cblxuaW50ZXJmYWNlIEhhbmRsZUxvYWRlcnNSZXN1bHQgZXh0ZW5kcyBTaG9ydENpcmN1aXRhYmxlIHtcbiAgLyoqXG4gICAqIGxvYWRlckRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgY3VycmVudCBzZXQgb2YgbG9hZGVyc1xuICAgKi9cbiAgbG9hZGVyRGF0YT86IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXTtcbiAgLyoqXG4gICAqIGVycm9ycyB0aHJvd24gZnJvbSB0aGUgY3VycmVudCBzZXQgb2YgbG9hZGVyc1xuICAgKi9cbiAgZXJyb3JzPzogUm91dGVyU3RhdGVbXCJlcnJvcnNcIl07XG59XG5cbi8qKlxuICogQ2FjaGVkIGluZm8gZm9yIGFjdGl2ZSBmZXRjaGVyLmxvYWQoKSBpbnN0YW5jZXMgc28gdGhleSBjYW4gcGFydGljaXBhdGVcbiAqIGluIHJldmFsaWRhdGlvblxuICovXG5pbnRlcmZhY2UgRmV0Y2hMb2FkTWF0Y2gge1xuICByb3V0ZUlkOiBzdHJpbmc7XG4gIHBhdGg6IHN0cmluZztcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2g7XG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXTtcbn1cblxuLyoqXG4gKiBJZGVudGlmaWVkIGZldGNoZXIubG9hZCgpIGNhbGxzIHRoYXQgbmVlZCB0byBiZSByZXZhbGlkYXRlZFxuICovXG5pbnRlcmZhY2UgUmV2YWxpZGF0aW5nRmV0Y2hlciBleHRlbmRzIEZldGNoTG9hZE1hdGNoIHtcbiAga2V5OiBzdHJpbmc7XG59XG5cbi8qKlxuICogV3JhcHBlciBvYmplY3QgdG8gYWxsb3cgdXMgdG8gdGhyb3cgYW55IHJlc3BvbnNlIG91dCBmcm9tIGNhbGxMb2FkZXJPckFjdGlvblxuICogZm9yIHF1ZXJ5Um91dGVyIHdoaWxlIHByZXNlcnZpbmcgd2hldGhlciBvciBub3QgaXQgd2FzIHRocm93biBvciByZXR1cm5lZFxuICogZnJvbSB0aGUgbG9hZGVyL2FjdGlvblxuICovXG5pbnRlcmZhY2UgUXVlcnlSb3V0ZVJlc3BvbnNlIHtcbiAgdHlwZTogUmVzdWx0VHlwZS5kYXRhIHwgUmVzdWx0VHlwZS5lcnJvcjtcbiAgcmVzcG9uc2U6IFJlc3BvbnNlO1xufVxuXG5jb25zdCB2YWxpZE11dGF0aW9uTWV0aG9kc0FycjogTXV0YXRpb25Gb3JtTWV0aG9kW10gPSBbXG4gIFwicG9zdFwiLFxuICBcInB1dFwiLFxuICBcInBhdGNoXCIsXG4gIFwiZGVsZXRlXCIsXG5dO1xuY29uc3QgdmFsaWRNdXRhdGlvbk1ldGhvZHMgPSBuZXcgU2V0PE11dGF0aW9uRm9ybU1ldGhvZD4oXG4gIHZhbGlkTXV0YXRpb25NZXRob2RzQXJyXG4pO1xuXG5jb25zdCB2YWxpZFJlcXVlc3RNZXRob2RzQXJyOiBGb3JtTWV0aG9kW10gPSBbXG4gIFwiZ2V0XCIsXG4gIC4uLnZhbGlkTXV0YXRpb25NZXRob2RzQXJyLFxuXTtcbmNvbnN0IHZhbGlkUmVxdWVzdE1ldGhvZHMgPSBuZXcgU2V0PEZvcm1NZXRob2Q+KHZhbGlkUmVxdWVzdE1ldGhvZHNBcnIpO1xuXG5jb25zdCByZWRpcmVjdFN0YXR1c0NvZGVzID0gbmV3IFNldChbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdKTtcbmNvbnN0IHJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2RlcyA9IG5ldyBTZXQoWzMwNywgMzA4XSk7XG5cbmV4cG9ydCBjb25zdCBJRExFX05BVklHQVRJT046IE5hdmlnYXRpb25TdGF0ZXNbXCJJZGxlXCJdID0ge1xuICBzdGF0ZTogXCJpZGxlXCIsXG4gIGxvY2F0aW9uOiB1bmRlZmluZWQsXG4gIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICBmb3JtRGF0YTogdW5kZWZpbmVkLFxufTtcblxuZXhwb3J0IGNvbnN0IElETEVfRkVUQ0hFUjogRmV0Y2hlclN0YXRlc1tcIklkbGVcIl0gPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgZGF0YTogdW5kZWZpbmVkLFxuICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbn07XG5cbmV4cG9ydCBjb25zdCBJRExFX0JMT0NLRVI6IEJsb2NrZXJVbmJsb2NrZWQgPSB7XG4gIHN0YXRlOiBcInVuYmxvY2tlZFwiLFxuICBwcm9jZWVkOiB1bmRlZmluZWQsXG4gIHJlc2V0OiB1bmRlZmluZWQsXG4gIGxvY2F0aW9uOiB1bmRlZmluZWQsXG59O1xuXG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG5cbmNvbnN0IGlzQnJvd3NlciA9XG4gIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5jb25zdCBpc1NlcnZlciA9ICFpc0Jyb3dzZXI7XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBjcmVhdGVSb3V0ZXJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ3JlYXRlIGEgcm91dGVyIGFuZCBsaXN0ZW4gdG8gaGlzdG9yeSBQT1AgbmF2aWdhdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlcihpbml0OiBSb3V0ZXJJbml0KTogUm91dGVyIHtcbiAgaW52YXJpYW50KFxuICAgIGluaXQucm91dGVzLmxlbmd0aCA+IDAsXG4gICAgXCJZb3UgbXVzdCBwcm92aWRlIGEgbm9uLWVtcHR5IHJvdXRlcyBhcnJheSB0byBjcmVhdGVSb3V0ZXJcIlxuICApO1xuXG4gIGxldCBkYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhpbml0LnJvdXRlcyk7XG4gIC8vIENsZWFudXAgZnVuY3Rpb24gZm9yIGhpc3RvcnlcbiAgbGV0IHVubGlzdGVuSGlzdG9yeTogKCgpID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb25zIHRvIGNhbGwgb24gYWxsIHN0YXRlIGNoYW5nZXNcbiAgbGV0IHN1YnNjcmliZXJzID0gbmV3IFNldDxSb3V0ZXJTdWJzY3JpYmVyPigpO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIG9iamVjdCB0byBob2xkIHNjcm9sbCByZXN0b3JhdGlvbiBsb2NhdGlvbnMgZHVyaW5nIHJvdXRpbmdcbiAgbGV0IHNhdmVkU2Nyb2xsUG9zaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+IHwgbnVsbCA9IG51bGw7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb24gdG8gZ2V0IHNjcm9sbCByZXN0b3JhdGlvbiBrZXlzXG4gIGxldCBnZXRTY3JvbGxSZXN0b3JhdGlvbktleTogR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvbiB8IG51bGwgPSBudWxsO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIGZ1bmN0aW9uIHRvIGdldCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICBsZXQgZ2V0U2Nyb2xsUG9zaXRpb246IEdldFNjcm9sbFBvc2l0aW9uRnVuY3Rpb24gfCBudWxsID0gbnVsbDtcbiAgLy8gT25lLXRpbWUgZmxhZyB0byBjb250cm9sIHRoZSBpbml0aWFsIGh5ZHJhdGlvbiBzY3JvbGwgcmVzdG9yYXRpb24uICBCZWNhdXNlXG4gIC8vIHdlIGRvbid0IGdldCB0aGUgc2F2ZWQgcG9zaXRpb25zIGZyb20gPFNjcm9sbFJlc3RvcmF0aW9uIC8+IHVudGlsIF9hZnRlcl9cbiAgLy8gdGhlIGluaXRpYWwgcmVuZGVyLCB3ZSBuZWVkIHRvIG1hbnVhbGx5IHRyaWdnZXIgYSBzZXBhcmF0ZSB1cGRhdGVTdGF0ZSB0b1xuICAvLyBzZW5kIGFsb25nIHRoZSByZXN0b3JlU2Nyb2xsUG9zaXRpb25cbiAgLy8gU2V0IHRvIHRydWUgaWYgd2UgaGF2ZSBgaHlkcmF0aW9uRGF0YWAgc2luY2Ugd2UgYXNzdW1lIHdlIHdlcmUgU1NSJ2QgYW5kIHRoYXRcbiAgLy8gU1NSIGRpZCB0aGUgaW5pdGlhbCBzY3JvbGwgcmVzdG9yYXRpb24uXG4gIGxldCBpbml0aWFsU2Nyb2xsUmVzdG9yZWQgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbDtcblxuICBsZXQgaW5pdGlhbE1hdGNoZXMgPSBtYXRjaFJvdXRlcyhcbiAgICBkYXRhUm91dGVzLFxuICAgIGluaXQuaGlzdG9yeS5sb2NhdGlvbixcbiAgICBpbml0LmJhc2VuYW1lXG4gICk7XG4gIGxldCBpbml0aWFsRXJyb3JzOiBSb3V0ZURhdGEgfCBudWxsID0gbnVsbDtcblxuICBpZiAoaW5pdGlhbE1hdGNoZXMgPT0gbnVsbCkge1xuICAgIC8vIElmIHdlIGRvIG5vdCBtYXRjaCBhIHVzZXItcHJvdmlkZWQtcm91dGUsIGZhbGwgYmFjayB0byB0aGUgcm9vdFxuICAgIC8vIHRvIGFsbG93IHRoZSBlcnJvciBib3VuZGFyeSB0byB0YWtlIG92ZXJcbiAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgcGF0aG5hbWU6IGluaXQuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICB9KTtcbiAgICBsZXQgeyBtYXRjaGVzLCByb3V0ZSB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgaW5pdGlhbEVycm9ycyA9IHsgW3JvdXRlLmlkXTogZXJyb3IgfTtcbiAgfVxuXG4gIGxldCBpbml0aWFsaXplZCA9XG4gICAgIWluaXRpYWxNYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUubG9hZGVyKSB8fCBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbDtcblxuICBsZXQgcm91dGVyOiBSb3V0ZXI7XG4gIGxldCBzdGF0ZTogUm91dGVyU3RhdGUgPSB7XG4gICAgaGlzdG9yeUFjdGlvbjogaW5pdC5oaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaW5pdC5oaXN0b3J5LmxvY2F0aW9uLFxuICAgIG1hdGNoZXM6IGluaXRpYWxNYXRjaGVzLFxuICAgIGluaXRpYWxpemVkLFxuICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAvLyBEb24ndCByZXN0b3JlIG9uIGluaXRpYWwgdXBkYXRlU3RhdGUoKSBpZiB3ZSB3ZXJlIFNTUidkXG4gICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbCA/IGZhbHNlIDogbnVsbCxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGZhbHNlLFxuICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgbG9hZGVyRGF0YTogKGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YSkgfHwge30sXG4gICAgYWN0aW9uRGF0YTogKGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEuYWN0aW9uRGF0YSkgfHwgbnVsbCxcbiAgICBlcnJvcnM6IChpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmVycm9ycykgfHwgaW5pdGlhbEVycm9ycyxcbiAgICBmZXRjaGVyczogbmV3IE1hcCgpLFxuICAgIGJsb2NrZXJzOiBuZXcgTWFwKCksXG4gIH07XG5cbiAgLy8gLS0gU3RhdGVmdWwgaW50ZXJuYWwgdmFyaWFibGVzIHRvIG1hbmFnZSBuYXZpZ2F0aW9ucyAtLVxuICAvLyBDdXJyZW50IG5hdmlnYXRpb24gaW4gcHJvZ3Jlc3MgKHRvIGJlIGNvbW1pdHRlZCBpbiBjb21wbGV0ZU5hdmlnYXRpb24pXG4gIGxldCBwZW5kaW5nQWN0aW9uOiBIaXN0b3J5QWN0aW9uID0gSGlzdG9yeUFjdGlvbi5Qb3A7XG5cbiAgLy8gU2hvdWxkIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gcHJldmVudCB0aGUgc2Nyb2xsIHJlc2V0IGlmIHNjcm9sbCBjYW5ub3RcbiAgLy8gYmUgcmVzdG9yZWQ/XG4gIGxldCBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gZmFsc2U7XG5cbiAgLy8gQWJvcnRDb250cm9sbGVyIGZvciB0aGUgYWN0aXZlIG5hdmlnYXRpb25cbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgbnVsbDtcblxuICAvLyBXZSB1c2UgdGhpcyB0byBhdm9pZCB0b3VjaGluZyBoaXN0b3J5IGluIGNvbXBsZXRlTmF2aWdhdGlvbiBpZiBhXG4gIC8vIHJldmFsaWRhdGlvbiBpcyBlbnRpcmVseSB1bmludGVycnVwdGVkXG4gIGxldCBpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gPSBmYWxzZTtcblxuICAvLyBVc2UgdGhpcyBpbnRlcm5hbCBmbGFnIHRvIGZvcmNlIHJldmFsaWRhdGlvbiBvZiBhbGwgbG9hZGVyczpcbiAgLy8gIC0gc3VibWlzc2lvbnMgKGNvbXBsZXRlZCBvciBpbnRlcnJ1cHRlZClcbiAgLy8gIC0gdXNlUmV2YWxpZGF0ZSgpXG4gIC8vICAtIFgtUmVtaXgtUmV2YWxpZGF0ZSAoZnJvbSByZWRpcmVjdClcbiAgbGV0IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcblxuICAvLyBVc2UgdGhpcyBpbnRlcm5hbCBhcnJheSB0byBjYXB0dXJlIHJvdXRlcyB0aGF0IHJlcXVpcmUgcmV2YWxpZGF0aW9uIGR1ZVxuICAvLyB0byBhIGNhbmNlbGxlZCBkZWZlcnJlZCBvbiBhY3Rpb24gc3VibWlzc2lvblxuICBsZXQgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXM6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gVXNlIHRoaXMgaW50ZXJuYWwgYXJyYXkgdG8gY2FwdHVyZSBmZXRjaGVyIGxvYWRzIHRoYXQgd2VyZSBjYW5jZWxsZWQgYnkgYW5cbiAgLy8gYWN0aW9uIG5hdmlnYXRpb24gYW5kIHJlcXVpcmUgcmV2YWxpZGF0aW9uXG4gIGxldCBjYW5jZWxsZWRGZXRjaGVyTG9hZHM6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gQWJvcnRDb250cm9sbGVycyBmb3IgYW55IGluLWZsaWdodCBmZXRjaGVyc1xuICBsZXQgZmV0Y2hDb250cm9sbGVycyA9IG5ldyBNYXA8c3RyaW5nLCBBYm9ydENvbnRyb2xsZXI+KCk7XG5cbiAgLy8gVHJhY2sgbG9hZHMgYmFzZWQgb24gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgc3RhcnRlZFxuICBsZXQgaW5jcmVtZW50aW5nTG9hZElkID0gMDtcblxuICAvLyBUcmFjayB0aGUgb3V0c3RhbmRpbmcgcGVuZGluZyBuYXZpZ2F0aW9uIGRhdGEgbG9hZCB0byBiZSBjb21wYXJlZCBhZ2FpbnN0XG4gIC8vIHRoZSBnbG9iYWxseSBpbmNyZW1lbnRpbmcgbG9hZCB3aGVuIGEgZmV0Y2hlciBsb2FkIGxhbmRzIGFmdGVyIGEgY29tcGxldGVkXG4gIC8vIG5hdmlnYXRpb25cbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID0gLTE7XG5cbiAgLy8gRmV0Y2hlcnMgdGhhdCB0cmlnZ2VyZWQgZGF0YSByZWxvYWRzIGFzIGEgcmVzdWx0IG9mIHRoZWlyIGFjdGlvbnNcbiAgbGV0IGZldGNoUmVsb2FkSWRzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcblxuICAvLyBGZXRjaGVycyB0aGF0IHRyaWdnZXJlZCByZWRpcmVjdCBuYXZpZ2F0aW9ucyBmcm9tIHRoZWlyIGFjdGlvbnNcbiAgbGV0IGZldGNoUmVkaXJlY3RJZHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAvLyBNb3N0IHJlY2VudCBocmVmL21hdGNoIGZvciBmZXRjaGVyLmxvYWQgY2FsbHMgZm9yIGZldGNoZXJzXG4gIGxldCBmZXRjaExvYWRNYXRjaGVzID0gbmV3IE1hcDxzdHJpbmcsIEZldGNoTG9hZE1hdGNoPigpO1xuXG4gIC8vIFN0b3JlIERlZmVycmVkRGF0YSBpbnN0YW5jZXMgZm9yIGFjdGl2ZSByb3V0ZSBtYXRjaGVzLiAgV2hlbiBhXG4gIC8vIHJvdXRlIGxvYWRlciByZXR1cm5zIGRlZmVyKCkgd2Ugc3RpY2sgb25lIGluIGhlcmUuICBUaGVuLCB3aGVuIGEgbmVzdGVkXG4gIC8vIHByb21pc2UgcmVzb2x2ZXMgd2UgdXBkYXRlIGxvYWRlckRhdGEuICBJZiBhIG5ldyBuYXZpZ2F0aW9uIHN0YXJ0cyB3ZVxuICAvLyBjYW5jZWwgYWN0aXZlIGRlZmVycmVkcyBmb3IgZWxpbWluYXRlZCByb3V0ZXMuXG4gIGxldCBhY3RpdmVEZWZlcnJlZHMgPSBuZXcgTWFwPHN0cmluZywgRGVmZXJyZWREYXRhPigpO1xuXG4gIC8vIFN0b3JlIGJsb2NrZXIgZnVuY3Rpb25zIGluIGEgc2VwYXJhdGUgTWFwIG91dHNpZGUgb2Ygcm91dGVyIHN0YXRlIHNpbmNlXG4gIC8vIHdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIFVJIHN0YXRlIGlmIHRoZXkgY2hhbmdlXG4gIGxldCBibG9ja2VyRnVuY3Rpb25zID0gbmV3IE1hcDxzdHJpbmcsIEJsb2NrZXJGdW5jdGlvbj4oKTtcblxuICAvLyBGbGFnIHRvIGlnbm9yZSB0aGUgbmV4dCBoaXN0b3J5IHVwZGF0ZSwgc28gd2UgY2FuIHJldmVydCB0aGUgVVJMIGNoYW5nZSBvblxuICAvLyBhIFBPUCBuYXZpZ2F0aW9uIHRoYXQgd2FzIGJsb2NrZWQgYnkgdGhlIHVzZXIgd2l0aG91dCB0b3VjaGluZyByb3V0ZXIgc3RhdGVcbiAgbGV0IGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlID0gZmFsc2U7XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgcm91dGVyLCBhbGwgc2lkZSBlZmZlY3RzIHNob3VsZCBiZSBraWNrZWQgb2ZmIGZyb20gaGVyZS5cbiAgLy8gSW1wbGVtZW50ZWQgYXMgYSBGbHVlbnQgQVBJIGZvciBlYXNlIG9mOlxuICAvLyAgIGxldCByb3V0ZXIgPSBjcmVhdGVSb3V0ZXIoaW5pdCkuaW5pdGlhbGl6ZSgpO1xuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIC8vIElmIGhpc3RvcnkgaW5mb3JtcyB1cyBvZiBhIFBPUCBuYXZpZ2F0aW9uLCBzdGFydCB0aGUgbmF2aWdhdGlvbiBidXQgZG8gbm90IHVwZGF0ZVxuICAgIC8vIHN0YXRlLiAgV2UnbGwgdXBkYXRlIG91ciBvd24gc3RhdGUgb25jZSB0aGUgbmF2aWdhdGlvbiBjb21wbGV0ZXNcbiAgICB1bmxpc3Rlbkhpc3RvcnkgPSBpbml0Lmhpc3RvcnkubGlzdGVuKFxuICAgICAgKHsgYWN0aW9uOiBoaXN0b3J5QWN0aW9uLCBsb2NhdGlvbiwgZGVsdGEgfSkgPT4ge1xuICAgICAgICAvLyBJZ25vcmUgdGhpcyBldmVudCBpZiBpdCB3YXMganVzdCB1cyByZXNldHRpbmcgdGhlIFVSTCBmcm9tIGFcbiAgICAgICAgLy8gYmxvY2tlZCBQT1AgbmF2aWdhdGlvblxuICAgICAgICBpZiAoaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUpIHtcbiAgICAgICAgICBpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgYmxvY2tlckZ1bmN0aW9ucy5zaXplID09PSAwIHx8IGRlbHRhICE9IG51bGwsXG4gICAgICAgICAgXCJZb3UgYXJlIHRyeWluZyB0byB1c2UgYSBibG9ja2VyIG9uIGEgUE9QIG5hdmlnYXRpb24gdG8gYSBsb2NhdGlvbiBcIiArXG4gICAgICAgICAgICBcInRoYXQgd2FzIG5vdCBjcmVhdGVkIGJ5IEByZW1peC1ydW4vcm91dGVyLiBUaGlzIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBcIiArXG4gICAgICAgICAgICBcInByb2R1Y3Rpb24uIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgYXJlIG5hdmlnYXRpbmcgb3V0c2lkZSB0aGUgcm91dGVyIFwiICtcbiAgICAgICAgICAgIFwidmlhIGB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGVgL2B3aW5kb3cubG9jYXRpb24uaGFzaGAgaW5zdGVhZCBvZiB1c2luZyBcIiArXG4gICAgICAgICAgICBcInJvdXRlciBuYXZpZ2F0aW9uIEFQSXMuICBUaGlzIGNhbiBhbHNvIGhhcHBlbiBpZiB5b3UgYXJlIHVzaW5nIFwiICtcbiAgICAgICAgICAgIFwiY3JlYXRlSGFzaFJvdXRlciBhbmQgdGhlIHVzZXIgbWFudWFsbHkgY2hhbmdlcyB0aGUgVVJMLlwiXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IGJsb2NrZXJLZXkgPSBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBoaXN0b3J5QWN0aW9uLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYmxvY2tlcktleSAmJiBkZWx0YSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gUmVzdG9yZSB0aGUgVVJMIHRvIG1hdGNoIHRoZSBjdXJyZW50IFVJLCBidXQgZG9uJ3QgdXBkYXRlIHJvdXRlciBzdGF0ZVxuICAgICAgICAgIGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICBpbml0Lmhpc3RvcnkuZ28oZGVsdGEgKiAtMSk7XG5cbiAgICAgICAgICAvLyBQdXQgdGhlIGJsb2NrZXIgaW50byBhIGJsb2NrZWQgc3RhdGVcbiAgICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgICAgIHN0YXRlOiBcImJsb2NrZWRcIixcbiAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgcHJvY2VlZCgpIHtcbiAgICAgICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5ISwge1xuICAgICAgICAgICAgICAgIHN0YXRlOiBcInByb2NlZWRpbmdcIixcbiAgICAgICAgICAgICAgICBwcm9jZWVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcmVzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIC8vIFJlLWRvIHRoZSBzYW1lIFBPUCBuYXZpZ2F0aW9uIHdlIGp1c3QgYmxvY2tlZFxuICAgICAgICAgICAgICBpbml0Lmhpc3RvcnkuZ28oZGVsdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgICBkZWxldGVCbG9ja2VyKGJsb2NrZXJLZXkhKTtcbiAgICAgICAgICAgICAgdXBkYXRlU3RhdGUoeyBibG9ja2VyczogbmV3IE1hcChyb3V0ZXIuc3RhdGUuYmxvY2tlcnMpIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIGxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gS2ljayBvZmYgaW5pdGlhbCBkYXRhIGxvYWQgaWYgbmVlZGVkLiAgVXNlIFBvcCB0byBhdm9pZCBtb2RpZnlpbmcgaGlzdG9yeVxuICAgIGlmICghc3RhdGUuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihIaXN0b3J5QWN0aW9uLlBvcCwgc3RhdGUubG9jYXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiByb3V0ZXI7XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhIHJvdXRlciBhbmQgaXQncyBzaWRlIGVmZmVjdHNcbiAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBpZiAodW5saXN0ZW5IaXN0b3J5KSB7XG4gICAgICB1bmxpc3Rlbkhpc3RvcnkoKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlcnMuY2xlYXIoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoXywga2V5KSA9PiBkZWxldGVGZXRjaGVyKGtleSkpO1xuICAgIHN0YXRlLmJsb2NrZXJzLmZvckVhY2goKF8sIGtleSkgPT4gZGVsZXRlQmxvY2tlcihrZXkpKTtcbiAgfVxuXG4gIC8vIFN1YnNjcmliZSB0byBzdGF0ZSB1cGRhdGVzIGZvciB0aGUgcm91dGVyXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShmbjogUm91dGVyU3Vic2NyaWJlcikge1xuICAgIHN1YnNjcmliZXJzLmFkZChmbik7XG4gICAgcmV0dXJuICgpID0+IHN1YnNjcmliZXJzLmRlbGV0ZShmbik7XG4gIH1cblxuICAvLyBVcGRhdGUgb3VyIHN0YXRlIGFuZCBub3RpZnkgdGhlIGNhbGxpbmcgY29udGV4dCBvZiB0aGUgY2hhbmdlXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKG5ld1N0YXRlOiBQYXJ0aWFsPFJvdXRlclN0YXRlPik6IHZvaWQge1xuICAgIHN0YXRlID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi5uZXdTdGF0ZSxcbiAgICB9O1xuICAgIHN1YnNjcmliZXJzLmZvckVhY2goKHN1YnNjcmliZXIpID0+IHN1YnNjcmliZXIoc3RhdGUpKTtcbiAgfVxuXG4gIC8vIENvbXBsZXRlIGEgbmF2aWdhdGlvbiByZXR1cm5pbmcgdGhlIHN0YXRlLm5hdmlnYXRpb24gYmFjayB0byB0aGUgSURMRV9OQVZJR0FUSU9OXG4gIC8vIGFuZCBzZXR0aW5nIHN0YXRlLltoaXN0b3J5QWN0aW9uL2xvY2F0aW9uL21hdGNoZXNdIHRvIHRoZSBuZXcgcm91dGUuXG4gIC8vIC0gTG9jYXRpb24gaXMgYSByZXF1aXJlZCBwYXJhbVxuICAvLyAtIE5hdmlnYXRpb24gd2lsbCBhbHdheXMgYmUgc2V0IHRvIElETEVfTkFWSUdBVElPTlxuICAvLyAtIENhbiBwYXNzIGFueSBvdGhlciBzdGF0ZSBpbiBuZXdTdGF0ZVxuICBmdW5jdGlvbiBjb21wbGV0ZU5hdmlnYXRpb24oXG4gICAgbG9jYXRpb246IExvY2F0aW9uLFxuICAgIG5ld1N0YXRlOiBQYXJ0aWFsPE9taXQ8Um91dGVyU3RhdGUsIFwiYWN0aW9uXCIgfCBcImxvY2F0aW9uXCIgfCBcIm5hdmlnYXRpb25cIj4+XG4gICk6IHZvaWQge1xuICAgIC8vIERlZHVjZSBpZiB3ZSdyZSBpbiBhIGxvYWRpbmcvYWN0aW9uUmVsb2FkIHN0YXRlOlxuICAgIC8vIC0gV2UgaGF2ZSBjb21taXR0ZWQgYWN0aW9uRGF0YSBpbiB0aGUgc3RvcmVcbiAgICAvLyAtIFRoZSBjdXJyZW50IG5hdmlnYXRpb24gd2FzIGEgbXV0YXRpb24gc3VibWlzc2lvblxuICAgIC8vIC0gV2UncmUgcGFzdCB0aGUgc3VibWl0dGluZyBzdGF0ZSBhbmQgaW50byB0aGUgbG9hZGluZyBzdGF0ZVxuICAgIC8vIC0gVGhlIGxvY2F0aW9uIGJlaW5nIGxvYWRlZCBpcyBub3QgdGhlIHJlc3VsdCBvZiBhIHJlZGlyZWN0XG4gICAgbGV0IGlzQWN0aW9uUmVsb2FkID1cbiAgICAgIHN0YXRlLmFjdGlvbkRhdGEgIT0gbnVsbCAmJlxuICAgICAgc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kICE9IG51bGwgJiZcbiAgICAgIGlzTXV0YXRpb25NZXRob2Qoc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kKSAmJlxuICAgICAgc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgJiZcbiAgICAgIGxvY2F0aW9uLnN0YXRlPy5faXNSZWRpcmVjdCAhPT0gdHJ1ZTtcblxuICAgIGxldCBhY3Rpb25EYXRhOiBSb3V0ZURhdGEgfCBudWxsO1xuICAgIGlmIChuZXdTdGF0ZS5hY3Rpb25EYXRhKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMobmV3U3RhdGUuYWN0aW9uRGF0YSkubGVuZ3RoID4gMCkge1xuICAgICAgICBhY3Rpb25EYXRhID0gbmV3U3RhdGUuYWN0aW9uRGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVtcHR5IGFjdGlvbkRhdGEgLT4gY2xlYXIgcHJpb3IgYWN0aW9uRGF0YSBkdWUgdG8gYW4gYWN0aW9uIGVycm9yXG4gICAgICAgIGFjdGlvbkRhdGEgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNBY3Rpb25SZWxvYWQpIHtcbiAgICAgIC8vIEtlZXAgdGhlIGN1cnJlbnQgZGF0YSBpZiB3ZSdyZSB3cmFwcGluZyB1cCB0aGUgYWN0aW9uIHJlbG9hZFxuICAgICAgYWN0aW9uRGF0YSA9IHN0YXRlLmFjdGlvbkRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENsZWFyIGFjdGlvbkRhdGEgb24gYW55IG90aGVyIGNvbXBsZXRlZCBuYXZpZ2F0aW9uc1xuICAgICAgYWN0aW9uRGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIHByZXNlcnZlIGFueSBleGlzdGluZyBsb2FkZXJEYXRhIGZyb20gcmUtdXNlZCByb3V0ZXNcbiAgICBsZXQgbG9hZGVyRGF0YSA9IG5ld1N0YXRlLmxvYWRlckRhdGFcbiAgICAgID8gbWVyZ2VMb2FkZXJEYXRhKFxuICAgICAgICAgIHN0YXRlLmxvYWRlckRhdGEsXG4gICAgICAgICAgbmV3U3RhdGUubG9hZGVyRGF0YSxcbiAgICAgICAgICBuZXdTdGF0ZS5tYXRjaGVzIHx8IFtdLFxuICAgICAgICAgIG5ld1N0YXRlLmVycm9yc1xuICAgICAgICApXG4gICAgICA6IHN0YXRlLmxvYWRlckRhdGE7XG5cbiAgICAvLyBPbiBhIHN1Y2Nlc3NmdWwgbmF2aWdhdGlvbiB3ZSBjYW4gYXNzdW1lIHdlIGdvdCB0aHJvdWdoIGFsbCBibG9ja2Vyc1xuICAgIC8vIHNvIHdlIGNhbiBzdGFydCBmcmVzaFxuICAgIGZvciAobGV0IFtrZXldIG9mIGJsb2NrZXJGdW5jdGlvbnMpIHtcbiAgICAgIGRlbGV0ZUJsb2NrZXIoa2V5KTtcbiAgICB9XG5cbiAgICAvLyBBbHdheXMgcmVzcGVjdCB0aGUgdXNlciBmbGFnLiAgT3RoZXJ3aXNlIGRvbid0IHJlc2V0IG9uIG11dGF0aW9uXG4gICAgLy8gc3VibWlzc2lvbiBuYXZpZ2F0aW9ucyB1bmxlc3MgdGhleSByZWRpcmVjdFxuICAgIGxldCBwcmV2ZW50U2Nyb2xsUmVzZXQgPVxuICAgICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSB8fFxuICAgICAgKHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCAhPSBudWxsICYmXG4gICAgICAgIGlzTXV0YXRpb25NZXRob2Qoc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kKSAmJlxuICAgICAgICBsb2NhdGlvbi5zdGF0ZT8uX2lzUmVkaXJlY3QgIT09IHRydWUpO1xuXG4gICAgdXBkYXRlU3RhdGUoe1xuICAgICAgLi4ubmV3U3RhdGUsIC8vIG1hdGNoZXMsIGVycm9ycywgZmV0Y2hlcnMgZ28gdGhyb3VnaCBhcy1pc1xuICAgICAgYWN0aW9uRGF0YSxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBoaXN0b3J5QWN0aW9uOiBwZW5kaW5nQWN0aW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBpbml0aWFsaXplZDogdHJ1ZSxcbiAgICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24oXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBuZXdTdGF0ZS5tYXRjaGVzIHx8IHN0YXRlLm1hdGNoZXNcbiAgICAgICksXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICBibG9ja2VyczogbmV3IE1hcChzdGF0ZS5ibG9ja2VycyksXG4gICAgfSk7XG5cbiAgICBpZiAoaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uKSB7XG4gICAgICAvLyBJZiB0aGlzIHdhcyBhbiB1bmludGVycnVwdGVkIHJldmFsaWRhdGlvbiB0aGVuIGRvIG5vdCB0b3VjaCBoaXN0b3J5XG4gICAgfSBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBIaXN0b3J5QWN0aW9uLlBvcCkge1xuICAgICAgLy8gRG8gbm90aGluZyBmb3IgUE9QIC0gVVJMIGhhcyBhbHJlYWR5IGJlZW4gdXBkYXRlZFxuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gSGlzdG9yeUFjdGlvbi5QdXNoKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucHVzaChsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gSGlzdG9yeUFjdGlvbi5SZXBsYWNlKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IHN0YXRlZnVsIG5hdmlnYXRpb24gdmFyc1xuICAgIHBlbmRpbmdBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlBvcDtcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gZmFsc2U7XG4gICAgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzID0gW107XG4gICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzID0gW107XG4gIH1cblxuICAvLyBUcmlnZ2VyIGEgbmF2aWdhdGlvbiBldmVudCwgd2hpY2ggY2FuIGVpdGhlciBiZSBhIG51bWVyaWNhbCBQT1Agb3IgYSBQVVNIXG4gIC8vIHJlcGxhY2Ugd2l0aCBhbiBvcHRpb25hbCBzdWJtaXNzaW9uXG4gIGFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRlKFxuICAgIHRvOiBudW1iZXIgfCBUbyxcbiAgICBvcHRzPzogUm91dGVyTmF2aWdhdGVPcHRpb25zXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGluaXQuaGlzdG9yeS5nbyh0byk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHsgcGF0aCwgc3VibWlzc2lvbiwgZXJyb3IgfSA9IG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyh0bywgb3B0cyk7XG5cbiAgICBsZXQgY3VycmVudExvY2F0aW9uID0gc3RhdGUubG9jYXRpb247XG4gICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHN0YXRlLmxvY2F0aW9uLCBwYXRoLCBvcHRzICYmIG9wdHMuc3RhdGUpO1xuXG4gICAgLy8gV2hlbiB1c2luZyBuYXZpZ2F0ZSBhcyBhIFBVU0gvUkVQTEFDRSB3ZSBhcmVuJ3QgcmVhZGluZyBhbiBhbHJlYWR5LWVuY29kZWRcbiAgICAvLyBVUkwgZnJvbSB3aW5kb3cubG9jYXRpb24sIHNvIHdlIG5lZWQgdG8gZW5jb2RlIGl0IGhlcmUgc28gdGhlIGJlaGF2aW9yXG4gICAgLy8gcmVtYWlucyB0aGUgc2FtZSBhcyBQT1AgYW5kIG5vbi1kYXRhLXJvdXRlciB1c2FnZXMuICBuZXcgVVJMKCkgZG9lcyBhbGxcbiAgICAvLyB0aGUgc2FtZSBlbmNvZGluZyB3ZSdkIGdldCBmcm9tIGEgaGlzdG9yeS5wdXNoU3RhdGUvd2luZG93LmxvY2F0aW9uIHJlYWRcbiAgICAvLyB3aXRob3V0IGhhdmluZyB0byB0b3VjaCBoaXN0b3J5XG4gICAgbmV4dExvY2F0aW9uID0ge1xuICAgICAgLi4ubmV4dExvY2F0aW9uLFxuICAgICAgLi4uaW5pdC5oaXN0b3J5LmVuY29kZUxvY2F0aW9uKG5leHRMb2NhdGlvbiksXG4gICAgfTtcblxuICAgIGxldCB1c2VyUmVwbGFjZSA9IG9wdHMgJiYgb3B0cy5yZXBsYWNlICE9IG51bGwgPyBvcHRzLnJlcGxhY2UgOiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgaGlzdG9yeUFjdGlvbiA9IEhpc3RvcnlBY3Rpb24uUHVzaDtcblxuICAgIGlmICh1c2VyUmVwbGFjZSA9PT0gdHJ1ZSkge1xuICAgICAgaGlzdG9yeUFjdGlvbiA9IEhpc3RvcnlBY3Rpb24uUmVwbGFjZTtcbiAgICB9IGVsc2UgaWYgKHVzZXJSZXBsYWNlID09PSBmYWxzZSkge1xuICAgICAgLy8gbm8tb3BcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc3VibWlzc2lvbiAhPSBudWxsICYmXG4gICAgICBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkgJiZcbiAgICAgIHN1Ym1pc3Npb24uZm9ybUFjdGlvbiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2hcbiAgICApIHtcbiAgICAgIC8vIEJ5IGRlZmF1bHQgb24gc3VibWlzc2lvbnMgdG8gdGhlIGN1cnJlbnQgbG9jYXRpb24gd2UgUkVQTEFDRSBzbyB0aGF0XG4gICAgICAvLyB1c2VycyBkb24ndCBoYXZlIHRvIGRvdWJsZS1jbGljayB0aGUgYmFjayBidXR0b24gdG8gZ2V0IHRvIHRoZSBwcmlvclxuICAgICAgLy8gbG9jYXRpb24uICBJZiB0aGUgdXNlciByZWRpcmVjdHMgdG8gYSBkaWZmZXJlbnQgbG9jYXRpb24gZnJvbSB0aGVcbiAgICAgIC8vIGFjdGlvbi9sb2FkZXIgdGhpcyB3aWxsIGJlIGlnbm9yZWQgYW5kIHRoZSByZWRpcmVjdCB3aWxsIGJlIGEgUFVTSFxuICAgICAgaGlzdG9yeUFjdGlvbiA9IEhpc3RvcnlBY3Rpb24uUmVwbGFjZTtcbiAgICB9XG5cbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID1cbiAgICAgIG9wdHMgJiYgXCJwcmV2ZW50U2Nyb2xsUmVzZXRcIiBpbiBvcHRzXG4gICAgICAgID8gb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWVcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgYmxvY2tlcktleSA9IHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgICBjdXJyZW50TG9jYXRpb24sXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBoaXN0b3J5QWN0aW9uLFxuICAgIH0pO1xuICAgIGlmIChibG9ja2VyS2V5KSB7XG4gICAgICAvLyBQdXQgdGhlIGJsb2NrZXIgaW50byBhIGJsb2NrZWQgc3RhdGVcbiAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICBzdGF0ZTogXCJibG9ja2VkXCIsXG4gICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sXG4gICAgICAgIHByb2NlZWQoKSB7XG4gICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5ISwge1xuICAgICAgICAgICAgc3RhdGU6IFwicHJvY2VlZGluZ1wiLFxuICAgICAgICAgICAgcHJvY2VlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gU2VuZCB0aGUgc2FtZSBuYXZpZ2F0aW9uIHRocm91Z2hcbiAgICAgICAgICBuYXZpZ2F0ZSh0bywgb3B0cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgIGRlbGV0ZUJsb2NrZXIoYmxvY2tlcktleSEpO1xuICAgICAgICAgIHVwZGF0ZVN0YXRlKHsgYmxvY2tlcnM6IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpIH0pO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHN0YXJ0TmF2aWdhdGlvbihoaXN0b3J5QWN0aW9uLCBuZXh0TG9jYXRpb24sIHtcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAvLyBTZW5kIHRocm91Z2ggdGhlIGZvcm1EYXRhIHNlcmlhbGl6YXRpb24gZXJyb3IgaWYgd2UgaGF2ZSBvbmUgc28gd2UgY2FuXG4gICAgICAvLyByZW5kZXIgYXQgdGhlIHJpZ2h0IGVycm9yIGJvdW5kYXJ5IGFmdGVyIHdlIG1hdGNoIHJvdXRlc1xuICAgICAgcGVuZGluZ0Vycm9yOiBlcnJvcixcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlcGxhY2U6IG9wdHMgJiYgb3B0cy5yZXBsYWNlLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gUmV2YWxpZGF0ZSBhbGwgY3VycmVudCBsb2FkZXJzLiAgSWYgYSBuYXZpZ2F0aW9uIGlzIGluIHByb2dyZXNzIG9yIGlmIHRoaXNcbiAgLy8gaXMgaW50ZXJydXB0ZWQgYnkgYSBuYXZpZ2F0aW9uLCBhbGxvdyB0aGlzIHRvIFwic3VjY2VlZFwiIGJ5IGNhbGxpbmcgYWxsXG4gIC8vIGxvYWRlcnMgZHVyaW5nIHRoZSBuZXh0IGxvYWRlciByb3VuZFxuICBmdW5jdGlvbiByZXZhbGlkYXRlKCkge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgdXBkYXRlU3RhdGUoeyByZXZhbGlkYXRpb246IFwibG9hZGluZ1wiIH0pO1xuXG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IHN1Ym1pdHRpbmcgYW4gYWN0aW9uLCB3ZSBkb24ndCBuZWVkIHRvIHN0YXJ0IGEgbmV3XG4gICAgLy8gbmF2aWdhdGlvbiwgd2UnbGwganVzdCBsZXQgdGhlIGZvbGxvdyB1cCBsb2FkZXIgZXhlY3V0aW9uIGNhbGwgYWxsIGxvYWRlcnNcbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJzdWJtaXR0aW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgaW4gYW4gaWRsZSBzdGF0ZSwgc3RhcnQgYSBuZXcgbmF2aWdhdGlvbiBmb3IgdGhlIGN1cnJlbnRcbiAgICAvLyBhY3Rpb24vbG9jYXRpb24gYW5kIG1hcmsgaXQgYXMgdW5pbnRlcnJ1cHRlZCwgd2hpY2ggd2lsbCBza2lwIHRoZSBoaXN0b3J5XG4gICAgLy8gdXBkYXRlIGluIGNvbXBsZXRlTmF2aWdhdGlvblxuICAgIGlmIChzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgc3RhcnROYXZpZ2F0aW9uKHN0YXRlLmhpc3RvcnlBY3Rpb24sIHN0YXRlLmxvY2F0aW9uLCB7XG4gICAgICAgIHN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbjogdHJ1ZSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgaWYgd2UncmUgY3VycmVudGx5IGluIGEgbG9hZGluZyBzdGF0ZSwganVzdCBzdGFydCBhIG5ld1xuICAgIC8vIG5hdmlnYXRpb24gdG8gdGhlIG5hdmlnYXRpb24ubG9jYXRpb24gYnV0IGRvIG5vdCB0cmlnZ2VyIGFuIHVuaW50ZXJydXB0ZWRcbiAgICAvLyByZXZhbGlkYXRpb24gc28gdGhhdCBoaXN0b3J5IGNvcnJlY3RseSB1cGRhdGVzIG9uY2UgdGhlIG5hdmlnYXRpb24gY29tcGxldGVzXG4gICAgc3RhcnROYXZpZ2F0aW9uKFxuICAgICAgcGVuZGluZ0FjdGlvbiB8fCBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgICAgc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbixcbiAgICAgIHsgb3ZlcnJpZGVOYXZpZ2F0aW9uOiBzdGF0ZS5uYXZpZ2F0aW9uIH1cbiAgICApO1xuICB9XG5cbiAgLy8gU3RhcnQgYSBuYXZpZ2F0aW9uIHRvIHRoZSBnaXZlbiBhY3Rpb24vbG9jYXRpb24uICBDYW4gb3B0aW9uYWxseSBwcm92aWRlIGFcbiAgLy8gb3ZlcnJpZGVOYXZpZ2F0aW9uIHdoaWNoIHdpbGwgb3ZlcnJpZGUgdGhlIG5vcm1hbExvYWQgaW4gdGhlIGNhc2Ugb2YgYSByZWRpcmVjdFxuICAvLyBuYXZpZ2F0aW9uXG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0TmF2aWdhdGlvbihcbiAgICBoaXN0b3J5QWN0aW9uOiBIaXN0b3J5QWN0aW9uLFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBvcHRzPzoge1xuICAgICAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb247XG4gICAgICBvdmVycmlkZU5hdmlnYXRpb24/OiBOYXZpZ2F0aW9uO1xuICAgICAgcGVuZGluZ0Vycm9yPzogRXJyb3JSZXNwb25zZTtcbiAgICAgIHN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbj86IGJvb2xlYW47XG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ/OiBib29sZWFuO1xuICAgICAgcmVwbGFjZT86IGJvb2xlYW47XG4gICAgfVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBBYm9ydCBhbnkgaW4tcHJvZ3Jlc3MgbmF2aWdhdGlvbnMgYW5kIHN0YXJ0IGEgbmV3IG9uZS4gVW5zZXQgYW55IG9uZ29pbmdcbiAgICAvLyB1bmludGVycnVwdGVkIHJldmFsaWRhdGlvbnMgdW5sZXNzIHRvbGQgb3RoZXJ3aXNlLCBzaW5jZSB3ZSB3YW50IHRoaXNcbiAgICAvLyBuZXcgbmF2aWdhdGlvbiB0byB1cGRhdGUgaGlzdG9yeSBub3JtYWxseVxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuICAgIHBlbmRpbmdBY3Rpb24gPSBoaXN0b3J5QWN0aW9uO1xuICAgIGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9XG4gICAgICAob3B0cyAmJiBvcHRzLnN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikgPT09IHRydWU7XG5cbiAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBldmVyeSB0aW1lIHdlIHN0YXJ0IGEgbmV3IG5hdmlnYXRpb24sXG4gICAgLy8gYW5kIHRyYWNrIHdoZXRoZXIgd2Ugc2hvdWxkIHJlc2V0IHNjcm9sbCBvbiBjb21wbGV0aW9uXG4gICAgc2F2ZVNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gKG9wdHMgJiYgb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQpID09PSB0cnVlO1xuXG4gICAgbGV0IGxvYWRpbmdOYXZpZ2F0aW9uID0gb3B0cyAmJiBvcHRzLm92ZXJyaWRlTmF2aWdhdGlvbjtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGxvY2F0aW9uLCBpbml0LmJhc2VuYW1lKTtcblxuICAgIC8vIFNob3J0IGNpcmN1aXQgd2l0aCBhIDQwNCBvbiB0aGUgcm9vdCBlcnJvciBib3VuZGFyeSBpZiB3ZSBtYXRjaCBub3RoaW5nXG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgICBsZXQgeyBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsIHJvdXRlIH0gPVxuICAgICAgICBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgICAgLy8gQ2FuY2VsIGFsbCBwZW5kaW5nIGRlZmVycmVkIG9uIDQwNHMgc2luY2Ugd2UgZG9uJ3Qga2VlcCBhbnkgcm91dGVzXG4gICAgICBjYW5jZWxBY3RpdmVEZWZlcnJlZHMoKTtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwge1xuICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvcixcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgaXQncyBvbmx5IGEgaGFzaCBjaGFuZ2UgYW5kIG5vdCBhIG11dGF0aW9uIHN1Ym1pc3Npb25cbiAgICAvLyBGb3IgZXhhbXBsZSwgb24gL3BhZ2UjaGFzaCBhbmQgc3VibWl0IGEgPEZvcm0gbWV0aG9kPVwicG9zdFwiPiB3aGljaCB3aWxsXG4gICAgLy8gZGVmYXVsdCB0byBhIG5hdmlnYXRpb24gdG8gL3BhZ2VcbiAgICBpZiAoXG4gICAgICBpc0hhc2hDaGFuZ2VPbmx5KHN0YXRlLmxvY2F0aW9uLCBsb2NhdGlvbikgJiZcbiAgICAgICEob3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChvcHRzLnN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpXG4gICAgKSB7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHsgbWF0Y2hlcyB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBjb250cm9sbGVyL1JlcXVlc3QgZm9yIHRoaXMgbmF2aWdhdGlvblxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgcmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgb3B0cyAmJiBvcHRzLnN1Ym1pc3Npb25cbiAgICApO1xuICAgIGxldCBwZW5kaW5nQWN0aW9uRGF0YTogUm91dGVEYXRhIHwgdW5kZWZpbmVkO1xuICAgIGxldCBwZW5kaW5nRXJyb3I6IFJvdXRlRGF0YSB8IHVuZGVmaW5lZDtcblxuICAgIGlmIChvcHRzICYmIG9wdHMucGVuZGluZ0Vycm9yKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcGVuZGluZ0Vycm9yLCBpdCBtZWFucyB0aGUgdXNlciBhdHRlbXB0ZWQgYSBHRVQgc3VibWlzc2lvblxuICAgICAgLy8gd2l0aCBiaW5hcnkgRm9ybURhdGEgc28gYXNzaWduIGhlcmUgYW5kIHNraXAgdG8gaGFuZGxlTG9hZGVycy4gIFRoYXRcbiAgICAgIC8vIHdheSB3ZSBoYW5kbGUgY2FsbGluZyBsb2FkZXJzIGFib3ZlIHRoZSBib3VuZGFyeSBldGMuICBJdCdzIG5vdCByZWFsbHlcbiAgICAgIC8vIGRpZmZlcmVudCBmcm9tIGFuIGFjdGlvbkVycm9yIGluIHRoYXQgc2Vuc2UuXG4gICAgICBwZW5kaW5nRXJyb3IgPSB7XG4gICAgICAgIFtmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMpLnJvdXRlLmlkXTogb3B0cy5wZW5kaW5nRXJyb3IsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBvcHRzICYmXG4gICAgICBvcHRzLnN1Ym1pc3Npb24gJiZcbiAgICAgIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpXG4gICAgKSB7XG4gICAgICAvLyBDYWxsIGFjdGlvbiBpZiB3ZSByZWNlaXZlZCBhbiBhY3Rpb24gc3VibWlzc2lvblxuICAgICAgbGV0IGFjdGlvbk91dHB1dCA9IGF3YWl0IGhhbmRsZUFjdGlvbihcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG9wdHMuc3VibWlzc2lvbixcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgeyByZXBsYWNlOiBvcHRzLnJlcGxhY2UgfVxuICAgICAgKTtcblxuICAgICAgaWYgKGFjdGlvbk91dHB1dC5zaG9ydENpcmN1aXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBlbmRpbmdBY3Rpb25EYXRhID0gYWN0aW9uT3V0cHV0LnBlbmRpbmdBY3Rpb25EYXRhO1xuICAgICAgcGVuZGluZ0Vycm9yID0gYWN0aW9uT3V0cHV0LnBlbmRpbmdBY3Rpb25FcnJvcjtcblxuICAgICAgbGV0IG5hdmlnYXRpb246IE5hdmlnYXRpb25TdGF0ZXNbXCJMb2FkaW5nXCJdID0ge1xuICAgICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAuLi5vcHRzLnN1Ym1pc3Npb24sXG4gICAgICB9O1xuICAgICAgbG9hZGluZ05hdmlnYXRpb24gPSBuYXZpZ2F0aW9uO1xuXG4gICAgICAvLyBDcmVhdGUgYSBHRVQgcmVxdWVzdCBmb3IgdGhlIGxvYWRlcnNcbiAgICAgIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChyZXF1ZXN0LnVybCwgeyBzaWduYWw6IHJlcXVlc3Quc2lnbmFsIH0pO1xuICAgIH1cblxuICAgIC8vIENhbGwgbG9hZGVyc1xuICAgIGxldCB7IHNob3J0Q2lyY3VpdGVkLCBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IGF3YWl0IGhhbmRsZUxvYWRlcnMoXG4gICAgICByZXF1ZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBtYXRjaGVzLFxuICAgICAgbG9hZGluZ05hdmlnYXRpb24sXG4gICAgICBvcHRzICYmIG9wdHMuc3VibWlzc2lvbixcbiAgICAgIG9wdHMgJiYgb3B0cy5yZXBsYWNlLFxuICAgICAgcGVuZGluZ0FjdGlvbkRhdGEsXG4gICAgICBwZW5kaW5nRXJyb3JcbiAgICApO1xuXG4gICAgaWYgKHNob3J0Q2lyY3VpdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gdXAgbm93IHRoYXQgdGhlIGFjdGlvbi9sb2FkZXJzIGhhdmUgY29tcGxldGVkLiAgRG9uJ3QgY2xlYW4gdXAgaWZcbiAgICAvLyB3ZSBzaG9ydCBjaXJjdWl0ZWQgYmVjYXVzZSBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgd2lsbCBoYXZlIGFscmVhZHlcbiAgICAvLyBiZWVuIGFzc2lnbmVkIHRvIGEgbmV3IGNvbnRyb2xsZXIgZm9yIHRoZSBuZXh0IG5hdmlnYXRpb25cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuXG4gICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgLi4uKHBlbmRpbmdBY3Rpb25EYXRhID8geyBhY3Rpb25EYXRhOiBwZW5kaW5nQWN0aW9uRGF0YSB9IDoge30pLFxuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9ycyxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENhbGwgdGhlIGFjdGlvbiBtYXRjaGVkIGJ5IHRoZSBsZWFmIHJvdXRlIGZvciB0aGlzIG5hdmlnYXRpb24gYW5kIGhhbmRsZVxuICAvLyByZWRpcmVjdHMvZXJyb3JzXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUFjdGlvbihcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBvcHRzPzogeyByZXBsYWNlPzogYm9vbGVhbiB9XG4gICk6IFByb21pc2U8SGFuZGxlQWN0aW9uUmVzdWx0PiB7XG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcblxuICAgIC8vIFB1dCB1cyBpbiBhIHN1Ym1pdHRpbmcgc3RhdGVcbiAgICBsZXQgbmF2aWdhdGlvbjogTmF2aWdhdGlvblN0YXRlc1tcIlN1Ym1pdHRpbmdcIl0gPSB7XG4gICAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIC4uLnN1Ym1pc3Npb24sXG4gICAgfTtcbiAgICB1cGRhdGVTdGF0ZSh7IG5hdmlnYXRpb24gfSk7XG5cbiAgICAvLyBDYWxsIG91ciBhY3Rpb24gYW5kIGdldCB0aGUgcmVzdWx0XG4gICAgbGV0IHJlc3VsdDogRGF0YVJlc3VsdDtcbiAgICBsZXQgYWN0aW9uTWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbik7XG5cbiAgICBpZiAoIWFjdGlvbk1hdGNoLnJvdXRlLmFjdGlvbikge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgICByb3V0ZUlkOiBhY3Rpb25NYXRjaC5yb3V0ZS5pZCxcbiAgICAgICAgfSksXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gICAgICAgIFwiYWN0aW9uXCIsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGFjdGlvbk1hdGNoLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICByb3V0ZXIuYmFzZW5hbWVcbiAgICAgICk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IHJlcGxhY2U6IGJvb2xlYW47XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLnJlcGxhY2UgIT0gbnVsbCkge1xuICAgICAgICByZXBsYWNlID0gb3B0cy5yZXBsYWNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgZGlkbid0IGV4cGxpY2l0eSBpbmRpY2F0ZSByZXBsYWNlIGJlaGF2aW9yLCByZXBsYWNlIGlmXG4gICAgICAgIC8vIHdlIHJlZGlyZWN0ZWQgdG8gdGhlIGV4YWN0IHNhbWUgbG9jYXRpb24gd2UncmUgY3VycmVudGx5IGF0IHRvIGF2b2lkXG4gICAgICAgIC8vIGRvdWJsZSBiYWNrLWJ1dHRvbnNcbiAgICAgICAgcmVwbGFjZSA9XG4gICAgICAgICAgcmVzdWx0LmxvY2F0aW9uID09PSBzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSArIHN0YXRlLmxvY2F0aW9uLnNlYXJjaDtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZXN1bHQsIHsgc3VibWlzc2lvbiwgcmVwbGFjZSB9KTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuXG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gU3RvcmUgb2ZmIHRoZSBwZW5kaW5nIGVycm9yIC0gd2UgdXNlIGl0IHRvIGRldGVybWluZSB3aGljaCBsb2FkZXJzXG4gICAgICAvLyB0byBjYWxsIGFuZCB3aWxsIGNvbW1pdCBpdCB3aGVuIHdlIGNvbXBsZXRlIHRoZSBuYXZpZ2F0aW9uXG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgYWN0aW9uTWF0Y2gucm91dGUuaWQpO1xuXG4gICAgICAvLyBCeSBkZWZhdWx0LCBhbGwgc3VibWlzc2lvbnMgYXJlIFJFUExBQ0UgbmF2aWdhdGlvbnMsIGJ1dCBpZiB0aGVcbiAgICAgIC8vIGFjdGlvbiB0aHJldyBhbiBlcnJvciB0aGF0J2xsIGJlIHJlbmRlcmVkIGluIGFuIGVycm9yRWxlbWVudCwgd2UgZmFsbFxuICAgICAgLy8gYmFjayB0byBQVVNIIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHVzZSB0aGUgYmFjayBidXR0b24gdG8gZ2V0IGJhY2sgdG9cbiAgICAgIC8vIHRoZSBwcmUtc3VibWlzc2lvbiBmb3JtIGxvY2F0aW9uIHRvIHRyeSBhZ2FpblxuICAgICAgaWYgKChvcHRzICYmIG9wdHMucmVwbGFjZSkgIT09IHRydWUpIHtcbiAgICAgICAgcGVuZGluZ0FjdGlvbiA9IEhpc3RvcnlBY3Rpb24uUHVzaDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gU2VuZCBiYWNrIGFuIGVtcHR5IG9iamVjdCB3ZSBjYW4gdXNlIHRvIGNsZWFyIG91dCBhbnkgcHJpb3IgYWN0aW9uRGF0YVxuICAgICAgICBwZW5kaW5nQWN0aW9uRGF0YToge30sXG4gICAgICAgIHBlbmRpbmdBY3Rpb25FcnJvcjogeyBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvciB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwgeyB0eXBlOiBcImRlZmVyLWFjdGlvblwiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwZW5kaW5nQWN0aW9uRGF0YTogeyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YSB9LFxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGFsbCBhcHBsaWNhYmxlIGxvYWRlcnMgZm9yIHRoZSBnaXZlbiBtYXRjaGVzLCBoYW5kbGluZyByZWRpcmVjdHMsXG4gIC8vIGVycm9ycywgZXRjLlxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkZXJzKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgbG9jYXRpb246IExvY2F0aW9uLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBvdmVycmlkZU5hdmlnYXRpb24/OiBOYXZpZ2F0aW9uLFxuICAgIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uLFxuICAgIHJlcGxhY2U/OiBib29sZWFuLFxuICAgIHBlbmRpbmdBY3Rpb25EYXRhPzogUm91dGVEYXRhLFxuICAgIHBlbmRpbmdFcnJvcj86IFJvdXRlRGF0YVxuICApOiBQcm9taXNlPEhhbmRsZUxvYWRlcnNSZXN1bHQ+IHtcbiAgICAvLyBGaWd1cmUgb3V0IHRoZSByaWdodCBuYXZpZ2F0aW9uIHdlIHdhbnQgdG8gdXNlIGZvciBkYXRhIGxvYWRpbmdcbiAgICBsZXQgbG9hZGluZ05hdmlnYXRpb24gPSBvdmVycmlkZU5hdmlnYXRpb247XG4gICAgaWYgKCFsb2FkaW5nTmF2aWdhdGlvbikge1xuICAgICAgbGV0IG5hdmlnYXRpb246IE5hdmlnYXRpb25TdGF0ZXNbXCJMb2FkaW5nXCJdID0ge1xuICAgICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgIH07XG4gICAgICBsb2FkaW5nTmF2aWdhdGlvbiA9IG5hdmlnYXRpb247XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyB3YXMgYSByZWRpcmVjdCBmcm9tIGFuIGFjdGlvbiB3ZSBkb24ndCBoYXZlIGEgXCJzdWJtaXNzaW9uXCIgYnV0XG4gICAgLy8gd2UgaGF2ZSBpdCBvbiB0aGUgbG9hZGluZyBuYXZpZ2F0aW9uIHNvIHVzZSB0aGF0IGlmIGF2YWlsYWJsZVxuICAgIGxldCBhY3RpdmVTdWJtaXNzaW9uID0gc3VibWlzc2lvblxuICAgICAgPyBzdWJtaXNzaW9uXG4gICAgICA6IGxvYWRpbmdOYXZpZ2F0aW9uLmZvcm1NZXRob2QgJiZcbiAgICAgICAgbG9hZGluZ05hdmlnYXRpb24uZm9ybUFjdGlvbiAmJlxuICAgICAgICBsb2FkaW5nTmF2aWdhdGlvbi5mb3JtRGF0YSAmJlxuICAgICAgICBsb2FkaW5nTmF2aWdhdGlvbi5mb3JtRW5jVHlwZVxuICAgICAgPyB7XG4gICAgICAgICAgZm9ybU1ldGhvZDogbG9hZGluZ05hdmlnYXRpb24uZm9ybU1ldGhvZCxcbiAgICAgICAgICBmb3JtQWN0aW9uOiBsb2FkaW5nTmF2aWdhdGlvbi5mb3JtQWN0aW9uLFxuICAgICAgICAgIGZvcm1EYXRhOiBsb2FkaW5nTmF2aWdhdGlvbi5mb3JtRGF0YSxcbiAgICAgICAgICBmb3JtRW5jVHlwZTogbG9hZGluZ05hdmlnYXRpb24uZm9ybUVuY1R5cGUsXG4gICAgICAgIH1cbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgbGV0IFttYXRjaGVzVG9Mb2FkLCByZXZhbGlkYXRpbmdGZXRjaGVyc10gPSBnZXRNYXRjaGVzVG9Mb2FkKFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgc3RhdGUsXG4gICAgICBtYXRjaGVzLFxuICAgICAgYWN0aXZlU3VibWlzc2lvbixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCxcbiAgICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzLFxuICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLFxuICAgICAgcGVuZGluZ0FjdGlvbkRhdGEsXG4gICAgICBwZW5kaW5nRXJyb3IsXG4gICAgICBmZXRjaExvYWRNYXRjaGVzXG4gICAgKTtcblxuICAgIC8vIENhbmNlbCBwZW5kaW5nIGRlZmVycmVkcyBmb3Igbm8tbG9uZ2VyLW1hdGNoZWQgcm91dGVzIG9yIHJvdXRlcyB3ZSdyZVxuICAgIC8vIGFib3V0IHRvIHJlbG9hZC4gIE5vdGUgdGhhdCBpZiB0aGlzIGlzIGFuIGFjdGlvbiByZWxvYWQgd2Ugd291bGQgaGF2ZVxuICAgIC8vIGFscmVhZHkgY2FuY2VsbGVkIGFsbCBwZW5kaW5nIGRlZmVycmVkcyBzbyB0aGlzIHdvdWxkIGJlIGEgbm8tb3BcbiAgICBjYW5jZWxBY3RpdmVEZWZlcnJlZHMoXG4gICAgICAocm91dGVJZCkgPT5cbiAgICAgICAgIShtYXRjaGVzICYmIG1hdGNoZXMuc29tZSgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkpIHx8XG4gICAgICAgIChtYXRjaGVzVG9Mb2FkICYmIG1hdGNoZXNUb0xvYWQuc29tZSgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkpXG4gICAgKTtcblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgd2UgaGF2ZSBubyBsb2FkZXJzIHRvIHJ1blxuICAgIGlmIChtYXRjaGVzVG9Mb2FkLmxlbmd0aCA9PT0gMCAmJiByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgLy8gQ29tbWl0IHBlbmRpbmcgZXJyb3IgaWYgd2UncmUgc2hvcnQgY2lyY3VpdGluZ1xuICAgICAgICBlcnJvcnM6IHBlbmRpbmdFcnJvciB8fCBudWxsLFxuICAgICAgICAuLi4ocGVuZGluZ0FjdGlvbkRhdGEgPyB7IGFjdGlvbkRhdGE6IHBlbmRpbmdBY3Rpb25EYXRhIH0gOiB7fSksXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiB1bmludGVycnVwdGVkIHJldmFsaWRhdGlvbiwgd2UgcmVtYWluIGluIG91ciBjdXJyZW50IGlkbGVcbiAgICAvLyBzdGF0ZS4gIElmIG5vdCwgd2UgbmVlZCB0byBzd2l0Y2ggdG8gb3VyIGxvYWRpbmcgc3RhdGUgYW5kIGxvYWQgZGF0YSxcbiAgICAvLyBwcmVzZXJ2aW5nIGFueSBuZXcgYWN0aW9uIGRhdGEgb3IgZXhpc3RpbmcgYWN0aW9uIGRhdGEgKGluIHRoZSBjYXNlIG9mXG4gICAgLy8gYSByZXZhbGlkYXRpb24gaW50ZXJydXB0aW5nIGFuIGFjdGlvblJlbG9hZClcbiAgICBpZiAoIWlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikge1xuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocmYpID0+IHtcbiAgICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQocmYua2V5KTtcbiAgICAgICAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXI6IEZldGNoZXJTdGF0ZXNbXCJMb2FkaW5nXCJdID0ge1xuICAgICAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgICAgICBkYXRhOiBmZXRjaGVyICYmIGZldGNoZXIuZGF0YSxcbiAgICAgICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICAgICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICBcIiBfaGFzRmV0Y2hlckRvbmVBbnl0aGluZyBcIjogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KHJmLmtleSwgcmV2YWxpZGF0aW5nRmV0Y2hlcik7XG4gICAgICB9KTtcbiAgICAgIGxldCBhY3Rpb25EYXRhID0gcGVuZGluZ0FjdGlvbkRhdGEgfHwgc3RhdGUuYWN0aW9uRGF0YTtcbiAgICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgICAgbmF2aWdhdGlvbjogbG9hZGluZ05hdmlnYXRpb24sXG4gICAgICAgIC4uLihhY3Rpb25EYXRhXG4gICAgICAgICAgPyBPYmplY3Qua2V5cyhhY3Rpb25EYXRhKS5sZW5ndGggPT09IDBcbiAgICAgICAgICAgID8geyBhY3Rpb25EYXRhOiBudWxsIH1cbiAgICAgICAgICAgIDogeyBhY3Rpb25EYXRhIH1cbiAgICAgICAgICA6IHt9KSxcbiAgICAgICAgLi4uKHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA+IDBcbiAgICAgICAgICA/IHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH1cbiAgICAgICAgICA6IHt9KSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocmYpID0+XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLnNldChyZi5rZXksIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciEpXG4gICAgKTtcblxuICAgIGxldCB7IHJlc3VsdHMsIGxvYWRlclJlc3VsdHMsIGZldGNoZXJSZXN1bHRzIH0gPVxuICAgICAgYXdhaXQgY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKFxuICAgICAgICBzdGF0ZS5tYXRjaGVzLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgKTtcblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIF9hZnRlcl8gbG9hZGVycyBoYXZlIGNvbXBsZXRlZC4gIERvbid0IGNsZWFuIHVwIGlmIHdlIHNob3J0XG4gICAgLy8gY2lyY3VpdGVkIGJlY2F1c2UgZmV0Y2hDb250cm9sbGVycyB3b3VsZCBoYXZlIGJlZW4gYWJvcnRlZCBhbmRcbiAgICAvLyByZWFzc2lnbmVkIHRvIG5ldyBjb250cm9sbGVycyBmb3IgdGhlIG5leHQgbmF2aWdhdGlvblxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShyZi5rZXkpKTtcblxuICAgIC8vIElmIGFueSBsb2FkZXJzIHJldHVybmVkIGEgcmVkaXJlY3QgUmVzcG9uc2UsIHN0YXJ0IGEgbmV3IFJFUExBQ0UgbmF2aWdhdGlvblxuICAgIGxldCByZWRpcmVjdCA9IGZpbmRSZWRpcmVjdChyZXN1bHRzKTtcbiAgICBpZiAocmVkaXJlY3QpIHtcbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZWRpcmVjdCwgeyByZXBsYWNlIH0pO1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCB7IGxvYWRlckRhdGEsIGVycm9ycyB9ID0gcHJvY2Vzc0xvYWRlckRhdGEoXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgIHBlbmRpbmdFcnJvcixcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgZmV0Y2hlclJlc3VsdHMsXG4gICAgICBhY3RpdmVEZWZlcnJlZHNcbiAgICApO1xuXG4gICAgLy8gV2lyZSB1cCBzdWJzY3JpYmVycyB0byB1cGRhdGUgbG9hZGVyRGF0YSBhcyBwcm9taXNlcyBzZXR0bGVcbiAgICBhY3RpdmVEZWZlcnJlZHMuZm9yRWFjaCgoZGVmZXJyZWREYXRhLCByb3V0ZUlkKSA9PiB7XG4gICAgICBkZWZlcnJlZERhdGEuc3Vic2NyaWJlKChhYm9ydGVkKSA9PiB7XG4gICAgICAgIC8vIE5vdGU6IE5vIG5lZWQgdG8gdXBkYXRlU3RhdGUgaGVyZSBzaW5jZSB0aGUgVHJhY2tlZFByb21pc2Ugb25cbiAgICAgICAgLy8gbG9hZGVyRGF0YSBpcyBzdGFibGUgYWNyb3NzIHJlc29sdmUvcmVqZWN0XG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIGluc3RhbmNlIGlmIHdlIHdlcmUgYWJvcnRlZCBvciBpZiBwcm9taXNlcyBoYXZlIHNldHRsZWRcbiAgICAgICAgaWYgKGFib3J0ZWQgfHwgZGVmZXJyZWREYXRhLmRvbmUpIHtcbiAgICAgICAgICBhY3RpdmVEZWZlcnJlZHMuZGVsZXRlKHJvdXRlSWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKTtcbiAgICBsZXQgZGlkQWJvcnRGZXRjaExvYWRzID0gYWJvcnRTdGFsZUZldGNoTG9hZHMocGVuZGluZ05hdmlnYXRpb25Mb2FkSWQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnMsXG4gICAgICAuLi4oZGlkQWJvcnRGZXRjaExvYWRzIHx8IHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA+IDBcbiAgICAgICAgPyB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9XG4gICAgICAgIDoge30pLFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGZXRjaGVyPFREYXRhID0gYW55PihrZXk6IHN0cmluZyk6IEZldGNoZXI8VERhdGE+IHtcbiAgICByZXR1cm4gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSkgfHwgSURMRV9GRVRDSEVSO1xuICB9XG5cbiAgLy8gVHJpZ2dlciBhIGZldGNoZXIgbG9hZC9zdWJtaXQgZm9yIHRoZSBnaXZlbiBmZXRjaGVyIGtleVxuICBmdW5jdGlvbiBmZXRjaChcbiAgICBrZXk6IHN0cmluZyxcbiAgICByb3V0ZUlkOiBzdHJpbmcsXG4gICAgaHJlZjogc3RyaW5nLFxuICAgIG9wdHM/OiBSb3V0ZXJGZXRjaE9wdGlvbnNcbiAgKSB7XG4gICAgaWYgKGlzU2VydmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwicm91dGVyLmZldGNoKCkgd2FzIGNhbGxlZCBkdXJpbmcgdGhlIHNlcnZlciByZW5kZXIsIGJ1dCBpdCBzaG91bGRuJ3QgYmUuIFwiICtcbiAgICAgICAgICBcIllvdSBhcmUgbGlrZWx5IGNhbGxpbmcgYSB1c2VGZXRjaGVyKCkgbWV0aG9kIGluIHRoZSBib2R5IG9mIHlvdXIgY29tcG9uZW50LiBcIiArXG4gICAgICAgICAgXCJUcnkgbW92aW5nIGl0IHRvIGEgdXNlRWZmZWN0IG9yIGEgY2FsbGJhY2suXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkpIGFib3J0RmV0Y2hlcihrZXkpO1xuXG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBocmVmLCBpbml0LmJhc2VuYW1lKTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkLFxuICAgICAgICBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogaHJlZiB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgeyBwYXRoLCBzdWJtaXNzaW9uIH0gPSBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoaHJlZiwgb3B0cywgdHJ1ZSk7XG4gICAgbGV0IG1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgcGF0aCk7XG5cbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gKG9wdHMgJiYgb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQpID09PSB0cnVlO1xuXG4gICAgaWYgKHN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICBoYW5kbGVGZXRjaGVyQWN0aW9uKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIG1hdGNoZXMsIHN1Ym1pc3Npb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFN0b3JlIG9mZiB0aGUgbWF0Y2ggc28gd2UgY2FuIGNhbGwgaXQncyBzaG91bGRSZXZhbGlkYXRlIG9uIHN1YnNlcXVlbnRcbiAgICAvLyByZXZhbGlkYXRpb25zXG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5zZXQoa2V5LCB7IHJvdXRlSWQsIHBhdGgsIG1hdGNoLCBtYXRjaGVzIH0pO1xuICAgIGhhbmRsZUZldGNoZXJMb2FkZXIoa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgbWF0Y2hlcywgc3VibWlzc2lvbik7XG4gIH1cblxuICAvLyBDYWxsIHRoZSBhY3Rpb24gZm9yIHRoZSBtYXRjaGVkIGZldGNoZXIuc3VibWl0KCksIGFuZCB0aGVuIGhhbmRsZSByZWRpcmVjdHMsXG4gIC8vIGVycm9ycywgYW5kIHJldmFsaWRhdGlvblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaGVyQWN0aW9uKFxuICAgIGtleTogc3RyaW5nLFxuICAgIHJvdXRlSWQ6IHN0cmluZyxcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gICAgcmVxdWVzdE1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uXG4gICkge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5kZWxldGUoa2V5KTtcblxuICAgIGlmICghbWF0Y2gucm91dGUuYWN0aW9uKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgICAgcGF0aG5hbWU6IHBhdGgsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlSWQsXG4gICAgICB9KTtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQdXQgdGhpcyBmZXRjaGVyIGludG8gaXQncyBzdWJtaXR0aW5nIHN0YXRlXG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBmZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiU3VibWl0dGluZ1wiXSA9IHtcbiAgICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICAgIC4uLnN1Ym1pc3Npb24sXG4gICAgICBkYXRhOiBleGlzdGluZ0ZldGNoZXIgJiYgZXhpc3RpbmdGZXRjaGVyLmRhdGEsXG4gICAgICBcIiBfaGFzRmV0Y2hlckRvbmVBbnl0aGluZyBcIjogdHJ1ZSxcbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGZldGNoZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuXG4gICAgLy8gQ2FsbCB0aGUgYWN0aW9uIGZvciB0aGUgZmV0Y2hlclxuICAgIGxldCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IGZldGNoUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgcGF0aCxcbiAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICBzdWJtaXNzaW9uXG4gICAgKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGFib3J0Q29udHJvbGxlcik7XG5cbiAgICBsZXQgYWN0aW9uUmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgXCJhY3Rpb25cIixcbiAgICAgIGZldGNoUmVxdWVzdCxcbiAgICAgIG1hdGNoLFxuICAgICAgcmVxdWVzdE1hdGNoZXMsXG4gICAgICByb3V0ZXIuYmFzZW5hbWVcbiAgICApO1xuXG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNvIGxvbmcgYXMgd2Ugd2VyZW4ndCBhYm9ydGVkIGJ5IG91IG91ciBvd24gZmV0Y2hlclxuICAgICAgLy8gcmUtc3VibWl0IHdoaWNoIHdvdWxkIGhhdmUgcHV0IF9uZXdfIGNvbnRyb2xsZXIgaXMgaW4gZmV0Y2hDb250cm9sbGVyc1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChrZXkpO1xuICAgICAgbGV0IGxvYWRpbmdGZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgICAuLi5zdWJtaXNzaW9uLFxuICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgIFwiIF9oYXNGZXRjaGVyRG9uZUFueXRoaW5nIFwiOiB0cnVlLFxuICAgICAgfTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGxvYWRpbmdGZXRjaGVyKTtcbiAgICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuXG4gICAgICByZXR1cm4gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oc3RhdGUsIGFjdGlvblJlc3VsdCwge1xuICAgICAgICBpc0ZldGNoQWN0aW9uUmVkaXJlY3Q6IHRydWUsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGFueSBub24tcmVkaXJlY3QgZXJyb3JzIHRocm93blxuICAgIGlmIChpc0Vycm9yUmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGFjdGlvblJlc3VsdC5lcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHsgdHlwZTogXCJkZWZlci1hY3Rpb25cIiB9KTtcbiAgICB9XG5cbiAgICAvLyBTdGFydCB0aGUgZGF0YSBsb2FkIGZvciBjdXJyZW50IG1hdGNoZXMsIG9yIHRoZSBuZXh0IGxvY2F0aW9uIGlmIHdlJ3JlXG4gICAgLy8gaW4gdGhlIG1pZGRsZSBvZiBhIG5hdmlnYXRpb25cbiAgICBsZXQgbmV4dExvY2F0aW9uID0gc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiB8fCBzdGF0ZS5sb2NhdGlvbjtcbiAgICBsZXQgcmV2YWxpZGF0aW9uUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKTtcbiAgICBsZXQgbWF0Y2hlcyA9XG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlICE9PSBcImlkbGVcIlxuICAgICAgICA/IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sIGluaXQuYmFzZW5hbWUpXG4gICAgICAgIDogc3RhdGUubWF0Y2hlcztcblxuICAgIGludmFyaWFudChtYXRjaGVzLCBcIkRpZG4ndCBmaW5kIGFueSBtYXRjaGVzIGFmdGVyIGZldGNoZXIgYWN0aW9uXCIpO1xuXG4gICAgbGV0IGxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGZldGNoUmVsb2FkSWRzLnNldChrZXksIGxvYWRJZCk7XG5cbiAgICBsZXQgbG9hZEZldGNoZXI6IEZldGNoZXJTdGF0ZXNbXCJMb2FkaW5nXCJdID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgZGF0YTogYWN0aW9uUmVzdWx0LmRhdGEsXG4gICAgICAuLi5zdWJtaXNzaW9uLFxuICAgICAgXCIgX2hhc0ZldGNoZXJEb25lQW55dGhpbmcgXCI6IHRydWUsXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBsb2FkRmV0Y2hlcik7XG5cbiAgICBsZXQgW21hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzXSA9IGdldE1hdGNoZXNUb0xvYWQoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCxcbiAgICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzLFxuICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLFxuICAgICAgeyBbbWF0Y2gucm91dGUuaWRdOiBhY3Rpb25SZXN1bHQuZGF0YSB9LFxuICAgICAgdW5kZWZpbmVkLCAvLyBObyBuZWVkIHRvIHNlbmQgdGhyb3VnaCBlcnJvcnMgc2luY2Ugd2Ugc2hvcnQgY2lyY3VpdCBhYm92ZVxuICAgICAgZmV0Y2hMb2FkTWF0Y2hlc1xuICAgICk7XG5cbiAgICAvLyBQdXQgYWxsIHJldmFsaWRhdGluZyBmZXRjaGVycyBpbnRvIHRoZSBsb2FkaW5nIHN0YXRlLCBleGNlcHQgZm9yIHRoZVxuICAgIC8vIGN1cnJlbnQgZmV0Y2hlciB3aGljaCB3ZSB3YW50IHRvIGtlZXAgaW4gaXQncyBjdXJyZW50IGxvYWRpbmcgc3RhdGUgd2hpY2hcbiAgICAvLyBjb250YWlucyBpdCdzIGFjdGlvbiBzdWJtaXNzaW9uIGluZm8gKyBhY3Rpb24gZGF0YVxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzXG4gICAgICAuZmlsdGVyKChyZikgPT4gcmYua2V5ICE9PSBrZXkpXG4gICAgICAuZm9yRWFjaCgocmYpID0+IHtcbiAgICAgICAgbGV0IHN0YWxlS2V5ID0gcmYua2V5O1xuICAgICAgICBsZXQgZXhpc3RpbmdGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KHN0YWxlS2V5KTtcbiAgICAgICAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXI6IEZldGNoZXJTdGF0ZXNbXCJMb2FkaW5nXCJdID0ge1xuICAgICAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgICAgICBkYXRhOiBleGlzdGluZ0ZldGNoZXIgJiYgZXhpc3RpbmdGZXRjaGVyLmRhdGEsXG4gICAgICAgICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgXCIgX2hhc0ZldGNoZXJEb25lQW55dGhpbmcgXCI6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHN0YXRlLmZldGNoZXJzLnNldChzdGFsZUtleSwgcmV2YWxpZGF0aW5nRmV0Y2hlcik7XG4gICAgICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KHN0YWxlS2V5LCBhYm9ydENvbnRyb2xsZXIpO1xuICAgICAgfSk7XG5cbiAgICB1cGRhdGVTdGF0ZSh7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9KTtcblxuICAgIGxldCB7IHJlc3VsdHMsIGxvYWRlclJlc3VsdHMsIGZldGNoZXJSZXN1bHRzIH0gPVxuICAgICAgYXdhaXQgY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKFxuICAgICAgICBzdGF0ZS5tYXRjaGVzLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgICAgcmV2YWxpZGF0aW9uUmVxdWVzdFxuICAgICAgKTtcblxuICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHIpID0+IGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKHIua2V5KSk7XG5cbiAgICBsZXQgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QocmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0KSB7XG4gICAgICByZXR1cm4gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oc3RhdGUsIHJlZGlyZWN0KTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCB7IGxvYWRlckRhdGEsIGVycm9ycyB9ID0gcHJvY2Vzc0xvYWRlckRhdGEoXG4gICAgICBzdGF0ZSxcbiAgICAgIHN0YXRlLm1hdGNoZXMsXG4gICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgZmV0Y2hlclJlc3VsdHMsXG4gICAgICBhY3RpdmVEZWZlcnJlZHNcbiAgICApO1xuXG4gICAgbGV0IGRvbmVGZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiSWRsZVwiXSA9IHtcbiAgICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICAgIGRhdGE6IGFjdGlvblJlc3VsdC5kYXRhLFxuICAgICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICBcIiBfaGFzRmV0Y2hlckRvbmVBbnl0aGluZyBcIjogdHJ1ZSxcbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcblxuICAgIGxldCBkaWRBYm9ydEZldGNoTG9hZHMgPSBhYm9ydFN0YWxlRmV0Y2hMb2Fkcyhsb2FkSWQpO1xuXG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbiBhIG5hdmlnYXRpb24gbG9hZGluZyBzdGF0ZSBhbmQgdGhpcyBmZXRjaGVyIGlzXG4gICAgLy8gbW9yZSByZWNlbnQgdGhhbiB0aGUgbmF2aWdhdGlvbiwgd2Ugd2FudCB0aGUgbmV3ZXIgZGF0YSBzbyBhYm9ydCB0aGVcbiAgICAvLyBuYXZpZ2F0aW9uIGFuZCBjb21wbGV0ZSBpdCB3aXRoIHRoZSBmZXRjaGVyIGRhdGFcbiAgICBpZiAoXG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJlxuICAgICAgbG9hZElkID4gcGVuZGluZ05hdmlnYXRpb25Mb2FkSWRcbiAgICApIHtcbiAgICAgIGludmFyaWFudChwZW5kaW5nQWN0aW9uLCBcIkV4cGVjdGVkIHBlbmRpbmcgYWN0aW9uXCIpO1xuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuXG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24oc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UganVzdCB1cGRhdGUgd2l0aCB0aGUgZmV0Y2hlciBkYXRhLCBwcmVzZXJ2aW5nIGFueSBleGlzdGluZ1xuICAgICAgLy8gbG9hZGVyRGF0YSBmb3IgbG9hZGVycyB0aGF0IGRpZCBub3QgbmVlZCB0byByZWxvYWQuICBXZSBoYXZlIHRvXG4gICAgICAvLyBtYW51YWxseSBtZXJnZSBoZXJlIHNpbmNlIHdlIGFyZW4ndCBnb2luZyB0aHJvdWdoIGNvbXBsZXRlTmF2aWdhdGlvblxuICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGxvYWRlckRhdGE6IG1lcmdlTG9hZGVyRGF0YShcbiAgICAgICAgICBzdGF0ZS5sb2FkZXJEYXRhLFxuICAgICAgICAgIGxvYWRlckRhdGEsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBlcnJvcnNcbiAgICAgICAgKSxcbiAgICAgICAgLi4uKGRpZEFib3J0RmV0Y2hMb2FkcyA/IHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0gOiB7fSksXG4gICAgICB9KTtcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsIHRoZSBtYXRjaGVkIGxvYWRlciBmb3IgZmV0Y2hlci5sb2FkKCksIGhhbmRsaW5nIHJlZGlyZWN0cywgZXJyb3JzLCBldGMuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUZldGNoZXJMb2FkZXIoXG4gICAga2V5OiBzdHJpbmcsXG4gICAgcm91dGVJZDogc3RyaW5nLFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb25cbiAgKSB7XG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIC8vIFB1dCB0aGlzIGZldGNoZXIgaW50byBpdCdzIGxvYWRpbmcgc3RhdGVcbiAgICBsZXQgbG9hZGluZ0ZldGNoZXI6IEZldGNoZXJTdGF0ZXNbXCJMb2FkaW5nXCJdID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICAuLi5zdWJtaXNzaW9uLFxuICAgICAgZGF0YTogZXhpc3RpbmdGZXRjaGVyICYmIGV4aXN0aW5nRmV0Y2hlci5kYXRhLFxuICAgICAgXCIgX2hhc0ZldGNoZXJEb25lQW55dGhpbmcgXCI6IHRydWUsXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBsb2FkaW5nRmV0Y2hlcik7XG4gICAgdXBkYXRlU3RhdGUoeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSk7XG5cbiAgICAvLyBDYWxsIHRoZSBsb2FkZXIgZm9yIHRoaXMgZmV0Y2hlciByb3V0ZSBtYXRjaFxuICAgIGxldCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IGZldGNoUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgcGF0aCxcbiAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICApO1xuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgYWJvcnRDb250cm9sbGVyKTtcbiAgICBsZXQgcmVzdWx0OiBEYXRhUmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgXCJsb2FkZXJcIixcbiAgICAgIGZldGNoUmVxdWVzdCxcbiAgICAgIG1hdGNoLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHJvdXRlci5iYXNlbmFtZVxuICAgICk7XG5cbiAgICAvLyBEZWZlcnJlZCBpc24ndCBzdXBwb3J0ZWQgZm9yIGZldGNoZXIgbG9hZHMsIGF3YWl0IGV2ZXJ5dGhpbmcgYW5kIHRyZWF0IGl0XG4gICAgLy8gYXMgYSBub3JtYWwgbG9hZC4gIHJlc29sdmVEZWZlcnJlZERhdGEgd2lsbCByZXR1cm4gdW5kZWZpbmVkIGlmIHRoaXNcbiAgICAvLyBmZXRjaGVyIGdldHMgYWJvcnRlZCwgc28gd2UganVzdCBsZWF2ZSByZXN1bHQgdW50b3VjaGVkIGFuZCBzaG9ydCBjaXJjdWl0XG4gICAgLy8gYmVsb3cgaWYgdGhhdCBoYXBwZW5zXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgcmVzdWx0ID1cbiAgICAgICAgKGF3YWl0IHJlc29sdmVEZWZlcnJlZERhdGEocmVzdWx0LCBmZXRjaFJlcXVlc3Quc2lnbmFsLCB0cnVlKSkgfHxcbiAgICAgICAgcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFdlIGNhbiBkZWxldGUgdGhpcyBzbyBsb25nIGFzIHdlIHdlcmVuJ3QgYWJvcnRlZCBieSBvdSBvdXIgb3duIGZldGNoZXJcbiAgICAvLyByZS1sb2FkIHdoaWNoIHdvdWxkIGhhdmUgcHV0IF9uZXdfIGNvbnRyb2xsZXIgaXMgaW4gZmV0Y2hDb250cm9sbGVyc1xuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpID09PSBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgfVxuXG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb2FkZXIgdGhyZXcgYSByZWRpcmVjdCBSZXNwb25zZSwgc3RhcnQgYSBuZXcgUkVQTEFDRSBuYXZpZ2F0aW9uXG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oc3RhdGUsIHJlc3VsdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBhbnkgbm9uLXJlZGlyZWN0IGVycm9ycyB0aHJvd25cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoc3RhdGUubWF0Y2hlcywgcm91dGVJZCk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgIC8vIFRPRE86IEluIHJlbWl4LCB0aGlzIHdvdWxkIHJlc2V0IHRvIElETEVfTkFWSUdBVElPTiBpZiBpdCB3YXMgYSBjYXRjaCAtXG4gICAgICAvLyBkbyB3ZSBuZWVkIHRvIGJlaGF2ZSBhbnkgZGlmZmVyZW50bHkgd2l0aCBvdXIgbm9uLXJlZGlyZWN0IGVycm9ycz9cbiAgICAgIC8vIFdoYXQgaWYgaXQgd2FzIGEgbm9uLXJlZGlyZWN0IFJlc3BvbnNlP1xuICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycyksXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmVycm9yLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52YXJpYW50KCFpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCksIFwiVW5oYW5kbGVkIGZldGNoZXIgZGVmZXJyZWQgZGF0YVwiKTtcblxuICAgIC8vIFB1dCB0aGUgZmV0Y2hlciBiYWNrIGludG8gYW4gaWRsZSBzdGF0ZVxuICAgIGxldCBkb25lRmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIklkbGVcIl0gPSB7XG4gICAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgICBkYXRhOiByZXN1bHQuZGF0YSxcbiAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgXCIgX2hhc0ZldGNoZXJEb25lQW55dGhpbmcgXCI6IHRydWUsXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgdXBkYXRlU3RhdGUoeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBoYW5kbGUgcmVkaXJlY3RzIHJldHVybmVkIGZyb20gYW4gYWN0aW9uIG9yIGxvYWRlci5cbiAgICogTm9ybWFsbHksIGEgcmVkaXJlY3QgXCJyZXBsYWNlc1wiIHRoZSBuYXZpZ2F0aW9uIHRoYXQgdHJpZ2dlcmVkIGl0LiAgU28sIGZvclxuICAgKiBleGFtcGxlOlxuICAgKlxuICAgKiAgLSB1c2VyIGlzIG9uIC9hXG4gICAqICAtIHVzZXIgY2xpY2tzIGEgbGluayB0byAvYlxuICAgKiAgLSBsb2FkZXIgZm9yIC9iIHJlZGlyZWN0cyB0byAvY1xuICAgKlxuICAgKiBJbiBhIG5vbi1KUyBhcHAgdGhlIGJyb3dzZXIgd291bGQgdHJhY2sgdGhlIGluLWZsaWdodCBuYXZpZ2F0aW9uIHRvIC9iIGFuZFxuICAgKiB0aGVuIHJlcGxhY2UgaXQgd2l0aCAvYyB3aGVuIGl0IGVuY291bnRlcmVkIHRoZSByZWRpcmVjdCByZXNwb25zZS4gIEluXG4gICAqIHRoZSBlbmQgaXQgd291bGQgb25seSBldmVyIHVwZGF0ZSB0aGUgVVJMIGJhciB3aXRoIC9jLlxuICAgKlxuICAgKiBJbiBjbGllbnQtc2lkZSByb3V0aW5nIHVzaW5nIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGUsIHdlIGFpbSB0byBlbXVsYXRlXG4gICAqIHRoaXMgYmVoYXZpb3IgYW5kIHdlIGFsc28gZG8gbm90IHVwZGF0ZSBoaXN0b3J5IHVudGlsIHRoZSBlbmQgb2YgdGhlXG4gICAqIG5hdmlnYXRpb24gKGluY2x1ZGluZyBwcm9jZXNzZWQgcmVkaXJlY3RzKS4gIFRoaXMgbWVhbnMgdGhhdCB3ZSBuZXZlclxuICAgKiBhY3R1YWxseSB0b3VjaCBoaXN0b3J5IHVudGlsIHdlJ3ZlIHByb2Nlc3NlZCByZWRpcmVjdHMsIHNvIHdlIGp1c3QgdXNlXG4gICAqIHRoZSBoaXN0b3J5IGFjdGlvbiBmcm9tIHRoZSBvcmlnaW5hbCBuYXZpZ2F0aW9uIChQVVNIIG9yIFJFUExBQ0UpLlxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oXG4gICAgc3RhdGU6IFJvdXRlclN0YXRlLFxuICAgIHJlZGlyZWN0OiBSZWRpcmVjdFJlc3VsdCxcbiAgICB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgcmVwbGFjZSxcbiAgICAgIGlzRmV0Y2hBY3Rpb25SZWRpcmVjdCxcbiAgICB9OiB7XG4gICAgICBzdWJtaXNzaW9uPzogU3VibWlzc2lvbjtcbiAgICAgIHJlcGxhY2U/OiBib29sZWFuO1xuICAgICAgaXNGZXRjaEFjdGlvblJlZGlyZWN0PzogYm9vbGVhbjtcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgaWYgKHJlZGlyZWN0LnJldmFsaWRhdGUpIHtcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCByZWRpcmVjdExvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXG4gICAgICBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIHJlZGlyZWN0LmxvY2F0aW9uLFxuICAgICAgLy8gVE9ETzogVGhpcyBjYW4gYmUgcmVtb3ZlZCBvbmNlIHdlIGdldCByaWQgb2YgdXNlVHJhbnNpdGlvbiBpbiBSZW1peCB2MlxuICAgICAge1xuICAgICAgICBfaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgLi4uKGlzRmV0Y2hBY3Rpb25SZWRpcmVjdCA/IHsgX2lzRmV0Y2hBY3Rpb25SZWRpcmVjdDogdHJ1ZSB9IDoge30pLFxuICAgICAgfVxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgcmVkaXJlY3RMb2NhdGlvbixcbiAgICAgIFwiRXhwZWN0ZWQgYSBsb2NhdGlvbiBvbiB0aGUgcmVkaXJlY3QgbmF2aWdhdGlvblwiXG4gICAgKTtcblxuICAgIC8vIENoZWNrIGlmIHRoaXMgYW4gYWJzb2x1dGUgZXh0ZXJuYWwgcmVkaXJlY3QgdGhhdCBnb2VzIHRvIGEgbmV3IG9yaWdpblxuICAgIGlmIChcbiAgICAgIEFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KHJlZGlyZWN0LmxvY2F0aW9uKSAmJlxuICAgICAgaXNCcm93c2VyICYmXG4gICAgICB0eXBlb2Ygd2luZG93Py5sb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICkge1xuICAgICAgbGV0IG5ld09yaWdpbiA9IGluaXQuaGlzdG9yeS5jcmVhdGVVUkwocmVkaXJlY3QubG9jYXRpb24pLm9yaWdpbjtcbiAgICAgIGlmICh3aW5kb3cubG9jYXRpb24ub3JpZ2luICE9PSBuZXdPcmlnaW4pIHtcbiAgICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBhYm9ydCBvbiByZWRpcmVjdHMsIHNpbmNlIHdlIGRvbid0IGRldGVjdCB0aGVcbiAgICAvLyByZWRpcmVjdCB1bnRpbCB0aGUgYWN0aW9uL2xvYWRlcnMgaGF2ZSBzZXR0bGVkXG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcblxuICAgIGxldCByZWRpcmVjdEhpc3RvcnlBY3Rpb24gPVxuICAgICAgcmVwbGFjZSA9PT0gdHJ1ZSA/IEhpc3RvcnlBY3Rpb24uUmVwbGFjZSA6IEhpc3RvcnlBY3Rpb24uUHVzaDtcblxuICAgIC8vIFVzZSB0aGUgaW5jb21pbmcgc3VibWlzc2lvbiBpZiBwcm92aWRlZCwgZmFsbGJhY2sgb24gdGhlIGFjdGl2ZSBvbmUgaW5cbiAgICAvLyBzdGF0ZS5uYXZpZ2F0aW9uXG4gICAgbGV0IHsgZm9ybU1ldGhvZCwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUsIGZvcm1EYXRhIH0gPSBzdGF0ZS5uYXZpZ2F0aW9uO1xuICAgIGlmICghc3VibWlzc2lvbiAmJiBmb3JtTWV0aG9kICYmIGZvcm1BY3Rpb24gJiYgZm9ybURhdGEgJiYgZm9ybUVuY1R5cGUpIHtcbiAgICAgIHN1Ym1pc3Npb24gPSB7XG4gICAgICAgIGZvcm1NZXRob2QsXG4gICAgICAgIGZvcm1BY3Rpb24sXG4gICAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgICBmb3JtRGF0YSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyB3YXMgYSAzMDcvMzA4IHN1Ym1pc3Npb24gd2Ugd2FudCB0byBwcmVzZXJ2ZSB0aGUgSFRUUCBtZXRob2QgYW5kXG4gICAgLy8gcmUtc3VibWl0IHRoZSBHRVQvUE9TVC9QVVQvUEFUQ0gvREVMRVRFIGFzIGEgc3VibWlzc2lvbiBuYXZpZ2F0aW9uIHRvIHRoZVxuICAgIC8vIHJlZGlyZWN0ZWQgbG9jYXRpb25cbiAgICBpZiAoXG4gICAgICByZWRpcmVjdFByZXNlcnZlTWV0aG9kU3RhdHVzQ29kZXMuaGFzKHJlZGlyZWN0LnN0YXR1cykgJiZcbiAgICAgIHN1Ym1pc3Npb24gJiZcbiAgICAgIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKVxuICAgICkge1xuICAgICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKHJlZGlyZWN0SGlzdG9yeUFjdGlvbiwgcmVkaXJlY3RMb2NhdGlvbiwge1xuICAgICAgICBzdWJtaXNzaW9uOiB7XG4gICAgICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgICAgICBmb3JtQWN0aW9uOiByZWRpcmVjdC5sb2NhdGlvbixcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUHJlc2VydmUgdGhpcyBmbGFnIGFjcm9zcyByZWRpcmVjdHNcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgd2Uga2ljayBvZmYgYSBuZXcgbG9hZGluZyBuYXZpZ2F0aW9uLCBwcmVzZXJ2aW5nIHRoZVxuICAgICAgLy8gc3VibWlzc2lvbiBpbmZvIGZvciB0aGUgZHVyYXRpb24gb2YgdGhpcyBuYXZpZ2F0aW9uXG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3RIaXN0b3J5QWN0aW9uLCByZWRpcmVjdExvY2F0aW9uLCB7XG4gICAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbjoge1xuICAgICAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgICAgICBsb2NhdGlvbjogcmVkaXJlY3RMb2NhdGlvbixcbiAgICAgICAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uID8gc3VibWlzc2lvbi5mb3JtTWV0aG9kIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24gPyBzdWJtaXNzaW9uLmZvcm1BY3Rpb24gOiB1bmRlZmluZWQsXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24gPyBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uID8gc3VibWlzc2lvbi5mb3JtRGF0YSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUHJlc2VydmUgdGhpcyBmbGFnIGFjcm9zcyByZWRpcmVjdHNcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKFxuICAgIGN1cnJlbnRNYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIG1hdGNoZXNUb0xvYWQ6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBmZXRjaGVyc1RvTG9hZDogUmV2YWxpZGF0aW5nRmV0Y2hlcltdLFxuICAgIHJlcXVlc3Q6IFJlcXVlc3RcbiAgKSB7XG4gICAgLy8gQ2FsbCBhbGwgbmF2aWdhdGlvbiBsb2FkZXJzIGFuZCByZXZhbGlkYXRpbmcgZmV0Y2hlciBsb2FkZXJzIGluIHBhcmFsbGVsLFxuICAgIC8vIHRoZW4gc2xpY2Ugb2ZmIHRoZSByZXN1bHRzIGludG8gc2VwYXJhdGUgYXJyYXlzIHNvIHdlIGNhbiBoYW5kbGUgdGhlbVxuICAgIC8vIGFjY29yZGluZ2x5XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAuLi5tYXRjaGVzVG9Mb2FkLm1hcCgobWF0Y2gpID0+XG4gICAgICAgIGNhbGxMb2FkZXJPckFjdGlvbihcImxvYWRlclwiLCByZXF1ZXN0LCBtYXRjaCwgbWF0Y2hlcywgcm91dGVyLmJhc2VuYW1lKVxuICAgICAgKSxcbiAgICAgIC4uLmZldGNoZXJzVG9Mb2FkLm1hcCgoZikgPT5cbiAgICAgICAgY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgICAgIFwibG9hZGVyXCIsXG4gICAgICAgICAgY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaW5pdC5oaXN0b3J5LCBmLnBhdGgsIHJlcXVlc3Quc2lnbmFsKSxcbiAgICAgICAgICBmLm1hdGNoLFxuICAgICAgICAgIGYubWF0Y2hlcyxcbiAgICAgICAgICByb3V0ZXIuYmFzZW5hbWVcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICBdKTtcbiAgICBsZXQgbG9hZGVyUmVzdWx0cyA9IHJlc3VsdHMuc2xpY2UoMCwgbWF0Y2hlc1RvTG9hZC5sZW5ndGgpO1xuICAgIGxldCBmZXRjaGVyUmVzdWx0cyA9IHJlc3VsdHMuc2xpY2UobWF0Y2hlc1RvTG9hZC5sZW5ndGgpO1xuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgcmVzb2x2ZURlZmVycmVkUmVzdWx0cyhcbiAgICAgICAgY3VycmVudE1hdGNoZXMsXG4gICAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgc3RhdGUubG9hZGVyRGF0YVxuICAgICAgKSxcbiAgICAgIHJlc29sdmVEZWZlcnJlZFJlc3VsdHMoXG4gICAgICAgIGN1cnJlbnRNYXRjaGVzLFxuICAgICAgICBmZXRjaGVyc1RvTG9hZC5tYXAoKGYpID0+IGYubWF0Y2gpLFxuICAgICAgICBmZXRjaGVyUmVzdWx0cyxcbiAgICAgICAgcmVxdWVzdC5zaWduYWwsXG4gICAgICAgIHRydWVcbiAgICAgICksXG4gICAgXSk7XG5cbiAgICByZXR1cm4geyByZXN1bHRzLCBsb2FkZXJSZXN1bHRzLCBmZXRjaGVyUmVzdWx0cyB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJydXB0QWN0aXZlTG9hZHMoKSB7XG4gICAgLy8gRXZlcnkgaW50ZXJydXB0aW9uIHRyaWdnZXJzIGEgcmV2YWxpZGF0aW9uXG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IHRydWU7XG5cbiAgICAvLyBDYW5jZWwgcGVuZGluZyByb3V0ZS1sZXZlbCBkZWZlcnJlZHMgYW5kIG1hcmsgY2FuY2VsbGVkIHJvdXRlcyBmb3JcbiAgICAvLyByZXZhbGlkYXRpb25cbiAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcy5wdXNoKC4uLmNhbmNlbEFjdGl2ZURlZmVycmVkcygpKTtcblxuICAgIC8vIEFib3J0IGluLWZsaWdodCBmZXRjaGVyIGxvYWRzXG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5mb3JFYWNoKChfLCBrZXkpID0+IHtcbiAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5wdXNoKGtleSk7XG4gICAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0RmV0Y2hlckVycm9yKGtleTogc3RyaW5nLCByb3V0ZUlkOiBzdHJpbmcsIGVycm9yOiBhbnkpIHtcbiAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoc3RhdGUubWF0Y2hlcywgcm91dGVJZCk7XG4gICAgZGVsZXRlRmV0Y2hlcihrZXkpO1xuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGVycm9yczoge1xuICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IGVycm9yLFxuICAgICAgfSxcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSxcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUZldGNoZXIoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaFJlZGlyZWN0SWRzLmRlbGV0ZShrZXkpO1xuICAgIHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWJvcnRGZXRjaGVyKGtleTogc3RyaW5nKSB7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpO1xuICAgIGludmFyaWFudChjb250cm9sbGVyLCBgRXhwZWN0ZWQgZmV0Y2ggY29udHJvbGxlcjogJHtrZXl9YCk7XG4gICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrRmV0Y2hlcnNEb25lKGtleXM6IHN0cmluZ1tdKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgIGxldCBmZXRjaGVyID0gZ2V0RmV0Y2hlcihrZXkpO1xuICAgICAgbGV0IGRvbmVGZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiSWRsZVwiXSA9IHtcbiAgICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgICBkYXRhOiBmZXRjaGVyLmRhdGEsXG4gICAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgICBcIiBfaGFzRmV0Y2hlckRvbmVBbnl0aGluZyBcIjogdHJ1ZSxcbiAgICAgIH07XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpOiB2b2lkIHtcbiAgICBsZXQgZG9uZUtleXMgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgb2YgZmV0Y2hSZWRpcmVjdElkcykge1xuICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgIGludmFyaWFudChmZXRjaGVyLCBgRXhwZWN0ZWQgZmV0Y2hlcjogJHtrZXl9YCk7XG4gICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICAgICAgZG9uZUtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXJrRmV0Y2hlcnNEb25lKGRvbmVLZXlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0U3RhbGVGZXRjaExvYWRzKGxhbmRlZElkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBsZXQgeWVldGVkS2V5cyA9IFtdO1xuICAgIGZvciAobGV0IFtrZXksIGlkXSBvZiBmZXRjaFJlbG9hZElkcykge1xuICAgICAgaWYgKGlkIDwgbGFuZGVkSWQpIHtcbiAgICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgICAgaW52YXJpYW50KGZldGNoZXIsIGBFeHBlY3RlZCBmZXRjaGVyOiAke2tleX1gKTtcbiAgICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgICAgICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgeWVldGVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbWFya0ZldGNoZXJzRG9uZSh5ZWV0ZWRLZXlzKTtcbiAgICByZXR1cm4geWVldGVkS2V5cy5sZW5ndGggPiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QmxvY2tlcihrZXk6IHN0cmluZywgZm46IEJsb2NrZXJGdW5jdGlvbikge1xuICAgIGxldCBibG9ja2VyOiBCbG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGtleSkgfHwgSURMRV9CTE9DS0VSO1xuXG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuZ2V0KGtleSkgIT09IGZuKSB7XG4gICAgICBibG9ja2VyRnVuY3Rpb25zLnNldChrZXksIGZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2tlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUJsb2NrZXIoa2V5OiBzdHJpbmcpIHtcbiAgICBzdGF0ZS5ibG9ja2Vycy5kZWxldGUoa2V5KTtcbiAgICBibG9ja2VyRnVuY3Rpb25zLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBmdW5jdGlvbiB0byB1cGRhdGUgYmxvY2tlcnMsIGVuc3VyaW5nIHZhbGlkIHN0YXRlIHRyYW5zaXRpb25zXG4gIGZ1bmN0aW9uIHVwZGF0ZUJsb2NrZXIoa2V5OiBzdHJpbmcsIG5ld0Jsb2NrZXI6IEJsb2NrZXIpIHtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChrZXkpIHx8IElETEVfQkxPQ0tFUjtcblxuICAgIC8vIFBvb3IgbWFucyBzdGF0ZSBtYWNoaW5lIDopXG4gICAgLy8gaHR0cHM6Ly9tZXJtYWlkLmxpdmUvZWRpdCNwYWtvOmVOcVZrYzlPd3pBTXhsOGw4bm5qQVlyRXRESU9IRUJJZ3d2S0pUUmVHeTNfbERwSXFPMjdrNmF3TUcwWGNyTGxuejg3bndkb25FU29nS1hYQnVFNzlycTc1WFpPMy15SGRzMFJKVnV2NzBZclBsVXJDRWUySGZyT1JTM3J1YnFaZnVodHBnNUM5d2s1dFo0VktjUlVxODhxOVo4UlMwLTQ4Y0UxaUhKa0wwdWdiSHVGTHVzOUw2c3BaeThuWDlNUDJDTmRvbVZhcG9zcXUzZkdheVQ4VDgtakpRd2hlcG9fVXRwZ0JRYURFVW9tMDRkWmhBTjFhSkJEbFVLSkJ4RTFjZUIyU21qME1sbi1JQlc1QUZVMmR3VWlrdHRfMlFhcTJkQmZhS2RFdXA4NVVWN1lkLWRLamxua2FibDJQdnIwRFRrVHJlTVxuICAgIGludmFyaWFudChcbiAgICAgIChibG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiKSB8fFxuICAgICAgICAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIpIHx8XG4gICAgICAgIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIikgfHxcbiAgICAgICAgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIpIHx8XG4gICAgICAgIChibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiKSxcbiAgICAgIGBJbnZhbGlkIGJsb2NrZXIgc3RhdGUgdHJhbnNpdGlvbjogJHtibG9ja2VyLnN0YXRlfSAtPiAke25ld0Jsb2NrZXIuc3RhdGV9YFxuICAgICk7XG5cbiAgICBzdGF0ZS5ibG9ja2Vycy5zZXQoa2V5LCBuZXdCbG9ja2VyKTtcbiAgICB1cGRhdGVTdGF0ZSh7IGJsb2NrZXJzOiBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKSB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgY3VycmVudExvY2F0aW9uLFxuICAgIG5leHRMb2NhdGlvbixcbiAgICBoaXN0b3J5QWN0aW9uLFxuICB9OiB7XG4gICAgY3VycmVudExvY2F0aW9uOiBMb2NhdGlvbjtcbiAgICBuZXh0TG9jYXRpb246IExvY2F0aW9uO1xuICAgIGhpc3RvcnlBY3Rpb246IEhpc3RvcnlBY3Rpb247XG4gIH0pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXZSBvbnkgc3VwcG9ydCBhIHNpbmdsZSBhY3RpdmUgYmxvY2tlciBhdCB0aGUgbW9tZW50IHNpbmNlIHdlIGRvbid0IGhhdmVcbiAgICAvLyBhbnkgY29tcGVsbGluZyB1c2UgY2FzZXMgZm9yIG11bHRpLWJsb2NrZXIgeWV0XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA+IDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiQSByb3V0ZXIgb25seSBzdXBwb3J0cyBvbmUgYmxvY2tlciBhdCBhIHRpbWVcIik7XG4gICAgfVxuXG4gICAgbGV0IGVudHJpZXMgPSBBcnJheS5mcm9tKGJsb2NrZXJGdW5jdGlvbnMuZW50cmllcygpKTtcbiAgICBsZXQgW2Jsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbl0gPSBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV07XG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoYmxvY2tlcktleSk7XG5cbiAgICBpZiAoYmxvY2tlciAmJiBibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIikge1xuICAgICAgLy8gSWYgdGhlIGJsb2NrZXIgaXMgY3VycmVudGx5IHByb2NlZWRpbmcsIHdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2tcbiAgICAgIC8vIGl0IGFuZCBjYW4gbGV0IHRoaXMgbmF2aWdhdGlvbiBjb250aW51ZVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGtub3cgd2UncmUgdW5ibG9ja2VkL2Jsb2NrZWQgc28gd2UgbmVlZCB0byBjaGVjayB0aGVcbiAgICAvLyB1c2VyLXByb3ZpZGVkIGJsb2NrZXIgZnVuY3Rpb25cbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9uKHsgY3VycmVudExvY2F0aW9uLCBuZXh0TG9jYXRpb24sIGhpc3RvcnlBY3Rpb24gfSkpIHtcbiAgICAgIHJldHVybiBibG9ja2VyS2V5O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbEFjdGl2ZURlZmVycmVkcyhcbiAgICBwcmVkaWNhdGU/OiAocm91dGVJZDogc3RyaW5nKSA9PiBib29sZWFuXG4gICk6IHN0cmluZ1tdIHtcbiAgICBsZXQgY2FuY2VsbGVkUm91dGVJZHM6IHN0cmluZ1tdID0gW107XG4gICAgYWN0aXZlRGVmZXJyZWRzLmZvckVhY2goKGRmZCwgcm91dGVJZCkgPT4ge1xuICAgICAgaWYgKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlKHJvdXRlSWQpKSB7XG4gICAgICAgIC8vIENhbmNlbCB0aGUgZGVmZXJyZWQgLSBidXQgZG8gbm90IHJlbW92ZSBmcm9tIGFjdGl2ZURlZmVycmVkcyBoZXJlIC1cbiAgICAgICAgLy8gd2UgcmVseSBvbiB0aGUgc3Vic2NyaWJlcnMgdG8gZG8gdGhhdCBzbyBvdXIgdGVzdHMgY2FuIGFzc2VydCBwcm9wZXJcbiAgICAgICAgLy8gY2xlYW51cCB2aWEgX2ludGVybmFsQWN0aXZlRGVmZXJyZWRzXG4gICAgICAgIGRmZC5jYW5jZWwoKTtcbiAgICAgICAgY2FuY2VsbGVkUm91dGVJZHMucHVzaChyb3V0ZUlkKTtcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzLmRlbGV0ZShyb3V0ZUlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2FuY2VsbGVkUm91dGVJZHM7XG4gIH1cblxuICAvLyBPcHQgaW4gdG8gY2FwdHVyaW5nIGFuZCByZXBvcnRpbmcgc2Nyb2xsIHBvc2l0aW9ucyBkdXJpbmcgbmF2aWdhdGlvbnMsXG4gIC8vIHVzZWQgYnkgdGhlIDxTY3JvbGxSZXN0b3JhdGlvbj4gY29tcG9uZW50XG4gIGZ1bmN0aW9uIGVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uKFxuICAgIHBvc2l0aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgICBnZXRQb3NpdGlvbjogR2V0U2Nyb2xsUG9zaXRpb25GdW5jdGlvbixcbiAgICBnZXRLZXk/OiBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uXG4gICkge1xuICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgIGdldFNjcm9sbFBvc2l0aW9uID0gZ2V0UG9zaXRpb247XG4gICAgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkgPSBnZXRLZXkgfHwgKChsb2NhdGlvbikgPT4gbG9jYXRpb24ua2V5KTtcblxuICAgIC8vIFBlcmZvcm0gaW5pdGlhbCBoeWRyYXRpb24gc2Nyb2xsIHJlc3RvcmF0aW9uLCBzaW5jZSB3ZSBtaXNzIHRoZSBib2F0IG9uXG4gICAgLy8gdGhlIGluaXRpYWwgdXBkYXRlU3RhdGUoKSBiZWNhdXNlIHdlJ3ZlIG5vdCB5ZXQgcmVuZGVyZWQgPFNjcm9sbFJlc3RvcmF0aW9uLz5cbiAgICAvLyBhbmQgdGhlcmVmb3JlIGhhdmUgbm8gc2F2ZWRTY3JvbGxQb3NpdGlvbnMgYXZhaWxhYmxlXG4gICAgaWYgKCFpbml0aWFsU2Nyb2xsUmVzdG9yZWQgJiYgc3RhdGUubmF2aWdhdGlvbiA9PT0gSURMRV9OQVZJR0FUSU9OKSB7XG4gICAgICBpbml0aWFsU2Nyb2xsUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgbGV0IHkgPSBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlU3RhdGUoeyByZXN0b3JlU2Nyb2xsUG9zaXRpb246IHkgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gbnVsbDtcbiAgICAgIGdldFNjcm9sbFBvc2l0aW9uID0gbnVsbDtcbiAgICAgIGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5ID0gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uKFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW11cbiAgKTogdm9pZCB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zICYmIGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5ICYmIGdldFNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICBsZXQgdXNlck1hdGNoZXMgPSBtYXRjaGVzLm1hcCgobSkgPT5cbiAgICAgICAgY3JlYXRlVXNlTWF0Y2hlc01hdGNoKG0sIHN0YXRlLmxvYWRlckRhdGEpXG4gICAgICApO1xuICAgICAgbGV0IGtleSA9IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5KGxvY2F0aW9uLCB1c2VyTWF0Y2hlcykgfHwgbG9jYXRpb24ua2V5O1xuICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XSA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdXG4gICk6IG51bWJlciB8IG51bGwge1xuICAgIGlmIChzYXZlZFNjcm9sbFBvc2l0aW9ucyAmJiBnZXRTY3JvbGxSZXN0b3JhdGlvbktleSAmJiBnZXRTY3JvbGxQb3NpdGlvbikge1xuICAgICAgbGV0IHVzZXJNYXRjaGVzID0gbWF0Y2hlcy5tYXAoKG0pID0+XG4gICAgICAgIGNyZWF0ZVVzZU1hdGNoZXNNYXRjaChtLCBzdGF0ZS5sb2FkZXJEYXRhKVxuICAgICAgKTtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShsb2NhdGlvbiwgdXNlck1hdGNoZXMpIHx8IGxvY2F0aW9uLmtleTtcbiAgICAgIGxldCB5ID0gc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgeSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4geTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByb3V0ZXIgPSB7XG4gICAgZ2V0IGJhc2VuYW1lKCkge1xuICAgICAgcmV0dXJuIGluaXQuYmFzZW5hbWU7XG4gICAgfSxcbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcbiAgICBnZXQgcm91dGVzKCkge1xuICAgICAgcmV0dXJuIGRhdGFSb3V0ZXM7XG4gICAgfSxcbiAgICBpbml0aWFsaXplLFxuICAgIHN1YnNjcmliZSxcbiAgICBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbixcbiAgICBuYXZpZ2F0ZSxcbiAgICBmZXRjaCxcbiAgICByZXZhbGlkYXRlLFxuICAgIC8vIFBhc3N0aHJvdWdoIHRvIGhpc3RvcnktYXdhcmUgY3JlYXRlSHJlZiB1c2VkIGJ5IHVzZUhyZWYgc28gd2UgZ2V0IHByb3BlclxuICAgIC8vIGhhc2gtYXdhcmUgVVJMcyBpbiBET00gcGF0aHNcbiAgICBjcmVhdGVIcmVmOiAodG86IFRvKSA9PiBpbml0Lmhpc3RvcnkuY3JlYXRlSHJlZih0byksXG4gICAgZW5jb2RlTG9jYXRpb246ICh0bzogVG8pID0+IGluaXQuaGlzdG9yeS5lbmNvZGVMb2NhdGlvbih0byksXG4gICAgZ2V0RmV0Y2hlcixcbiAgICBkZWxldGVGZXRjaGVyLFxuICAgIGRpc3Bvc2UsXG4gICAgZ2V0QmxvY2tlcixcbiAgICBkZWxldGVCbG9ja2VyLFxuICAgIF9pbnRlcm5hbEZldGNoQ29udHJvbGxlcnM6IGZldGNoQ29udHJvbGxlcnMsXG4gICAgX2ludGVybmFsQWN0aXZlRGVmZXJyZWRzOiBhY3RpdmVEZWZlcnJlZHMsXG4gIH07XG5cbiAgcmV0dXJuIHJvdXRlcjtcbn1cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBjb25zdCBVTlNBRkVfREVGRVJSRURfU1lNQk9MID0gU3ltYm9sKFwiZGVmZXJyZWRcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdGF0aWNIYW5kbGVyKFxuICByb3V0ZXM6IEFnbm9zdGljUm91dGVPYmplY3RbXSxcbiAgb3B0cz86IHtcbiAgICBiYXNlbmFtZT86IHN0cmluZztcbiAgfVxuKTogU3RhdGljSGFuZGxlciB7XG4gIGludmFyaWFudChcbiAgICByb3V0ZXMubGVuZ3RoID4gMCxcbiAgICBcIllvdSBtdXN0IHByb3ZpZGUgYSBub24tZW1wdHkgcm91dGVzIGFycmF5IHRvIGNyZWF0ZVN0YXRpY0hhbmRsZXJcIlxuICApO1xuXG4gIGxldCBkYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhyb3V0ZXMpO1xuICBsZXQgYmFzZW5hbWUgPSAob3B0cyA/IG9wdHMuYmFzZW5hbWUgOiBudWxsKSB8fCBcIi9cIjtcblxuICAvKipcbiAgICogVGhlIHF1ZXJ5KCkgbWV0aG9kIGlzIGludGVuZGVkIGZvciBkb2N1bWVudCByZXF1ZXN0cywgaW4gd2hpY2ggd2Ugd2FudCB0b1xuICAgKiBjYWxsIGFuIG9wdGlvbmFsIGFjdGlvbiBhbmQgcG90ZW50aWFsbHkgbXVsdGlwbGUgbG9hZGVycyBmb3IgYWxsIG5lc3RlZFxuICAgKiByb3V0ZXMuICBJdCByZXR1cm5zIGEgU3RhdGljSGFuZGxlckNvbnRleHQgb2JqZWN0LCB3aGljaCBpcyB2ZXJ5IHNpbWlsYXJcbiAgICogdG8gdGhlIHJvdXRlciBzdGF0ZSAobG9jYXRpb24sIGxvYWRlckRhdGEsIGFjdGlvbkRhdGEsIGVycm9ycywgZXRjLikgYW5kXG4gICAqIGFsc28gYWRkcyBTU1Itc3BlY2lmaWMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgc3RhdHVzQ29kZSBhbmQgaGVhZGVyc1xuICAgKiBmcm9tIGFjdGlvbi9sb2FkZXJzIFJlc3BvbnNlcy5cbiAgICpcbiAgICogSXQgX3Nob3VsZF8gbmV2ZXIgdGhyb3cgYW5kIHNob3VsZCByZXBvcnQgYWxsIGVycm9ycyB0aHJvdWdoIHRoZVxuICAgKiByZXR1cm5lZCBjb250ZXh0LmVycm9ycyBvYmplY3QsIHByb3Blcmx5IGFzc29jaWF0aW5nIGVycm9ycyB0byB0aGVpciBlcnJvclxuICAgKiBib3VuZGFyeS4gIEFkZGl0aW9uYWxseSwgaXQgdHJhY2tzIF9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIHdoaWNoIGNhbiBiZVxuICAgKiB1c2VkIHRvIGVtdWxhdGUgUmVhY3QgZXJyb3IgYm91bmRhcmllcyBkdXJpbmcgU1NyIGJ5IHBlcmZvcm1pbmcgYSBzZWNvbmRcbiAgICogcGFzcyBvbmx5IGRvd24gdG8gdGhlIGJvdW5kYXJ5SWQuXG4gICAqXG4gICAqIFRoZSBvbmUgZXhjZXB0aW9uIHdoZXJlIHdlIGRvIG5vdCByZXR1cm4gYSBTdGF0aWNIYW5kbGVyQ29udGV4dCBpcyB3aGVuIGFcbiAgICogcmVkaXJlY3QgcmVzcG9uc2UgaXMgcmV0dXJuZWQgb3IgdGhyb3duIGZyb20gYW55IGFjdGlvbi9sb2FkZXIuICBXZVxuICAgKiBwcm9wYWdhdGUgdGhhdCBvdXQgYW5kIHJldHVybiB0aGUgcmF3IFJlc3BvbnNlIHNvIHRoZSBIVFRQIHNlcnZlciBjYW5cbiAgICogcmV0dXJuIGl0IGRpcmVjdGx5LlxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnkoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICB7IHJlcXVlc3RDb250ZXh0IH06IHsgcmVxdWVzdENvbnRleHQ/OiB1bmtub3duIH0gPSB7fVxuICApOiBQcm9taXNlPFN0YXRpY0hhbmRsZXJDb250ZXh0IHwgUmVzcG9uc2U+IHtcbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXCJcIiwgY3JlYXRlUGF0aCh1cmwpLCBudWxsLCBcImRlZmF1bHRcIik7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuXG4gICAgLy8gU1NSIHN1cHBvcnRzIEhFQUQgcmVxdWVzdHMgd2hpbGUgU1BBIGRvZXNuJ3RcbiAgICBpZiAoIWlzVmFsaWRNZXRob2QobWV0aG9kKSAmJiBtZXRob2QgIT09IFwiaGVhZFwiKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwgeyBtZXRob2QgfSk7XG4gICAgICBsZXQgeyBtYXRjaGVzOiBtZXRob2ROb3RBbGxvd2VkTWF0Y2hlcywgcm91dGUgfSA9XG4gICAgICAgIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IG1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3IsXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1c0NvZGU6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9LFxuICAgICAgICBhY3RpdmVEZWZlcnJlZHM6IG51bGwsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSB9KTtcbiAgICAgIGxldCB7IG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcywgcm91dGUgfSA9XG4gICAgICAgIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yLFxuICAgICAgICB9LFxuICAgICAgICBzdGF0dXNDb2RlOiBlcnJvci5zdGF0dXMsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcXVlcnlJbXBsKHJlcXVlc3QsIGxvY2F0aW9uLCBtYXRjaGVzLCByZXF1ZXN0Q29udGV4dCk7XG4gICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBXaGVuIHJldHVybmluZyBTdGF0aWNIYW5kbGVyQ29udGV4dCwgd2UgcGF0Y2ggYmFjayBpbiB0aGUgbG9jYXRpb24gaGVyZVxuICAgIC8vIHNpbmNlIHdlIG5lZWQgaXQgZm9yIFJlYWN0IENvbnRleHQuICBCdXQgdGhpcyBoZWxwcyBrZWVwIG91ciBzdWJtaXQgYW5kXG4gICAgLy8gbG9hZFJvdXRlRGF0YSBvcGVyYXRpbmcgb24gYSBSZXF1ZXN0IGluc3RlYWQgb2YgYSBMb2NhdGlvblxuICAgIHJldHVybiB7IGxvY2F0aW9uLCBiYXNlbmFtZSwgLi4ucmVzdWx0IH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIHF1ZXJ5Um91dGUoKSBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIHRhcmdldGVkIHJvdXRlIHJlcXVlc3RzLCBlaXRoZXJcbiAgICogZm9yIGZldGNoID9fZGF0YSByZXF1ZXN0cyBvciByZXNvdXJjZSByb3V0ZSByZXF1ZXN0cy4gIEluIHRoaXMgY2FzZSwgd2VcbiAgICogYXJlIG9ubHkgZXZlciBjYWxsaW5nIGEgc2luZ2xlIGFjdGlvbiBvciBsb2FkZXIsIGFuZCB3ZSBhcmUgcmV0dXJuaW5nIHRoZVxuICAgKiByZXR1cm5lZCB2YWx1ZSBkaXJlY3RseS4gIEluIG1vc3QgY2FzZXMsIHRoaXMgd2lsbCBiZSBhIFJlc3BvbnNlIHJldHVybmVkXG4gICAqIGZyb20gdGhlIGFjdGlvbi9sb2FkZXIsIGJ1dCBpdCBtYXkgYmUgYSBwcmltaXRpdmUgb3Igb3RoZXIgdmFsdWUgYXMgd2VsbCAtXG4gICAqIGFuZCBpbiBzdWNoIGNhc2VzIHRoZSBjYWxsaW5nIGNvbnRleHQgc2hvdWxkIGhhbmRsZSB0aGF0IGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBXZSBkbyByZXNwZWN0IHRoZSB0aHJvdy9yZXR1cm4gZGlmZmVyZW50aWF0aW9uLCBzbyBpZiBhbiBhY3Rpb24vbG9hZGVyXG4gICAqIHRocm93cywgdGhlbiB0aGlzIG1ldGhvZCB3aWxsIHRocm93IHRoZSB2YWx1ZS4gIFRoaXMgaXMgaW1wb3J0YW50IHNvIHdlXG4gICAqIGNhbiBkbyBwcm9wZXIgYm91bmRhcnkgaWRlbnRpZmljYXRpb24gaW4gUmVtaXggd2hlcmUgYSB0aHJvd24gUmVzcG9uc2VcbiAgICogbXVzdCBnbyB0byB0aGUgQ2F0Y2ggQm91bmRhcnkgYnV0IGEgcmV0dXJuZWQgUmVzcG9uc2UgaXMgaGFwcHktcGF0aC5cbiAgICpcbiAgICogT25lIHRoaW5nIHRvIG5vdGUgaXMgdGhhdCBhbnkgUm91dGVyLWluaXRpYXRlZCBFcnJvcnMgdGhhdCBtYWtlIHNlbnNlXG4gICAqIHRvIGFzc29jaWF0ZSB3aXRoIGEgc3RhdHVzIGNvZGUgd2lsbCBiZSB0aHJvd24gYXMgYW4gRXJyb3JSZXNwb25zZVxuICAgKiBpbnN0YW5jZSB3aGljaCBpbmNsdWRlIHRoZSByYXcgRXJyb3IsIHN1Y2ggdGhhdCB0aGUgY2FsbGluZyBjb250ZXh0IGNhblxuICAgKiBzZXJpYWxpemUgdGhlIGVycm9yIGFzIHRoZXkgc2VlIGZpdCB3aGlsZSBpbmNsdWRpbmcgdGhlIHByb3BlciByZXNwb25zZVxuICAgKiBjb2RlLiAgRXhhbXBsZXMgaGVyZSBhcmUgNDA0IGFuZCA0MDUgZXJyb3JzIHRoYXQgb2NjdXIgcHJpb3IgdG8gcmVhY2hpbmdcbiAgICogYW55IHVzZXItZGVmaW5lZCBsb2FkZXJzLlxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnlSb3V0ZShcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIHtcbiAgICAgIHJvdXRlSWQsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICB9OiB7IHJlcXVlc3RDb250ZXh0PzogdW5rbm93bjsgcm91dGVJZD86IHN0cmluZyB9ID0ge31cbiAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXCJcIiwgY3JlYXRlUGF0aCh1cmwpLCBudWxsLCBcImRlZmF1bHRcIik7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuXG4gICAgLy8gU1NSIHN1cHBvcnRzIEhFQUQgcmVxdWVzdHMgd2hpbGUgU1BBIGRvZXNuJ3RcbiAgICBpZiAoIWlzVmFsaWRNZXRob2QobWV0aG9kKSAmJiBtZXRob2QgIT09IFwiaGVhZFwiICYmIG1ldGhvZCAhPT0gXCJvcHRpb25zXCIpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7IG1ldGhvZCB9KTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGVzKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgfVxuXG4gICAgbGV0IG1hdGNoID0gcm91dGVJZFxuICAgICAgPyBtYXRjaGVzLmZpbmQoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpXG4gICAgICA6IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKTtcblxuICAgIGlmIChyb3V0ZUlkICYmICFtYXRjaCkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDMsIHtcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICByb3V0ZUlkLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghbWF0Y2gpIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhpdCBJIGRvbid0IHRoaW5rP1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lIH0pO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBxdWVyeUltcGwoXG4gICAgICByZXF1ZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBtYXRjaGVzLFxuICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICBtYXRjaFxuICAgICk7XG4gICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBsZXQgZXJyb3IgPSByZXN1bHQuZXJyb3JzID8gT2JqZWN0LnZhbHVlcyhyZXN1bHQuZXJyb3JzKVswXSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gSWYgd2UgZ290IGJhY2sgcmVzdWx0LmVycm9ycywgdGhhdCBtZWFucyB0aGUgbG9hZGVyL2FjdGlvbiB0aHJld1xuICAgICAgLy8gX3NvbWV0aGluZ18gdGhhdCB3YXNuJ3QgYSBSZXNwb25zZSwgYnV0IGl0J3Mgbm90IGd1YXJhbnRlZWQvcmVxdWlyZWRcbiAgICAgIC8vIHRvIGJlIGFuIGBpbnN0YW5jZW9mIEVycm9yYCBlaXRoZXIsIHNvIHdlIGhhdmUgdG8gdXNlIHRocm93IGhlcmUgdG9cbiAgICAgIC8vIHByZXNlcnZlIHRoZSBcImVycm9yXCIgc3RhdGUgb3V0c2lkZSBvZiBxdWVyeUltcGwuXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBQaWNrIG9mZiB0aGUgcmlnaHQgc3RhdGUgdmFsdWUgdG8gcmV0dXJuXG4gICAgaWYgKHJlc3VsdC5hY3Rpb25EYXRhKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZXN1bHQuYWN0aW9uRGF0YSlbMF07XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5sb2FkZXJEYXRhKSB7XG4gICAgICBsZXQgZGF0YSA9IE9iamVjdC52YWx1ZXMocmVzdWx0LmxvYWRlckRhdGEpWzBdO1xuICAgICAgaWYgKHJlc3VsdC5hY3RpdmVEZWZlcnJlZHM/LlttYXRjaC5yb3V0ZS5pZF0pIHtcbiAgICAgICAgZGF0YVtVTlNBRkVfREVGRVJSRURfU1lNQk9MXSA9IHJlc3VsdC5hY3RpdmVEZWZlcnJlZHNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5SW1wbChcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgcmVxdWVzdENvbnRleHQ6IHVua25vd24sXG4gICAgcm91dGVNYXRjaD86IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hcbiAgKTogUHJvbWlzZTxPbWl0PFN0YXRpY0hhbmRsZXJDb250ZXh0LCBcImxvY2F0aW9uXCIgfCBcImJhc2VuYW1lXCI+IHwgUmVzcG9uc2U+IHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICByZXF1ZXN0LnNpZ25hbCxcbiAgICAgIFwicXVlcnkoKS9xdWVyeVJvdXRlKCkgcmVxdWVzdHMgbXVzdCBjb250YWluIGFuIEFib3J0Q29udHJvbGxlciBzaWduYWxcIlxuICAgICk7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKGlzTXV0YXRpb25NZXRob2QocmVxdWVzdC5tZXRob2QudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHN1Ym1pdChcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgcm91dGVNYXRjaCB8fCBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbiksXG4gICAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgICAgcm91dGVNYXRjaCAhPSBudWxsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBsb2FkUm91dGVEYXRhKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgcm91dGVNYXRjaFxuICAgICAgKTtcbiAgICAgIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdClcbiAgICAgICAgPyByZXN1bHRcbiAgICAgICAgOiB7XG4gICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB0aHJldy9yZXR1cm5lZCBhIFJlc3BvbnNlIGluIGNhbGxMb2FkZXJPckFjdGlvbiwgd2UgdGhyb3dcbiAgICAgIC8vIGl0IHRvIGJhaWwgb3V0IGFuZCB0aGVuIHJldHVybiBvciB0aHJvdyBoZXJlIGJhc2VkIG9uIHdoZXRoZXIgdGhlIHVzZXJcbiAgICAgIC8vIHJldHVybmVkIG9yIHRocmV3XG4gICAgICBpZiAoaXNRdWVyeVJvdXRlUmVzcG9uc2UoZSkpIHtcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvciAmJiAhaXNSZWRpcmVjdFJlc3BvbnNlKGUucmVzcG9uc2UpKSB7XG4gICAgICAgICAgdGhyb3cgZS5yZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZS5yZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIC8vIFJlZGlyZWN0cyBhcmUgYWx3YXlzIHJldHVybmVkIHNpbmNlIHRoZXkgZG9uJ3QgcHJvcGFnYXRlIHRvIGNhdGNoXG4gICAgICAvLyBib3VuZGFyaWVzXG4gICAgICBpZiAoaXNSZWRpcmVjdFJlc3BvbnNlKGUpKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBzdWJtaXQoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgYWN0aW9uTWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gICAgcmVxdWVzdENvbnRleHQ6IHVua25vd24sXG4gICAgaXNSb3V0ZVJlcXVlc3Q6IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxPbWl0PFN0YXRpY0hhbmRsZXJDb250ZXh0LCBcImxvY2F0aW9uXCIgfCBcImJhc2VuYW1lXCI+IHwgUmVzcG9uc2U+IHtcbiAgICBsZXQgcmVzdWx0OiBEYXRhUmVzdWx0O1xuXG4gICAgaWYgKCFhY3Rpb25NYXRjaC5yb3V0ZS5hY3Rpb24pIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgIHBhdGhuYW1lOiBuZXcgVVJMKHJlcXVlc3QudXJsKS5wYXRobmFtZSxcbiAgICAgICAgcm91dGVJZDogYWN0aW9uTWF0Y2gucm91dGUuaWQsXG4gICAgICB9KTtcbiAgICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgZXJyb3IsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gICAgICAgIFwiYWN0aW9uXCIsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGFjdGlvbk1hdGNoLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgaXNSb3V0ZVJlcXVlc3QsXG4gICAgICAgIHJlcXVlc3RDb250ZXh0XG4gICAgICApO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBsZXQgbWV0aG9kID0gaXNSb3V0ZVJlcXVlc3QgPyBcInF1ZXJ5Um91dGVcIiA6IFwicXVlcnlcIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke21ldGhvZH0oKSBjYWxsIGFib3J0ZWRgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBVaGhoaCAtIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgd2Ugc2hvdWxkIGFsd2F5cyB0aHJvdyB0aGVzZSBmcm9tXG4gICAgICAvLyBjYWxsTG9hZGVyT3JBY3Rpb24sIGJ1dCB0aGUgdHlwZSBuYXJyb3dpbmcgaGVyZSBrZWVwcyBUUyBoYXBweSBhbmQgd2VcbiAgICAgIC8vIGNhbiBnZXQgYmFjayBvbiB0aGUgXCJ0aHJvdyBhbGwgcmVkaXJlY3QgcmVzcG9uc2VzXCIgdHJhaW4gaGVyZSBzaG91bGRcbiAgICAgIC8vIHRoaXMgZXZlciBoYXBwZW4gOi9cbiAgICAgIHRocm93IG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiByZXN1bHQubG9jYXRpb24sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwgeyB0eXBlOiBcImRlZmVyLWFjdGlvblwiIH0pO1xuICAgICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvcixcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAvLyBOb3RlOiBUaGlzIHNob3VsZCBvbmx5IGJlIG5vbi1SZXNwb25zZSB2YWx1ZXMgaWYgd2UgZ2V0IGhlcmUsIHNpbmNlXG4gICAgICAvLyBpc1JvdXRlUmVxdWVzdCBzaG91bGQgdGhyb3cgYW55IFJlc3BvbnNlIHJlY2VpdmVkIGluIGNhbGxMb2FkZXJPckFjdGlvblxuICAgICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXM6IFthY3Rpb25NYXRjaF0sXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhIH0sXG4gICAgICAgIGVycm9yczogbnVsbCxcbiAgICAgICAgLy8gTm90ZTogc3RhdHVzQ29kZSArIGhlYWRlcnMgYXJlIHVudXNlZCBoZXJlIHNpbmNlIHF1ZXJ5Um91dGUgd2lsbFxuICAgICAgICAvLyByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBvciB2YWx1ZVxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTdG9yZSBvZmYgdGhlIHBlbmRpbmcgZXJyb3IgLSB3ZSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoaWNoIGxvYWRlcnNcbiAgICAgIC8vIHRvIGNhbGwgYW5kIHdpbGwgY29tbWl0IGl0IHdoZW4gd2UgY29tcGxldGUgdGhlIG5hdmlnYXRpb25cbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEoXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHtcbiAgICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvcixcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgLy8gYWN0aW9uIHN0YXR1cyBjb2RlcyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBsb2FkZXIgc3RhdHVzIGNvZGVzXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpXG4gICAgICAgICAgPyByZXN1bHQuZXJyb3Iuc3RhdHVzXG4gICAgICAgICAgOiA1MDAsXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHtcbiAgICAgICAgICAuLi4ocmVzdWx0LmhlYWRlcnMgPyB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzIH0gOiB7fSksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIEdFVCByZXF1ZXN0IGZvciB0aGUgbG9hZGVyc1xuICAgIGxldCBsb2FkZXJSZXF1ZXN0ID0gbmV3IFJlcXVlc3QocmVxdWVzdC51cmwsIHtcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgIHJlZGlyZWN0OiByZXF1ZXN0LnJlZGlyZWN0LFxuICAgICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbCxcbiAgICB9KTtcbiAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEobG9hZGVyUmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICAvLyBhY3Rpb24gc3RhdHVzIGNvZGVzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzdGF0dXMgY29kZXNcbiAgICAgIC4uLihyZXN1bHQuc3RhdHVzQ29kZSA/IHsgc3RhdHVzQ29kZTogcmVzdWx0LnN0YXR1c0NvZGUgfSA6IHt9KSxcbiAgICAgIGFjdGlvbkRhdGE6IHtcbiAgICAgICAgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGEsXG4gICAgICB9LFxuICAgICAgYWN0aW9uSGVhZGVyczoge1xuICAgICAgICAuLi4ocmVzdWx0LmhlYWRlcnMgPyB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzIH0gOiB7fSksXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBsb2FkUm91dGVEYXRhKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIHJlcXVlc3RDb250ZXh0OiB1bmtub3duLFxuICAgIHJvdXRlTWF0Y2g/OiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICAgIHBlbmRpbmdBY3Rpb25FcnJvcj86IFJvdXRlRGF0YVxuICApOiBQcm9taXNlPFxuICAgIHwgT21pdDxcbiAgICAgICAgU3RhdGljSGFuZGxlckNvbnRleHQsXG4gICAgICAgIFwibG9jYXRpb25cIiB8IFwiYmFzZW5hbWVcIiB8IFwiYWN0aW9uRGF0YVwiIHwgXCJhY3Rpb25IZWFkZXJzXCJcbiAgICAgID5cbiAgICB8IFJlc3BvbnNlXG4gID4ge1xuICAgIGxldCBpc1JvdXRlUmVxdWVzdCA9IHJvdXRlTWF0Y2ggIT0gbnVsbDtcblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgd2UgaGF2ZSBubyBsb2FkZXJzIHRvIHJ1biAocXVlcnlSb3V0ZSgpKVxuICAgIGlmIChpc1JvdXRlUmVxdWVzdCAmJiAhcm91dGVNYXRjaD8ucm91dGUubG9hZGVyKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlTWF0Y2g/LnJvdXRlLmlkLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IHJlcXVlc3RNYXRjaGVzID0gcm91dGVNYXRjaFxuICAgICAgPyBbcm91dGVNYXRjaF1cbiAgICAgIDogZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkoXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBPYmplY3Qua2V5cyhwZW5kaW5nQWN0aW9uRXJyb3IgfHwge30pWzBdXG4gICAgICAgICk7XG4gICAgbGV0IG1hdGNoZXNUb0xvYWQgPSByZXF1ZXN0TWF0Y2hlcy5maWx0ZXIoKG0pID0+IG0ucm91dGUubG9hZGVyKTtcblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgd2UgaGF2ZSBubyBsb2FkZXJzIHRvIHJ1biAocXVlcnkoKSlcbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIC8vIEFkZCBhIG51bGwgZm9yIGFsbCBtYXRjaGVkIHJvdXRlcyBmb3IgcHJvcGVyIHJldmFsaWRhdGlvbiBvbiB0aGUgY2xpZW50XG4gICAgICAgIGxvYWRlckRhdGE6IG1hdGNoZXMucmVkdWNlKFxuICAgICAgICAgIChhY2MsIG0pID0+IE9iamVjdC5hc3NpZ24oYWNjLCB7IFttLnJvdXRlLmlkXTogbnVsbCB9KSxcbiAgICAgICAgICB7fVxuICAgICAgICApLFxuICAgICAgICBlcnJvcnM6IHBlbmRpbmdBY3Rpb25FcnJvciB8fCBudWxsLFxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3RpdmVEZWZlcnJlZHM6IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGxldCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgLi4ubWF0Y2hlc1RvTG9hZC5tYXAoKG1hdGNoKSA9PlxuICAgICAgICBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gICAgICAgICAgXCJsb2FkZXJcIixcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBpc1JvdXRlUmVxdWVzdCxcbiAgICAgICAgICByZXF1ZXN0Q29udGV4dFxuICAgICAgICApXG4gICAgICApLFxuICAgIF0pO1xuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGxldCBtZXRob2QgPSBpc1JvdXRlUmVxdWVzdCA/IFwicXVlcnlSb3V0ZVwiIDogXCJxdWVyeVwiO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke21ldGhvZH0oKSBjYWxsIGFib3J0ZWRgKTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCBhY3RpdmVEZWZlcnJlZHMgPSBuZXcgTWFwPHN0cmluZywgRGVmZXJyZWREYXRhPigpO1xuICAgIGxldCBjb250ZXh0ID0gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShcbiAgICAgIG1hdGNoZXMsXG4gICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgcmVzdWx0cyxcbiAgICAgIHBlbmRpbmdBY3Rpb25FcnJvcixcbiAgICAgIGFjdGl2ZURlZmVycmVkc1xuICAgICk7XG5cbiAgICAvLyBBZGQgYSBudWxsIGZvciBhbnkgbm9uLWxvYWRlciBtYXRjaGVzIGZvciBwcm9wZXIgcmV2YWxpZGF0aW9uIG9uIHRoZSBjbGllbnRcbiAgICBsZXQgZXhlY3V0ZWRMb2FkZXJzID0gbmV3IFNldDxzdHJpbmc+KFxuICAgICAgbWF0Y2hlc1RvTG9hZC5tYXAoKG1hdGNoKSA9PiBtYXRjaC5yb3V0ZS5pZClcbiAgICApO1xuICAgIG1hdGNoZXMuZm9yRWFjaCgobWF0Y2gpID0+IHtcbiAgICAgIGlmICghZXhlY3V0ZWRMb2FkZXJzLmhhcyhtYXRjaC5yb3V0ZS5pZCkpIHtcbiAgICAgICAgY29udGV4dC5sb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBhY3RpdmVEZWZlcnJlZHM6XG4gICAgICAgIGFjdGl2ZURlZmVycmVkcy5zaXplID4gMFxuICAgICAgICAgID8gT2JqZWN0LmZyb21FbnRyaWVzKGFjdGl2ZURlZmVycmVkcy5lbnRyaWVzKCkpXG4gICAgICAgICAgOiBudWxsLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRhdGFSb3V0ZXMsXG4gICAgcXVlcnksXG4gICAgcXVlcnlSb3V0ZSxcbiAgfTtcbn1cblxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gSGVscGVyc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBHaXZlbiBhbiBleGlzdGluZyBTdGF0aWNIYW5kbGVyQ29udGV4dCBhbmQgYW4gZXJyb3IgdGhyb3duIGF0IHJlbmRlciB0aW1lLFxuICogcHJvdmlkZSBhbiB1cGRhdGVkIFN0YXRpY0hhbmRsZXJDb250ZXh0IHN1aXRhYmxlIGZvciBhIHNlY29uZCBTU1IgcmVuZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yKFxuICByb3V0ZXM6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W10sXG4gIGNvbnRleHQ6IFN0YXRpY0hhbmRsZXJDb250ZXh0LFxuICBlcnJvcjogYW55XG4pIHtcbiAgbGV0IG5ld0NvbnRleHQ6IFN0YXRpY0hhbmRsZXJDb250ZXh0ID0ge1xuICAgIC4uLmNvbnRleHQsXG4gICAgc3RhdHVzQ29kZTogNTAwLFxuICAgIGVycm9yczoge1xuICAgICAgW2NvbnRleHQuX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgfHwgcm91dGVzWzBdLmlkXTogZXJyb3IsXG4gICAgfSxcbiAgfTtcbiAgcmV0dXJuIG5ld0NvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGlzU3VibWlzc2lvbk5hdmlnYXRpb24oXG4gIG9wdHM6IFJvdXRlck5hdmlnYXRlT3B0aW9uc1xuKTogb3B0cyBpcyBTdWJtaXNzaW9uTmF2aWdhdGVPcHRpb25zIHtcbiAgcmV0dXJuIG9wdHMgIT0gbnVsbCAmJiBcImZvcm1EYXRhXCIgaW4gb3B0cztcbn1cblxuLy8gTm9ybWFsaXplIG5hdmlnYXRpb24gb3B0aW9ucyBieSBjb252ZXJ0aW5nIGZvcm1NZXRob2Q9R0VUIGZvcm1EYXRhIG9iamVjdHMgdG9cbi8vIFVSTFNlYXJjaFBhcmFtcyBzbyB0aGV5IGJlaGF2ZSBpZGVudGljYWxseSB0byBsaW5rcyB3aXRoIHF1ZXJ5IHBhcmFtc1xuZnVuY3Rpb24gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKFxuICB0bzogVG8sXG4gIG9wdHM/OiBSb3V0ZXJOYXZpZ2F0ZU9wdGlvbnMsXG4gIGlzRmV0Y2hlciA9IGZhbHNlXG4pOiB7XG4gIHBhdGg6IHN0cmluZztcbiAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb247XG4gIGVycm9yPzogRXJyb3JSZXNwb25zZTtcbn0ge1xuICBsZXQgcGF0aCA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG5cbiAgLy8gUmV0dXJuIGxvY2F0aW9uIHZlcmJhdGltIG9uIG5vbi1zdWJtaXNzaW9uIG5hdmlnYXRpb25zXG4gIGlmICghb3B0cyB8fCAhaXNTdWJtaXNzaW9uTmF2aWdhdGlvbihvcHRzKSkge1xuICAgIHJldHVybiB7IHBhdGggfTtcbiAgfVxuXG4gIGlmIChvcHRzLmZvcm1NZXRob2QgJiYgIWlzVmFsaWRNZXRob2Qob3B0cy5mb3JtTWV0aG9kKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7IG1ldGhvZDogb3B0cy5mb3JtTWV0aG9kIH0pLFxuICAgIH07XG4gIH1cblxuICAvLyBDcmVhdGUgYSBTdWJtaXNzaW9uIG9uIG5vbi1HRVQgbmF2aWdhdGlvbnNcbiAgbGV0IHN1Ym1pc3Npb246IFN1Ym1pc3Npb24gfCB1bmRlZmluZWQ7XG4gIGlmIChvcHRzLmZvcm1EYXRhKSB7XG4gICAgc3VibWlzc2lvbiA9IHtcbiAgICAgIGZvcm1NZXRob2Q6IG9wdHMuZm9ybU1ldGhvZCB8fCBcImdldFwiLFxuICAgICAgZm9ybUFjdGlvbjogc3RyaXBIYXNoRnJvbVBhdGgocGF0aCksXG4gICAgICBmb3JtRW5jVHlwZTpcbiAgICAgICAgKG9wdHMgJiYgb3B0cy5mb3JtRW5jVHlwZSkgfHwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcbiAgICAgIGZvcm1EYXRhOiBvcHRzLmZvcm1EYXRhLFxuICAgIH07XG5cbiAgICBpZiAoaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICByZXR1cm4geyBwYXRoLCBzdWJtaXNzaW9uIH07XG4gICAgfVxuICB9XG5cbiAgLy8gRmxhdHRlbiBzdWJtaXNzaW9uIG9udG8gVVJMU2VhcmNoUGFyYW1zIGZvciBHRVQgc3VibWlzc2lvbnNcbiAgbGV0IHBhcnNlZFBhdGggPSBwYXJzZVBhdGgocGF0aCk7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhvcHRzLmZvcm1EYXRhKTtcbiAgLy8gU2luY2UgZmV0Y2hlciBHRVQgc3VibWlzc2lvbnMgb25seSBydW4gYSBzaW5nbGUgbG9hZGVyIChhcyBvcHBvc2VkIHRvXG4gIC8vIG5hdmlnYXRpb24gR0VUIHN1Ym1pc3Npb25zIHdoaWNoIHJ1biBhbGwgbG9hZGVycyksIHdlIG5lZWQgdG8gcHJlc2VydmVcbiAgLy8gYW55IGluY29taW5nID9pbmRleCBwYXJhbXNcbiAgaWYgKGlzRmV0Y2hlciAmJiBwYXJzZWRQYXRoLnNlYXJjaCAmJiBoYXNOYWtlZEluZGV4UXVlcnkocGFyc2VkUGF0aC5zZWFyY2gpKSB7XG4gICAgc2VhcmNoUGFyYW1zLmFwcGVuZChcImluZGV4XCIsIFwiXCIpO1xuICB9XG4gIHBhcnNlZFBhdGguc2VhcmNoID0gYD8ke3NlYXJjaFBhcmFtc31gO1xuXG4gIHJldHVybiB7IHBhdGg6IGNyZWF0ZVBhdGgocGFyc2VkUGF0aCksIHN1Ym1pc3Npb24gfTtcbn1cblxuLy8gRmlsdGVyIG91dCBhbGwgcm91dGVzIGJlbG93IGFueSBjYXVnaHQgZXJyb3IgYXMgdGhleSBhcmVuJ3QgZ29pbmcgdG9cbi8vIHJlbmRlciBzbyB3ZSBkb24ndCBuZWVkIHRvIGxvYWQgdGhlbVxuZnVuY3Rpb24gZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkoXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgYm91bmRhcnlJZD86IHN0cmluZ1xuKSB7XG4gIGxldCBib3VuZGFyeU1hdGNoZXMgPSBtYXRjaGVzO1xuICBpZiAoYm91bmRhcnlJZCkge1xuICAgIGxldCBpbmRleCA9IG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBtLnJvdXRlLmlkID09PSBib3VuZGFyeUlkKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgYm91bmRhcnlNYXRjaGVzID0gbWF0Y2hlcy5zbGljZSgwLCBpbmRleCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZGFyeU1hdGNoZXM7XG59XG5cbmZ1bmN0aW9uIGdldE1hdGNoZXNUb0xvYWQoXG4gIGhpc3Rvcnk6IEhpc3RvcnksXG4gIHN0YXRlOiBSb3V0ZXJTdGF0ZSxcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uIHwgdW5kZWZpbmVkLFxuICBsb2NhdGlvbjogTG9jYXRpb24sXG4gIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQ6IGJvb2xlYW4sXG4gIGNhbmNlbGxlZERlZmVycmVkUm91dGVzOiBzdHJpbmdbXSxcbiAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzOiBzdHJpbmdbXSxcbiAgcGVuZGluZ0FjdGlvbkRhdGE/OiBSb3V0ZURhdGEsXG4gIHBlbmRpbmdFcnJvcj86IFJvdXRlRGF0YSxcbiAgZmV0Y2hMb2FkTWF0Y2hlcz86IE1hcDxzdHJpbmcsIEZldGNoTG9hZE1hdGNoPlxuKTogW0Fnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSwgUmV2YWxpZGF0aW5nRmV0Y2hlcltdXSB7XG4gIGxldCBhY3Rpb25SZXN1bHQgPSBwZW5kaW5nRXJyb3JcbiAgICA/IE9iamVjdC52YWx1ZXMocGVuZGluZ0Vycm9yKVswXVxuICAgIDogcGVuZGluZ0FjdGlvbkRhdGFcbiAgICA/IE9iamVjdC52YWx1ZXMocGVuZGluZ0FjdGlvbkRhdGEpWzBdXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgbGV0IGN1cnJlbnRVcmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdGF0ZS5sb2NhdGlvbik7XG4gIGxldCBuZXh0VXJsID0gaGlzdG9yeS5jcmVhdGVVUkwobG9jYXRpb24pO1xuXG4gIGxldCBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZSA9XG4gICAgLy8gRm9yY2VkIHJldmFsaWRhdGlvbiBkdWUgdG8gc3VibWlzc2lvbiwgdXNlUmV2YWxpZGF0ZSwgb3IgWC1SZW1peC1SZXZhbGlkYXRlXG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCB8fFxuICAgIC8vIENsaWNrZWQgdGhlIHNhbWUgbGluaywgcmVzdWJtaXR0ZWQgYSBHRVQgZm9ybVxuICAgIGN1cnJlbnRVcmwudG9TdHJpbmcoKSA9PT0gbmV4dFVybC50b1N0cmluZygpIHx8XG4gICAgLy8gU2VhcmNoIHBhcmFtcyBhZmZlY3QgYWxsIGxvYWRlcnNcbiAgICBjdXJyZW50VXJsLnNlYXJjaCAhPT0gbmV4dFVybC5zZWFyY2g7XG5cbiAgLy8gUGljayBuYXZpZ2F0aW9uIG1hdGNoZXMgdGhhdCBhcmUgbmV0LW5ldyBvciBxdWFsaWZ5IGZvciByZXZhbGlkYXRpb25cbiAgbGV0IGJvdW5kYXJ5SWQgPSBwZW5kaW5nRXJyb3IgPyBPYmplY3Qua2V5cyhwZW5kaW5nRXJyb3IpWzBdIDogdW5kZWZpbmVkO1xuICBsZXQgYm91bmRhcnlNYXRjaGVzID0gZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkobWF0Y2hlcywgYm91bmRhcnlJZCk7XG5cbiAgbGV0IG5hdmlnYXRpb25NYXRjaGVzID0gYm91bmRhcnlNYXRjaGVzLmZpbHRlcigobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgaWYgKG1hdGNoLnJvdXRlLmxvYWRlciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIGNhbGwgdGhlIGxvYWRlciBvbiBuZXcgcm91dGUgaW5zdGFuY2VzIGFuZCBwZW5kaW5nIGRlZmVyIGNhbmNlbGxhdGlvbnNcbiAgICBpZiAoXG4gICAgICBpc05ld0xvYWRlcihzdGF0ZS5sb2FkZXJEYXRhLCBzdGF0ZS5tYXRjaGVzW2luZGV4XSwgbWF0Y2gpIHx8XG4gICAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcy5zb21lKChpZCkgPT4gaWQgPT09IG1hdGNoLnJvdXRlLmlkKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBmb3Igd2hlbiB3ZSByZXZhbGlkYXRlLiAgSWYgdGhlIHJvdXRlXG4gICAgLy8gcHJvdmlkZXMgaXQncyBvd24gaW1wbGVtZW50YXRpb24sIHRoZW4gd2UgZ2l2ZSB0aGVtIGZ1bGwgY29udHJvbCBidXRcbiAgICAvLyBwcm92aWRlIHRoaXMgdmFsdWUgc28gdGhleSBjYW4gbGV2ZXJhZ2UgaXQgaWYgbmVlZGVkIGFmdGVyIHRoZXkgY2hlY2tcbiAgICAvLyB0aGVpciBvd24gc3BlY2lmaWMgdXNlIGNhc2VzXG4gICAgbGV0IGN1cnJlbnRSb3V0ZU1hdGNoID0gc3RhdGUubWF0Y2hlc1tpbmRleF07XG4gICAgbGV0IG5leHRSb3V0ZU1hdGNoID0gbWF0Y2g7XG5cbiAgICByZXR1cm4gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihtYXRjaCwge1xuICAgICAgY3VycmVudFVybCxcbiAgICAgIGN1cnJlbnRQYXJhbXM6IGN1cnJlbnRSb3V0ZU1hdGNoLnBhcmFtcyxcbiAgICAgIG5leHRVcmwsXG4gICAgICBuZXh0UGFyYW1zOiBuZXh0Um91dGVNYXRjaC5wYXJhbXMsXG4gICAgICAuLi5zdWJtaXNzaW9uLFxuICAgICAgYWN0aW9uUmVzdWx0LFxuICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6XG4gICAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlIHx8XG4gICAgICAgIGlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50Um91dGVNYXRjaCwgbmV4dFJvdXRlTWF0Y2gpLFxuICAgIH0pO1xuICB9KTtcblxuICAvLyBQaWNrIGZldGNoZXIubG9hZHMgdGhhdCBuZWVkIHRvIGJlIHJldmFsaWRhdGVkXG4gIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyczogUmV2YWxpZGF0aW5nRmV0Y2hlcltdID0gW107XG4gIGZldGNoTG9hZE1hdGNoZXMgJiZcbiAgICBmZXRjaExvYWRNYXRjaGVzLmZvckVhY2goKGYsIGtleSkgPT4ge1xuICAgICAgaWYgKCFtYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUuaWQgPT09IGYucm91dGVJZCkpIHtcbiAgICAgICAgLy8gVGhpcyBmZXRjaGVyIGlzIG5vdCBnb2luZyB0byBiZSBwcmVzZW50IGluIHRoZSBzdWJzZXF1ZW50IHJlbmRlciBzb1xuICAgICAgICAvLyB0aGVyZSdzIG5vIG5lZWQgdG8gcmV2YWxpZGF0ZSBpdFxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIC8vIFRoaXMgZmV0Y2hlciB3YXMgY2FuY2VsbGVkIGZyb20gYSBwcmlvciBhY3Rpb24gc3VibWlzc2lvbiAtIGZvcmNlIHJlbG9hZFxuICAgICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5wdXNoKHsga2V5LCAuLi5mIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV2YWxpZGF0aW5nIGZldGNoZXJzIGFyZSBkZWNvdXBsZWQgZnJvbSB0aGUgcm91dGUgbWF0Y2hlcyBzaW5jZSB0aGV5XG4gICAgICAgIC8vIGhpdCBhIHN0YXRpYyBocmVmLCBzbyB0aGV5IF9hbHdheXNfIGNoZWNrIHNob3VsZFJldmFsaWRhdGUgYW5kIHRoZVxuICAgICAgICAvLyBkZWZhdWx0IGlzIHN0cmljdGx5IGlmIGEgcmV2YWxpZGF0aW9uIGlzIGV4cGxpY2l0bHkgcmVxdWlyZWQgKGFjdGlvblxuICAgICAgICAvLyBzdWJtaXNzaW9ucywgdXNlUmV2YWxpZGF0b3IsIFgtUmVtaXgtUmV2YWxpZGF0ZSkuXG4gICAgICAgIGxldCBzaG91bGRSZXZhbGlkYXRlID0gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihmLm1hdGNoLCB7XG4gICAgICAgICAgY3VycmVudFVybCxcbiAgICAgICAgICBjdXJyZW50UGFyYW1zOiBzdGF0ZS5tYXRjaGVzW3N0YXRlLm1hdGNoZXMubGVuZ3RoIC0gMV0ucGFyYW1zLFxuICAgICAgICAgIG5leHRVcmwsXG4gICAgICAgICAgbmV4dFBhcmFtczogbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnBhcmFtcyxcbiAgICAgICAgICAuLi5zdWJtaXNzaW9uLFxuICAgICAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgICAgICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMucHVzaCh7IGtleSwgLi4uZiB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gIHJldHVybiBbbmF2aWdhdGlvbk1hdGNoZXMsIHJldmFsaWRhdGluZ0ZldGNoZXJzXTtcbn1cblxuZnVuY3Rpb24gaXNOZXdMb2FkZXIoXG4gIGN1cnJlbnRMb2FkZXJEYXRhOiBSb3V0ZURhdGEsXG4gIGN1cnJlbnRNYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hcbikge1xuICBsZXQgaXNOZXcgPVxuICAgIC8vIFthXSAtPiBbYSwgYl1cbiAgICAhY3VycmVudE1hdGNoIHx8XG4gICAgLy8gW2EsIGJdIC0+IFthLCBjXVxuICAgIG1hdGNoLnJvdXRlLmlkICE9PSBjdXJyZW50TWF0Y2gucm91dGUuaWQ7XG5cbiAgLy8gSGFuZGxlIHRoZSBjYXNlIHRoYXQgd2UgZG9uJ3QgaGF2ZSBkYXRhIGZvciBhIHJlLXVzZWQgcm91dGUsIHBvdGVudGlhbGx5XG4gIC8vIGZyb20gYSBwcmlvciBlcnJvciBvciBmcm9tIGEgY2FuY2VsbGVkIHBlbmRpbmcgZGVmZXJyZWRcbiAgbGV0IGlzTWlzc2luZ0RhdGEgPSBjdXJyZW50TG9hZGVyRGF0YVttYXRjaC5yb3V0ZS5pZF0gPT09IHVuZGVmaW5lZDtcblxuICAvLyBBbHdheXMgbG9hZCBpZiB0aGlzIGlzIGEgbmV0LW5ldyByb3V0ZSBvciB3ZSBkb24ndCB5ZXQgaGF2ZSBkYXRhXG4gIHJldHVybiBpc05ldyB8fCBpc01pc3NpbmdEYXRhO1xufVxuXG5mdW5jdGlvbiBpc05ld1JvdXRlSW5zdGFuY2UoXG4gIGN1cnJlbnRNYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hcbikge1xuICBsZXQgY3VycmVudFBhdGggPSBjdXJyZW50TWF0Y2gucm91dGUucGF0aDtcbiAgcmV0dXJuIChcbiAgICAvLyBwYXJhbSBjaGFuZ2UgZm9yIHRoaXMgbWF0Y2gsIC91c2Vycy8xMjMgLT4gL3VzZXJzLzQ1NlxuICAgIGN1cnJlbnRNYXRjaC5wYXRobmFtZSAhPT0gbWF0Y2gucGF0aG5hbWUgfHxcbiAgICAvLyBzcGxhdCBwYXJhbSBjaGFuZ2VkLCB3aGljaCBpcyBub3QgcHJlc2VudCBpbiBtYXRjaC5wYXRoXG4gICAgLy8gZS5nLiAvZmlsZXMvaW1hZ2VzL2F2YXRhci5qcGcgLT4gZmlsZXMvZmluYW5jZXMueGxzXG4gICAgKGN1cnJlbnRQYXRoICE9IG51bGwgJiZcbiAgICAgIGN1cnJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSAmJlxuICAgICAgY3VycmVudE1hdGNoLnBhcmFtc1tcIipcIl0gIT09IG1hdGNoLnBhcmFtc1tcIipcIl0pXG4gICk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFJldmFsaWRhdGVMb2FkZXIoXG4gIGxvYWRlck1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICBhcmc6IFBhcmFtZXRlcnM8U2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uPlswXVxuKSB7XG4gIGlmIChsb2FkZXJNYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgbGV0IHJvdXRlQ2hvaWNlID0gbG9hZGVyTWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZShhcmcpO1xuICAgIGlmICh0eXBlb2Ygcm91dGVDaG9pY2UgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gcm91dGVDaG9pY2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFyZy5kZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2FsbExvYWRlck9yQWN0aW9uKFxuICB0eXBlOiBcImxvYWRlclwiIHwgXCJhY3Rpb25cIixcbiAgcmVxdWVzdDogUmVxdWVzdCxcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgYmFzZW5hbWUgPSBcIi9cIixcbiAgaXNTdGF0aWNSZXF1ZXN0OiBib29sZWFuID0gZmFsc2UsXG4gIGlzUm91dGVSZXF1ZXN0OiBib29sZWFuID0gZmFsc2UsXG4gIHJlcXVlc3RDb250ZXh0PzogdW5rbm93blxuKTogUHJvbWlzZTxEYXRhUmVzdWx0PiB7XG4gIGxldCByZXN1bHRUeXBlO1xuICBsZXQgcmVzdWx0O1xuXG4gIC8vIFNldHVwIGEgcHJvbWlzZSB3ZSBjYW4gcmFjZSBhZ2FpbnN0IHNvIHRoYXQgYWJvcnQgc2lnbmFscyBzaG9ydCBjaXJjdWl0XG4gIGxldCByZWplY3Q6ICgpID0+IHZvaWQ7XG4gIGxldCBhYm9ydFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcikgPT4gKHJlamVjdCA9IHIpKTtcbiAgbGV0IG9uUmVqZWN0ID0gKCkgPT4gcmVqZWN0KCk7XG4gIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XG5cbiAgdHJ5IHtcbiAgICBsZXQgaGFuZGxlciA9IG1hdGNoLnJvdXRlW3R5cGVdO1xuICAgIGludmFyaWFudDxGdW5jdGlvbj4oXG4gICAgICBoYW5kbGVyLFxuICAgICAgYENvdWxkIG5vdCBmaW5kIHRoZSAke3R5cGV9IHRvIHJ1biBvbiB0aGUgXCIke21hdGNoLnJvdXRlLmlkfVwiIHJvdXRlYFxuICAgICk7XG5cbiAgICByZXN1bHQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgaGFuZGxlcih7IHJlcXVlc3QsIHBhcmFtczogbWF0Y2gucGFyYW1zLCBjb250ZXh0OiByZXF1ZXN0Q29udGV4dCB9KSxcbiAgICAgIGFib3J0UHJvbWlzZSxcbiAgICBdKTtcblxuICAgIGludmFyaWFudChcbiAgICAgIHJlc3VsdCAhPT0gdW5kZWZpbmVkLFxuICAgICAgYFlvdSBkZWZpbmVkICR7dHlwZSA9PT0gXCJhY3Rpb25cIiA/IFwiYW4gYWN0aW9uXCIgOiBcImEgbG9hZGVyXCJ9IGZvciByb3V0ZSBgICtcbiAgICAgICAgYFwiJHttYXRjaC5yb3V0ZS5pZH1cIiBidXQgZGlkbid0IHJldHVybiBhbnl0aGluZyBmcm9tIHlvdXIgXFxgJHt0eXBlfVxcYCBgICtcbiAgICAgICAgYGZ1bmN0aW9uLiBQbGVhc2UgcmV0dXJuIGEgdmFsdWUgb3IgXFxgbnVsbFxcYC5gXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlc3VsdFR5cGUgPSBSZXN1bHRUeXBlLmVycm9yO1xuICAgIHJlc3VsdCA9IGU7XG4gIH0gZmluYWxseSB7XG4gICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uUmVqZWN0KTtcbiAgfVxuXG4gIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICBsZXQgc3RhdHVzID0gcmVzdWx0LnN0YXR1cztcblxuICAgIC8vIFByb2Nlc3MgcmVkaXJlY3RzXG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzQ29kZXMuaGFzKHN0YXR1cykpIHtcbiAgICAgIGxldCBsb2NhdGlvbiA9IHJlc3VsdC5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpO1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgXCJSZWRpcmVjdHMgcmV0dXJuZWQvdGhyb3duIGZyb20gbG9hZGVycy9hY3Rpb25zIG11c3QgaGF2ZSBhIExvY2F0aW9uIGhlYWRlclwiXG4gICAgICApO1xuXG4gICAgICAvLyBTdXBwb3J0IHJlbGF0aXZlIHJvdXRpbmcgaW4gaW50ZXJuYWwgcmVkaXJlY3RzXG4gICAgICBpZiAoIUFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KGxvY2F0aW9uKSkge1xuICAgICAgICBsZXQgYWN0aXZlTWF0Y2hlcyA9IG1hdGNoZXMuc2xpY2UoMCwgbWF0Y2hlcy5pbmRleE9mKG1hdGNoKSArIDEpO1xuICAgICAgICBsZXQgcm91dGVQYXRobmFtZXMgPSBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhhY3RpdmVNYXRjaGVzKS5tYXAoXG4gICAgICAgICAgKG1hdGNoKSA9PiBtYXRjaC5wYXRobmFtZUJhc2VcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHJlc29sdmVkTG9jYXRpb24gPSByZXNvbHZlVG8oXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgcm91dGVQYXRobmFtZXMsXG4gICAgICAgICAgbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIGNyZWF0ZVBhdGgocmVzb2x2ZWRMb2NhdGlvbiksXG4gICAgICAgICAgYFVuYWJsZSB0byByZXNvbHZlIHJlZGlyZWN0IGxvY2F0aW9uOiAke2xvY2F0aW9ufWBcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBQcmVwZW5kIHRoZSBiYXNlbmFtZSB0byB0aGUgcmVkaXJlY3QgbG9jYXRpb24gaWYgd2UgaGF2ZSBvbmVcbiAgICAgICAgaWYgKGJhc2VuYW1lKSB7XG4gICAgICAgICAgbGV0IHBhdGggPSByZXNvbHZlZExvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICAgIHJlc29sdmVkTG9jYXRpb24ucGF0aG5hbWUgPVxuICAgICAgICAgICAgcGF0aCA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2F0aW9uID0gY3JlYXRlUGF0aChyZXNvbHZlZExvY2F0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzU3RhdGljUmVxdWVzdCkge1xuICAgICAgICAvLyBTdHJpcCBvZmYgdGhlIHByb3RvY29sK29yaWdpbiBmb3Igc2FtZS1vcmlnaW4gYWJzb2x1dGUgcmVkaXJlY3RzLlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgc3RhdGljIHJlcXVlcywgd2UgY2FuIGxldCBpdCBnbyBiYWNrIHRvIHRoZSBicm93c2VyXG4gICAgICAgIC8vIGFzLWlzXG4gICAgICAgIGxldCBjdXJyZW50VXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgIGxldCB1cmwgPSBsb2NhdGlvbi5zdGFydHNXaXRoKFwiLy9cIilcbiAgICAgICAgICA/IG5ldyBVUkwoY3VycmVudFVybC5wcm90b2NvbCArIGxvY2F0aW9uKVxuICAgICAgICAgIDogbmV3IFVSTChsb2NhdGlvbik7XG4gICAgICAgIGlmICh1cmwub3JpZ2luID09PSBjdXJyZW50VXJsLm9yaWdpbikge1xuICAgICAgICAgIGxvY2F0aW9uID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCArIHVybC5oYXNoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERvbid0IHByb2Nlc3MgcmVkaXJlY3RzIGluIHRoZSByb3V0ZXIgZHVyaW5nIHN0YXRpYyByZXF1ZXN0cyByZXF1ZXN0cy5cbiAgICAgIC8vIEluc3RlYWQsIHRocm93IHRoZSBSZXNwb25zZSBhbmQgbGV0IHRoZSBzZXJ2ZXIgaGFuZGxlIGl0IHdpdGggYW4gSFRUUFxuICAgICAgLy8gcmVkaXJlY3QuICBXZSBhbHNvIHVwZGF0ZSB0aGUgTG9jYXRpb24gaGVhZGVyIGluIHBsYWNlIGluIHRoaXMgZmxvdyBzb1xuICAgICAgLy8gYmFzZW5hbWUgYW5kIHJlbGF0aXZlIHJvdXRpbmcgaXMgdGFrZW4gaW50byBhY2NvdW50XG4gICAgICBpZiAoaXNTdGF0aWNSZXF1ZXN0KSB7XG4gICAgICAgIHJlc3VsdC5oZWFkZXJzLnNldChcIkxvY2F0aW9uXCIsIGxvY2F0aW9uKTtcbiAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLnJlZGlyZWN0LFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICByZXZhbGlkYXRlOiByZXN1bHQuaGVhZGVycy5nZXQoXCJYLVJlbWl4LVJldmFsaWRhdGVcIikgIT09IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZvciBTU1Igc2luZ2xlLXJvdXRlIHJlcXVlc3RzLCB3ZSB3YW50IHRvIGhhbmQgUmVzcG9uc2VzIGJhY2sgZGlyZWN0bHlcbiAgICAvLyB3aXRob3V0IHVud3JhcHBpbmcuICBXZSBkbyB0aGlzIHdpdGggdGhlIFF1ZXJ5Um91dGVSZXNwb25zZSB3cmFwcGVyXG4gICAgLy8gaW50ZXJmYWNlIHNvIHdlIGNhbiBrbm93IHdoZXRoZXIgaXQgd2FzIHJldHVybmVkIG9yIHRocm93blxuICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICAgIHRocm93IHtcbiAgICAgICAgdHlwZTogcmVzdWx0VHlwZSB8fCBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICAgIHJlc3BvbnNlOiByZXN1bHQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGxldCBkYXRhOiBhbnk7XG4gICAgbGV0IGNvbnRlbnRUeXBlID0gcmVzdWx0LmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuICAgIC8vIENoZWNrIGJldHdlZW4gd29yZCBib3VuZGFyaWVzIGluc3RlYWQgb2Ygc3RhcnRzV2l0aCgpIGR1ZSB0byB0aGUgbGFzdFxuICAgIC8vIHBhcmFncmFwaCBvZiBodHRwczovL2h0dHB3Zy5vcmcvc3BlY3MvcmZjOTExMC5odG1sI2ZpZWxkLmNvbnRlbnQtdHlwZVxuICAgIGlmIChjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgZGF0YSA9IGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBhd2FpdCByZXN1bHQudGV4dCgpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHRUeXBlID09PSBSZXN1bHRUeXBlLmVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiByZXN1bHRUeXBlLFxuICAgICAgICBlcnJvcjogbmV3IEVycm9yUmVzcG9uc2Uoc3RhdHVzLCByZXN1bHQuc3RhdHVzVGV4dCwgZGF0YSksXG4gICAgICAgIGhlYWRlcnM6IHJlc3VsdC5oZWFkZXJzLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogUmVzdWx0VHlwZS5kYXRhLFxuICAgICAgZGF0YSxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3VsdC5zdGF0dXMsXG4gICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVycyxcbiAgICB9O1xuICB9XG5cbiAgaWYgKHJlc3VsdFR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3IpIHtcbiAgICByZXR1cm4geyB0eXBlOiByZXN1bHRUeXBlLCBlcnJvcjogcmVzdWx0IH07XG4gIH1cblxuICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRGVmZXJyZWREYXRhKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogUmVzdWx0VHlwZS5kZWZlcnJlZCwgZGVmZXJyZWREYXRhOiByZXN1bHQgfTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IFJlc3VsdFR5cGUuZGF0YSwgZGF0YTogcmVzdWx0IH07XG59XG5cbi8vIFV0aWxpdHkgbWV0aG9kIGZvciBjcmVhdGluZyB0aGUgUmVxdWVzdCBpbnN0YW5jZXMgZm9yIGxvYWRlcnMvYWN0aW9ucyBkdXJpbmdcbi8vIGNsaWVudC1zaWRlIG5hdmlnYXRpb25zIGFuZCBmZXRjaGVzLiAgRHVyaW5nIFNTUiB3ZSB3aWxsIGFsd2F5cyBoYXZlIGFcbi8vIFJlcXVlc3QgaW5zdGFuY2UgZnJvbSB0aGUgc3RhdGljIGhhbmRsZXIgKHF1ZXJ5L3F1ZXJ5Um91dGUpXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgaGlzdG9yeTogSGlzdG9yeSxcbiAgbG9jYXRpb246IHN0cmluZyB8IExvY2F0aW9uLFxuICBzaWduYWw6IEFib3J0U2lnbmFsLFxuICBzdWJtaXNzaW9uPzogU3VibWlzc2lvblxuKTogUmVxdWVzdCB7XG4gIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdHJpcEhhc2hGcm9tUGF0aChsb2NhdGlvbikpLnRvU3RyaW5nKCk7XG4gIGxldCBpbml0OiBSZXF1ZXN0SW5pdCA9IHsgc2lnbmFsIH07XG5cbiAgaWYgKHN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgbGV0IHsgZm9ybU1ldGhvZCwgZm9ybUVuY1R5cGUsIGZvcm1EYXRhIH0gPSBzdWJtaXNzaW9uO1xuICAgIGluaXQubWV0aG9kID0gZm9ybU1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIGluaXQuYm9keSA9XG4gICAgICBmb3JtRW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxuICAgICAgICA/IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKGZvcm1EYXRhKVxuICAgICAgICA6IGZvcm1EYXRhO1xuICB9XG5cbiAgLy8gQ29udGVudC1UeXBlIGlzIGluZmVycmVkIChodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlcXVlc3QpXG4gIHJldHVybiBuZXcgUmVxdWVzdCh1cmwsIGluaXQpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhmb3JtRGF0YTogRm9ybURhdGEpOiBVUkxTZWFyY2hQYXJhbXMge1xuICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuXG4gIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBmb3JtRGF0YS5lbnRyaWVzKCkpIHtcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNjb252ZXJ0aW5nLWFuLWVudHJ5LWxpc3QtdG8tYS1saXN0LW9mLW5hbWUtdmFsdWUtcGFpcnNcbiAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUgaW5zdGFuY2VvZiBGaWxlID8gdmFsdWUubmFtZSA6IHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBzZWFyY2hQYXJhbXM7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgbWF0Y2hlc1RvTG9hZDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICByZXN1bHRzOiBEYXRhUmVzdWx0W10sXG4gIHBlbmRpbmdFcnJvcjogUm91dGVEYXRhIHwgdW5kZWZpbmVkLFxuICBhY3RpdmVEZWZlcnJlZHM6IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT5cbik6IHtcbiAgbG9hZGVyRGF0YTogUm91dGVyU3RhdGVbXCJsb2FkZXJEYXRhXCJdO1xuICBlcnJvcnM6IFJvdXRlclN0YXRlW1wiZXJyb3JzXCJdIHwgbnVsbDtcbiAgc3RhdHVzQ29kZTogbnVtYmVyO1xuICBsb2FkZXJIZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBIZWFkZXJzPjtcbn0ge1xuICAvLyBGaWxsIGluIGxvYWRlckRhdGEvZXJyb3JzIGZyb20gb3VyIGxvYWRlcnNcbiAgbGV0IGxvYWRlckRhdGE6IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXSA9IHt9O1xuICBsZXQgZXJyb3JzOiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXSB8IG51bGwgPSBudWxsO1xuICBsZXQgc3RhdHVzQ29kZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICBsZXQgZm91bmRFcnJvciA9IGZhbHNlO1xuICBsZXQgbG9hZGVySGVhZGVyczogUmVjb3JkPHN0cmluZywgSGVhZGVycz4gPSB7fTtcblxuICAvLyBQcm9jZXNzIGxvYWRlciByZXN1bHRzIGludG8gc3RhdGUubG9hZGVyRGF0YS9zdGF0ZS5lcnJvcnNcbiAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGluZGV4KSA9PiB7XG4gICAgbGV0IGlkID0gbWF0Y2hlc1RvTG9hZFtpbmRleF0ucm91dGUuaWQ7XG4gICAgaW52YXJpYW50KFxuICAgICAgIWlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSxcbiAgICAgIFwiQ2Fubm90IGhhbmRsZSByZWRpcmVjdCByZXN1bHRzIGluIHByb2Nlc3NMb2FkZXJEYXRhXCJcbiAgICApO1xuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIExvb2sgdXB3YXJkcyBmcm9tIHRoZSBtYXRjaGVkIHJvdXRlIGZvciB0aGUgY2xvc2VzdCBhbmNlc3RvclxuICAgICAgLy8gZXJyb3IgYm91bmRhcnksIGRlZmF1bHRpbmcgdG8gdGhlIHJvb3QgbWF0Y2hcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBpZCk7XG4gICAgICBsZXQgZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcGVuZGluZyBhY3Rpb24gZXJyb3IsIHdlIHJlcG9ydCBpdCBhdCB0aGUgaGlnaGVzdC1yb3V0ZVxuICAgICAgLy8gdGhhdCB0aHJvd3MgYSBsb2FkZXIgZXJyb3IsIGFuZCB0aGVuIGNsZWFyIGl0IG91dCB0byBpbmRpY2F0ZSB0aGF0XG4gICAgICAvLyBpdCB3YXMgY29uc3VtZWRcbiAgICAgIGlmIChwZW5kaW5nRXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBPYmplY3QudmFsdWVzKHBlbmRpbmdFcnJvcilbMF07XG4gICAgICAgIHBlbmRpbmdFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IHt9O1xuXG4gICAgICAvLyBQcmVmZXIgaGlnaGVyIGVycm9yIHZhbHVlcyBpZiBsb3dlciBlcnJvcnMgYnViYmxlIHRvIHRoZSBzYW1lIGJvdW5kYXJ5XG4gICAgICBpZiAoZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdID09IG51bGwpIHtcbiAgICAgICAgZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdID0gZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIG91ciBhbnkgcHJpb3IgbG9hZGVyRGF0YSBmb3IgdGhlIHRocm93aW5nIHJvdXRlXG4gICAgICBsb2FkZXJEYXRhW2lkXSA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gT25jZSB3ZSBmaW5kIG91ciBmaXJzdCAoaGlnaGVzdCkgZXJyb3IsIHdlIHNldCB0aGUgc3RhdHVzIGNvZGUgYW5kXG4gICAgICAvLyBwcmV2ZW50IGRlZXBlciBzdGF0dXMgY29kZXMgZnJvbSBvdmVycmlkaW5nXG4gICAgICBpZiAoIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgZm91bmRFcnJvciA9IHRydWU7XG4gICAgICAgIHN0YXR1c0NvZGUgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpXG4gICAgICAgICAgPyByZXN1bHQuZXJyb3Iuc3RhdHVzXG4gICAgICAgICAgOiA1MDA7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmhlYWRlcnMpIHtcbiAgICAgICAgbG9hZGVySGVhZGVyc1tpZF0gPSByZXN1bHQuaGVhZGVycztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICBhY3RpdmVEZWZlcnJlZHMuc2V0KGlkLCByZXN1bHQuZGVmZXJyZWREYXRhKTtcbiAgICAgICAgbG9hZGVyRGF0YVtpZF0gPSByZXN1bHQuZGVmZXJyZWREYXRhLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkZXJEYXRhW2lkXSA9IHJlc3VsdC5kYXRhO1xuICAgICAgfVxuXG4gICAgICAvLyBFcnJvciBzdGF0dXMgY29kZXMgYWx3YXlzIG92ZXJyaWRlIHN1Y2Nlc3Mgc3RhdHVzIGNvZGVzLCBidXQgaWYgYWxsXG4gICAgICAvLyBsb2FkZXJzIGFyZSBzdWNjZXNzZnVsIHdlIHRha2UgdGhlIGRlZXBlc3Qgc3RhdHVzIGNvZGUuXG4gICAgICBpZiAoXG4gICAgICAgIHJlc3VsdC5zdGF0dXNDb2RlICE9IG51bGwgJiZcbiAgICAgICAgcmVzdWx0LnN0YXR1c0NvZGUgIT09IDIwMCAmJlxuICAgICAgICAhZm91bmRFcnJvclxuICAgICAgKSB7XG4gICAgICAgIHN0YXR1c0NvZGUgPSByZXN1bHQuc3RhdHVzQ29kZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gSWYgd2UgZGlkbid0IGNvbnN1bWUgdGhlIHBlbmRpbmcgYWN0aW9uIGVycm9yIChpLmUuLCBhbGwgbG9hZGVyc1xuICAvLyByZXNvbHZlZCksIHRoZW4gY29uc3VtZSBpdCBoZXJlLiAgQWxzbyBjbGVhciBvdXQgYW55IGxvYWRlckRhdGEgZm9yIHRoZVxuICAvLyB0aHJvd2luZyByb3V0ZVxuICBpZiAocGVuZGluZ0Vycm9yKSB7XG4gICAgZXJyb3JzID0gcGVuZGluZ0Vycm9yO1xuICAgIGxvYWRlckRhdGFbT2JqZWN0LmtleXMocGVuZGluZ0Vycm9yKVswXV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxvYWRlckRhdGEsXG4gICAgZXJyb3JzLFxuICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUgfHwgMjAwLFxuICAgIGxvYWRlckhlYWRlcnMsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NMb2FkZXJEYXRhKFxuICBzdGF0ZTogUm91dGVyU3RhdGUsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgbWF0Y2hlc1RvTG9hZDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICByZXN1bHRzOiBEYXRhUmVzdWx0W10sXG4gIHBlbmRpbmdFcnJvcjogUm91dGVEYXRhIHwgdW5kZWZpbmVkLFxuICByZXZhbGlkYXRpbmdGZXRjaGVyczogUmV2YWxpZGF0aW5nRmV0Y2hlcltdLFxuICBmZXRjaGVyUmVzdWx0czogRGF0YVJlc3VsdFtdLFxuICBhY3RpdmVEZWZlcnJlZHM6IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT5cbik6IHtcbiAgbG9hZGVyRGF0YTogUm91dGVyU3RhdGVbXCJsb2FkZXJEYXRhXCJdO1xuICBlcnJvcnM/OiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXTtcbn0ge1xuICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gICAgbWF0Y2hlcyxcbiAgICBtYXRjaGVzVG9Mb2FkLFxuICAgIHJlc3VsdHMsXG4gICAgcGVuZGluZ0Vycm9yLFxuICAgIGFjdGl2ZURlZmVycmVkc1xuICApO1xuXG4gIC8vIFByb2Nlc3MgcmVzdWx0cyBmcm9tIG91ciByZXZhbGlkYXRpbmcgZmV0Y2hlcnNcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCB7IGtleSwgbWF0Y2ggfSA9IHJldmFsaWRhdGluZ0ZldGNoZXJzW2luZGV4XTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBmZXRjaGVyUmVzdWx0cyAhPT0gdW5kZWZpbmVkICYmIGZldGNoZXJSZXN1bHRzW2luZGV4XSAhPT0gdW5kZWZpbmVkLFxuICAgICAgXCJEaWQgbm90IGZpbmQgY29ycmVzcG9uZGluZyBmZXRjaGVyIHJlc3VsdFwiXG4gICAgKTtcbiAgICBsZXQgcmVzdWx0ID0gZmV0Y2hlclJlc3VsdHNbaW5kZXhdO1xuXG4gICAgLy8gUHJvY2VzcyBmZXRjaGVyIG5vbi1yZWRpcmVjdCBlcnJvcnNcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoc3RhdGUubWF0Y2hlcywgbWF0Y2gucm91dGUuaWQpO1xuICAgICAgaWYgKCEoZXJyb3JzICYmIGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSkpIHtcbiAgICAgICAgZXJyb3JzID0ge1xuICAgICAgICAgIC4uLmVycm9ycyxcbiAgICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvcixcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICAgIH0gZWxzZSBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTaG91bGQgbmV2ZXIgZ2V0IGhlcmUsIHJlZGlyZWN0cyBzaG91bGQgZ2V0IHByb2Nlc3NlZCBhYm92ZSwgYnV0IHdlXG4gICAgICAvLyBrZWVwIHRoaXMgdG8gdHlwZSBuYXJyb3cgdG8gYSBzdWNjZXNzIHJlc3VsdCBpbiB0aGUgZWxzZVxuICAgICAgaW52YXJpYW50KGZhbHNlLCBcIlVuaGFuZGxlZCBmZXRjaGVyIHJldmFsaWRhdGlvbiByZWRpcmVjdFwiKTtcbiAgICB9IGVsc2UgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gU2hvdWxkIG5ldmVyIGdldCBoZXJlLCBkZWZlcnJlZCBkYXRhIHNob3VsZCBiZSBhd2FpdGVkIGZvciBmZXRjaGVyc1xuICAgICAgLy8gaW4gcmVzb2x2ZURlZmVycmVkUmVzdWx0c1xuICAgICAgaW52YXJpYW50KGZhbHNlLCBcIlVuaGFuZGxlZCBmZXRjaGVyIGRlZmVycmVkIGRhdGFcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkb25lRmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIklkbGVcIl0gPSB7XG4gICAgICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICAgICAgZGF0YTogcmVzdWx0LmRhdGEsXG4gICAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgICBcIiBfaGFzRmV0Y2hlckRvbmVBbnl0aGluZyBcIjogdHJ1ZSxcbiAgICAgIH07XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgbG9hZGVyRGF0YSwgZXJyb3JzIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlTG9hZGVyRGF0YShcbiAgbG9hZGVyRGF0YTogUm91dGVEYXRhLFxuICBuZXdMb2FkZXJEYXRhOiBSb3V0ZURhdGEsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgZXJyb3JzOiBSb3V0ZURhdGEgfCBudWxsIHwgdW5kZWZpbmVkXG4pOiBSb3V0ZURhdGEge1xuICBsZXQgbWVyZ2VkTG9hZGVyRGF0YSA9IHsgLi4ubmV3TG9hZGVyRGF0YSB9O1xuICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgaWYgKG5ld0xvYWRlckRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICBpZiAobmV3TG9hZGVyRGF0YVtpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtZXJnZWRMb2FkZXJEYXRhW2lkXSA9IG5ld0xvYWRlckRhdGFbaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8tb3AgLSB0aGlzIGlzIHNvIHdlIGlnbm9yZSBleGlzdGluZyBkYXRhIGlmIHdlIGhhdmUgYSBrZXkgaW4gdGhlXG4gICAgICAgIC8vIGluY29taW5nIG9iamVjdCB3aXRoIGFuIHVuZGVmaW5lZCB2YWx1ZSwgd2hpY2ggaXMgaG93IHdlIHVuc2V0IGEgcHJpb3JcbiAgICAgICAgLy8gbG9hZGVyRGF0YSBpZiB3ZSBlbmNvdW50ZXIgYSBsb2FkZXIgZXJyb3JcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvYWRlckRhdGFbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1lcmdlZExvYWRlckRhdGFbaWRdID0gbG9hZGVyRGF0YVtpZF07XG4gICAgfVxuXG4gICAgaWYgKGVycm9ycyAmJiBlcnJvcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAvLyBEb24ndCBrZWVwIGFueSBsb2FkZXIgZGF0YSBiZWxvdyB0aGUgYm91bmRhcnlcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VkTG9hZGVyRGF0YTtcbn1cblxuLy8gRmluZCB0aGUgbmVhcmVzdCBlcnJvciBib3VuZGFyeSwgbG9va2luZyB1cHdhcmRzIGZyb20gdGhlIGxlYWYgcm91dGUgKG9yIHRoZVxuLy8gcm91dGUgc3BlY2lmaWVkIGJ5IHJvdXRlSWQpIGZvciB0aGUgY2xvc2VzdCBhbmNlc3RvciBlcnJvciBib3VuZGFyeSxcbi8vIGRlZmF1bHRpbmcgdG8gdGhlIHJvb3QgbWF0Y2hcbmZ1bmN0aW9uIGZpbmROZWFyZXN0Qm91bmRhcnkoXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgcm91dGVJZD86IHN0cmluZ1xuKTogQWdub3N0aWNEYXRhUm91dGVNYXRjaCB7XG4gIGxldCBlbGlnaWJsZU1hdGNoZXMgPSByb3V0ZUlkXG4gICAgPyBtYXRjaGVzLnNsaWNlKDAsIG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSArIDEpXG4gICAgOiBbLi4ubWF0Y2hlc107XG4gIHJldHVybiAoXG4gICAgZWxpZ2libGVNYXRjaGVzLnJldmVyc2UoKS5maW5kKChtKSA9PiBtLnJvdXRlLmhhc0Vycm9yQm91bmRhcnkgPT09IHRydWUpIHx8XG4gICAgbWF0Y2hlc1swXVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKHJvdXRlczogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXSk6IHtcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdO1xuICByb3V0ZTogQWdub3N0aWNEYXRhUm91dGVPYmplY3Q7XG59IHtcbiAgLy8gUHJlZmVyIGEgcm9vdCBsYXlvdXQgcm91dGUgaWYgcHJlc2VudCwgb3RoZXJ3aXNlIHNoaW0gaW4gYSByb3V0ZSBvYmplY3RcbiAgbGV0IHJvdXRlID0gcm91dGVzLmZpbmQoKHIpID0+IHIuaW5kZXggfHwgIXIucGF0aCB8fCByLnBhdGggPT09IFwiL1wiKSB8fCB7XG4gICAgaWQ6IGBfX3NoaW0tZXJyb3Itcm91dGVfX2AsXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBtYXRjaGVzOiBbXG4gICAgICB7XG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIHBhdGhuYW1lOiBcIlwiLFxuICAgICAgICBwYXRobmFtZUJhc2U6IFwiXCIsXG4gICAgICAgIHJvdXRlLFxuICAgICAgfSxcbiAgICBdLFxuICAgIHJvdXRlLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKFxuICBzdGF0dXM6IG51bWJlcixcbiAge1xuICAgIHBhdGhuYW1lLFxuICAgIHJvdXRlSWQsXG4gICAgbWV0aG9kLFxuICAgIHR5cGUsXG4gIH06IHtcbiAgICBwYXRobmFtZT86IHN0cmluZztcbiAgICByb3V0ZUlkPzogc3RyaW5nO1xuICAgIG1ldGhvZD86IHN0cmluZztcbiAgICB0eXBlPzogXCJkZWZlci1hY3Rpb25cIjtcbiAgfSA9IHt9XG4pIHtcbiAgbGV0IHN0YXR1c1RleHQgPSBcIlVua25vd24gU2VydmVyIEVycm9yXCI7XG4gIGxldCBlcnJvck1lc3NhZ2UgPSBcIlVua25vd24gQHJlbWl4LXJ1bi9yb3V0ZXIgZXJyb3JcIjtcblxuICBpZiAoc3RhdHVzID09PSA0MDApIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJCYWQgUmVxdWVzdFwiO1xuICAgIGlmIChtZXRob2QgJiYgcGF0aG5hbWUgJiYgcm91dGVJZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgYFlvdSBtYWRlIGEgJHttZXRob2R9IHJlcXVlc3QgdG8gXCIke3BhdGhuYW1lfVwiIGJ1dCBgICtcbiAgICAgICAgYGRpZCBub3QgcHJvdmlkZSBhIFxcYGxvYWRlclxcYCBmb3Igcm91dGUgXCIke3JvdXRlSWR9XCIsIGAgK1xuICAgICAgICBgc28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5gO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJkZWZlci1hY3Rpb25cIikge1xuICAgICAgZXJyb3JNZXNzYWdlID0gXCJkZWZlcigpIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYWN0aW9uc1wiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwMykge1xuICAgIHN0YXR1c1RleHQgPSBcIkZvcmJpZGRlblwiO1xuICAgIGVycm9yTWVzc2FnZSA9IGBSb3V0ZSBcIiR7cm91dGVJZH1cIiBkb2VzIG5vdCBtYXRjaCBVUkwgXCIke3BhdGhuYW1lfVwiYDtcbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwNCkge1xuICAgIHN0YXR1c1RleHQgPSBcIk5vdCBGb3VuZFwiO1xuICAgIGVycm9yTWVzc2FnZSA9IGBObyByb3V0ZSBtYXRjaGVzIFVSTCBcIiR7cGF0aG5hbWV9XCJgO1xuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA1KSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCI7XG4gICAgaWYgKG1ldGhvZCAmJiBwYXRobmFtZSAmJiByb3V0ZUlkKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPVxuICAgICAgICBgWW91IG1hZGUgYSAke21ldGhvZC50b1VwcGVyQ2FzZSgpfSByZXF1ZXN0IHRvIFwiJHtwYXRobmFtZX1cIiBidXQgYCArXG4gICAgICAgIGBkaWQgbm90IHByb3ZpZGUgYW4gXFxgYWN0aW9uXFxgIGZvciByb3V0ZSBcIiR7cm91dGVJZH1cIiwgYCArXG4gICAgICAgIGBzbyB0aGVyZSBpcyBubyB3YXkgdG8gaGFuZGxlIHRoZSByZXF1ZXN0LmA7XG4gICAgfSBlbHNlIGlmIChtZXRob2QpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGBJbnZhbGlkIHJlcXVlc3QgbWV0aG9kIFwiJHttZXRob2QudG9VcHBlckNhc2UoKX1cImA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBFcnJvclJlc3BvbnNlKFxuICAgIHN0YXR1cyB8fCA1MDAsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSxcbiAgICB0cnVlXG4gICk7XG59XG5cbi8vIEZpbmQgYW55IHJldHVybmVkIHJlZGlyZWN0IGVycm9ycywgc3RhcnRpbmcgZnJvbSB0aGUgbG93ZXN0IG1hdGNoXG5mdW5jdGlvbiBmaW5kUmVkaXJlY3QocmVzdWx0czogRGF0YVJlc3VsdFtdKTogUmVkaXJlY3RSZXN1bHQgfCB1bmRlZmluZWQge1xuICBmb3IgKGxldCBpID0gcmVzdWx0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmlwSGFzaEZyb21QYXRoKHBhdGg6IFRvKSB7XG4gIGxldCBwYXJzZWRQYXRoID0gdHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgocGF0aCkgOiBwYXRoO1xuICByZXR1cm4gY3JlYXRlUGF0aCh7IC4uLnBhcnNlZFBhdGgsIGhhc2g6IFwiXCIgfSk7XG59XG5cbmZ1bmN0aW9uIGlzSGFzaENoYW5nZU9ubHkoYTogTG9jYXRpb24sIGI6IExvY2F0aW9uKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiYgYS5oYXNoICE9PSBiLmhhc2hcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQ6IERhdGFSZXN1bHQpOiByZXN1bHQgaXMgRGVmZXJyZWRSZXN1bHQge1xuICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFJlc3VsdFR5cGUuZGVmZXJyZWQ7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JSZXN1bHQocmVzdWx0OiBEYXRhUmVzdWx0KTogcmVzdWx0IGlzIEVycm9yUmVzdWx0IHtcbiAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBSZXN1bHRUeXBlLmVycm9yO1xufVxuXG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdD86IERhdGFSZXN1bHQpOiByZXN1bHQgaXMgUmVkaXJlY3RSZXN1bHQge1xuICByZXR1cm4gKHJlc3VsdCAmJiByZXN1bHQudHlwZSkgPT09IFJlc3VsdFR5cGUucmVkaXJlY3Q7XG59XG5cbmZ1bmN0aW9uIGlzUmVzcG9uc2UodmFsdWU6IGFueSk6IHZhbHVlIGlzIFJlc3BvbnNlIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSAhPSBudWxsICYmXG4gICAgdHlwZW9mIHZhbHVlLnN0YXR1cyA9PT0gXCJudW1iZXJcIiAmJlxuICAgIHR5cGVvZiB2YWx1ZS5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmXG4gICAgdHlwZW9mIHZhbHVlLmhlYWRlcnMgPT09IFwib2JqZWN0XCIgJiZcbiAgICB0eXBlb2YgdmFsdWUuYm9keSAhPT0gXCJ1bmRlZmluZWRcIlxuICApO1xufVxuXG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzcG9uc2UocmVzdWx0OiBhbnkpOiByZXN1bHQgaXMgUmVzcG9uc2Uge1xuICBpZiAoIWlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxldCBzdGF0dXMgPSByZXN1bHQuc3RhdHVzO1xuICBsZXQgbG9jYXRpb24gPSByZXN1bHQuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKTtcbiAgcmV0dXJuIHN0YXR1cyA+PSAzMDAgJiYgc3RhdHVzIDw9IDM5OSAmJiBsb2NhdGlvbiAhPSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1F1ZXJ5Um91dGVSZXNwb25zZShvYmo6IGFueSk6IG9iaiBpcyBRdWVyeVJvdXRlUmVzcG9uc2Uge1xuICByZXR1cm4gKFxuICAgIG9iaiAmJlxuICAgIGlzUmVzcG9uc2Uob2JqLnJlc3BvbnNlKSAmJlxuICAgIChvYmoudHlwZSA9PT0gUmVzdWx0VHlwZS5kYXRhIHx8IFJlc3VsdFR5cGUuZXJyb3IpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRNZXRob2QobWV0aG9kOiBzdHJpbmcpOiBtZXRob2QgaXMgRm9ybU1ldGhvZCB7XG4gIHJldHVybiB2YWxpZFJlcXVlc3RNZXRob2RzLmhhcyhtZXRob2QgYXMgRm9ybU1ldGhvZCk7XG59XG5cbmZ1bmN0aW9uIGlzTXV0YXRpb25NZXRob2QobWV0aG9kPzogc3RyaW5nKTogbWV0aG9kIGlzIE11dGF0aW9uRm9ybU1ldGhvZCB7XG4gIHJldHVybiB2YWxpZE11dGF0aW9uTWV0aG9kcy5oYXMobWV0aG9kIGFzIE11dGF0aW9uRm9ybU1ldGhvZCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVEZWZlcnJlZFJlc3VsdHMoXG4gIGN1cnJlbnRNYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIG1hdGNoZXNUb0xvYWQ6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgcmVzdWx0czogRGF0YVJlc3VsdFtdLFxuICBzaWduYWw6IEFib3J0U2lnbmFsLFxuICBpc0ZldGNoZXI6IGJvb2xlYW4sXG4gIGN1cnJlbnRMb2FkZXJEYXRhPzogUm91dGVEYXRhXG4pIHtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHJlc3VsdHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbaW5kZXhdO1xuICAgIGxldCBtYXRjaCA9IG1hdGNoZXNUb0xvYWRbaW5kZXhdO1xuICAgIGxldCBjdXJyZW50TWF0Y2ggPSBjdXJyZW50TWF0Y2hlcy5maW5kKFxuICAgICAgKG0pID0+IG0ucm91dGUuaWQgPT09IG1hdGNoLnJvdXRlLmlkXG4gICAgKTtcbiAgICBsZXQgaXNSZXZhbGlkYXRpbmdMb2FkZXIgPVxuICAgICAgY3VycmVudE1hdGNoICE9IG51bGwgJiZcbiAgICAgICFpc05ld1JvdXRlSW5zdGFuY2UoY3VycmVudE1hdGNoLCBtYXRjaCkgJiZcbiAgICAgIChjdXJyZW50TG9hZGVyRGF0YSAmJiBjdXJyZW50TG9hZGVyRGF0YVttYXRjaC5yb3V0ZS5pZF0pICE9PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpICYmIChpc0ZldGNoZXIgfHwgaXNSZXZhbGlkYXRpbmdMb2FkZXIpKSB7XG4gICAgICAvLyBOb3RlOiB3ZSBkbyBub3QgaGF2ZSB0byB0b3VjaCBhY3RpdmVEZWZlcnJlZHMgaGVyZSBzaW5jZSB3ZSByYWNlIHRoZW1cbiAgICAgIC8vIGFnYWluc3QgdGhlIHNpZ25hbCBpbiByZXNvbHZlRGVmZXJyZWREYXRhIGFuZCB0aGV5J2xsIGdldCBhYm9ydGVkXG4gICAgICAvLyB0aGVyZSBpZiBuZWVkZWRcbiAgICAgIGF3YWl0IHJlc29sdmVEZWZlcnJlZERhdGEocmVzdWx0LCBzaWduYWwsIGlzRmV0Y2hlcikudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHJlc3VsdCB8fCByZXN1bHRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVEZWZlcnJlZERhdGEoXG4gIHJlc3VsdDogRGVmZXJyZWRSZXN1bHQsXG4gIHNpZ25hbDogQWJvcnRTaWduYWwsXG4gIHVud3JhcCA9IGZhbHNlXG4pOiBQcm9taXNlPFN1Y2Nlc3NSZXN1bHQgfCBFcnJvclJlc3VsdCB8IHVuZGVmaW5lZD4ge1xuICBsZXQgYWJvcnRlZCA9IGF3YWl0IHJlc3VsdC5kZWZlcnJlZERhdGEucmVzb2x2ZURhdGEoc2lnbmFsKTtcbiAgaWYgKGFib3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodW53cmFwKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICAgICAgZGF0YTogcmVzdWx0LmRlZmVycmVkRGF0YS51bndyYXBwZWREYXRhLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBIYW5kbGUgYW55IFRyYWNrZWRQcm9taXNlLl9lcnJvciB2YWx1ZXMgZW5jb3VudGVyZWQgd2hpbGUgdW53cmFwcGluZ1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgZXJyb3I6IGUsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogUmVzdWx0VHlwZS5kYXRhLFxuICAgIGRhdGE6IHJlc3VsdC5kZWZlcnJlZERhdGEuZGF0YSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gaGFzTmFrZWRJbmRleFF1ZXJ5KHNlYXJjaDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKHNlYXJjaCkuZ2V0QWxsKFwiaW5kZXhcIikuc29tZSgodikgPT4gdiA9PT0gXCJcIik7XG59XG5cbi8vIE5vdGU6IFRoaXMgc2hvdWxkIG1hdGNoIHRoZSBmb3JtYXQgZXhwb3J0ZWQgYnkgdXNlTWF0Y2hlcywgc28gaWYgeW91IGNoYW5nZVxuLy8gdGhpcyBwbGVhc2UgYWxzbyBjaGFuZ2UgdGhhdCA6KSAgRXZlbnR1YWxseSB3ZSdsbCBEUlkgdGhpcyB1cFxuZnVuY3Rpb24gY3JlYXRlVXNlTWF0Y2hlc01hdGNoKFxuICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgbG9hZGVyRGF0YTogUm91dGVEYXRhXG4pOiBVc2VNYXRjaGVzTWF0Y2gge1xuICBsZXQgeyByb3V0ZSwgcGF0aG5hbWUsIHBhcmFtcyB9ID0gbWF0Y2g7XG4gIHJldHVybiB7XG4gICAgaWQ6IHJvdXRlLmlkLFxuICAgIHBhdGhuYW1lLFxuICAgIHBhcmFtcyxcbiAgICBkYXRhOiBsb2FkZXJEYXRhW3JvdXRlLmlkXSBhcyB1bmtub3duLFxuICAgIGhhbmRsZTogcm91dGUuaGFuZGxlIGFzIHVua25vd24sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldE1hdGNoKFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIGxvY2F0aW9uOiBMb2NhdGlvbiB8IHN0cmluZ1xuKSB7XG4gIGxldCBzZWFyY2ggPVxuICAgIHR5cGVvZiBsb2NhdGlvbiA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbikuc2VhcmNoIDogbG9jYXRpb24uc2VhcmNoO1xuICBpZiAoXG4gICAgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmluZGV4ICYmXG4gICAgaGFzTmFrZWRJbmRleFF1ZXJ5KHNlYXJjaCB8fCBcIlwiKVxuICApIHtcbiAgICAvLyBSZXR1cm4gdGhlIGxlYWYgaW5kZXggcm91dGUgd2hlbiBpbmRleCBpcyBwcmVzZW50XG4gICAgcmV0dXJuIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgfVxuICAvLyBPdGhlcndpc2UgZ3JhYiB0aGUgZGVlcGVzdCBcInBhdGggY29udHJpYnV0aW5nXCIgbWF0Y2ggKGlnbm9yaW5nIGluZGV4IGFuZFxuICAvLyBwYXRobGVzcyBsYXlvdXQgcm91dGVzKVxuICBsZXQgcGF0aE1hdGNoZXMgPSBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKTtcbiAgcmV0dXJuIHBhdGhNYXRjaGVzW3BhdGhNYXRjaGVzLmxlbmd0aCAtIDFdO1xufVxuLy8jZW5kcmVnaW9uXG4iLCJpbXBvcnQgdHlwZSB7IEZvcm1FbmNUeXBlLCBGb3JtTWV0aG9kIH0gZnJvbSBcIkByZW1peC1ydW4vcm91dGVyXCI7XG5pbXBvcnQgdHlwZSB7IFJlbGF0aXZlUm91dGluZ1R5cGUgfSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0TWV0aG9kID0gXCJnZXRcIjtcbmNvbnN0IGRlZmF1bHRFbmNUeXBlID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzSHRtbEVsZW1lbnQob2JqZWN0OiBhbnkpOiBvYmplY3QgaXMgSFRNTEVsZW1lbnQge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdC50YWdOYW1lID09PSBcInN0cmluZ1wiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNCdXR0b25FbGVtZW50KG9iamVjdDogYW55KTogb2JqZWN0IGlzIEhUTUxCdXR0b25FbGVtZW50IHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImJ1dHRvblwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNGb3JtRWxlbWVudChvYmplY3Q6IGFueSk6IG9iamVjdCBpcyBIVE1MRm9ybUVsZW1lbnQge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZm9ybVwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnB1dEVsZW1lbnQob2JqZWN0OiBhbnkpOiBvYmplY3QgaXMgSFRNTElucHV0RWxlbWVudCB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiO1xufVxuXG50eXBlIExpbWl0ZWRNb3VzZUV2ZW50ID0gUGljazxcbiAgTW91c2VFdmVudCxcbiAgXCJidXR0b25cIiB8IFwibWV0YUtleVwiIHwgXCJhbHRLZXlcIiB8IFwiY3RybEtleVwiIHwgXCJzaGlmdEtleVwiXG4+O1xuXG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQ6IExpbWl0ZWRNb3VzZUV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZFByb2Nlc3NMaW5rQ2xpY2soXG4gIGV2ZW50OiBMaW1pdGVkTW91c2VFdmVudCxcbiAgdGFyZ2V0Pzogc3RyaW5nXG4pIHtcbiAgcmV0dXJuIChcbiAgICBldmVudC5idXR0b24gPT09IDAgJiYgLy8gSWdub3JlIGV2ZXJ5dGhpbmcgYnV0IGxlZnQgY2xpY2tzXG4gICAgKCF0YXJnZXQgfHwgdGFyZ2V0ID09PSBcIl9zZWxmXCIpICYmIC8vIExldCBicm93c2VyIGhhbmRsZSBcInRhcmdldD1fYmxhbmtcIiBldGMuXG4gICAgIWlzTW9kaWZpZWRFdmVudChldmVudCkgLy8gSWdub3JlIGNsaWNrcyB3aXRoIG1vZGlmaWVyIGtleXNcbiAgKTtcbn1cblxuZXhwb3J0IHR5cGUgUGFyYW1LZXlWYWx1ZVBhaXIgPSBbc3RyaW5nLCBzdHJpbmddO1xuXG5leHBvcnQgdHlwZSBVUkxTZWFyY2hQYXJhbXNJbml0ID1cbiAgfCBzdHJpbmdcbiAgfCBQYXJhbUtleVZhbHVlUGFpcltdXG4gIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+XG4gIHwgVVJMU2VhcmNoUGFyYW1zO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0IHVzaW5nIHRoZSBnaXZlbiBpbml0aWFsaXplci5cbiAqXG4gKiBUaGlzIGlzIGlkZW50aWNhbCB0byBgbmV3IFVSTFNlYXJjaFBhcmFtcyhpbml0KWAgZXhjZXB0IGl0IGFsc29cbiAqIHN1cHBvcnRzIGFycmF5cyBhcyB2YWx1ZXMgaW4gdGhlIG9iamVjdCBmb3JtIG9mIHRoZSBpbml0aWFsaXplclxuICogaW5zdGVhZCBvZiBqdXN0IHN0cmluZ3MuIFRoaXMgaXMgY29udmVuaWVudCB3aGVuIHlvdSBuZWVkIG11bHRpcGxlXG4gKiB2YWx1ZXMgZm9yIGEgZ2l2ZW4ga2V5LCBidXQgZG9uJ3Qgd2FudCB0byB1c2UgYW4gYXJyYXkgaW5pdGlhbGl6ZXIuXG4gKlxuICogRm9yIGV4YW1wbGUsIGluc3RlYWQgb2Y6XG4gKlxuICogICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhbXG4gKiAgICAgWydzb3J0JywgJ25hbWUnXSxcbiAqICAgICBbJ3NvcnQnLCAncHJpY2UnXVxuICogICBdKTtcbiAqXG4gKiB5b3UgY2FuIGRvOlxuICpcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyh7XG4gKiAgICAgc29ydDogWyduYW1lJywgJ3ByaWNlJ11cbiAqICAgfSk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWFyY2hQYXJhbXMoXG4gIGluaXQ6IFVSTFNlYXJjaFBhcmFtc0luaXQgPSBcIlwiXG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhcbiAgICB0eXBlb2YgaW5pdCA9PT0gXCJzdHJpbmdcIiB8fFxuICAgIEFycmF5LmlzQXJyYXkoaW5pdCkgfHxcbiAgICBpbml0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zXG4gICAgICA/IGluaXRcbiAgICAgIDogT2JqZWN0LmtleXMoaW5pdCkucmVkdWNlKChtZW1vLCBrZXkpID0+IHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBpbml0W2tleV07XG4gICAgICAgICAgcmV0dXJuIG1lbW8uY29uY2F0KFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAoKHYpID0+IFtrZXksIHZdKSA6IFtba2V5LCB2YWx1ZV1dXG4gICAgICAgICAgKTtcbiAgICAgICAgfSwgW10gYXMgUGFyYW1LZXlWYWx1ZVBhaXJbXSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uKFxuICBsb2NhdGlvblNlYXJjaDogc3RyaW5nLFxuICBkZWZhdWx0U2VhcmNoUGFyYW1zOiBVUkxTZWFyY2hQYXJhbXMgfCBudWxsXG4pIHtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyhsb2NhdGlvblNlYXJjaCk7XG5cbiAgaWYgKGRlZmF1bHRTZWFyY2hQYXJhbXMpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgZGVmYXVsdFNlYXJjaFBhcmFtcy5rZXlzKCkpIHtcbiAgICAgIGlmICghc2VhcmNoUGFyYW1zLmhhcyhrZXkpKSB7XG4gICAgICAgIGRlZmF1bHRTZWFyY2hQYXJhbXMuZ2V0QWxsKGtleSkuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VhcmNoUGFyYW1zO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN1Ym1pdE9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIEhUVFAgbWV0aG9kIHVzZWQgdG8gc3VibWl0IHRoZSBmb3JtLiBPdmVycmlkZXMgYDxmb3JtIG1ldGhvZD5gLlxuICAgKiBEZWZhdWx0cyB0byBcIkdFVFwiLlxuICAgKi9cbiAgbWV0aG9kPzogRm9ybU1ldGhvZDtcblxuICAvKipcbiAgICogVGhlIGFjdGlvbiBVUkwgcGF0aCB1c2VkIHRvIHN1Ym1pdCB0aGUgZm9ybS4gT3ZlcnJpZGVzIGA8Zm9ybSBhY3Rpb24+YC5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHBhdGggb2YgdGhlIGN1cnJlbnQgcm91dGUuXG4gICAqXG4gICAqIE5vdGU6IEl0IGlzIGFzc3VtZWQgdGhlIHBhdGggaXMgYWxyZWFkeSByZXNvbHZlZC4gSWYgeW91IG5lZWQgdG8gcmVzb2x2ZSBhXG4gICAqIHJlbGF0aXZlIHBhdGgsIHVzZSBgdXNlRm9ybUFjdGlvbmAuXG4gICAqL1xuICBhY3Rpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBhY3Rpb24gVVJMIHVzZWQgdG8gc3VibWl0IHRoZSBmb3JtLiBPdmVycmlkZXMgYDxmb3JtIGVuY1R5cGU+YC5cbiAgICogRGVmYXVsdHMgdG8gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIi5cbiAgICovXG4gIGVuY1R5cGU/OiBGb3JtRW5jVHlwZTtcblxuICAvKipcbiAgICogU2V0IGB0cnVlYCB0byByZXBsYWNlIHRoZSBjdXJyZW50IGVudHJ5IGluIHRoZSBicm93c2VyJ3MgaGlzdG9yeSBzdGFja1xuICAgKiBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG9uZSAoaS5lLiBzdGF5IG9uIFwidGhlIHNhbWUgcGFnZVwiKS4gRGVmYXVsdHNcbiAgICogdG8gYGZhbHNlYC5cbiAgICovXG4gIHJlcGxhY2U/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZvcm0gYWN0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSByb3V0ZSBoaWVyYXJjaHkgb3JcbiAgICogdGhlIHBhdGhuYW1lLiAgVXNlIHRoaXMgaWYgeW91IHdhbnQgdG8gb3B0IG91dCBvZiBuYXZpZ2F0aW5nIHRoZSByb3V0ZVxuICAgKiBoaWVyYXJjaHkgYW5kIHdhbnQgdG8gaW5zdGVhZCByb3V0ZSBiYXNlZCBvbiAvLWRlbGltaXRlZCBVUkwgc2VnbWVudHNcbiAgICovXG4gIHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZTtcblxuICAvKipcbiAgICogSW4gYnJvd3Nlci1iYXNlZCBlbnZpcm9ubWVudHMsIHByZXZlbnQgcmVzZXR0aW5nIHNjcm9sbCBhZnRlciB0aGlzXG4gICAqIG5hdmlnYXRpb24gd2hlbiB1c2luZyB0aGUgPFNjcm9sbFJlc3RvcmF0aW9uPiBjb21wb25lbnRcbiAgICovXG4gIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGb3JtU3VibWlzc2lvbkluZm8oXG4gIHRhcmdldDpcbiAgICB8IEhUTUxGb3JtRWxlbWVudFxuICAgIHwgSFRNTEJ1dHRvbkVsZW1lbnRcbiAgICB8IEhUTUxJbnB1dEVsZW1lbnRcbiAgICB8IEZvcm1EYXRhXG4gICAgfCBVUkxTZWFyY2hQYXJhbXNcbiAgICB8IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9XG4gICAgfCBudWxsLFxuICBkZWZhdWx0QWN0aW9uOiBzdHJpbmcsXG4gIG9wdGlvbnM6IFN1Ym1pdE9wdGlvbnNcbik6IHtcbiAgdXJsOiBVUkw7XG4gIG1ldGhvZDogc3RyaW5nO1xuICBlbmNUeXBlOiBzdHJpbmc7XG4gIGZvcm1EYXRhOiBGb3JtRGF0YTtcbn0ge1xuICBsZXQgbWV0aG9kOiBzdHJpbmc7XG4gIGxldCBhY3Rpb246IHN0cmluZztcbiAgbGV0IGVuY1R5cGU6IHN0cmluZztcbiAgbGV0IGZvcm1EYXRhOiBGb3JtRGF0YTtcblxuICBpZiAoaXNGb3JtRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgbGV0IHN1Ym1pc3Npb25UcmlnZ2VyOiBIVE1MQnV0dG9uRWxlbWVudCB8IEhUTUxJbnB1dEVsZW1lbnQgPSAoXG4gICAgICBvcHRpb25zIGFzIGFueVxuICAgICkuc3VibWlzc2lvblRyaWdnZXI7XG5cbiAgICBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCB0YXJnZXQuZ2V0QXR0cmlidXRlKFwibWV0aG9kXCIpIHx8IGRlZmF1bHRNZXRob2Q7XG4gICAgYWN0aW9uID0gb3B0aW9ucy5hY3Rpb24gfHwgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImFjdGlvblwiKSB8fCBkZWZhdWx0QWN0aW9uO1xuICAgIGVuY1R5cGUgPVxuICAgICAgb3B0aW9ucy5lbmNUeXBlIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIpIHx8IGRlZmF1bHRFbmNUeXBlO1xuXG4gICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEodGFyZ2V0KTtcblxuICAgIGlmIChzdWJtaXNzaW9uVHJpZ2dlciAmJiBzdWJtaXNzaW9uVHJpZ2dlci5uYW1lKSB7XG4gICAgICBmb3JtRGF0YS5hcHBlbmQoc3VibWlzc2lvblRyaWdnZXIubmFtZSwgc3VibWlzc2lvblRyaWdnZXIudmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICBpc0J1dHRvbkVsZW1lbnQodGFyZ2V0KSB8fFxuICAgIChpc0lucHV0RWxlbWVudCh0YXJnZXQpICYmXG4gICAgICAodGFyZ2V0LnR5cGUgPT09IFwic3VibWl0XCIgfHwgdGFyZ2V0LnR5cGUgPT09IFwiaW1hZ2VcIikpXG4gICkge1xuICAgIGxldCBmb3JtID0gdGFyZ2V0LmZvcm07XG5cbiAgICBpZiAoZm9ybSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgc3VibWl0IGEgPGJ1dHRvbj4gb3IgPGlucHV0IHR5cGU9XCJzdWJtaXRcIj4gd2l0aG91dCBhIDxmb3JtPmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gPGJ1dHRvbj4vPGlucHV0IHR5cGU9XCJzdWJtaXRcIj4gbWF5IG92ZXJyaWRlIGF0dHJpYnV0ZXMgb2YgPGZvcm0+XG5cbiAgICBtZXRob2QgPVxuICAgICAgb3B0aW9ucy5tZXRob2QgfHxcbiAgICAgIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpIHx8XG4gICAgICBmb3JtLmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKSB8fFxuICAgICAgZGVmYXVsdE1ldGhvZDtcbiAgICBhY3Rpb24gPVxuICAgICAgb3B0aW9ucy5hY3Rpb24gfHxcbiAgICAgIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtYWN0aW9uXCIpIHx8XG4gICAgICBmb3JtLmdldEF0dHJpYnV0ZShcImFjdGlvblwiKSB8fFxuICAgICAgZGVmYXVsdEFjdGlvbjtcbiAgICBlbmNUeXBlID1cbiAgICAgIG9wdGlvbnMuZW5jVHlwZSB8fFxuICAgICAgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1lbmN0eXBlXCIpIHx8XG4gICAgICBmb3JtLmdldEF0dHJpYnV0ZShcImVuY3R5cGVcIikgfHxcbiAgICAgIGRlZmF1bHRFbmNUeXBlO1xuXG4gICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoZm9ybSk7XG5cbiAgICAvLyBJbmNsdWRlIG5hbWUgKyB2YWx1ZSBmcm9tIGEgPGJ1dHRvbj4sIGFwcGVuZGluZyBpbiBjYXNlIHRoZSBidXR0b24gbmFtZVxuICAgIC8vIG1hdGNoZXMgYW4gZXhpc3RpbmcgaW5wdXQgbmFtZVxuICAgIGlmICh0YXJnZXQubmFtZSkge1xuICAgICAgZm9ybURhdGEuYXBwZW5kKHRhcmdldC5uYW1lLCB0YXJnZXQudmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0h0bWxFbGVtZW50KHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2Fubm90IHN1Ym1pdCBlbGVtZW50IHRoYXQgaXMgbm90IDxmb3JtPiwgPGJ1dHRvbj4sIG9yIGAgK1xuICAgICAgICBgPGlucHV0IHR5cGU9XCJzdWJtaXR8aW1hZ2VcIj5gXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCBkZWZhdWx0TWV0aG9kO1xuICAgIGFjdGlvbiA9IG9wdGlvbnMuYWN0aW9uIHx8IGRlZmF1bHRBY3Rpb247XG4gICAgZW5jVHlwZSA9IG9wdGlvbnMuZW5jVHlwZSB8fCBkZWZhdWx0RW5jVHlwZTtcblxuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgZm9ybURhdGEgPSB0YXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgZm9yIChsZXQgW25hbWUsIHZhbHVlXSBvZiB0YXJnZXQpIHtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAobGV0IG5hbWUgb2YgT2JqZWN0LmtleXModGFyZ2V0KSkge1xuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChuYW1lLCB0YXJnZXRbbmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IHsgcHJvdG9jb2wsIGhvc3QgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgbGV0IHVybCA9IG5ldyBVUkwoYWN0aW9uLCBgJHtwcm90b2NvbH0vLyR7aG9zdH1gKTtcblxuICByZXR1cm4geyB1cmwsIG1ldGhvZDogbWV0aG9kLnRvTG93ZXJDYXNlKCksIGVuY1R5cGUsIGZvcm1EYXRhIH07XG59XG4iLCIvKipcbiAqIE5PVEU6IElmIHlvdSByZWZhY3RvciB0aGlzIHRvIHNwbGl0IHVwIHRoZSBtb2R1bGVzIGludG8gc2VwYXJhdGUgZmlsZXMsXG4gKiB5b3UnbGwgbmVlZCB0byB1cGRhdGUgdGhlIHJvbGx1cCBjb25maWcgZm9yIHJlYWN0LXJvdXRlci1kb20tdjUtY29tcGF0LlxuICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHtcbiAgTmF2aWdhdGVPcHRpb25zLFxuICBSZWxhdGl2ZVJvdXRpbmdUeXBlLFxuICBSb3V0ZU9iamVjdCxcbiAgVG8sXG59IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcbmltcG9ydCB7XG4gIFJvdXRlcixcbiAgY3JlYXRlUGF0aCxcbiAgdXNlSHJlZixcbiAgdXNlTG9jYXRpb24sXG4gIHVzZU1hdGNoZXMsXG4gIHVzZU5hdmlnYXRlLFxuICB1c2VOYXZpZ2F0aW9uLFxuICB1c2VSZXNvbHZlZFBhdGgsXG4gIHVuc3RhYmxlX3VzZUJsb2NrZXIgYXMgdXNlQmxvY2tlcixcbiAgVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0IGFzIERhdGFSb3V0ZXJDb250ZXh0LFxuICBVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCBhcyBEYXRhUm91dGVyU3RhdGVDb250ZXh0LFxuICBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQgYXMgTmF2aWdhdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9Sb3V0ZUNvbnRleHQgYXMgUm91dGVDb250ZXh0LFxuICBVTlNBRkVfZW5oYW5jZU1hbnVhbFJvdXRlT2JqZWN0cyBhcyBlbmhhbmNlTWFudWFsUm91dGVPYmplY3RzLFxufSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG5pbXBvcnQgdHlwZSB7XG4gIEJyb3dzZXJIaXN0b3J5LFxuICBGZXRjaGVyLFxuICBGb3JtRW5jVHlwZSxcbiAgRm9ybU1ldGhvZCxcbiAgR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvbixcbiAgSGFzaEhpc3RvcnksXG4gIEhpc3RvcnksXG4gIEh5ZHJhdGlvblN0YXRlLFxuICBSb3V0ZXIgYXMgUmVtaXhSb3V0ZXIsXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuaW1wb3J0IHtcbiAgY3JlYXRlUm91dGVyLFxuICBjcmVhdGVCcm93c2VySGlzdG9yeSxcbiAgY3JlYXRlSGFzaEhpc3RvcnksXG4gIGludmFyaWFudCxcbiAgam9pblBhdGhzLFxuICBFcnJvclJlc3BvbnNlLFxufSBmcm9tIFwiQHJlbWl4LXJ1bi9yb3V0ZXJcIjtcblxuaW1wb3J0IHR5cGUge1xuICBTdWJtaXRPcHRpb25zLFxuICBQYXJhbUtleVZhbHVlUGFpcixcbiAgVVJMU2VhcmNoUGFyYW1zSW5pdCxcbn0gZnJvbSBcIi4vZG9tXCI7XG5pbXBvcnQge1xuICBjcmVhdGVTZWFyY2hQYXJhbXMsXG4gIGRlZmF1bHRNZXRob2QsXG4gIGdldEZvcm1TdWJtaXNzaW9uSW5mbyxcbiAgZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24sXG4gIHNob3VsZFByb2Nlc3NMaW5rQ2xpY2ssXG59IGZyb20gXCIuL2RvbVwiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIFJlLWV4cG9ydHNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCB0eXBlIHtcbiAgRm9ybUVuY1R5cGUsXG4gIEZvcm1NZXRob2QsXG4gIEdldFNjcm9sbFJlc3RvcmF0aW9uS2V5RnVuY3Rpb24sXG4gIFBhcmFtS2V5VmFsdWVQYWlyLFxuICBTdWJtaXRPcHRpb25zLFxuICBVUkxTZWFyY2hQYXJhbXNJbml0LFxufTtcbmV4cG9ydCB7IGNyZWF0ZVNlYXJjaFBhcmFtcyB9O1xuXG4vLyBOb3RlOiBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yb3V0ZXIgZXhwb3J0cyFcbmV4cG9ydCB0eXBlIHtcbiAgQWN0aW9uRnVuY3Rpb24sXG4gIEFjdGlvbkZ1bmN0aW9uQXJncyxcbiAgQXdhaXRQcm9wcyxcbiAgdW5zdGFibGVfQmxvY2tlcixcbiAgdW5zdGFibGVfQmxvY2tlckZ1bmN0aW9uLFxuICBEYXRhUm91dGVNYXRjaCxcbiAgRGF0YVJvdXRlT2JqZWN0LFxuICBGZXRjaGVyLFxuICBIYXNoLFxuICBJbmRleFJvdXRlT2JqZWN0LFxuICBJbmRleFJvdXRlUHJvcHMsXG4gIEpzb25GdW5jdGlvbixcbiAgTGF5b3V0Um91dGVQcm9wcyxcbiAgTG9hZGVyRnVuY3Rpb24sXG4gIExvYWRlckZ1bmN0aW9uQXJncyxcbiAgTG9jYXRpb24sXG4gIE1lbW9yeVJvdXRlclByb3BzLFxuICBOYXZpZ2F0ZUZ1bmN0aW9uLFxuICBOYXZpZ2F0ZU9wdGlvbnMsXG4gIE5hdmlnYXRlUHJvcHMsXG4gIE5hdmlnYXRpb24sXG4gIE5hdmlnYXRvcixcbiAgTm9uSW5kZXhSb3V0ZU9iamVjdCxcbiAgT3V0bGV0UHJvcHMsXG4gIFBhcmFtcyxcbiAgUGFyYW1QYXJzZUtleSxcbiAgUGF0aCxcbiAgUGF0aE1hdGNoLFxuICBQYXRobmFtZSxcbiAgUGF0aFBhdHRlcm4sXG4gIFBhdGhSb3V0ZVByb3BzLFxuICBSZWRpcmVjdEZ1bmN0aW9uLFxuICBSZWxhdGl2ZVJvdXRpbmdUeXBlLFxuICBSb3V0ZU1hdGNoLFxuICBSb3V0ZU9iamVjdCxcbiAgUm91dGVQcm9wcyxcbiAgUm91dGVyUHJvcHMsXG4gIFJvdXRlclByb3ZpZGVyUHJvcHMsXG4gIFJvdXRlc1Byb3BzLFxuICBTZWFyY2gsXG4gIFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbixcbiAgVG8sXG59IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcbmV4cG9ydCB7XG4gIEFib3J0ZWREZWZlcnJlZEVycm9yLFxuICBBd2FpdCxcbiAgTWVtb3J5Um91dGVyLFxuICBOYXZpZ2F0ZSxcbiAgTmF2aWdhdGlvblR5cGUsXG4gIE91dGxldCxcbiAgUm91dGUsXG4gIFJvdXRlcixcbiAgUm91dGVyUHJvdmlkZXIsXG4gIFJvdXRlcyxcbiAgY3JlYXRlTWVtb3J5Um91dGVyLFxuICBjcmVhdGVQYXRoLFxuICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sXG4gIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cyxcbiAgZGVmZXIsXG4gIGlzUm91dGVFcnJvclJlc3BvbnNlLFxuICBnZW5lcmF0ZVBhdGgsXG4gIGpzb24sXG4gIG1hdGNoUGF0aCxcbiAgbWF0Y2hSb3V0ZXMsXG4gIHBhcnNlUGF0aCxcbiAgcmVkaXJlY3QsXG4gIHJlbmRlck1hdGNoZXMsXG4gIHJlc29sdmVQYXRoLFxuICB1c2VBY3Rpb25EYXRhLFxuICB1c2VBc3luY0Vycm9yLFxuICB1c2VBc3luY1ZhbHVlLFxuICB1bnN0YWJsZV91c2VCbG9ja2VyLFxuICB1c2VIcmVmLFxuICB1c2VJblJvdXRlckNvbnRleHQsXG4gIHVzZUxvYWRlckRhdGEsXG4gIHVzZUxvY2F0aW9uLFxuICB1c2VNYXRjaCxcbiAgdXNlTWF0Y2hlcyxcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU5hdmlnYXRpb24sXG4gIHVzZU5hdmlnYXRpb25UeXBlLFxuICB1c2VPdXRsZXQsXG4gIHVzZU91dGxldENvbnRleHQsXG4gIHVzZVBhcmFtcyxcbiAgdXNlUmVzb2x2ZWRQYXRoLFxuICB1c2VSZXZhbGlkYXRvcixcbiAgdXNlUm91dGVFcnJvcixcbiAgdXNlUm91dGVMb2FkZXJEYXRhLFxuICB1c2VSb3V0ZXMsXG59IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gREFOR0VSISBQTEVBU0UgUkVBRCBNRSFcbi8vIFdlIHByb3ZpZGUgdGhlc2UgZXhwb3J0cyBhcyBhbiBlc2NhcGUgaGF0Y2ggaW4gdGhlIGV2ZW50IHRoYXQgeW91IG5lZWQgYW55XG4vLyByb3V0aW5nIGRhdGEgdGhhdCB3ZSBkb24ndCBwcm92aWRlIGFuIGV4cGxpY2l0IEFQSSBmb3IuIFdpdGggdGhhdCBzYWlkLCB3ZVxuLy8gd2FudCB0byBjb3ZlciB5b3VyIHVzZSBjYXNlIGlmIHdlIGNhbiwgc28gaWYgeW91IGZlZWwgdGhlIG5lZWQgdG8gdXNlIHRoZXNlXG4vLyB3ZSB3YW50IHRvIGhlYXIgZnJvbSB5b3UuIExldCB1cyBrbm93IHdoYXQgeW91J3JlIGJ1aWxkaW5nIGFuZCB3ZSdsbCBkbyBvdXJcbi8vIGJlc3QgdG8gbWFrZSBzdXJlIHdlIGNhbiBzdXBwb3J0IHlvdSFcbi8vXG4vLyBXZSBjb25zaWRlciB0aGVzZSBleHBvcnRzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBhbmQgZG8gbm90IGd1YXJhbnRlZVxuLy8gYWdhaW5zdCBhbnkgYnJlYWtpbmcgY2hhbmdlcywgcmVnYXJkbGVzcyBvZiB0aGUgc2VtdmVyIHJlbGVhc2UuIFVzZSB3aXRoXG4vLyBleHRyZW1lIGNhdXRpb24gYW5kIG9ubHkgaWYgeW91IHVuZGVyc3RhbmQgdGhlIGNvbnNlcXVlbmNlcy4gR29kc3BlZWQuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCB7XG4gIFVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCxcbiAgVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsXG4gIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCxcbiAgVU5TQUZFX0xvY2F0aW9uQ29udGV4dCxcbiAgVU5TQUZFX1JvdXRlQ29udGV4dCxcbiAgVU5TQUZFX2VuaGFuY2VNYW51YWxSb3V0ZU9iamVjdHMsXG59IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcbi8vI2VuZHJlZ2lvblxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIHZhciBfX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGE6IEh5ZHJhdGlvblN0YXRlIHwgdW5kZWZpbmVkO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIFJvdXRlcnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCcm93c2VyUm91dGVyKFxuICByb3V0ZXM6IFJvdXRlT2JqZWN0W10sXG4gIG9wdHM/OiB7XG4gICAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gICAgaHlkcmF0aW9uRGF0YT86IEh5ZHJhdGlvblN0YXRlO1xuICAgIHdpbmRvdz86IFdpbmRvdztcbiAgfVxuKTogUmVtaXhSb3V0ZXIge1xuICByZXR1cm4gY3JlYXRlUm91dGVyKHtcbiAgICBiYXNlbmFtZTogb3B0cz8uYmFzZW5hbWUsXG4gICAgaGlzdG9yeTogY3JlYXRlQnJvd3Nlckhpc3RvcnkoeyB3aW5kb3c6IG9wdHM/LndpbmRvdyB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzPy5oeWRyYXRpb25EYXRhIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgIHJvdXRlczogZW5oYW5jZU1hbnVhbFJvdXRlT2JqZWN0cyhyb3V0ZXMpLFxuICB9KS5pbml0aWFsaXplKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIYXNoUm91dGVyKFxuICByb3V0ZXM6IFJvdXRlT2JqZWN0W10sXG4gIG9wdHM/OiB7XG4gICAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gICAgaHlkcmF0aW9uRGF0YT86IEh5ZHJhdGlvblN0YXRlO1xuICAgIHdpbmRvdz86IFdpbmRvdztcbiAgfVxuKTogUmVtaXhSb3V0ZXIge1xuICByZXR1cm4gY3JlYXRlUm91dGVyKHtcbiAgICBiYXNlbmFtZTogb3B0cz8uYmFzZW5hbWUsXG4gICAgaGlzdG9yeTogY3JlYXRlSGFzaEhpc3RvcnkoeyB3aW5kb3c6IG9wdHM/LndpbmRvdyB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzPy5oeWRyYXRpb25EYXRhIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgIHJvdXRlczogZW5oYW5jZU1hbnVhbFJvdXRlT2JqZWN0cyhyb3V0ZXMpLFxuICB9KS5pbml0aWFsaXplKCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSHlkcmF0aW9uRGF0YSgpOiBIeWRyYXRpb25TdGF0ZSB8IHVuZGVmaW5lZCB7XG4gIGxldCBzdGF0ZSA9IHdpbmRvdz8uX19zdGF0aWNSb3V0ZXJIeWRyYXRpb25EYXRhO1xuICBpZiAoc3RhdGUgJiYgc3RhdGUuZXJyb3JzKSB7XG4gICAgc3RhdGUgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGVycm9yczogZGVzZXJpYWxpemVFcnJvcnMoc3RhdGUuZXJyb3JzKSxcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gZGVzZXJpYWxpemVFcnJvcnMoXG4gIGVycm9yczogUmVtaXhSb3V0ZXJbXCJzdGF0ZVwiXVtcImVycm9yc1wiXVxuKTogUmVtaXhSb3V0ZXJbXCJzdGF0ZVwiXVtcImVycm9yc1wiXSB7XG4gIGlmICghZXJyb3JzKSByZXR1cm4gbnVsbDtcbiAgbGV0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhlcnJvcnMpO1xuICBsZXQgc2VyaWFsaXplZDogUmVtaXhSb3V0ZXJbXCJzdGF0ZVwiXVtcImVycm9yc1wiXSA9IHt9O1xuICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIGVudHJpZXMpIHtcbiAgICAvLyBIZXkgeW91ISAgSWYgeW91IGNoYW5nZSB0aGlzLCBwbGVhc2UgY2hhbmdlIHRoZSBjb3JyZXNwb25kaW5nIGxvZ2ljIGluXG4gICAgLy8gc2VyaWFsaXplRXJyb3JzIGluIHJlYWN0LXJvdXRlci1kb20vc2VydmVyLnRzeCA6KVxuICAgIGlmICh2YWwgJiYgdmFsLl9fdHlwZSA9PT0gXCJSb3V0ZUVycm9yUmVzcG9uc2VcIikge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gbmV3IEVycm9yUmVzcG9uc2UoXG4gICAgICAgIHZhbC5zdGF0dXMsXG4gICAgICAgIHZhbC5zdGF0dXNUZXh0LFxuICAgICAgICB2YWwuZGF0YSxcbiAgICAgICAgdmFsLmludGVybmFsID09PSB0cnVlXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiRXJyb3JcIikge1xuICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKHZhbC5tZXNzYWdlKTtcbiAgICAgIC8vIFdpcGUgYXdheSB0aGUgY2xpZW50LXNpZGUgc3RhY2sgdHJhY2UuICBOb3RoaW5nIHRvIGZpbGwgaXQgaW4gd2l0aFxuICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBzZXJpYWxpemUgU1NSIHN0YWNrIHRyYWNlcyBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgZXJyb3Iuc3RhY2sgPSBcIlwiO1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gZXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIENvbXBvbmVudHNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBpbnRlcmZhY2UgQnJvd3NlclJvdXRlclByb3BzIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICB3aW5kb3c/OiBXaW5kb3c7XG59XG5cbi8qKlxuICogQSBgPFJvdXRlcj5gIGZvciB1c2UgaW4gd2ViIGJyb3dzZXJzLiBQcm92aWRlcyB0aGUgY2xlYW5lc3QgVVJMcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEJyb3dzZXJSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIHdpbmRvdyxcbn06IEJyb3dzZXJSb3V0ZXJQcm9wcykge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZjxCcm93c2VySGlzdG9yeT4oKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlQnJvd3Nlckhpc3RvcnkoeyB3aW5kb3csIHY1Q29tcGF0OiB0cnVlIH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLFxuICB9KTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlclxuICAgICAgYmFzZW5hbWU9e2Jhc2VuYW1lfVxuICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmFjdGlvbn1cbiAgICAgIG5hdmlnYXRvcj17aGlzdG9yeX1cbiAgICAvPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhhc2hSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgd2luZG93PzogV2luZG93O1xufVxuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCBmb3IgdXNlIGluIHdlYiBicm93c2Vycy4gU3RvcmVzIHRoZSBsb2NhdGlvbiBpbiB0aGUgaGFzaFxuICogcG9ydGlvbiBvZiB0aGUgVVJMIHNvIGl0IGlzIG5vdCBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBIYXNoUm91dGVyKHsgYmFzZW5hbWUsIGNoaWxkcmVuLCB3aW5kb3cgfTogSGFzaFJvdXRlclByb3BzKSB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmPEhhc2hIaXN0b3J5PigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVIYXNoSGlzdG9yeSh7IHdpbmRvdywgdjVDb21wYXQ6IHRydWUgfSk7XG4gIH1cblxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sXG4gIH0pO1xuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgIC8+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeVJvdXRlclByb3BzIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBoaXN0b3J5OiBIaXN0b3J5O1xufVxuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCB0aGF0IGFjY2VwdHMgYSBwcmUtaW5zdGFudGlhdGVkIGhpc3Rvcnkgb2JqZWN0LiBJdCdzIGltcG9ydGFudFxuICogdG8gbm90ZSB0aGF0IHVzaW5nIHlvdXIgb3duIGhpc3Rvcnkgb2JqZWN0IGlzIGhpZ2hseSBkaXNjb3VyYWdlZCBhbmQgbWF5IGFkZFxuICogdHdvIHZlcnNpb25zIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdG8geW91ciBidW5kbGVzIHVubGVzcyB5b3UgdXNlIHRoZSBzYW1lXG4gKiB2ZXJzaW9uIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdGhhdCBSZWFjdCBSb3V0ZXIgdXNlcyBpbnRlcm5hbGx5LlxuICovXG5mdW5jdGlvbiBIaXN0b3J5Um91dGVyKHsgYmFzZW5hbWUsIGNoaWxkcmVuLCBoaXN0b3J5IH06IEhpc3RvcnlSb3V0ZXJQcm9wcykge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLFxuICB9KTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlclxuICAgICAgYmFzZW5hbWU9e2Jhc2VuYW1lfVxuICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmFjdGlvbn1cbiAgICAgIG5hdmlnYXRvcj17aGlzdG9yeX1cbiAgICAvPlxuICApO1xufVxuXG5pZiAoX19ERVZfXykge1xuICBIaXN0b3J5Um91dGVyLmRpc3BsYXlOYW1lID0gXCJ1bnN0YWJsZV9IaXN0b3J5Um91dGVyXCI7XG59XG5cbmV4cG9ydCB7IEhpc3RvcnlSb3V0ZXIgYXMgdW5zdGFibGVfSGlzdG9yeVJvdXRlciB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIExpbmtQcm9wc1xuICBleHRlbmRzIE9taXQ8UmVhY3QuQW5jaG9ySFRNTEF0dHJpYnV0ZXM8SFRNTEFuY2hvckVsZW1lbnQ+LCBcImhyZWZcIj4ge1xuICByZWxvYWREb2N1bWVudD86IGJvb2xlYW47XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbiAgcHJldmVudFNjcm9sbFJlc2V0PzogYm9vbGVhbjtcbiAgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlO1xuICB0bzogVG87XG59XG5cbmNvbnN0IGlzQnJvd3NlciA9XG4gIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgPGE+LlxuICovXG5leHBvcnQgY29uc3QgTGluayA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTEFuY2hvckVsZW1lbnQsIExpbmtQcm9wcz4oXG4gIGZ1bmN0aW9uIExpbmtXaXRoUmVmKFxuICAgIHtcbiAgICAgIG9uQ2xpY2ssXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIHJlbG9hZERvY3VtZW50LFxuICAgICAgcmVwbGFjZSxcbiAgICAgIHN0YXRlLFxuICAgICAgdGFyZ2V0LFxuICAgICAgdG8sXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAuLi5yZXN0XG4gICAgfSxcbiAgICByZWZcbiAgKSB7XG4gICAgLy8gUmVuZGVyZWQgaW50byA8YSBocmVmPiBmb3IgYWJzb2x1dGUgVVJMc1xuICAgIGxldCBhYnNvbHV0ZUhyZWY7XG4gICAgbGV0IGlzRXh0ZXJuYWwgPSBmYWxzZTtcblxuICAgIGlmIChcbiAgICAgIGlzQnJvd3NlciAmJlxuICAgICAgdHlwZW9mIHRvID09PSBcInN0cmluZ1wiICYmXG4gICAgICAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2kudGVzdCh0bylcbiAgICApIHtcbiAgICAgIGFic29sdXRlSHJlZiA9IHRvO1xuICAgICAgbGV0IGN1cnJlbnRVcmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgIGxldCB0YXJnZXRVcmwgPSB0by5zdGFydHNXaXRoKFwiLy9cIilcbiAgICAgICAgPyBuZXcgVVJMKGN1cnJlbnRVcmwucHJvdG9jb2wgKyB0bylcbiAgICAgICAgOiBuZXcgVVJMKHRvKTtcbiAgICAgIGlmICh0YXJnZXRVcmwub3JpZ2luID09PSBjdXJyZW50VXJsLm9yaWdpbikge1xuICAgICAgICAvLyBTdHJpcCB0aGUgcHJvdG9jb2wvb3JpZ2luIGZvciBzYW1lLW9yaWdpbiBhYnNvbHV0ZSBVUkxzXG4gICAgICAgIHRvID0gdGFyZ2V0VXJsLnBhdGhuYW1lICsgdGFyZ2V0VXJsLnNlYXJjaCArIHRhcmdldFVybC5oYXNoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNFeHRlcm5hbCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVuZGVyZWQgaW50byA8YSBocmVmPiBmb3IgcmVsYXRpdmUgVVJMc1xuICAgIGxldCBocmVmID0gdXNlSHJlZih0bywgeyByZWxhdGl2ZSB9KTtcblxuICAgIGxldCBpbnRlcm5hbE9uQ2xpY2sgPSB1c2VMaW5rQ2xpY2tIYW5kbGVyKHRvLCB7XG4gICAgICByZXBsYWNlLFxuICAgICAgc3RhdGUsXG4gICAgICB0YXJnZXQsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZWxhdGl2ZSxcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhcbiAgICAgIGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxBbmNob3JFbGVtZW50LCBNb3VzZUV2ZW50PlxuICAgICkge1xuICAgICAgaWYgKG9uQ2xpY2spIG9uQ2xpY2soZXZlbnQpO1xuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGludGVybmFsT25DbGljayhldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9hbmNob3ItaGFzLWNvbnRlbnRcbiAgICAgIDxhXG4gICAgICAgIHsuLi5yZXN0fVxuICAgICAgICBocmVmPXthYnNvbHV0ZUhyZWYgfHwgaHJlZn1cbiAgICAgICAgb25DbGljaz17aXNFeHRlcm5hbCB8fCByZWxvYWREb2N1bWVudCA/IG9uQ2xpY2sgOiBoYW5kbGVDbGlja31cbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIHRhcmdldD17dGFyZ2V0fVxuICAgICAgLz5cbiAgICApO1xuICB9XG4pO1xuXG5pZiAoX19ERVZfXykge1xuICBMaW5rLmRpc3BsYXlOYW1lID0gXCJMaW5rXCI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF2TGlua1Byb3BzXG4gIGV4dGVuZHMgT21pdDxMaW5rUHJvcHMsIFwiY2xhc3NOYW1lXCIgfCBcInN0eWxlXCIgfCBcImNoaWxkcmVuXCI+IHtcbiAgY2hpbGRyZW4/OlxuICAgIHwgUmVhY3QuUmVhY3ROb2RlXG4gICAgfCAoKHByb3BzOiB7IGlzQWN0aXZlOiBib29sZWFuOyBpc1BlbmRpbmc6IGJvb2xlYW4gfSkgPT4gUmVhY3QuUmVhY3ROb2RlKTtcbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIGNsYXNzTmFtZT86XG4gICAgfCBzdHJpbmdcbiAgICB8ICgocHJvcHM6IHtcbiAgICAgICAgaXNBY3RpdmU6IGJvb2xlYW47XG4gICAgICAgIGlzUGVuZGluZzogYm9vbGVhbjtcbiAgICAgIH0pID0+IHN0cmluZyB8IHVuZGVmaW5lZCk7XG4gIGVuZD86IGJvb2xlYW47XG4gIHN0eWxlPzpcbiAgICB8IFJlYWN0LkNTU1Byb3BlcnRpZXNcbiAgICB8ICgocHJvcHM6IHtcbiAgICAgICAgaXNBY3RpdmU6IGJvb2xlYW47XG4gICAgICAgIGlzUGVuZGluZzogYm9vbGVhbjtcbiAgICAgIH0pID0+IFJlYWN0LkNTU1Byb3BlcnRpZXMgfCB1bmRlZmluZWQpO1xufVxuXG4vKipcbiAqIEEgPExpbms+IHdyYXBwZXIgdGhhdCBrbm93cyBpZiBpdCdzIFwiYWN0aXZlXCIgb3Igbm90LlxuICovXG5leHBvcnQgY29uc3QgTmF2TGluayA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTEFuY2hvckVsZW1lbnQsIE5hdkxpbmtQcm9wcz4oXG4gIGZ1bmN0aW9uIE5hdkxpbmtXaXRoUmVmKFxuICAgIHtcbiAgICAgIFwiYXJpYS1jdXJyZW50XCI6IGFyaWFDdXJyZW50UHJvcCA9IFwicGFnZVwiLFxuICAgICAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVQcm9wID0gXCJcIixcbiAgICAgIGVuZCA9IGZhbHNlLFxuICAgICAgc3R5bGU6IHN0eWxlUHJvcCxcbiAgICAgIHRvLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICAuLi5yZXN0XG4gICAgfSxcbiAgICByZWZcbiAgKSB7XG4gICAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmU6IHJlc3QucmVsYXRpdmUgfSk7XG4gICAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgICBsZXQgcm91dGVyU3RhdGUgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICAgIGxldCB7IG5hdmlnYXRvciB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG5cbiAgICBsZXQgdG9QYXRobmFtZSA9IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvblxuICAgICAgPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24ocGF0aCkucGF0aG5hbWVcbiAgICAgIDogcGF0aC5wYXRobmFtZTtcbiAgICBsZXQgbG9jYXRpb25QYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIGxldCBuZXh0TG9jYXRpb25QYXRobmFtZSA9XG4gICAgICByb3V0ZXJTdGF0ZSAmJiByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uICYmIHJvdXRlclN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb25cbiAgICAgICAgPyByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICAgIDogbnVsbDtcblxuICAgIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgbG9jYXRpb25QYXRobmFtZSA9IGxvY2F0aW9uUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIG5leHRMb2NhdGlvblBhdGhuYW1lID0gbmV4dExvY2F0aW9uUGF0aG5hbWVcbiAgICAgICAgPyBuZXh0TG9jYXRpb25QYXRobmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIDogbnVsbDtcbiAgICAgIHRvUGF0aG5hbWUgPSB0b1BhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgbGV0IGlzQWN0aXZlID1cbiAgICAgIGxvY2F0aW9uUGF0aG5hbWUgPT09IHRvUGF0aG5hbWUgfHxcbiAgICAgICghZW5kICYmXG4gICAgICAgIGxvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJlxuICAgICAgICBsb2NhdGlvblBhdGhuYW1lLmNoYXJBdCh0b1BhdGhuYW1lLmxlbmd0aCkgPT09IFwiL1wiKTtcblxuICAgIGxldCBpc1BlbmRpbmcgPVxuICAgICAgbmV4dExvY2F0aW9uUGF0aG5hbWUgIT0gbnVsbCAmJlxuICAgICAgKG5leHRMb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8XG4gICAgICAgICghZW5kICYmXG4gICAgICAgICAgbmV4dExvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJlxuICAgICAgICAgIG5leHRMb2NhdGlvblBhdGhuYW1lLmNoYXJBdCh0b1BhdGhuYW1lLmxlbmd0aCkgPT09IFwiL1wiKSk7XG5cbiAgICBsZXQgYXJpYUN1cnJlbnQgPSBpc0FjdGl2ZSA/IGFyaWFDdXJyZW50UHJvcCA6IHVuZGVmaW5lZDtcblxuICAgIGxldCBjbGFzc05hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIGNsYXNzTmFtZVByb3AgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lUHJvcCh7IGlzQWN0aXZlLCBpc1BlbmRpbmcgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBjbGFzc05hbWUgcHJvcCBpcyBub3QgYSBmdW5jdGlvbiwgd2UgdXNlIGEgZGVmYXVsdCBgYWN0aXZlYFxuICAgICAgLy8gY2xhc3MgZm9yIDxOYXZMaW5rIC8+cyB0aGF0IGFyZSBhY3RpdmUuIEluIHY1IGBhY3RpdmVgIHdhcyB0aGUgZGVmYXVsdFxuICAgICAgLy8gdmFsdWUgZm9yIGBhY3RpdmVDbGFzc05hbWVgLCBidXQgd2UgYXJlIHJlbW92aW5nIHRoYXQgQVBJIGFuZCBjYW4gc3RpbGxcbiAgICAgIC8vIHVzZSB0aGUgb2xkIGRlZmF1bHQgYmVoYXZpb3IgZm9yIGEgY2xlYW5lciB1cGdyYWRlIHBhdGggYW5kIGtlZXAgdGhlXG4gICAgICAvLyBzaW1wbGUgc3R5bGluZyBydWxlcyB3b3JraW5nIGFzIHRoZXkgY3VycmVudGx5IGRvLlxuICAgICAgY2xhc3NOYW1lID0gW1xuICAgICAgICBjbGFzc05hbWVQcm9wLFxuICAgICAgICBpc0FjdGl2ZSA/IFwiYWN0aXZlXCIgOiBudWxsLFxuICAgICAgICBpc1BlbmRpbmcgPyBcInBlbmRpbmdcIiA6IG51bGwsXG4gICAgICBdXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oXCIgXCIpO1xuICAgIH1cblxuICAgIGxldCBzdHlsZSA9XG4gICAgICB0eXBlb2Ygc3R5bGVQcm9wID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBzdHlsZVByb3AoeyBpc0FjdGl2ZSwgaXNQZW5kaW5nIH0pXG4gICAgICAgIDogc3R5bGVQcm9wO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxMaW5rXG4gICAgICAgIHsuLi5yZXN0fVxuICAgICAgICBhcmlhLWN1cnJlbnQ9e2FyaWFDdXJyZW50fVxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIHN0eWxlPXtzdHlsZX1cbiAgICAgICAgdG89e3RvfVxuICAgICAgPlxuICAgICAgICB7dHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGNoaWxkcmVuKHsgaXNBY3RpdmUsIGlzUGVuZGluZyB9KVxuICAgICAgICAgIDogY2hpbGRyZW59XG4gICAgICA8L0xpbms+XG4gICAgKTtcbiAgfVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTmF2TGluay5kaXNwbGF5TmFtZSA9IFwiTmF2TGlua1wiO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1Qcm9wcyBleHRlbmRzIFJlYWN0LkZvcm1IVE1MQXR0cmlidXRlczxIVE1MRm9ybUVsZW1lbnQ+IHtcbiAgLyoqXG4gICAqIFRoZSBIVFRQIHZlcmIgdG8gdXNlIHdoZW4gdGhlIGZvcm0gaXMgc3VibWl0LiBTdXBwb3J0cyBcImdldFwiLCBcInBvc3RcIixcbiAgICogXCJwdXRcIiwgXCJkZWxldGVcIiwgXCJwYXRjaFwiLlxuICAgKi9cbiAgbWV0aG9kPzogRm9ybU1ldGhvZDtcblxuICAvKipcbiAgICogTm9ybWFsIGA8Zm9ybSBhY3Rpb24+YCBidXQgc3VwcG9ydHMgUmVhY3QgUm91dGVyJ3MgcmVsYXRpdmUgcGF0aHMuXG4gICAqL1xuICBhY3Rpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhIGZ1bGwgZG9jdW1lbnQgbmF2aWdhdGlvbiBpbnN0ZWFkIG9mIGEgZmV0Y2guXG4gICAqL1xuICByZWxvYWREb2N1bWVudD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IGVudHJ5IGluIHRoZSBicm93c2VyIGhpc3Rvcnkgc3RhY2sgd2hlbiB0aGUgZm9ybVxuICAgKiBuYXZpZ2F0ZXMuIFVzZSB0aGlzIGlmIHlvdSBkb24ndCB3YW50IHRoZSB1c2VyIHRvIGJlIGFibGUgdG8gY2xpY2sgXCJiYWNrXCJcbiAgICogdG8gdGhlIHBhZ2Ugd2l0aCB0aGUgZm9ybSBvbiBpdC5cbiAgICovXG4gIHJlcGxhY2U/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZvcm0gYWN0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSByb3V0ZSBoaWVyYXJjaHkgb3JcbiAgICogdGhlIHBhdGhuYW1lLiAgVXNlIHRoaXMgaWYgeW91IHdhbnQgdG8gb3B0IG91dCBvZiBuYXZpZ2F0aW5nIHRoZSByb3V0ZVxuICAgKiBoaWVyYXJjaHkgYW5kIHdhbnQgdG8gaW5zdGVhZCByb3V0ZSBiYXNlZCBvbiAvLWRlbGltaXRlZCBVUkwgc2VnbWVudHNcbiAgICovXG4gIHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZTtcblxuICAvKipcbiAgICogUHJldmVudCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGZyb20gcmVzZXR0aW5nIHRvIHRoZSB0b3Agb2YgdGhlIHZpZXdwb3J0IG9uXG4gICAqIGNvbXBsZXRpb24gb2YgdGhlIG5hdmlnYXRpb24gd2hlbiB1c2luZyB0aGUgPFNjcm9sbFJlc3RvcmF0aW9uPiBjb21wb25lbnRcbiAgICovXG4gIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBmb3JtIGlzIHN1Ym1pdHRlZC4gSWYgeW91IGNhbGxcbiAgICogYGV2ZW50LnByZXZlbnREZWZhdWx0KClgIHRoZW4gdGhpcyBmb3JtIHdpbGwgbm90IGRvIGFueXRoaW5nLlxuICAgKi9cbiAgb25TdWJtaXQ/OiBSZWFjdC5Gb3JtRXZlbnRIYW5kbGVyPEhUTUxGb3JtRWxlbWVudD47XG59XG5cbi8qKlxuICogQSBgQHJlbWl4LXJ1bi9yb3V0ZXJgLWF3YXJlIGA8Zm9ybT5gLiBJdCBiZWhhdmVzIGxpa2UgYSBub3JtYWwgZm9ybSBleGNlcHRcbiAqIHRoYXQgdGhlIGludGVyYWN0aW9uIHdpdGggdGhlIHNlcnZlciBpcyB3aXRoIGBmZXRjaGAgaW5zdGVhZCBvZiBuZXcgZG9jdW1lbnRcbiAqIHJlcXVlc3RzLCBhbGxvd2luZyBjb21wb25lbnRzIHRvIGFkZCBuaWNlciBVWCB0byB0aGUgcGFnZSBhcyB0aGUgZm9ybSBpc1xuICogc3VibWl0dGVkIGFuZCByZXR1cm5zIHdpdGggZGF0YS5cbiAqL1xuZXhwb3J0IGNvbnN0IEZvcm0gPSBSZWFjdC5mb3J3YXJkUmVmPEhUTUxGb3JtRWxlbWVudCwgRm9ybVByb3BzPihcbiAgKHByb3BzLCByZWYpID0+IHtcbiAgICByZXR1cm4gPEZvcm1JbXBsIHsuLi5wcm9wc30gcmVmPXtyZWZ9IC8+O1xuICB9XG4pO1xuXG5pZiAoX19ERVZfXykge1xuICBGb3JtLmRpc3BsYXlOYW1lID0gXCJGb3JtXCI7XG59XG5cbnR5cGUgSFRNTFN1Ym1pdEV2ZW50ID0gUmVhY3QuQmFzZVN5bnRoZXRpY0V2ZW50PFxuICBTdWJtaXRFdmVudCxcbiAgRXZlbnQsXG4gIEhUTUxGb3JtRWxlbWVudFxuPjtcblxudHlwZSBIVE1MRm9ybVN1Ym1pdHRlciA9IEhUTUxCdXR0b25FbGVtZW50IHwgSFRNTElucHV0RWxlbWVudDtcblxuaW50ZXJmYWNlIEZvcm1JbXBsUHJvcHMgZXh0ZW5kcyBGb3JtUHJvcHMge1xuICBmZXRjaGVyS2V5Pzogc3RyaW5nO1xuICByb3V0ZUlkPzogc3RyaW5nO1xufVxuXG5jb25zdCBGb3JtSW1wbCA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTEZvcm1FbGVtZW50LCBGb3JtSW1wbFByb3BzPihcbiAgKFxuICAgIHtcbiAgICAgIHJlbG9hZERvY3VtZW50LFxuICAgICAgcmVwbGFjZSxcbiAgICAgIG1ldGhvZCA9IGRlZmF1bHRNZXRob2QsXG4gICAgICBhY3Rpb24sXG4gICAgICBvblN1Ym1pdCxcbiAgICAgIGZldGNoZXJLZXksXG4gICAgICByb3V0ZUlkLFxuICAgICAgcmVsYXRpdmUsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAuLi5wcm9wc1xuICAgIH0sXG4gICAgZm9yd2FyZGVkUmVmXG4gICkgPT4ge1xuICAgIGxldCBzdWJtaXQgPSB1c2VTdWJtaXRJbXBsKGZldGNoZXJLZXksIHJvdXRlSWQpO1xuICAgIGxldCBmb3JtTWV0aG9kOiBGb3JtTWV0aG9kID1cbiAgICAgIG1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImdldFwiID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICAgIGxldCBmb3JtQWN0aW9uID0gdXNlRm9ybUFjdGlvbihhY3Rpb24sIHsgcmVsYXRpdmUgfSk7XG4gICAgbGV0IHN1Ym1pdEhhbmRsZXI6IFJlYWN0LkZvcm1FdmVudEhhbmRsZXI8SFRNTEZvcm1FbGVtZW50PiA9IChldmVudCkgPT4ge1xuICAgICAgb25TdWJtaXQgJiYgb25TdWJtaXQoZXZlbnQpO1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGxldCBzdWJtaXR0ZXIgPSAoZXZlbnQgYXMgdW5rbm93biBhcyBIVE1MU3VibWl0RXZlbnQpLm5hdGl2ZUV2ZW50XG4gICAgICAgIC5zdWJtaXR0ZXIgYXMgSFRNTEZvcm1TdWJtaXR0ZXIgfCBudWxsO1xuXG4gICAgICBsZXQgc3VibWl0TWV0aG9kID1cbiAgICAgICAgKHN1Ym1pdHRlcj8uZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSBhcyBGb3JtTWV0aG9kIHwgdW5kZWZpbmVkKSB8fFxuICAgICAgICBtZXRob2Q7XG5cbiAgICAgIHN1Ym1pdChzdWJtaXR0ZXIgfHwgZXZlbnQuY3VycmVudFRhcmdldCwge1xuICAgICAgICBtZXRob2Q6IHN1Ym1pdE1ldGhvZCxcbiAgICAgICAgcmVwbGFjZSxcbiAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGZvcm1cbiAgICAgICAgcmVmPXtmb3J3YXJkZWRSZWZ9XG4gICAgICAgIG1ldGhvZD17Zm9ybU1ldGhvZH1cbiAgICAgICAgYWN0aW9uPXtmb3JtQWN0aW9ufVxuICAgICAgICBvblN1Ym1pdD17cmVsb2FkRG9jdW1lbnQgPyBvblN1Ym1pdCA6IHN1Ym1pdEhhbmRsZXJ9XG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgRm9ybUltcGwuZGlzcGxheU5hbWUgPSBcIkZvcm1JbXBsXCI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Nyb2xsUmVzdG9yYXRpb25Qcm9wcyB7XG4gIGdldEtleT86IEdldFNjcm9sbFJlc3RvcmF0aW9uS2V5RnVuY3Rpb247XG4gIHN0b3JhZ2VLZXk/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgd2lsbCBlbXVsYXRlIHRoZSBicm93c2VyJ3Mgc2Nyb2xsIHJlc3RvcmF0aW9uIG9uIGxvY2F0aW9uXG4gKiBjaGFuZ2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gU2Nyb2xsUmVzdG9yYXRpb24oe1xuICBnZXRLZXksXG4gIHN0b3JhZ2VLZXksXG59OiBTY3JvbGxSZXN0b3JhdGlvblByb3BzKSB7XG4gIHVzZVNjcm9sbFJlc3RvcmF0aW9uKHsgZ2V0S2V5LCBzdG9yYWdlS2V5IH0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuaWYgKF9fREVWX18pIHtcbiAgU2Nyb2xsUmVzdG9yYXRpb24uZGlzcGxheU5hbWUgPSBcIlNjcm9sbFJlc3RvcmF0aW9uXCI7XG59XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBIb29rc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZW51bSBEYXRhUm91dGVySG9vayB7XG4gIFVzZVNjcm9sbFJlc3RvcmF0aW9uID0gXCJ1c2VTY3JvbGxSZXN0b3JhdGlvblwiLFxuICBVc2VTdWJtaXRJbXBsID0gXCJ1c2VTdWJtaXRJbXBsXCIsXG4gIFVzZUZldGNoZXIgPSBcInVzZUZldGNoZXJcIixcbn1cblxuZW51bSBEYXRhUm91dGVyU3RhdGVIb29rIHtcbiAgVXNlRmV0Y2hlcnMgPSBcInVzZUZldGNoZXJzXCIsXG4gIFVzZVNjcm9sbFJlc3RvcmF0aW9uID0gXCJ1c2VTY3JvbGxSZXN0b3JhdGlvblwiLFxufVxuXG5mdW5jdGlvbiBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKFxuICBob29rTmFtZTogRGF0YVJvdXRlckhvb2sgfCBEYXRhUm91dGVyU3RhdGVIb29rXG4pIHtcbiAgcmV0dXJuIGAke2hvb2tOYW1lfSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgZGF0YSByb3V0ZXIuICBTZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vcm91dGVycy9waWNraW5nLWEtcm91dGVyLmA7XG59XG5cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJDb250ZXh0KGhvb2tOYW1lOiBEYXRhUm91dGVySG9vaykge1xuICBsZXQgY3R4ID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XG4gIGludmFyaWFudChjdHgsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKTtcbiAgcmV0dXJuIGN0eDtcbn1cblxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlclN0YXRlKGhvb2tOYW1lOiBEYXRhUm91dGVyU3RhdGVIb29rKSB7XG4gIGxldCBzdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gIGludmFyaWFudChzdGF0ZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpO1xuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSGFuZGxlcyB0aGUgY2xpY2sgYmVoYXZpb3IgZm9yIHJvdXRlciBgPExpbms+YCBjb21wb25lbnRzLiBUaGlzIGlzIHVzZWZ1bCBpZlxuICogeW91IG5lZWQgdG8gY3JlYXRlIGN1c3RvbSBgPExpbms+YCBjb21wb25lbnRzIHdpdGggdGhlIHNhbWUgY2xpY2sgYmVoYXZpb3Igd2VcbiAqIHVzZSBpbiBvdXIgZXhwb3J0ZWQgYDxMaW5rPmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaW5rQ2xpY2tIYW5kbGVyPEUgZXh0ZW5kcyBFbGVtZW50ID0gSFRNTEFuY2hvckVsZW1lbnQ+KFxuICB0bzogVG8sXG4gIHtcbiAgICB0YXJnZXQsXG4gICAgcmVwbGFjZTogcmVwbGFjZVByb3AsXG4gICAgc3RhdGUsXG4gICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgIHJlbGF0aXZlLFxuICB9OiB7XG4gICAgdGFyZ2V0PzogUmVhY3QuSFRNTEF0dHJpYnV0ZUFuY2hvclRhcmdldDtcbiAgICByZXBsYWNlPzogYm9vbGVhbjtcbiAgICBzdGF0ZT86IGFueTtcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ/OiBib29sZWFuO1xuICAgIHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZTtcbiAgfSA9IHt9XG4pOiAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8RSwgTW91c2VFdmVudD4pID0+IHZvaWQge1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywgeyByZWxhdGl2ZSB9KTtcblxuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEUsIE1vdXNlRXZlbnQ+KSA9PiB7XG4gICAgICBpZiAoc2hvdWxkUHJvY2Vzc0xpbmtDbGljayhldmVudCwgdGFyZ2V0KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIElmIHRoZSBVUkwgaGFzbid0IGNoYW5nZWQsIGEgcmVndWxhciA8YT4gd2lsbCBkbyBhIHJlcGxhY2UgaW5zdGVhZCBvZlxuICAgICAgICAvLyBhIHB1c2gsIHNvIGRvIHRoZSBzYW1lIGhlcmUgdW5sZXNzIHRoZSByZXBsYWNlIHByb3AgaXMgZXhwbGljaXRseSBzZXRcbiAgICAgICAgbGV0IHJlcGxhY2UgPVxuICAgICAgICAgIHJlcGxhY2VQcm9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gcmVwbGFjZVByb3BcbiAgICAgICAgICAgIDogY3JlYXRlUGF0aChsb2NhdGlvbikgPT09IGNyZWF0ZVBhdGgocGF0aCk7XG5cbiAgICAgICAgbmF2aWdhdGUodG8sIHsgcmVwbGFjZSwgc3RhdGUsIHByZXZlbnRTY3JvbGxSZXNldCwgcmVsYXRpdmUgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG5hdmlnYXRlLFxuICAgICAgcGF0aCxcbiAgICAgIHJlcGxhY2VQcm9wLFxuICAgICAgc3RhdGUsXG4gICAgICB0YXJnZXQsXG4gICAgICB0byxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlbGF0aXZlLFxuICAgIF1cbiAgKTtcbn1cblxuLyoqXG4gKiBBIGNvbnZlbmllbnQgd3JhcHBlciBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBzZWFyY2ggcGFyYW1ldGVycyB2aWEgdGhlXG4gKiBVUkxTZWFyY2hQYXJhbXMgaW50ZXJmYWNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU2VhcmNoUGFyYW1zKFxuICBkZWZhdWx0SW5pdD86IFVSTFNlYXJjaFBhcmFtc0luaXRcbik6IFtVUkxTZWFyY2hQYXJhbXMsIFNldFVSTFNlYXJjaFBhcmFtc10ge1xuICB3YXJuaW5nKFxuICAgIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09IFwidW5kZWZpbmVkXCIsXG4gICAgYFlvdSBjYW5ub3QgdXNlIHRoZSBcXGB1c2VTZWFyY2hQYXJhbXNcXGAgaG9vayBpbiBhIGJyb3dzZXIgdGhhdCBkb2VzIG5vdCBgICtcbiAgICAgIGBzdXBwb3J0IHRoZSBVUkxTZWFyY2hQYXJhbXMgQVBJLiBJZiB5b3UgbmVlZCB0byBzdXBwb3J0IEludGVybmV0IGAgK1xuICAgICAgYEV4cGxvcmVyIDExLCB3ZSByZWNvbW1lbmQgeW91IGxvYWQgYSBwb2x5ZmlsbCBzdWNoIGFzIGAgK1xuICAgICAgYGh0dHBzOi8vZ2l0aHViLmNvbS91bmdhcC91cmwtc2VhcmNoLXBhcmFtc1xcblxcbmAgK1xuICAgICAgYElmIHlvdSdyZSB1bnN1cmUgaG93IHRvIGxvYWQgcG9seWZpbGxzLCB3ZSByZWNvbW1lbmQgeW91IGNoZWNrIG91dCBgICtcbiAgICAgIGBodHRwczovL3BvbHlmaWxsLmlvL3YzLyB3aGljaCBwcm92aWRlcyBzb21lIHJlY29tbWVuZGF0aW9ucyBhYm91dCBob3cgYCArXG4gICAgICBgdG8gbG9hZCBwb2x5ZmlsbHMgb25seSBmb3IgdXNlcnMgdGhhdCBuZWVkIHRoZW0sIGluc3RlYWQgb2YgZm9yIGV2ZXJ5IGAgK1xuICAgICAgYHVzZXIuYFxuICApO1xuXG4gIGxldCBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmID0gUmVhY3QudXNlUmVmKGNyZWF0ZVNlYXJjaFBhcmFtcyhkZWZhdWx0SW5pdCkpO1xuICBsZXQgaGFzU2V0U2VhcmNoUGFyYW1zUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcblxuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgc2VhcmNoUGFyYW1zID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PlxuICAgICAgLy8gT25seSBtZXJnZSBpbiB0aGUgZGVmYXVsdHMgaWYgd2UgaGF2ZW4ndCB5ZXQgY2FsbGVkIHNldFNlYXJjaFBhcmFtcy5cbiAgICAgIC8vIE9uY2Ugd2UgY2FsbCB0aGF0IHdlIHdhbnQgdGhvc2UgdG8gdGFrZSBwcmVjZWRlbmNlLCBvdGhlcndpc2UgeW91IGNhbid0XG4gICAgICAvLyByZW1vdmUgYSBwYXJhbSB3aXRoIHNldFNlYXJjaFBhcmFtcyh7fSkgaWYgaXQgaGFzIGFuIGluaXRpYWwgdmFsdWVcbiAgICAgIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uKFxuICAgICAgICBsb2NhdGlvbi5zZWFyY2gsXG4gICAgICAgIGhhc1NldFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50ID8gbnVsbCA6IGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYuY3VycmVudFxuICAgICAgKSxcbiAgICBbbG9jYXRpb24uc2VhcmNoXVxuICApO1xuXG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBzZXRTZWFyY2hQYXJhbXMgPSBSZWFjdC51c2VDYWxsYmFjazxTZXRVUkxTZWFyY2hQYXJhbXM+KFxuICAgIChuZXh0SW5pdCwgbmF2aWdhdGVPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBuZXdTZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMoXG4gICAgICAgIHR5cGVvZiBuZXh0SW5pdCA9PT0gXCJmdW5jdGlvblwiID8gbmV4dEluaXQoc2VhcmNoUGFyYW1zKSA6IG5leHRJbml0XG4gICAgICApO1xuICAgICAgaGFzU2V0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgbmF2aWdhdGUoXCI/XCIgKyBuZXdTZWFyY2hQYXJhbXMsIG5hdmlnYXRlT3B0aW9ucyk7XG4gICAgfSxcbiAgICBbbmF2aWdhdGUsIHNlYXJjaFBhcmFtc11cbiAgKTtcblxuICByZXR1cm4gW3NlYXJjaFBhcmFtcywgc2V0U2VhcmNoUGFyYW1zXTtcbn1cblxudHlwZSBTZXRVUkxTZWFyY2hQYXJhbXMgPSAoXG4gIG5leHRJbml0PzpcbiAgICB8IFVSTFNlYXJjaFBhcmFtc0luaXRcbiAgICB8ICgocHJldjogVVJMU2VhcmNoUGFyYW1zKSA9PiBVUkxTZWFyY2hQYXJhbXNJbml0KSxcbiAgbmF2aWdhdGVPcHRzPzogTmF2aWdhdGVPcHRpb25zXG4pID0+IHZvaWQ7XG5cbnR5cGUgU3VibWl0VGFyZ2V0ID1cbiAgfCBIVE1MRm9ybUVsZW1lbnRcbiAgfCBIVE1MQnV0dG9uRWxlbWVudFxuICB8IEhUTUxJbnB1dEVsZW1lbnRcbiAgfCBGb3JtRGF0YVxuICB8IFVSTFNlYXJjaFBhcmFtc1xuICB8IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9XG4gIHwgbnVsbDtcblxuLyoqXG4gKiBTdWJtaXRzIGEgSFRNTCBgPGZvcm0+YCB0byB0aGUgc2VydmVyIHdpdGhvdXQgcmVsb2FkaW5nIHRoZSBwYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN1Ym1pdEZ1bmN0aW9uIHtcbiAgKFxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgYDxmb3JtPmAgdG8gYmUgc3VibWl0dGVkIHRvIHRoZSBzZXJ2ZXIsIGEgc3BlY2lmaWNcbiAgICAgKiBgPGJ1dHRvbj5gIG9yIGA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiPmAgdG8gdXNlIHRvIHN1Ym1pdCB0aGUgZm9ybSwgb3Igc29tZVxuICAgICAqIGFyYml0cmFyeSBkYXRhIHRvIHN1Ym1pdC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFdoZW4gdXNpbmcgYSBgPGJ1dHRvbj5gIGl0cyBgbmFtZWAgYW5kIGB2YWx1ZWAgd2lsbCBhbHNvIGJlXG4gICAgICogaW5jbHVkZWQgaW4gdGhlIGZvcm0gZGF0YSB0aGF0IGlzIHN1Ym1pdHRlZC5cbiAgICAgKi9cbiAgICB0YXJnZXQ6IFN1Ym1pdFRhcmdldCxcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbnMgdGhhdCBvdmVycmlkZSB0aGUgYDxmb3JtPmAncyBvd24gYXR0cmlidXRlcy4gUmVxdWlyZWQgd2hlblxuICAgICAqIHN1Ym1pdHRpbmcgYXJiaXRyYXJ5IGRhdGEgd2l0aG91dCBhIGJhY2tpbmcgYDxmb3JtPmAuXG4gICAgICovXG4gICAgb3B0aW9ucz86IFN1Ym1pdE9wdGlvbnNcbiAgKTogdm9pZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBwcm9ncmFtbWF0aWNhbGx5IHN1Ym1pdCBhIGZvcm0gKG9yXG4gKiBzb21lIGFyYml0cmFyeSBkYXRhKSB0byB0aGUgc2VydmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3VibWl0KCk6IFN1Ym1pdEZ1bmN0aW9uIHtcbiAgcmV0dXJuIHVzZVN1Ym1pdEltcGwoKTtcbn1cblxuZnVuY3Rpb24gdXNlU3VibWl0SW1wbChmZXRjaGVyS2V5Pzogc3RyaW5nLCByb3V0ZUlkPzogc3RyaW5nKTogU3VibWl0RnVuY3Rpb24ge1xuICBsZXQgeyByb3V0ZXIgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZVN1Ym1pdEltcGwpO1xuICBsZXQgZGVmYXVsdEFjdGlvbiA9IHVzZUZvcm1BY3Rpb24oKTtcblxuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKHRhcmdldCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIllvdSBhcmUgY2FsbGluZyBzdWJtaXQgZHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyLiBcIiArXG4gICAgICAgICAgICBcIlRyeSBjYWxsaW5nIHN1Ym1pdCB3aXRoaW4gYSBgdXNlRWZmZWN0YCBvciBjYWxsYmFjayBpbnN0ZWFkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGxldCB7IG1ldGhvZCwgZW5jVHlwZSwgZm9ybURhdGEsIHVybCB9ID0gZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvKFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGRlZmF1bHRBY3Rpb24sXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG5cbiAgICAgIGxldCBocmVmID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgIGxldCBvcHRzID0ge1xuICAgICAgICByZXBsYWNlOiBvcHRpb25zLnJlcGxhY2UsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0aW9ucy5wcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIGZvcm1EYXRhLFxuICAgICAgICBmb3JtTWV0aG9kOiBtZXRob2QgYXMgRm9ybU1ldGhvZCxcbiAgICAgICAgZm9ybUVuY1R5cGU6IGVuY1R5cGUgYXMgRm9ybUVuY1R5cGUsXG4gICAgICB9O1xuICAgICAgaWYgKGZldGNoZXJLZXkpIHtcbiAgICAgICAgaW52YXJpYW50KHJvdXRlSWQgIT0gbnVsbCwgXCJObyByb3V0ZUlkIGF2YWlsYWJsZSBmb3IgdXNlRmV0Y2hlcigpXCIpO1xuICAgICAgICByb3V0ZXIuZmV0Y2goZmV0Y2hlcktleSwgcm91dGVJZCwgaHJlZiwgb3B0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3V0ZXIubmF2aWdhdGUoaHJlZiwgb3B0cyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbZGVmYXVsdEFjdGlvbiwgcm91dGVyLCBmZXRjaGVyS2V5LCByb3V0ZUlkXVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9ybUFjdGlvbihcbiAgYWN0aW9uPzogc3RyaW5nLFxuICB7IHJlbGF0aXZlIH06IHsgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlIH0gPSB7fVxuKTogc3RyaW5nIHtcbiAgbGV0IHsgYmFzZW5hbWUgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgcm91dGVDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQocm91dGVDb250ZXh0LCBcInVzZUZvcm1BY3Rpb24gbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dFwiKTtcblxuICBsZXQgW21hdGNoXSA9IHJvdXRlQ29udGV4dC5tYXRjaGVzLnNsaWNlKC0xKTtcbiAgLy8gU2hhbGxvdyBjbG9uZSBwYXRoIHNvIHdlIGNhbiBtb2RpZnkgaXQgYmVsb3csIG90aGVyd2lzZSB3ZSBtb2RpZnkgdGhlXG4gIC8vIG9iamVjdCByZWZlcmVuY2VkIGJ5IHVzZU1lbW8gaW5zaWRlIHVzZVJlc29sdmVkUGF0aFxuICBsZXQgcGF0aCA9IHsgLi4udXNlUmVzb2x2ZWRQYXRoKGFjdGlvbiA/IGFjdGlvbiA6IFwiLlwiLCB7IHJlbGF0aXZlIH0pIH07XG5cbiAgLy8gUHJldmlvdXNseSB3ZSBzZXQgdGhlIGRlZmF1bHQgYWN0aW9uIHRvIFwiLlwiLiBUaGUgcHJvYmxlbSB3aXRoIHRoaXMgaXMgdGhhdFxuICAvLyBgdXNlUmVzb2x2ZWRQYXRoKFwiLlwiKWAgZXhjbHVkZXMgc2VhcmNoIHBhcmFtcyBhbmQgdGhlIGhhc2ggb2YgdGhlIHJlc29sdmVkXG4gIC8vIFVSTC4gVGhpcyBpcyB0aGUgaW50ZW5kZWQgYmVoYXZpb3Igb2Ygd2hlbiBcIi5cIiBpcyBzcGVjaWZpY2FsbHkgcHJvdmlkZWQgYXNcbiAgLy8gdGhlIGZvcm0gYWN0aW9uLCBidXQgaW5jb25zaXN0ZW50IHcvIGJyb3dzZXJzIHdoZW4gdGhlIGFjdGlvbiBpcyBvbWl0dGVkLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL3JlbWl4L2lzc3Vlcy85MjdcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgaWYgKGFjdGlvbiA9PSBudWxsKSB7XG4gICAgLy8gU2FmZSB0byB3cml0ZSB0byB0aGVzZSBkaXJlY3RseSBoZXJlIHNpbmNlIGlmIGFjdGlvbiB3YXMgdW5kZWZpbmVkLCB3ZVxuICAgIC8vIHdvdWxkIGhhdmUgY2FsbGVkIHVzZVJlc29sdmVkUGF0aChcIi5cIikgd2hpY2ggd2lsbCBuZXZlciBpbmNsdWRlIGEgc2VhcmNoXG4gICAgLy8gb3IgaGFzaFxuICAgIHBhdGguc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuICAgIHBhdGguaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG5cbiAgICAvLyBXaGVuIGdyYWJiaW5nIHNlYXJjaCBwYXJhbXMgZnJvbSB0aGUgVVJMLCByZW1vdmUgdGhlIGF1dG9tYXRpY2FsbHlcbiAgICAvLyBpbnNlcnRlZCA/aW5kZXggcGFyYW0gc28gd2UgbWF0Y2ggdGhlIHVzZVJlc29sdmVkUGF0aCBzZWFyY2ggYmVoYXZpb3JcbiAgICAvLyB3aGljaCB3b3VsZCBub3QgaW5jbHVkZSA/aW5kZXhcbiAgICBpZiAobWF0Y2gucm91dGUuaW5kZXgpIHtcbiAgICAgIGxldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhdGguc2VhcmNoKTtcbiAgICAgIHBhcmFtcy5kZWxldGUoXCJpbmRleFwiKTtcbiAgICAgIHBhdGguc2VhcmNoID0gcGFyYW1zLnRvU3RyaW5nKCkgPyBgPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCA6IFwiXCI7XG4gICAgfVxuICB9XG5cbiAgaWYgKCghYWN0aW9uIHx8IGFjdGlvbiA9PT0gXCIuXCIpICYmIG1hdGNoLnJvdXRlLmluZGV4KSB7XG4gICAgcGF0aC5zZWFyY2ggPSBwYXRoLnNlYXJjaFxuICAgICAgPyBwYXRoLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpXG4gICAgICA6IFwiP2luZGV4XCI7XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lIHByaW9yXG4gIC8vIHRvIGNyZWF0aW5nIHRoZSBmb3JtIGFjdGlvbi4gIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4ganVzdCB1c2VcbiAgLy8gdGhlIHJhdyBiYXNlbmFtZSB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlXG4gIC8vIHByZXNlbmNlIG9mIGEgdHJhaWxpbmcgc2xhc2ggb24gcm9vdCBhY3Rpb25zXG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBwYXRoLnBhdGhuYW1lID1cbiAgICAgIHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlUGF0aChwYXRoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hlckZvcm0oZmV0Y2hlcktleTogc3RyaW5nLCByb3V0ZUlkOiBzdHJpbmcpIHtcbiAgbGV0IEZldGNoZXJGb3JtID0gUmVhY3QuZm9yd2FyZFJlZjxIVE1MRm9ybUVsZW1lbnQsIEZvcm1Qcm9wcz4oXG4gICAgKHByb3BzLCByZWYpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxGb3JtSW1wbFxuICAgICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgICBmZXRjaGVyS2V5PXtmZXRjaGVyS2V5fVxuICAgICAgICAgIHJvdXRlSWQ9e3JvdXRlSWR9XG4gICAgICAgIC8+XG4gICAgICApO1xuICAgIH1cbiAgKTtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBGZXRjaGVyRm9ybS5kaXNwbGF5TmFtZSA9IFwiZmV0Y2hlci5Gb3JtXCI7XG4gIH1cbiAgcmV0dXJuIEZldGNoZXJGb3JtO1xufVxuXG5sZXQgZmV0Y2hlcklkID0gMDtcblxuZXhwb3J0IHR5cGUgRmV0Y2hlcldpdGhDb21wb25lbnRzPFREYXRhPiA9IEZldGNoZXI8VERhdGE+ICYge1xuICBGb3JtOiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVGZXRjaGVyRm9ybT47XG4gIHN1Ym1pdDogKFxuICAgIHRhcmdldDogU3VibWl0VGFyZ2V0LFxuICAgIC8vIEZldGNoZXJzIGNhbm5vdCByZXBsYWNlL3ByZXZlbnRTY3JvbGxSZXNldCBiZWNhdXNlIHRoZXkgYXJlIG5vdFxuICAgIC8vIG5hdmlnYXRpb24gZXZlbnRzXG4gICAgb3B0aW9ucz86IE9taXQ8U3VibWl0T3B0aW9ucywgXCJyZXBsYWNlXCIgfCBcInByZXZlbnRTY3JvbGxSZXNldFwiPlxuICApID0+IHZvaWQ7XG4gIGxvYWQ6IChocmVmOiBzdHJpbmcpID0+IHZvaWQ7XG59O1xuXG4vKipcbiAqIEludGVyYWN0cyB3aXRoIHJvdXRlIGxvYWRlcnMgYW5kIGFjdGlvbnMgd2l0aG91dCBjYXVzaW5nIGEgbmF2aWdhdGlvbi4gR3JlYXRcbiAqIGZvciBhbnkgaW50ZXJhY3Rpb24gdGhhdCBzdGF5cyBvbiB0aGUgc2FtZSBwYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRmV0Y2hlcjxURGF0YSA9IGFueT4oKTogRmV0Y2hlcldpdGhDb21wb25lbnRzPFREYXRhPiB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlRmV0Y2hlcik7XG5cbiAgbGV0IHJvdXRlID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQocm91dGUsIGB1c2VGZXRjaGVyIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBSb3V0ZUNvbnRleHRgKTtcblxuICBsZXQgcm91dGVJZCA9IHJvdXRlLm1hdGNoZXNbcm91dGUubWF0Y2hlcy5sZW5ndGggLSAxXT8ucm91dGUuaWQ7XG4gIGludmFyaWFudChcbiAgICByb3V0ZUlkICE9IG51bGwsXG4gICAgYHVzZUZldGNoZXIgY2FuIG9ubHkgYmUgdXNlZCBvbiByb3V0ZXMgdGhhdCBjb250YWluIGEgdW5pcXVlIFwiaWRcImBcbiAgKTtcblxuICBsZXQgW2ZldGNoZXJLZXldID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gU3RyaW5nKCsrZmV0Y2hlcklkKSk7XG4gIGxldCBbRm9ybV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB7XG4gICAgaW52YXJpYW50KHJvdXRlSWQsIGBObyByb3V0ZUlkIGF2YWlsYWJsZSBmb3IgZmV0Y2hlci5Gb3JtKClgKTtcbiAgICByZXR1cm4gY3JlYXRlRmV0Y2hlckZvcm0oZmV0Y2hlcktleSwgcm91dGVJZCk7XG4gIH0pO1xuICBsZXQgW2xvYWRdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gKGhyZWY6IHN0cmluZykgPT4ge1xuICAgIGludmFyaWFudChyb3V0ZXIsIFwiTm8gcm91dGVyIGF2YWlsYWJsZSBmb3IgZmV0Y2hlci5sb2FkKClcIik7XG4gICAgaW52YXJpYW50KHJvdXRlSWQsIFwiTm8gcm91dGVJZCBhdmFpbGFibGUgZm9yIGZldGNoZXIubG9hZCgpXCIpO1xuICAgIHJvdXRlci5mZXRjaChmZXRjaGVyS2V5LCByb3V0ZUlkLCBocmVmKTtcbiAgfSk7XG4gIGxldCBzdWJtaXQgPSB1c2VTdWJtaXRJbXBsKGZldGNoZXJLZXksIHJvdXRlSWQpO1xuXG4gIGxldCBmZXRjaGVyID0gcm91dGVyLmdldEZldGNoZXI8VERhdGE+KGZldGNoZXJLZXkpO1xuXG4gIGxldCBmZXRjaGVyV2l0aENvbXBvbmVudHMgPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBGb3JtLFxuICAgICAgc3VibWl0LFxuICAgICAgbG9hZCxcbiAgICAgIC4uLmZldGNoZXIsXG4gICAgfSksXG4gICAgW2ZldGNoZXIsIEZvcm0sIHN1Ym1pdCwgbG9hZF1cbiAgKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIElzIHRoaXMgYnVzdGVkIHdoZW4gdGhlIFJlYWN0IHRlYW0gZ2V0cyByZWFsIHdlaXJkIGFuZCBjYWxscyBlZmZlY3RzXG4gICAgLy8gdHdpY2Ugb24gbW91bnQ/ICBXZSByZWFsbHkganVzdCBuZWVkIHRvIGdhcmJhZ2UgY29sbGVjdCBoZXJlIHdoZW4gdGhpc1xuICAgIC8vIGZldGNoZXIgaXMgbm8gbG9uZ2VyIGFyb3VuZC5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBObyBmZXRjaGVyIGF2YWlsYWJsZSB0byBjbGVhbiB1cCBmcm9tIHVzZUZldGNoZXIoKWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByb3V0ZXIuZGVsZXRlRmV0Y2hlcihmZXRjaGVyS2V5KTtcbiAgICB9O1xuICB9LCBbcm91dGVyLCBmZXRjaGVyS2V5XSk7XG5cbiAgcmV0dXJuIGZldGNoZXJXaXRoQ29tcG9uZW50cztcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBhbGwgZmV0Y2hlcnMgY3VycmVudGx5IG9uIHRoZSBwYWdlLiBVc2VmdWwgZm9yIGxheW91dHMgYW5kIHBhcmVudFxuICogcm91dGVzIHRoYXQgbmVlZCB0byBwcm92aWRlIHBlbmRpbmcvb3B0aW1pc3RpYyBVSSByZWdhcmRpbmcgdGhlIGZldGNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRmV0Y2hlcnMoKTogRmV0Y2hlcltdIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlRmV0Y2hlcnMpO1xuICByZXR1cm4gWy4uLnN0YXRlLmZldGNoZXJzLnZhbHVlcygpXTtcbn1cblxuY29uc3QgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZID0gXCJyZWFjdC1yb3V0ZXItc2Nyb2xsLXBvc2l0aW9uc1wiO1xubGV0IHNhdmVkU2Nyb2xsUG9zaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG5cbi8qKlxuICogV2hlbiByZW5kZXJlZCBpbnNpZGUgYSBSb3V0ZXJQcm92aWRlciwgd2lsbCByZXN0b3JlIHNjcm9sbCBwb3NpdGlvbnMgb24gbmF2aWdhdGlvbnNcbiAqL1xuZnVuY3Rpb24gdXNlU2Nyb2xsUmVzdG9yYXRpb24oe1xuICBnZXRLZXksXG4gIHN0b3JhZ2VLZXksXG59OiB7XG4gIGdldEtleT86IEdldFNjcm9sbFJlc3RvcmF0aW9uS2V5RnVuY3Rpb247XG4gIHN0b3JhZ2VLZXk/OiBzdHJpbmc7XG59ID0ge30pIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VTY3JvbGxSZXN0b3JhdGlvbik7XG4gIGxldCB7IHJlc3RvcmVTY3JvbGxQb3NpdGlvbiwgcHJldmVudFNjcm9sbFJlc2V0IH0gPSB1c2VEYXRhUm91dGVyU3RhdGUoXG4gICAgRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VTY3JvbGxSZXN0b3JhdGlvblxuICApO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbWF0Y2hlcyA9IHVzZU1hdGNoZXMoKTtcbiAgbGV0IG5hdmlnYXRpb24gPSB1c2VOYXZpZ2F0aW9uKCk7XG5cbiAgLy8gVHJpZ2dlciBtYW51YWwgc2Nyb2xsIHJlc3RvcmF0aW9uIHdoaWxlIHdlJ3JlIGFjdGl2ZVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIjtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcImF1dG9cIjtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gU2F2ZSBwb3NpdGlvbnMgb24gcGFnZWhpZGVcbiAgdXNlUGFnZUhpZGUoXG4gICAgUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgaWYgKG5hdmlnYXRpb24uc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICAgIGxldCBrZXkgPSAoZ2V0S2V5ID8gZ2V0S2V5KGxvY2F0aW9uLCBtYXRjaGVzKSA6IG51bGwpIHx8IGxvY2F0aW9uLmtleTtcbiAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgfVxuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVksXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHNhdmVkU2Nyb2xsUG9zaXRpb25zKVxuICAgICAgKTtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gICAgfSwgW3N0b3JhZ2VLZXksIGdldEtleSwgbmF2aWdhdGlvbi5zdGF0ZSwgbG9jYXRpb24sIG1hdGNoZXNdKVxuICApO1xuXG4gIC8vIFJlYWQgaW4gYW55IHNhdmVkIHNjcm9sbCBsb2NhdGlvbnNcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgc2Vzc2lvblBvc2l0aW9ucyA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXG4gICAgICAgICAgc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHNlc3Npb25Qb3NpdGlvbnMpIHtcbiAgICAgICAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IEpTT04ucGFyc2Uoc2Vzc2lvblBvc2l0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbm8tb3AsIHVzZSBkZWZhdWx0IGVtcHR5IG9iamVjdFxuICAgICAgfVxuICAgIH0sIFtzdG9yYWdlS2V5XSk7XG5cbiAgICAvLyBFbmFibGUgc2Nyb2xsIHJlc3RvcmF0aW9uIGluIHRoZSByb3V0ZXJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgbGV0IGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiA9IHJvdXRlcj8uZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oXG4gICAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zLFxuICAgICAgICAoKSA9PiB3aW5kb3cuc2Nyb2xsWSxcbiAgICAgICAgZ2V0S2V5XG4gICAgICApO1xuICAgICAgcmV0dXJuICgpID0+IGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiAmJiBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24oKTtcbiAgICB9LCBbcm91dGVyLCBnZXRLZXldKTtcblxuICAgIC8vIFJlc3RvcmUgc2Nyb2xsaW5nIHdoZW4gc3RhdGUucmVzdG9yZVNjcm9sbFBvc2l0aW9uIGNoYW5nZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgLy8gRXhwbGljaXQgZmFsc2UgbWVhbnMgZG9uJ3QgZG8gYW55dGhpbmcgKHVzZWQgZm9yIHN1Ym1pc3Npb25zKVxuICAgICAgaWYgKHJlc3RvcmVTY3JvbGxQb3NpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBiZWVuIGhlcmUgYmVmb3JlLCBzY3JvbGwgdG8gaXRcbiAgICAgIGlmICh0eXBlb2YgcmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCByZXN0b3JlU2Nyb2xsUG9zaXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHRyeSB0byBzY3JvbGwgdG8gdGhlIGhhc2hcbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGxvY2F0aW9uLmhhc2guc2xpY2UoMSkpO1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCByZXNldCBpZiB0aGlzIG5hdmlnYXRpb24gb3B0ZWQgb3V0XG4gICAgICBpZiAocHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gb3RoZXJ3aXNlIGdvIHRvIHRoZSB0b3Agb24gbmV3IGxvY2F0aW9uc1xuICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgIH0sIFtsb2NhdGlvbiwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uLCBwcmV2ZW50U2Nyb2xsUmVzZXRdKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldHVwIGEgY2FsbGJhY2sgdG8gYmUgZmlyZWQgb24gdGhlIHdpbmRvdydzIGBiZWZvcmV1bmxvYWRgIGV2ZW50LiBUaGlzIGlzXG4gKiB1c2VmdWwgZm9yIHNhdmluZyBzb21lIGRhdGEgdG8gYHdpbmRvdy5sb2NhbFN0b3JhZ2VgIGp1c3QgYmVmb3JlIHRoZSBwYWdlXG4gKiByZWZyZXNoZXMuXG4gKlxuICogTm90ZTogVGhlIGBjYWxsYmFja2AgYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24gY3JlYXRlZCB3aXRoXG4gKiBgUmVhY3QudXNlQ2FsbGJhY2soKWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VCZWZvcmVVbmxvYWQoXG4gIGNhbGxiYWNrOiAoZXZlbnQ6IEJlZm9yZVVubG9hZEV2ZW50KSA9PiBhbnksXG4gIG9wdGlvbnM/OiB7IGNhcHR1cmU/OiBib29sZWFuIH1cbik6IHZvaWQge1xuICBsZXQgeyBjYXB0dXJlIH0gPSBvcHRpb25zIHx8IHt9O1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBvcHRzID0gY2FwdHVyZSAhPSBudWxsID8geyBjYXB0dXJlIH0gOiB1bmRlZmluZWQ7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrLCBjYXB0dXJlXSk7XG59XG5cbi8qKlxuICogU2V0dXAgYSBjYWxsYmFjayB0byBiZSBmaXJlZCBvbiB0aGUgd2luZG93J3MgYHBhZ2VoaWRlYCBldmVudC4gVGhpcyBpc1xuICogdXNlZnVsIGZvciBzYXZpbmcgc29tZSBkYXRhIHRvIGB3aW5kb3cubG9jYWxTdG9yYWdlYCBqdXN0IGJlZm9yZSB0aGUgcGFnZVxuICogcmVmcmVzaGVzLiAgVGhpcyBldmVudCBpcyBiZXR0ZXIgc3VwcG9ydGVkIHRoYW4gYmVmb3JldW5sb2FkIGFjcm9zcyBicm93c2Vycy5cbiAqXG4gKiBOb3RlOiBUaGUgYGNhbGxiYWNrYCBhcmd1bWVudCBzaG91bGQgYmUgYSBmdW5jdGlvbiBjcmVhdGVkIHdpdGhcbiAqIGBSZWFjdC51c2VDYWxsYmFjaygpYC5cbiAqL1xuZnVuY3Rpb24gdXNlUGFnZUhpZGUoXG4gIGNhbGxiYWNrOiAoZXZlbnQ6IFBhZ2VUcmFuc2l0aW9uRXZlbnQpID0+IGFueSxcbiAgb3B0aW9ucz86IHsgY2FwdHVyZT86IGJvb2xlYW4gfVxuKTogdm9pZCB7XG4gIGxldCB7IGNhcHR1cmUgfSA9IG9wdGlvbnMgfHwge307XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IG9wdHMgPSBjYXB0dXJlICE9IG51bGwgPyB7IGNhcHR1cmUgfSA6IHVuZGVmaW5lZDtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrLCBjYXB0dXJlXSk7XG59XG5cbi8qKlxuICogV3JhcHBlciBhcm91bmQgdXNlQmxvY2tlciB0byBzaG93IGEgd2luZG93LmNvbmZpcm0gcHJvbXB0IHRvIHVzZXJzIGluc3RlYWRcbiAqIG9mIGJ1aWxkaW5nIGEgY3VzdG9tIFVJIHdpdGggdXNlQmxvY2tlci5cbiAqXG4gKiBXYXJuaW5nOiBUaGlzIGhhcyAqYSBsb3Qgb2Ygcm91Z2ggZWRnZXMqIGFuZCBiZWhhdmVzIHZlcnkgZGlmZmVyZW50bHkgKGFuZFxuICogdmVyeSBpbmNvcnJlY3RseSBpbiBzb21lIGNhc2VzKSBhY3Jvc3MgYnJvd3NlcnMgaWYgdXNlciBjbGljayBhZGRpdGlvblxuICogYmFjay9mb3J3YXJkIG5hdmlnYXRpb25zIHdoaWxlIHRoZSBjb25maXJtIGlzIG9wZW4uICBVc2UgYXQgeW91ciBvd24gcmlzay5cbiAqL1xuZnVuY3Rpb24gdXNlUHJvbXB0KHsgd2hlbiwgbWVzc2FnZSB9OiB7IHdoZW46IGJvb2xlYW47IG1lc3NhZ2U6IHN0cmluZyB9KSB7XG4gIGxldCBibG9ja2VyID0gdXNlQmxvY2tlcih3aGVuKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiAhd2hlbikge1xuICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIHdoZW5dKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIikge1xuICAgICAgbGV0IHByb2NlZWQgPSB3aW5kb3cuY29uZmlybShtZXNzYWdlKTtcbiAgICAgIGlmIChwcm9jZWVkKSB7XG4gICAgICAgIHNldFRpbWVvdXQoYmxvY2tlci5wcm9jZWVkLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJsb2NrZXIucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtibG9ja2VyLCBtZXNzYWdlXSk7XG59XG5cbmV4cG9ydCB7IHVzZVByb21wdCBhcyB1bnN0YWJsZV91c2VQcm9tcHQgfTtcblxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gVXRpbHNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIHdhcm5pbmcoY29uZDogYm9vbGVhbiwgbWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gIGlmICghY29uZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgUm91dGVyIVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28geW91IGNhbiBtb3JlIGVhc2lseVxuICAgICAgLy8gZmluZCB0aGUgc291cmNlIGZvciBhIHdhcm5pbmcgdGhhdCBhcHBlYXJzIGluIHRoZSBjb25zb2xlIGJ5XG4gICAgICAvLyBlbmFibGluZyBcInBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIEphdmFTY3JpcHQgZGVidWdnZXIuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG59XG4vLyNlbmRyZWdpb25cblxuZXhwb3J0IHsgdXNlU2Nyb2xsUmVzdG9yYXRpb24gYXMgVU5TQUZFX3VzZVNjcm9sbFJlc3RvcmF0aW9uIH07XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgcm91dGVyID0gcmVxdWlyZSgnQHJlbWl4LXJ1bi9yb3V0ZXInKTtcbnZhciByZWFjdFJvdXRlckRvbSA9IHJlcXVpcmUoJ3JlYWN0LXJvdXRlci1kb20nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuICAgIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gICAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChlKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBSZWFjdF9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlKFJlYWN0KTtcblxuLyoqXG4gKiBBIDxSb3V0ZXI+IHRoYXQgbWF5IG5vdCBuYXZpZ2F0ZSB0byBhbnkgb3RoZXIgbG9jYXRpb24uIFRoaXMgaXMgdXNlZnVsXG4gKiBvbiB0aGUgc2VydmVyIHdoZXJlIHRoZXJlIGlzIG5vIHN0YXRlZnVsIFVJLlxuICovXG5cbmZ1bmN0aW9uIFN0YXRpY1JvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgbG9jYXRpb246IGxvY2F0aW9uUHJvcCA9IFwiL1wiXG59KSB7XG4gIGlmICh0eXBlb2YgbG9jYXRpb25Qcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgbG9jYXRpb25Qcm9wID0gcmVhY3RSb3V0ZXJEb20ucGFyc2VQYXRoKGxvY2F0aW9uUHJvcCk7XG4gIH1cblxuICBsZXQgYWN0aW9uID0gcm91dGVyLkFjdGlvbi5Qb3A7XG4gIGxldCBsb2NhdGlvbiA9IHtcbiAgICBwYXRobmFtZTogbG9jYXRpb25Qcm9wLnBhdGhuYW1lIHx8IFwiL1wiLFxuICAgIHNlYXJjaDogbG9jYXRpb25Qcm9wLnNlYXJjaCB8fCBcIlwiLFxuICAgIGhhc2g6IGxvY2F0aW9uUHJvcC5oYXNoIHx8IFwiXCIsXG4gICAgc3RhdGU6IGxvY2F0aW9uUHJvcC5zdGF0ZSB8fCBudWxsLFxuICAgIGtleTogbG9jYXRpb25Qcm9wLmtleSB8fCBcImRlZmF1bHRcIlxuICB9O1xuICBsZXQgc3RhdGljTmF2aWdhdG9yID0gZ2V0U3RhdGVsZXNzTmF2aWdhdG9yKCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KHJlYWN0Um91dGVyRG9tLlJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBhY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBzdGF0aWNOYXZpZ2F0b3IsXG4gICAgc3RhdGljOiB0cnVlXG4gIH0pO1xufVxuLyoqXG4gKiBBIERhdGEgUm91dGVyIHRoYXQgbWF5IG5vdCBuYXZpZ2F0ZSB0byBhbnkgb3RoZXIgbG9jYXRpb24uIFRoaXMgaXMgdXNlZnVsXG4gKiBvbiB0aGUgc2VydmVyIHdoZXJlIHRoZXJlIGlzIG5vIHN0YXRlZnVsIFVJLlxuICovXG5cbmZ1bmN0aW9uIFN0YXRpY1JvdXRlclByb3ZpZGVyKHtcbiAgY29udGV4dCxcbiAgcm91dGVyOiByb3V0ZXIkMSxcbiAgaHlkcmF0ZSA9IHRydWUsXG4gIG5vbmNlXG59KSB7XG4gICEocm91dGVyJDEgJiYgY29udGV4dCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyByb3V0ZXIuaW52YXJpYW50KGZhbHNlLCBcIllvdSBtdXN0IHByb3ZpZGUgYHJvdXRlcmAgYW5kIGBjb250ZXh0YCB0byA8U3RhdGljUm91dGVyUHJvdmlkZXI+XCIpIDogcm91dGVyLmludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IHtcbiAgICByb3V0ZXI6IHJvdXRlciQxLFxuICAgIG5hdmlnYXRvcjogZ2V0U3RhdGVsZXNzTmF2aWdhdG9yKCksXG4gICAgc3RhdGljOiB0cnVlLFxuICAgIHN0YXRpY0NvbnRleHQ6IGNvbnRleHQsXG4gICAgYmFzZW5hbWU6IGNvbnRleHQuYmFzZW5hbWUgfHwgXCIvXCJcbiAgfTtcbiAgbGV0IGh5ZHJhdGVTY3JpcHQgPSBcIlwiO1xuXG4gIGlmIChoeWRyYXRlICE9PSBmYWxzZSkge1xuICAgIGxldCBkYXRhID0ge1xuICAgICAgbG9hZGVyRGF0YTogY29udGV4dC5sb2FkZXJEYXRhLFxuICAgICAgYWN0aW9uRGF0YTogY29udGV4dC5hY3Rpb25EYXRhLFxuICAgICAgZXJyb3JzOiBzZXJpYWxpemVFcnJvcnMoY29udGV4dC5lcnJvcnMpXG4gICAgfTsgLy8gVXNlIEpTT04ucGFyc2UgaGVyZSBpbnN0ZWFkIG9mIGVtYmVkZGluZyBhIHJhdyBKUyBvYmplY3QgaGVyZSB0byBzcGVlZFxuICAgIC8vIHVwIHBhcnNpbmcgb24gdGhlIGNsaWVudC4gIER1YWwtc3RyaW5naWZ5IGlzIG5lZWRlZCB0byBlbnN1cmUgYWxsIHF1b3Rlc1xuICAgIC8vIGFyZSBwcm9wZXJseSBlc2NhcGVkIGluIHRoZSByZXN1bHRpbmcgc3RyaW5nLiAgU2VlOlxuICAgIC8vICAgaHR0cHM6Ly92OC5kZXYvYmxvZy9jb3N0LW9mLWphdmFzY3JpcHQtMjAxOSNqc29uXG5cbiAgICBsZXQganNvbiA9IEpTT04uc3RyaW5naWZ5KEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICBoeWRyYXRlU2NyaXB0ID0gYHdpbmRvdy5fX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGEgPSBKU09OLnBhcnNlKCR7anNvbn0pO2A7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KHJlYWN0Um91dGVyRG9tLlVOU0FGRV9EYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBkYXRhUm91dGVyQ29udGV4dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KHJlYWN0Um91dGVyRG9tLlVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGRhdGFSb3V0ZXJDb250ZXh0LnJvdXRlci5zdGF0ZVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KHJlYWN0Um91dGVyRG9tLlJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBkYXRhUm91dGVyQ29udGV4dC5iYXNlbmFtZSxcbiAgICBsb2NhdGlvbjogZGF0YVJvdXRlckNvbnRleHQucm91dGVyLnN0YXRlLmxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBkYXRhUm91dGVyQ29udGV4dC5yb3V0ZXIuc3RhdGUuaGlzdG9yeUFjdGlvbixcbiAgICBuYXZpZ2F0b3I6IGRhdGFSb3V0ZXJDb250ZXh0Lm5hdmlnYXRvclxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KHJlYWN0Um91dGVyRG9tLlJvdXRlcywgbnVsbCkpKSksIGh5ZHJhdGVTY3JpcHQgPyAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIsIHtcbiAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgbm9uY2U6IG5vbmNlLFxuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICBfX2h0bWw6IGh5ZHJhdGVTY3JpcHRcbiAgICB9XG4gIH0pIDogbnVsbCk7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9ycyhlcnJvcnMpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG5cbiAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBlbnRyaWVzKSB7XG4gICAgLy8gSGV5IHlvdSEgIElmIHlvdSBjaGFuZ2UgdGhpcywgcGxlYXNlIGNoYW5nZSB0aGUgY29ycmVzcG9uZGluZyBsb2dpYyBpblxuICAgIC8vIGRlc2VyaWFsaXplRXJyb3JzIGluIHJlYWN0LXJvdXRlci1kb20vaW5kZXgudHN4IDopXG4gICAgaWYgKHJvdXRlci5pc1JvdXRlRXJyb3JSZXNwb25zZSh2YWwpKSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB7IC4uLnZhbCxcbiAgICAgICAgX190eXBlOiBcIlJvdXRlRXJyb3JSZXNwb25zZVwiXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIERvIG5vdCBzZXJpYWxpemUgc3RhY2sgdHJhY2VzIGZyb20gU1NSIGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB7XG4gICAgICAgIG1lc3NhZ2U6IHZhbC5tZXNzYWdlLFxuICAgICAgICBfX3R5cGU6IFwiRXJyb3JcIlxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZWxlc3NOYXZpZ2F0b3IoKSB7XG4gIHJldHVybiB7XG4gICAgY3JlYXRlSHJlZixcbiAgICBlbmNvZGVMb2NhdGlvbixcblxuICAgIHB1c2godG8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLnB1c2goKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgYCArIGBlbnZpcm9ubWVudC4gVGhpcyBlcnJvciB3YXMgcHJvYmFibHkgdHJpZ2dlcmVkIHdoZW4geW91IGRpZCBhIGAgKyBgXFxgbmF2aWdhdGUoJHtKU09OLnN0cmluZ2lmeSh0byl9KVxcYCBzb21ld2hlcmUgaW4geW91ciBhcHAuYCk7XG4gICAgfSxcblxuICAgIHJlcGxhY2UodG8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLnJlcGxhY2UoKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgYCArIGBlbnZpcm9ubWVudC4gVGhpcyBlcnJvciB3YXMgcHJvYmFibHkgdHJpZ2dlcmVkIHdoZW4geW91IGRpZCBhIGAgKyBgXFxgbmF2aWdhdGUoJHtKU09OLnN0cmluZ2lmeSh0byl9LCB7IHJlcGxhY2U6IHRydWUgfSlcXGAgc29tZXdoZXJlIGAgKyBgaW4geW91ciBhcHAuYCk7XG4gICAgfSxcblxuICAgIGdvKGRlbHRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5nbygpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LiBUaGlzIGVycm9yIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgd2hlbiB5b3UgZGlkIGEgYCArIGBcXGBuYXZpZ2F0ZSgke2RlbHRhfSlcXGAgc29tZXdoZXJlIGluIHlvdXIgYXBwLmApO1xuICAgIH0sXG5cbiAgICBiYWNrKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuYmFjaygpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LmApO1xuICAgIH0sXG5cbiAgICBmb3J3YXJkKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuZm9yd2FyZCgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LmApO1xuICAgIH1cblxuICB9O1xufSAvLyBUZW1wb3JhcnkgbWFuaWZlc3QgZ2VuZXJhdGlvbiAtIHdlIHNob3VsZCBvcHRpbWl6ZSB0aGlzIGJ5IGNvbWJpbmluZyB0aGVcbi8vIHRyZWUtd2Fsa3MgYmV0d2VlbiBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzLCBlbmhhbmNlTWFudWFsUm91dGVPYmplY3RzLFxuLy8gYW5kIGdlbmVyYXRlTWFuaWZlc3QuXG4vLyBBbHNvIGxvb2sgaW50byBnZXR0aW5nIHJpZCBvZiBgcm91dGUgYXMgQWdub3N0aWNEYXRhUm91dGVPYmplY3RgIGRvd24gYmVsb3c/XG5cblxuZnVuY3Rpb24gZ2VuZXJhdGVNYW5pZmVzdChyb3V0ZXMsIG1hbmlmZXN0ID0gbmV3IE1hcCgpKSB7XG4gIHJvdXRlcy5mb3JFYWNoKHJvdXRlID0+IHtcbiAgICBtYW5pZmVzdC5zZXQocm91dGUuaWQsIHJvdXRlKTtcblxuICAgIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgZ2VuZXJhdGVNYW5pZmVzdChyb3V0ZS5jaGlsZHJlbiwgbWFuaWZlc3QpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtYW5pZmVzdDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3RhdGljUm91dGVyKHJvdXRlcywgY29udGV4dCkge1xuICBsZXQgZGF0YVJvdXRlcyA9IHJvdXRlci5VTlNBRkVfY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhyZWFjdFJvdXRlckRvbS5VTlNBRkVfZW5oYW5jZU1hbnVhbFJvdXRlT2JqZWN0cyhyb3V0ZXMpKTtcbiAgbGV0IG1hbmlmZXN0ID0gZ2VuZXJhdGVNYW5pZmVzdChkYXRhUm91dGVzKTsgLy8gQmVjYXVzZSBvdXIgY29udGV4dCBtYXRjaGVzIG1heSBiZSBmcm9tIGEgZnJhbWV3b3JrLWFnbm9zdGljIHNldCBvZlxuICAvLyByb3V0ZXMgcGFzc2VkIHRvIGNyZWF0ZVN0YXRpY0hhbmRsZXIoKSwgd2UgdXBkYXRlIHRoZW0gaGVyZSB3aXRoIG91clxuICAvLyBuZXdseSBjcmVhdGVkL2VuaGFuY2VkIGRhdGEgcm91dGVzXG5cbiAgbGV0IG1hdGNoZXMgPSBjb250ZXh0Lm1hdGNoZXMubWFwKG1hdGNoID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdC5nZXQobWF0Y2gucm91dGUuaWQpIHx8IG1hdGNoLnJvdXRlO1xuICAgIHJldHVybiB7IC4uLm1hdGNoLFxuICAgICAgcm91dGU6IHJvdXRlXG4gICAgfTtcbiAgfSk7XG5cbiAgbGV0IG1zZyA9IG1ldGhvZCA9PiBgWW91IGNhbm5vdCB1c2Ugcm91dGVyLiR7bWV0aG9kfSgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBlbnZpcm9ubWVudGA7XG5cbiAgcmV0dXJuIHtcbiAgICBnZXQgYmFzZW5hbWUoKSB7XG4gICAgICByZXR1cm4gY29udGV4dC5iYXNlbmFtZTtcbiAgICB9LFxuXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGlzdG9yeUFjdGlvbjogcm91dGVyLkFjdGlvbi5Qb3AsXG4gICAgICAgIGxvY2F0aW9uOiBjb250ZXh0LmxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiBjb250ZXh0LmxvYWRlckRhdGEsXG4gICAgICAgIGFjdGlvbkRhdGE6IGNvbnRleHQuYWN0aW9uRGF0YSxcbiAgICAgICAgZXJyb3JzOiBjb250ZXh0LmVycm9ycyxcbiAgICAgICAgaW5pdGlhbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hdmlnYXRpb246IHJvdXRlci5JRExFX05BVklHQVRJT04sXG4gICAgICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogbnVsbCxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBmYWxzZSxcbiAgICAgICAgcmV2YWxpZGF0aW9uOiBcImlkbGVcIixcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoKSxcbiAgICAgICAgYmxvY2tlcnM6IG5ldyBNYXAoKVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0IHJvdXRlcygpIHtcbiAgICAgIHJldHVybiBkYXRhUm91dGVzO1xuICAgIH0sXG5cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgdGhyb3cgbXNnKFwiaW5pdGlhbGl6ZVwiKTtcbiAgICB9LFxuXG4gICAgc3Vic2NyaWJlKCkge1xuICAgICAgdGhyb3cgbXNnKFwic3Vic2NyaWJlXCIpO1xuICAgIH0sXG5cbiAgICBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbigpIHtcbiAgICAgIHRocm93IG1zZyhcImVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uXCIpO1xuICAgIH0sXG5cbiAgICBuYXZpZ2F0ZSgpIHtcbiAgICAgIHRocm93IG1zZyhcIm5hdmlnYXRlXCIpO1xuICAgIH0sXG5cbiAgICBmZXRjaCgpIHtcbiAgICAgIHRocm93IG1zZyhcImZldGNoXCIpO1xuICAgIH0sXG5cbiAgICByZXZhbGlkYXRlKCkge1xuICAgICAgdGhyb3cgbXNnKFwicmV2YWxpZGF0ZVwiKTtcbiAgICB9LFxuXG4gICAgY3JlYXRlSHJlZixcbiAgICBlbmNvZGVMb2NhdGlvbixcblxuICAgIGdldEZldGNoZXIoKSB7XG4gICAgICByZXR1cm4gcm91dGVyLklETEVfRkVUQ0hFUjtcbiAgICB9LFxuXG4gICAgZGVsZXRlRmV0Y2hlcigpIHtcbiAgICAgIHRocm93IG1zZyhcImRlbGV0ZUZldGNoZXJcIik7XG4gICAgfSxcblxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICB0aHJvdyBtc2coXCJkaXNwb3NlXCIpO1xuICAgIH0sXG5cbiAgICBnZXRCbG9ja2VyKCkge1xuICAgICAgdGhyb3cgbXNnKFwiZ2V0QmxvY2tlclwiKTtcbiAgICB9LFxuXG4gICAgZGVsZXRlQmxvY2tlcigpIHtcbiAgICAgIHRocm93IG1zZyhcImRlbGV0ZUJsb2NrZXJcIik7XG4gICAgfSxcblxuICAgIF9pbnRlcm5hbEZldGNoQ29udHJvbGxlcnM6IG5ldyBNYXAoKSxcbiAgICBfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHM6IG5ldyBNYXAoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIcmVmKHRvKSB7XG4gIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IHJlYWN0Um91dGVyRG9tLmNyZWF0ZVBhdGgodG8pO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVMb2NhdGlvbih0bykge1xuICAvLyBMb2NhdGlvbnMgc2hvdWxkIGFscmVhZHkgYmUgZW5jb2RlZCBvbiB0aGUgc2VydmVyLCBzbyBqdXN0IHJldHVybiBhcy1pc1xuICBsZXQgcGF0aCA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHJlYWN0Um91dGVyRG9tLnBhcnNlUGF0aCh0bykgOiB0bztcbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aC5wYXRobmFtZSB8fCBcIlwiLFxuICAgIHNlYXJjaDogcGF0aC5zZWFyY2ggfHwgXCJcIixcbiAgICBoYXNoOiBwYXRoLmhhc2ggfHwgXCJcIlxuICB9O1xufVxuXG5leHBvcnRzLlN0YXRpY1JvdXRlciA9IFN0YXRpY1JvdXRlcjtcbmV4cG9ydHMuU3RhdGljUm91dGVyUHJvdmlkZXIgPSBTdGF0aWNSb3V0ZXJQcm92aWRlcjtcbmV4cG9ydHMuY3JlYXRlU3RhdGljUm91dGVyID0gY3JlYXRlU3RhdGljUm91dGVyO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXNQb2x5ZmlsbCh4OiBhbnksIHk6IGFueSkge1xuICByZXR1cm4gKFxuICAgICh4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICk7XG59XG5cbmNvbnN0IGlzOiAoeDogYW55LCB5OiBhbnkpID0+IGJvb2xlYW4gPVxuICB0eXBlb2YgT2JqZWN0LmlzID09PSBcImZ1bmN0aW9uXCIgPyBPYmplY3QuaXMgOiBpc1BvbHlmaWxsO1xuXG4vLyBJbnRlbnRpb25hbGx5IG5vdCB1c2luZyBuYW1lZCBpbXBvcnRzIGJlY2F1c2UgUm9sbHVwIHVzZXMgZHluYW1pY1xuLy8gZGlzcGF0Y2ggZm9yIENvbW1vbkpTIGludGVyb3AgbmFtZWQgaW1wb3J0cy5cbmNvbnN0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VEZWJ1Z1ZhbHVlIH0gPSBSZWFjdDtcblxubGV0IGRpZFdhcm5PbGQxOEFscGhhID0gZmFsc2U7XG5sZXQgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSBmYWxzZTtcblxuLy8gRGlzY2xhaW1lcjogVGhpcyBzaGltIGJyZWFrcyBtYW55IG9mIHRoZSBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3Ncbi8vIGJlY2F1c2Ugb2YgYSB2ZXJ5IHBhcnRpY3VsYXIgc2V0IG9mIGltcGxlbWVudGF0aW9uIGRldGFpbHMgYW5kIGFzc3VtcHRpb25zXG4vLyAtLSBjaGFuZ2UgYW55IG9uZSBvZiB0aGVtIGFuZCBpdCB3aWxsIGJyZWFrLiBUaGUgbW9zdCBpbXBvcnRhbnQgYXNzdW1wdGlvblxuLy8gaXMgdGhhdCB1cGRhdGVzIGFyZSBhbHdheXMgc3luY2hyb25vdXMsIGJlY2F1c2UgY29uY3VycmVudCByZW5kZXJpbmcgaXNcbi8vIG9ubHkgYXZhaWxhYmxlIGluIHZlcnNpb25zIG9mIFJlYWN0IHRoYXQgYWxzbyBoYXZlIGEgYnVpbHQtaW5cbi8vIHVzZVN5bmNFeHRlcm5hbFN0b3JlIEFQSS4gQW5kIHdlIG9ubHkgdXNlIHRoaXMgc2hpbSB3aGVuIHRoZSBidWlsdC1pbiBBUElcbi8vIGRvZXMgbm90IGV4aXN0LlxuLy9cbi8vIERvIG5vdCBhc3N1bWUgdGhhdCB0aGUgY2xldmVyIGhhY2tzIHVzZWQgYnkgdGhpcyBob29rIGFsc28gd29yayBpbiBnZW5lcmFsLlxuLy8gVGhlIHBvaW50IG9mIHRoaXMgc2hpbSBpcyB0byByZXBsYWNlIHRoZSBuZWVkIGZvciBoYWNrcyBieSBvdGhlciBsaWJyYXJpZXMuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmU8VD4oXG4gIHN1YnNjcmliZTogKGZuOiAoKSA9PiB2b2lkKSA9PiAoKSA9PiB2b2lkLFxuICBnZXRTbmFwc2hvdDogKCkgPT4gVCxcbiAgLy8gTm90ZTogVGhlIHNoaW0gZG9lcyBub3QgdXNlIGdldFNlcnZlclNuYXBzaG90LCBiZWNhdXNlIHByZS0xOCB2ZXJzaW9ucyBvZlxuICAvLyBSZWFjdCBkbyBub3QgZXhwb3NlIGEgd2F5IHRvIGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZy4gU28gdXNlcnMgb2YgdGhlIHNoaW1cbiAgLy8gd2lsbCBuZWVkIHRvIHRyYWNrIHRoYXQgdGhlbXNlbHZlcyBhbmQgcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlXG4gIC8vIGZyb20gYGdldFNuYXBzaG90YC5cbiAgZ2V0U2VydmVyU25hcHNob3Q/OiAoKSA9PiBUXG4pOiBUIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBpZiAoIWRpZFdhcm5PbGQxOEFscGhhKSB7XG4gICAgICBpZiAoXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCkge1xuICAgICAgICBkaWRXYXJuT2xkMThBbHBoYSA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJZb3UgYXJlIHVzaW5nIGFuIG91dGRhdGVkLCBwcmUtcmVsZWFzZSBhbHBoYSBvZiBSZWFjdCAxOCB0aGF0IFwiICtcbiAgICAgICAgICAgIFwiZG9lcyBub3Qgc3VwcG9ydCB1c2VTeW5jRXh0ZXJuYWxTdG9yZS4gVGhlIFwiICtcbiAgICAgICAgICAgIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUgc2hpbSB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseS4gVXBncmFkZSBcIiArXG4gICAgICAgICAgICBcInRvIGEgbmV3ZXIgcHJlLXJlbGVhc2UuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZWFkIHRoZSBjdXJyZW50IHNuYXBzaG90IGZyb20gdGhlIHN0b3JlIG9uIGV2ZXJ5IHJlbmRlci4gQWdhaW4sIHRoaXNcbiAgLy8gYnJlYWtzIHRoZSBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3MgaGVyZSBiZWNhdXNlIG9mIHNwZWNpZmljXG4gIC8vIGltcGxlbWVudGF0aW9uIGRldGFpbHMsIG1vc3QgaW1wb3J0YW50bHkgdGhhdCB1cGRhdGVzIGFyZVxuICAvLyBhbHdheXMgc3luY2hyb25vdXMuXG4gIGNvbnN0IHZhbHVlID0gZ2V0U25hcHNob3QoKTtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBpZiAoIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90KSB7XG4gICAgICBjb25zdCBjYWNoZWRWYWx1ZSA9IGdldFNuYXBzaG90KCk7XG4gICAgICBpZiAoIWlzKHZhbHVlLCBjYWNoZWRWYWx1ZSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXCJcbiAgICAgICAgKTtcbiAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEJlY2F1c2UgdXBkYXRlcyBhcmUgc3luY2hyb25vdXMsIHdlIGRvbid0IHF1ZXVlIHRoZW0uIEluc3RlYWQgd2UgZm9yY2UgYVxuICAvLyByZS1yZW5kZXIgd2hlbmV2ZXIgdGhlIHN1YnNjcmliZWQgc3RhdGUgY2hhbmdlcyBieSB1cGRhdGluZyBhbiBzb21lXG4gIC8vIGFyYml0cmFyeSB1c2VTdGF0ZSBob29rLiBUaGVuLCBkdXJpbmcgcmVuZGVyLCB3ZSBjYWxsIGdldFNuYXBzaG90IHRvIHJlYWRcbiAgLy8gdGhlIGN1cnJlbnQgdmFsdWUuXG4gIC8vXG4gIC8vIEJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgdXNlIHRoZSBzdGF0ZSByZXR1cm5lZCBieSB0aGUgdXNlU3RhdGUgaG9vaywgd2VcbiAgLy8gY2FuIHNhdmUgYSBiaXQgb2YgbWVtb3J5IGJ5IHN0b3Jpbmcgb3RoZXIgc3R1ZmYgaW4gdGhhdCBzbG90LlxuICAvL1xuICAvLyBUbyBpbXBsZW1lbnQgdGhlIGVhcmx5IGJhaWxvdXQsIHdlIG5lZWQgdG8gdHJhY2sgc29tZSB0aGluZ3Mgb24gYSBtdXRhYmxlXG4gIC8vIG9iamVjdC4gVXN1YWxseSwgd2Ugd291bGQgcHV0IHRoYXQgaW4gYSB1c2VSZWYgaG9vaywgYnV0IHdlIGNhbiBzdGFzaCBpdCBpblxuICAvLyBvdXIgdXNlU3RhdGUgaG9vayBpbnN0ZWFkLlxuICAvL1xuICAvLyBUbyBmb3JjZSBhIHJlLXJlbmRlciwgd2UgY2FsbCBmb3JjZVVwZGF0ZSh7aW5zdH0pLiBUaGF0IHdvcmtzIGJlY2F1c2UgdGhlXG4gIC8vIG5ldyBvYmplY3QgYWx3YXlzIGZhaWxzIGFuIGVxdWFsaXR5IGNoZWNrLlxuICBjb25zdCBbeyBpbnN0IH0sIGZvcmNlVXBkYXRlXSA9IHVzZVN0YXRlKHsgaW5zdDogeyB2YWx1ZSwgZ2V0U25hcHNob3QgfSB9KTtcblxuICAvLyBUcmFjayB0aGUgbGF0ZXN0IGdldFNuYXBzaG90IGZ1bmN0aW9uIHdpdGggYSByZWYuIFRoaXMgbmVlZHMgdG8gYmUgdXBkYXRlZFxuICAvLyBpbiB0aGUgbGF5b3V0IHBoYXNlIHNvIHdlIGNhbiBhY2Nlc3MgaXQgZHVyaW5nIHRoZSB0ZWFyaW5nIGNoZWNrIHRoYXRcbiAgLy8gaGFwcGVucyBvbiBzdWJzY3JpYmUuXG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaW5zdC52YWx1ZSA9IHZhbHVlO1xuICAgIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDtcblxuICAgIC8vIFdoZW5ldmVyIGdldFNuYXBzaG90IG9yIHN1YnNjcmliZSBjaGFuZ2VzLCB3ZSBuZWVkIHRvIGNoZWNrIGluIHRoZVxuICAgIC8vIGNvbW1pdCBwaGFzZSBpZiB0aGVyZSB3YXMgYW4gaW50ZXJsZWF2ZWQgbXV0YXRpb24uIEluIGNvbmN1cnJlbnQgbW9kZVxuICAgIC8vIHRoaXMgY2FuIGhhcHBlbiBhbGwgdGhlIHRpbWUsIGJ1dCBldmVuIGluIHN5bmNocm9ub3VzIG1vZGUsIGFuIGVhcmxpZXJcbiAgICAvLyBlZmZlY3QgbWF5IGhhdmUgbXV0YXRlZCB0aGUgc3RvcmUuXG4gICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgIC8vIEZvcmNlIGEgcmUtcmVuZGVyLlxuICAgICAgZm9yY2VVcGRhdGUoeyBpbnN0IH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtzdWJzY3JpYmUsIHZhbHVlLCBnZXRTbmFwc2hvdF0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gQ2hlY2sgZm9yIGNoYW5nZXMgcmlnaHQgYmVmb3JlIHN1YnNjcmliaW5nLiBTdWJzZXF1ZW50IGNoYW5nZXMgd2lsbCBiZVxuICAgIC8vIGRldGVjdGVkIGluIHRoZSBzdWJzY3JpcHRpb24gaGFuZGxlci5cbiAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgICBmb3JjZVVwZGF0ZSh7IGluc3QgfSk7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZVN0b3JlQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgLy8gVE9ETzogQmVjYXVzZSB0aGVyZSBpcyBubyBjcm9zcy1yZW5kZXJlciBBUEkgZm9yIGJhdGNoaW5nIHVwZGF0ZXMsIGl0J3NcbiAgICAgIC8vIHVwIHRvIHRoZSBjb25zdW1lciBvZiB0aGlzIGxpYnJhcnkgdG8gd3JhcCB0aGVpciBzdWJzY3JpcHRpb24gZXZlbnRcbiAgICAgIC8vIHdpdGggdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMuIFNob3VsZCB3ZSB0cnkgdG8gZGV0ZWN0IHdoZW4gdGhpcyBpc24ndFxuICAgICAgLy8gdGhlIGNhc2UgYW5kIHByaW50IGEgd2FybmluZyBpbiBkZXZlbG9wbWVudD9cblxuICAgICAgLy8gVGhlIHN0b3JlIGNoYW5nZWQuIENoZWNrIGlmIHRoZSBzbmFwc2hvdCBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2VcbiAgICAgIC8vIHJlYWQgZnJvbSB0aGUgc3RvcmUuXG4gICAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuICAgICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgICAgZm9yY2VVcGRhdGUoeyBpbnN0IH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBzdG9yZSBhbmQgcmV0dXJuIGEgY2xlYW4tdXAgZnVuY3Rpb24uXG4gICAgcmV0dXJuIHN1YnNjcmliZShoYW5kbGVTdG9yZUNoYW5nZSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbc3Vic2NyaWJlXSk7XG5cbiAgdXNlRGVidWdWYWx1ZSh2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0OiBhbnkpIHtcbiAgY29uc3QgbGF0ZXN0R2V0U25hcHNob3QgPSBpbnN0LmdldFNuYXBzaG90O1xuICBjb25zdCBwcmV2VmFsdWUgPSBpbnN0LnZhbHVlO1xuICB0cnkge1xuICAgIGNvbnN0IG5leHRWYWx1ZSA9IGxhdGVzdEdldFNuYXBzaG90KCk7XG4gICAgcmV0dXJuICFpcyhwcmV2VmFsdWUsIG5leHRWYWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmU8VD4oXG4gIHN1YnNjcmliZTogKGZuOiAoKSA9PiB2b2lkKSA9PiAoKSA9PiB2b2lkLFxuICBnZXRTbmFwc2hvdDogKCkgPT4gVCxcbiAgZ2V0U2VydmVyU25hcHNob3Q/OiAoKSA9PiBUXG4pOiBUIHtcbiAgLy8gTm90ZTogVGhlIHNoaW0gZG9lcyBub3QgdXNlIGdldFNlcnZlclNuYXBzaG90LCBiZWNhdXNlIHByZS0xOCB2ZXJzaW9ucyBvZlxuICAvLyBSZWFjdCBkbyBub3QgZXhwb3NlIGEgd2F5IHRvIGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZy4gU28gdXNlcnMgb2YgdGhlIHNoaW1cbiAgLy8gd2lsbCBuZWVkIHRvIHRyYWNrIHRoYXQgdGhlbXNlbHZlcyBhbmQgcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlXG4gIC8vIGZyb20gYGdldFNuYXBzaG90YC5cbiAgcmV0dXJuIGdldFNuYXBzaG90KCk7XG59XG4iLCIvKipcbiAqIElubGluZWQgaW50byB0aGUgcmVhY3Qtcm91dGVyIHJlcG8gc2luY2UgdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUgZG9lcyBub3RcbiAqIHByb3ZpZGUgYSBVTUQtY29tcGF0aWJsZSBwYWNrYWdlLCBzbyB3ZSBuZWVkIHRoaXMgdG8gYmUgYWJsZSB0byBkaXN0cmlidXRlXG4gKiBVTUQgcmVhY3Qtcm91dGVyIGJ1bmRsZXNcbiAqL1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIGFzIGNsaWVudCB9IGZyb20gXCIuL3VzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbUNsaWVudFwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgYXMgc2VydmVyIH0gZnJvbSBcIi4vdXNlU3luY0V4dGVybmFsU3RvcmVTaGltU2VydmVyXCI7XG5cbmNvbnN0IGNhblVzZURPTTogYm9vbGVhbiA9ICEhKFxuICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiXG4pO1xuY29uc3QgaXNTZXJ2ZXJFbnZpcm9ubWVudCA9ICFjYW5Vc2VET007XG5jb25zdCBzaGltID0gaXNTZXJ2ZXJFbnZpcm9ubWVudCA/IHNlcnZlciA6IGNsaWVudDtcblxuZXhwb3J0IGNvbnN0IHVzZVN5bmNFeHRlcm5hbFN0b3JlID1cbiAgXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiIGluIFJlYWN0XG4gICAgPyAoKG1vZHVsZSkgPT4gbW9kdWxlLnVzZVN5bmNFeHRlcm5hbFN0b3JlKShSZWFjdClcbiAgICA6IHNoaW07XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHtcbiAgQWdub3N0aWNSb3V0ZU1hdGNoLFxuICBBZ25vc3RpY0luZGV4Um91dGVPYmplY3QsXG4gIEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdCxcbiAgSGlzdG9yeSxcbiAgTG9jYXRpb24sXG4gIFJvdXRlcixcbiAgU3RhdGljSGFuZGxlckNvbnRleHQsXG4gIFRvLFxuICBUcmFja2VkUHJvbWlzZSxcbn0gZnJvbSBcIkByZW1peC1ydW4vcm91dGVyXCI7XG5pbXBvcnQgdHlwZSB7IEFjdGlvbiBhcyBOYXZpZ2F0aW9uVHlwZSB9IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuXG4vLyBDcmVhdGUgcmVhY3Qtc3BlY2lmaWMgdHlwZXMgZnJvbSB0aGUgYWdub3N0aWMgdHlwZXMgaW4gQHJlbWl4LXJ1bi9yb3V0ZXIgdG9cbi8vIGV4cG9ydCBmcm9tIHJlYWN0LXJvdXRlclxuZXhwb3J0IGludGVyZmFjZSBJbmRleFJvdXRlT2JqZWN0IHtcbiAgY2FzZVNlbnNpdGl2ZT86IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdFtcImNhc2VTZW5zaXRpdmVcIl07XG4gIHBhdGg/OiBBZ25vc3RpY0luZGV4Um91dGVPYmplY3RbXCJwYXRoXCJdO1xuICBpZD86IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdFtcImlkXCJdO1xuICBsb2FkZXI/OiBBZ25vc3RpY0luZGV4Um91dGVPYmplY3RbXCJsb2FkZXJcIl07XG4gIGFjdGlvbj86IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdFtcImFjdGlvblwiXTtcbiAgaGFzRXJyb3JCb3VuZGFyeT86IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdFtcImhhc0Vycm9yQm91bmRhcnlcIl07XG4gIHNob3VsZFJldmFsaWRhdGU/OiBBZ25vc3RpY0luZGV4Um91dGVPYmplY3RbXCJzaG91bGRSZXZhbGlkYXRlXCJdO1xuICBoYW5kbGU/OiBBZ25vc3RpY0luZGV4Um91dGVPYmplY3RbXCJoYW5kbGVcIl07XG4gIGluZGV4OiB0cnVlO1xuICBjaGlsZHJlbj86IHVuZGVmaW5lZDtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG4gIGVycm9yRWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9uSW5kZXhSb3V0ZU9iamVjdCB7XG4gIGNhc2VTZW5zaXRpdmU/OiBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3RbXCJjYXNlU2Vuc2l0aXZlXCJdO1xuICBwYXRoPzogQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0W1wicGF0aFwiXTtcbiAgaWQ/OiBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3RbXCJpZFwiXTtcbiAgbG9hZGVyPzogQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0W1wibG9hZGVyXCJdO1xuICBhY3Rpb24/OiBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3RbXCJhY3Rpb25cIl07XG4gIGhhc0Vycm9yQm91bmRhcnk/OiBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3RbXCJoYXNFcnJvckJvdW5kYXJ5XCJdO1xuICBzaG91bGRSZXZhbGlkYXRlPzogQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0W1wic2hvdWxkUmV2YWxpZGF0ZVwiXTtcbiAgaGFuZGxlPzogQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0W1wiaGFuZGxlXCJdO1xuICBpbmRleD86IGZhbHNlO1xuICBjaGlsZHJlbj86IFJvdXRlT2JqZWN0W107XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBlcnJvckVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xufVxuXG5leHBvcnQgdHlwZSBSb3V0ZU9iamVjdCA9IEluZGV4Um91dGVPYmplY3QgfCBOb25JbmRleFJvdXRlT2JqZWN0O1xuXG5leHBvcnQgdHlwZSBEYXRhUm91dGVPYmplY3QgPSBSb3V0ZU9iamVjdCAmIHtcbiAgY2hpbGRyZW4/OiBEYXRhUm91dGVPYmplY3RbXTtcbiAgaWQ6IHN0cmluZztcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVNYXRjaDxcbiAgUGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsXG4gIFJvdXRlT2JqZWN0VHlwZSBleHRlbmRzIFJvdXRlT2JqZWN0ID0gUm91dGVPYmplY3Rcbj4gZXh0ZW5kcyBBZ25vc3RpY1JvdXRlTWF0Y2g8UGFyYW1LZXksIFJvdXRlT2JqZWN0VHlwZT4ge31cblxuZXhwb3J0IGludGVyZmFjZSBEYXRhUm91dGVNYXRjaCBleHRlbmRzIFJvdXRlTWF0Y2g8c3RyaW5nLCBEYXRhUm91dGVPYmplY3Q+IHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVJvdXRlckNvbnRleHRPYmplY3QgZXh0ZW5kcyBOYXZpZ2F0aW9uQ29udGV4dE9iamVjdCB7XG4gIHJvdXRlcjogUm91dGVyO1xuICBzdGF0aWNDb250ZXh0PzogU3RhdGljSGFuZGxlckNvbnRleHQ7XG59XG5cbmV4cG9ydCBjb25zdCBEYXRhUm91dGVyQ29udGV4dCA9XG4gIFJlYWN0LmNyZWF0ZUNvbnRleHQ8RGF0YVJvdXRlckNvbnRleHRPYmplY3QgfCBudWxsPihudWxsKTtcbmlmIChfX0RFVl9fKSB7XG4gIERhdGFSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJEYXRhUm91dGVyXCI7XG59XG5cbmV4cG9ydCBjb25zdCBEYXRhUm91dGVyU3RhdGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxcbiAgUm91dGVyW1wic3RhdGVcIl0gfCBudWxsXG4+KG51bGwpO1xuaWYgKF9fREVWX18pIHtcbiAgRGF0YVJvdXRlclN0YXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGF0YVJvdXRlclN0YXRlXCI7XG59XG5cbmV4cG9ydCBjb25zdCBBd2FpdENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PFRyYWNrZWRQcm9taXNlIHwgbnVsbD4obnVsbCk7XG5pZiAoX19ERVZfXykge1xuICBBd2FpdENvbnRleHQuZGlzcGxheU5hbWUgPSBcIkF3YWl0XCI7XG59XG5cbmV4cG9ydCB0eXBlIFJlbGF0aXZlUm91dGluZ1R5cGUgPSBcInJvdXRlXCIgfCBcInBhdGhcIjtcblxuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0ZU9wdGlvbnMge1xuICByZXBsYWNlPzogYm9vbGVhbjtcbiAgc3RhdGU/OiBhbnk7XG4gIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG4gIHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZTtcbn1cblxuLyoqXG4gKiBBIE5hdmlnYXRvciBpcyBhIFwibG9jYXRpb24gY2hhbmdlclwiOyBpdCdzIGhvdyB5b3UgZ2V0IHRvIGRpZmZlcmVudCBsb2NhdGlvbnMuXG4gKlxuICogRXZlcnkgaGlzdG9yeSBpbnN0YW5jZSBjb25mb3JtcyB0byB0aGUgTmF2aWdhdG9yIGludGVyZmFjZSwgYnV0IHRoZVxuICogZGlzdGluY3Rpb24gaXMgdXNlZnVsIHByaW1hcmlseSB3aGVuIGl0IGNvbWVzIHRvIHRoZSBsb3ctbGV2ZWwgPFJvdXRlcj4gQVBJXG4gKiB3aGVyZSBib3RoIHRoZSBsb2NhdGlvbiBhbmQgYSBuYXZpZ2F0b3IgbXVzdCBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGluIG9yZGVyXG4gKiB0byBhdm9pZCBcInRlYXJpbmdcIiB0aGF0IG1heSBvY2N1ciBpbiBhIHN1c3BlbnNlLWVuYWJsZWQgYXBwIGlmIHRoZSBhY3Rpb25cbiAqIGFuZC9vciBsb2NhdGlvbiB3ZXJlIHRvIGJlIHJlYWQgZGlyZWN0bHkgZnJvbSB0aGUgaGlzdG9yeSBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0b3Ige1xuICBjcmVhdGVIcmVmOiBIaXN0b3J5W1wiY3JlYXRlSHJlZlwiXTtcbiAgLy8gT3B0aW9uYWwgZm9yIGJhY2t3YXJkcy1jb21wYXQgd2l0aCBSb3V0ZXIvSGlzdG9yeVJvdXRlciB1c2FnZSAoZWRnZSBjYXNlKVxuICBlbmNvZGVMb2NhdGlvbj86IEhpc3RvcnlbXCJlbmNvZGVMb2NhdGlvblwiXTtcbiAgZ286IEhpc3RvcnlbXCJnb1wiXTtcbiAgcHVzaCh0bzogVG8sIHN0YXRlPzogYW55LCBvcHRzPzogTmF2aWdhdGVPcHRpb25zKTogdm9pZDtcbiAgcmVwbGFjZSh0bzogVG8sIHN0YXRlPzogYW55LCBvcHRzPzogTmF2aWdhdGVPcHRpb25zKTogdm9pZDtcbn1cblxuaW50ZXJmYWNlIE5hdmlnYXRpb25Db250ZXh0T2JqZWN0IHtcbiAgYmFzZW5hbWU6IHN0cmluZztcbiAgbmF2aWdhdG9yOiBOYXZpZ2F0b3I7XG4gIHN0YXRpYzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IE5hdmlnYXRpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxOYXZpZ2F0aW9uQ29udGV4dE9iamVjdD4oXG4gIG51bGwhXG4pO1xuXG5pZiAoX19ERVZfXykge1xuICBOYXZpZ2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTmF2aWdhdGlvblwiO1xufVxuXG5pbnRlcmZhY2UgTG9jYXRpb25Db250ZXh0T2JqZWN0IHtcbiAgbG9jYXRpb246IExvY2F0aW9uO1xuICBuYXZpZ2F0aW9uVHlwZTogTmF2aWdhdGlvblR5cGU7XG59XG5cbmV4cG9ydCBjb25zdCBMb2NhdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PExvY2F0aW9uQ29udGV4dE9iamVjdD4oXG4gIG51bGwhXG4pO1xuXG5pZiAoX19ERVZfXykge1xuICBMb2NhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkxvY2F0aW9uXCI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVDb250ZXh0T2JqZWN0IHtcbiAgb3V0bGV0OiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsO1xuICBtYXRjaGVzOiBSb3V0ZU1hdGNoW107XG59XG5cbmV4cG9ydCBjb25zdCBSb3V0ZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PFJvdXRlQ29udGV4dE9iamVjdD4oe1xuICBvdXRsZXQ6IG51bGwsXG4gIG1hdGNoZXM6IFtdLFxufSk7XG5cbmlmIChfX0RFVl9fKSB7XG4gIFJvdXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVcIjtcbn1cblxuZXhwb3J0IGNvbnN0IFJvdXRlRXJyb3JDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxhbnk+KG51bGwpO1xuXG5pZiAoX19ERVZfXykge1xuICBSb3V0ZUVycm9yQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVFcnJvclwiO1xufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7XG4gIEJsb2NrZXIsXG4gIEJsb2NrZXJGdW5jdGlvbixcbiAgTG9jYXRpb24sXG4gIFBhcmFtUGFyc2VLZXksXG4gIFBhcmFtcyxcbiAgUGF0aCxcbiAgUGF0aE1hdGNoLFxuICBQYXRoUGF0dGVybixcbiAgUm91dGVyIGFzIFJlbWl4Um91dGVyLFxuICBUbyxcbn0gZnJvbSBcIkByZW1peC1ydW4vcm91dGVyXCI7XG5pbXBvcnQge1xuICBBY3Rpb24gYXMgTmF2aWdhdGlvblR5cGUsXG4gIGludmFyaWFudCxcbiAgaXNSb3V0ZUVycm9yUmVzcG9uc2UsXG4gIGpvaW5QYXRocyxcbiAgbWF0Y2hQYXRoLFxuICBtYXRjaFJvdXRlcyxcbiAgcGFyc2VQYXRoLFxuICByZXNvbHZlVG8sXG4gIHdhcm5pbmcsXG4gIFVOU0FGRV9nZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyBhcyBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyxcbn0gZnJvbSBcIkByZW1peC1ydW4vcm91dGVyXCI7XG5cbmltcG9ydCB0eXBlIHtcbiAgTmF2aWdhdGVPcHRpb25zLFxuICBSb3V0ZUNvbnRleHRPYmplY3QsXG4gIFJvdXRlTWF0Y2gsXG4gIFJvdXRlT2JqZWN0LFxuICBEYXRhUm91dGVNYXRjaCxcbiAgUmVsYXRpdmVSb3V0aW5nVHlwZSxcbn0gZnJvbSBcIi4vY29udGV4dFwiO1xuaW1wb3J0IHtcbiAgRGF0YVJvdXRlckNvbnRleHQsXG4gIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsXG4gIExvY2F0aW9uQ29udGV4dCxcbiAgTmF2aWdhdGlvbkNvbnRleHQsXG4gIFJvdXRlQ29udGV4dCxcbiAgUm91dGVFcnJvckNvbnRleHQsXG4gIEF3YWl0Q29udGV4dCxcbn0gZnJvbSBcIi4vY29udGV4dFwiO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZ1bGwgaHJlZiBmb3IgdGhlIGdpdmVuIFwidG9cIiB2YWx1ZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGJ1aWxkaW5nXG4gKiBjdXN0b20gbGlua3MgdGhhdCBhcmUgYWxzbyBhY2Nlc3NpYmxlIGFuZCBwcmVzZXJ2ZSByaWdodC1jbGljayBiZWhhdmlvci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1ocmVmXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VIcmVmKFxuICB0bzogVG8sXG4gIHsgcmVsYXRpdmUgfTogeyByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGUgfSA9IHt9XG4pOiBzdHJpbmcge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VIcmVmKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgYmFzZW5hbWUsIG5hdmlnYXRvciB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7IGhhc2gsIHBhdGhuYW1lLCBzZWFyY2ggfSA9IHVzZVJlc29sdmVkUGF0aCh0bywgeyByZWxhdGl2ZSB9KTtcblxuICBsZXQgam9pbmVkUGF0aG5hbWUgPSBwYXRobmFtZTtcblxuICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lIHByaW9yXG4gIC8vIHRvIGNyZWF0aW5nIHRoZSBocmVmLiAgSWYgdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiBqdXN0IHVzZSB0aGUgcmF3XG4gIC8vIGJhc2VuYW1lIHdoaWNoIGFsbG93cyB0aGUgYmFzZW5hbWUgdG8gaGF2ZSBmdWxsIGNvbnRyb2wgb3ZlciB0aGUgcHJlc2VuY2VcbiAgLy8gb2YgYSB0cmFpbGluZyBzbGFzaCBvbiByb290IGxpbmtzXG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBqb2luZWRQYXRobmFtZSA9XG4gICAgICBwYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGhuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gbmF2aWdhdG9yLmNyZWF0ZUhyZWYoeyBwYXRobmFtZTogam9pbmVkUGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb21wb25lbnQgaXMgYSBkZXNjZW5kYW50IG9mIGEgPFJvdXRlcj4uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtaW4tcm91dGVyLWNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUluUm91dGVyQ29udGV4dCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KSAhPSBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbG9jYXRpb24gb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIHRoZSBjdXJyZW50IFVSTCBpbiB3ZWJcbiAqIGJyb3dzZXJzLlxuICpcbiAqIE5vdGU6IElmIHlvdSdyZSB1c2luZyB0aGlzIGl0IG1heSBtZWFuIHlvdSdyZSBkb2luZyBzb21lIG9mIHlvdXIgb3duXG4gKiBcInJvdXRpbmdcIiBpbiB5b3VyIGFwcCwgYW5kIHdlJ2QgbGlrZSB0byBrbm93IHdoYXQgeW91ciB1c2UgY2FzZSBpcy4gV2UgbWF5XG4gKiBiZSBhYmxlIHRvIHByb3ZpZGUgc29tZXRoaW5nIGhpZ2hlci1sZXZlbCB0byBiZXR0ZXIgc3VpdCB5b3VyIG5lZWRzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLWxvY2F0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2NhdGlvbigpOiBMb2NhdGlvbiB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZUxvY2F0aW9uKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KS5sb2NhdGlvbjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gYWN0aW9uIHdoaWNoIGRlc2NyaWJlcyBob3cgdGhlIHJvdXRlciBjYW1lIHRvXG4gKiB0aGUgY3VycmVudCBsb2NhdGlvbiwgZWl0aGVyIGJ5IGEgcG9wLCBwdXNoLCBvciByZXBsYWNlIG9uIHRoZSBoaXN0b3J5IHN0YWNrLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW5hdmlnYXRpb24tdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTmF2aWdhdGlvblR5cGUoKTogTmF2aWdhdGlvblR5cGUge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLm5hdmlnYXRpb25UeXBlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBQYXRoTWF0Y2ggb2JqZWN0IGlmIHRoZSBnaXZlbiBwYXR0ZXJuIG1hdGNoZXMgdGhlIGN1cnJlbnQgVVJMLlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGNvbXBvbmVudHMgdGhhdCBuZWVkIHRvIGtub3cgXCJhY3RpdmVcIiBzdGF0ZSwgZS5nLlxuICogPE5hdkxpbms+LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW1hdGNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYXRjaDxcbiAgUGFyYW1LZXkgZXh0ZW5kcyBQYXJhbVBhcnNlS2V5PFBhdGg+LFxuICBQYXRoIGV4dGVuZHMgc3RyaW5nXG4+KHBhdHRlcm46IFBhdGhQYXR0ZXJuPFBhdGg+IHwgUGF0aCk6IFBhdGhNYXRjaDxQYXJhbUtleT4gfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlTWF0Y2goKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICBsZXQgeyBwYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT4gbWF0Y2hQYXRoPFBhcmFtS2V5LCBQYXRoPihwYXR0ZXJuLCBwYXRobmFtZSksXG4gICAgW3BhdGhuYW1lLCBwYXR0ZXJuXVxuICApO1xufVxuXG4vKipcbiAqIFRoZSBpbnRlcmZhY2UgZm9yIHRoZSBuYXZpZ2F0ZSgpIGZ1bmN0aW9uIHJldHVybmVkIGZyb20gdXNlTmF2aWdhdGUoKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0ZUZ1bmN0aW9uIHtcbiAgKHRvOiBUbywgb3B0aW9ucz86IE5hdmlnYXRlT3B0aW9ucyk6IHZvaWQ7XG4gIChkZWx0YTogbnVtYmVyKTogdm9pZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGltcGVyYXRpdmUgbWV0aG9kIGZvciBjaGFuZ2luZyB0aGUgbG9jYXRpb24uIFVzZWQgYnkgPExpbms+cywgYnV0XG4gKiBtYXkgYWxzbyBiZSB1c2VkIGJ5IG90aGVyIGVsZW1lbnRzIHRvIGNoYW5nZSB0aGUgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbmF2aWdhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU5hdmlnYXRlKCk6IE5hdmlnYXRlRnVuY3Rpb24ge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VOYXZpZ2F0ZSgpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIGxldCB7IGJhc2VuYW1lLCBuYXZpZ2F0b3IgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7IHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lIH0gPSB1c2VMb2NhdGlvbigpO1xuXG4gIGxldCByb3V0ZVBhdGhuYW1lc0pzb24gPSBKU09OLnN0cmluZ2lmeShcbiAgICBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKS5tYXAoKG1hdGNoKSA9PiBtYXRjaC5wYXRobmFtZUJhc2UpXG4gICk7XG5cbiAgbGV0IGFjdGl2ZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgYWN0aXZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICB9KTtcblxuICBsZXQgbmF2aWdhdGU6IE5hdmlnYXRlRnVuY3Rpb24gPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAodG86IFRvIHwgbnVtYmVyLCBvcHRpb25zOiBOYXZpZ2F0ZU9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgYWN0aXZlUmVmLmN1cnJlbnQsXG4gICAgICAgIGBZb3Ugc2hvdWxkIGNhbGwgbmF2aWdhdGUoKSBpbiBhIFJlYWN0LnVzZUVmZmVjdCgpLCBub3Qgd2hlbiBgICtcbiAgICAgICAgICBgeW91ciBjb21wb25lbnQgaXMgZmlyc3QgcmVuZGVyZWQuYFxuICAgICAgKTtcblxuICAgICAgaWYgKCFhY3RpdmVSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG5hdmlnYXRvci5nbyh0byk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IHBhdGggPSByZXNvbHZlVG8oXG4gICAgICAgIHRvLFxuICAgICAgICBKU09OLnBhcnNlKHJvdXRlUGF0aG5hbWVzSnNvbiksXG4gICAgICAgIGxvY2F0aW9uUGF0aG5hbWUsXG4gICAgICAgIG9wdGlvbnMucmVsYXRpdmUgPT09IFwicGF0aFwiXG4gICAgICApO1xuXG4gICAgICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lIHByaW9yXG4gICAgICAvLyB0byBoYW5kaW5nIG9mZiB0byBoaXN0b3J5LiAgSWYgdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiB3ZVxuICAgICAgLy8gbmF2aWdhdGUgdG8gdGhlIHJhdyBiYXNlbmFtZSB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbFxuICAgICAgLy8gY29udHJvbCBvdmVyIHRoZSBwcmVzZW5jZSBvZiBhIHRyYWlsaW5nIHNsYXNoIG9uIHJvb3QgbGlua3NcbiAgICAgIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgICAgcGF0aC5wYXRobmFtZSA9XG4gICAgICAgICAgcGF0aC5wYXRobmFtZSA9PT0gXCIvXCJcbiAgICAgICAgICAgID8gYmFzZW5hbWVcbiAgICAgICAgICAgIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICAgICAgfVxuXG4gICAgICAoISFvcHRpb25zLnJlcGxhY2UgPyBuYXZpZ2F0b3IucmVwbGFjZSA6IG5hdmlnYXRvci5wdXNoKShcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb3B0aW9ucy5zdGF0ZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICB9LFxuICAgIFtiYXNlbmFtZSwgbmF2aWdhdG9yLCByb3V0ZVBhdGhuYW1lc0pzb24sIGxvY2F0aW9uUGF0aG5hbWVdXG4gICk7XG5cbiAgcmV0dXJuIG5hdmlnYXRlO1xufVxuXG5jb25zdCBPdXRsZXRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDx1bmtub3duPihudWxsKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250ZXh0IChpZiBwcm92aWRlZCkgZm9yIHRoZSBjaGlsZCByb3V0ZSBhdCB0aGlzIGxldmVsIG9mIHRoZSByb3V0ZVxuICogaGllcmFyY2h5LlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2Utb3V0bGV0LWNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU91dGxldENvbnRleHQ8Q29udGV4dCA9IHVua25vd24+KCk6IENvbnRleHQge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChPdXRsZXRDb250ZXh0KSBhcyBDb250ZXh0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQgZm9yIHRoZSBjaGlsZCByb3V0ZSBhdCB0aGlzIGxldmVsIG9mIHRoZSByb3V0ZVxuICogaGllcmFyY2h5LiBVc2VkIGludGVybmFsbHkgYnkgPE91dGxldD4gdG8gcmVuZGVyIGNoaWxkIHJvdXRlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1vdXRsZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU91dGxldChjb250ZXh0PzogdW5rbm93bik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBsZXQgb3V0bGV0ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpLm91dGxldDtcbiAgaWYgKG91dGxldCkge1xuICAgIHJldHVybiAoXG4gICAgICA8T3V0bGV0Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dH0+e291dGxldH08L091dGxldENvbnRleHQuUHJvdmlkZXI+XG4gICAgKTtcbiAgfVxuICByZXR1cm4gb3V0bGV0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycyBvZiB0aGUgZHluYW1pYyBwYXJhbXMgZnJvbSB0aGUgY3VycmVudFxuICogVVJMIHRoYXQgd2VyZSBtYXRjaGVkIGJ5IHRoZSByb3V0ZSBwYXRoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLXBhcmFtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUGFyYW1zPFxuICBQYXJhbXNPcktleSBleHRlbmRzIHN0cmluZyB8IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSBzdHJpbmdcbj4oKTogUmVhZG9ubHk8XG4gIFtQYXJhbXNPcktleV0gZXh0ZW5kcyBbc3RyaW5nXSA/IFBhcmFtczxQYXJhbXNPcktleT4gOiBQYXJ0aWFsPFBhcmFtc09yS2V5PlxuPiB7XG4gIGxldCB7IG1hdGNoZXMgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHJvdXRlTWF0Y2ggPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gIHJldHVybiByb3V0ZU1hdGNoID8gKHJvdXRlTWF0Y2gucGFyYW1zIGFzIGFueSkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyB0aGUgcGF0aG5hbWUgb2YgdGhlIGdpdmVuIGB0b2AgdmFsdWUgYWdhaW5zdCB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1yZXNvbHZlZC1wYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZXNvbHZlZFBhdGgoXG4gIHRvOiBUbyxcbiAgeyByZWxhdGl2ZSB9OiB7IHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZSB9ID0ge31cbik6IFBhdGgge1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7IHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lIH0gPSB1c2VMb2NhdGlvbigpO1xuXG4gIGxldCByb3V0ZVBhdGhuYW1lc0pzb24gPSBKU09OLnN0cmluZ2lmeShcbiAgICBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKS5tYXAoKG1hdGNoKSA9PiBtYXRjaC5wYXRobmFtZUJhc2UpXG4gICk7XG5cbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT5cbiAgICAgIHJlc29sdmVUbyhcbiAgICAgICAgdG8sXG4gICAgICAgIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSxcbiAgICAgICAgbG9jYXRpb25QYXRobmFtZSxcbiAgICAgICAgcmVsYXRpdmUgPT09IFwicGF0aFwiXG4gICAgICApLFxuICAgIFt0bywgcm91dGVQYXRobmFtZXNKc29uLCBsb2NhdGlvblBhdGhuYW1lLCByZWxhdGl2ZV1cbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IG9mIHRoZSByb3V0ZSB0aGF0IG1hdGNoZWQgdGhlIGN1cnJlbnQgbG9jYXRpb24sIHByZXBhcmVkXG4gKiB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHQgdG8gcmVuZGVyIHRoZSByZW1haW5kZXIgb2YgdGhlIHJvdXRlIHRyZWUuIFJvdXRlXG4gKiBlbGVtZW50cyBpbiB0aGUgdHJlZSBtdXN0IHJlbmRlciBhbiA8T3V0bGV0PiB0byByZW5kZXIgdGhlaXIgY2hpbGQgcm91dGUnc1xuICogZWxlbWVudC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1yb3V0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdXRlcyhcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFtdLFxuICBsb2NhdGlvbkFyZz86IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nXG4pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlUm91dGVzKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgbmF2aWdhdG9yIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGRhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICBsZXQgeyBtYXRjaGVzOiBwYXJlbnRNYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gcGFyZW50TWF0Y2hlc1twYXJlbnRNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBsZXQgcGFyZW50UGFyYW1zID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XG4gIGxldCBwYXJlbnRQYXRobmFtZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lIDogXCIvXCI7XG4gIGxldCBwYXJlbnRQYXRobmFtZUJhc2UgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZUJhc2UgOiBcIi9cIjtcbiAgbGV0IHBhcmVudFJvdXRlID0gcm91dGVNYXRjaCAmJiByb3V0ZU1hdGNoLnJvdXRlO1xuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgLy8gWW91IHdvbid0IGdldCBhIHdhcm5pbmcgYWJvdXQgMiBkaWZmZXJlbnQgPFJvdXRlcz4gdW5kZXIgYSA8Um91dGU+XG4gICAgLy8gd2l0aG91dCBhIHRyYWlsaW5nICosIGJ1dCB0aGlzIGlzIGEgYmVzdC1lZmZvcnQgd2FybmluZyBhbnl3YXkgc2luY2Ugd2VcbiAgICAvLyBjYW5ub3QgZXZlbiBnaXZlIHRoZSB3YXJuaW5nIHVubGVzcyB0aGV5IGxhbmQgYXQgdGhlIHBhcmVudCByb3V0ZS5cbiAgICAvL1xuICAgIC8vIEV4YW1wbGU6XG4gICAgLy9cbiAgICAvLyA8Um91dGVzPlxuICAgIC8vICAgey8qIFRoaXMgcm91dGUgcGF0aCBNVVNUIGVuZCB3aXRoIC8qIGJlY2F1c2Ugb3RoZXJ3aXNlXG4gICAgLy8gICAgICAgaXQgd2lsbCBuZXZlciBtYXRjaCAvYmxvZy9wb3N0LzEyMyAqL31cbiAgICAvLyAgIDxSb3V0ZSBwYXRoPVwiYmxvZ1wiIGVsZW1lbnQ9ezxCbG9nIC8+fSAvPlxuICAgIC8vICAgPFJvdXRlIHBhdGg9XCJibG9nL2ZlZWRcIiBlbGVtZW50PXs8QmxvZ0ZlZWQgLz59IC8+XG4gICAgLy8gPC9Sb3V0ZXM+XG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiBCbG9nKCkge1xuICAgIC8vICAgcmV0dXJuIChcbiAgICAvLyAgICAgPFJvdXRlcz5cbiAgICAvLyAgICAgICA8Um91dGUgcGF0aD1cInBvc3QvOmlkXCIgZWxlbWVudD17PFBvc3QgLz59IC8+XG4gICAgLy8gICAgIDwvUm91dGVzPlxuICAgIC8vICAgKTtcbiAgICAvLyB9XG4gICAgbGV0IHBhcmVudFBhdGggPSAocGFyZW50Um91dGUgJiYgcGFyZW50Um91dGUucGF0aCkgfHwgXCJcIjtcbiAgICB3YXJuaW5nT25jZShcbiAgICAgIHBhcmVudFBhdGhuYW1lLFxuICAgICAgIXBhcmVudFJvdXRlIHx8IHBhcmVudFBhdGguZW5kc1dpdGgoXCIqXCIpLFxuICAgICAgYFlvdSByZW5kZXJlZCBkZXNjZW5kYW50IDxSb3V0ZXM+IChvciBjYWxsZWQgXFxgdXNlUm91dGVzKClcXGApIGF0IGAgK1xuICAgICAgICBgXCIke3BhcmVudFBhdGhuYW1lfVwiICh1bmRlciA8Um91dGUgcGF0aD1cIiR7cGFyZW50UGF0aH1cIj4pIGJ1dCB0aGUgYCArXG4gICAgICAgIGBwYXJlbnQgcm91dGUgcGF0aCBoYXMgbm8gdHJhaWxpbmcgXCIqXCIuIFRoaXMgbWVhbnMgaWYgeW91IG5hdmlnYXRlIGAgK1xuICAgICAgICBgZGVlcGVyLCB0aGUgcGFyZW50IHdvbid0IG1hdGNoIGFueW1vcmUgYW5kIHRoZXJlZm9yZSB0aGUgY2hpbGQgYCArXG4gICAgICAgIGByb3V0ZXMgd2lsbCBuZXZlciByZW5kZXIuXFxuXFxuYCArXG4gICAgICAgIGBQbGVhc2UgY2hhbmdlIHRoZSBwYXJlbnQgPFJvdXRlIHBhdGg9XCIke3BhcmVudFBhdGh9XCI+IHRvIDxSb3V0ZSBgICtcbiAgICAgICAgYHBhdGg9XCIke3BhcmVudFBhdGggPT09IFwiL1wiID8gXCIqXCIgOiBgJHtwYXJlbnRQYXRofS8qYH1cIj4uYFxuICAgICk7XG4gIH1cblxuICBsZXQgbG9jYXRpb25Gcm9tQ29udGV4dCA9IHVzZUxvY2F0aW9uKCk7XG5cbiAgbGV0IGxvY2F0aW9uO1xuICBpZiAobG9jYXRpb25BcmcpIHtcbiAgICBsZXQgcGFyc2VkTG9jYXRpb25BcmcgPVxuICAgICAgdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuXG4gICAgaW52YXJpYW50KFxuICAgICAgcGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIiB8fFxuICAgICAgICBwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZT8uc3RhcnRzV2l0aChwYXJlbnRQYXRobmFtZUJhc2UpLFxuICAgICAgYFdoZW4gb3ZlcnJpZGluZyB0aGUgbG9jYXRpb24gdXNpbmcgXFxgPFJvdXRlcyBsb2NhdGlvbj5cXGAgb3IgXFxgdXNlUm91dGVzKHJvdXRlcywgbG9jYXRpb24pXFxgLCBgICtcbiAgICAgICAgYHRoZSBsb2NhdGlvbiBwYXRobmFtZSBtdXN0IGJlZ2luIHdpdGggdGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBgICtcbiAgICAgICAgYG1hdGNoZWQgYnkgYWxsIHBhcmVudCByb3V0ZXMuIFRoZSBjdXJyZW50IHBhdGhuYW1lIGJhc2UgaXMgXCIke3BhcmVudFBhdGhuYW1lQmFzZX1cIiBgICtcbiAgICAgICAgYGJ1dCBwYXRobmFtZSBcIiR7cGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWV9XCIgd2FzIGdpdmVuIGluIHRoZSBcXGBsb2NhdGlvblxcYCBwcm9wLmBcbiAgICApO1xuXG4gICAgbG9jYXRpb24gPSBwYXJzZWRMb2NhdGlvbkFyZztcbiAgfSBlbHNlIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uRnJvbUNvbnRleHQ7XG4gIH1cblxuICBsZXQgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIjtcbiAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID1cbiAgICBwYXJlbnRQYXRobmFtZUJhc2UgPT09IFwiL1wiXG4gICAgICA/IHBhdGhuYW1lXG4gICAgICA6IHBhdGhuYW1lLnNsaWNlKHBhcmVudFBhdGhuYW1lQmFzZS5sZW5ndGgpIHx8IFwiL1wiO1xuXG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzLCB7IHBhdGhuYW1lOiByZW1haW5pbmdQYXRobmFtZSB9KTtcblxuICBpZiAoX19ERVZfXykge1xuICAgIHdhcm5pbmcoXG4gICAgICBwYXJlbnRSb3V0ZSB8fCBtYXRjaGVzICE9IG51bGwsXG4gICAgICBgTm8gcm91dGVzIG1hdGNoZWQgbG9jYXRpb24gXCIke2xvY2F0aW9uLnBhdGhuYW1lfSR7bG9jYXRpb24uc2VhcmNofSR7bG9jYXRpb24uaGFzaH1cIiBgXG4gICAgKTtcblxuICAgIHdhcm5pbmcoXG4gICAgICBtYXRjaGVzID09IG51bGwgfHxcbiAgICAgICAgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmVsZW1lbnQgIT09IHVuZGVmaW5lZCxcbiAgICAgIGBNYXRjaGVkIGxlYWYgcm91dGUgYXQgbG9jYXRpb24gXCIke2xvY2F0aW9uLnBhdGhuYW1lfSR7bG9jYXRpb24uc2VhcmNofSR7bG9jYXRpb24uaGFzaH1cIiBkb2VzIG5vdCBoYXZlIGFuIGVsZW1lbnQuIGAgK1xuICAgICAgICBgVGhpcyBtZWFucyBpdCB3aWxsIHJlbmRlciBhbiA8T3V0bGV0IC8+IHdpdGggYSBudWxsIHZhbHVlIGJ5IGRlZmF1bHQgcmVzdWx0aW5nIGluIGFuIFwiZW1wdHlcIiBwYWdlLmBcbiAgICApO1xuICB9XG5cbiAgbGV0IHJlbmRlcmVkTWF0Y2hlcyA9IF9yZW5kZXJNYXRjaGVzKFxuICAgIG1hdGNoZXMgJiZcbiAgICAgIG1hdGNoZXMubWFwKChtYXRjaCkgPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgbWF0Y2gsIHtcbiAgICAgICAgICBwYXJhbXM6IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudFBhcmFtcywgbWF0Y2gucGFyYW1zKSxcbiAgICAgICAgICBwYXRobmFtZTogam9pblBhdGhzKFtcbiAgICAgICAgICAgIHBhcmVudFBhdGhuYW1lQmFzZSxcbiAgICAgICAgICAgIC8vIFJlLWVuY29kZSBwYXRobmFtZXMgdGhhdCB3ZXJlIGRlY29kZWQgaW5zaWRlIG1hdGNoUm91dGVzXG4gICAgICAgICAgICBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb25cbiAgICAgICAgICAgICAgPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24obWF0Y2gucGF0aG5hbWUpLnBhdGhuYW1lXG4gICAgICAgICAgICAgIDogbWF0Y2gucGF0aG5hbWUsXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcGF0aG5hbWVCYXNlOlxuICAgICAgICAgICAgbWF0Y2gucGF0aG5hbWVCYXNlID09PSBcIi9cIlxuICAgICAgICAgICAgICA/IHBhcmVudFBhdGhuYW1lQmFzZVxuICAgICAgICAgICAgICA6IGpvaW5QYXRocyhbXG4gICAgICAgICAgICAgICAgICBwYXJlbnRQYXRobmFtZUJhc2UsXG4gICAgICAgICAgICAgICAgICAvLyBSZS1lbmNvZGUgcGF0aG5hbWVzIHRoYXQgd2VyZSBkZWNvZGVkIGluc2lkZSBtYXRjaFJvdXRlc1xuICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uKG1hdGNoLnBhdGhuYW1lQmFzZSkucGF0aG5hbWVcbiAgICAgICAgICAgICAgICAgICAgOiBtYXRjaC5wYXRobmFtZUJhc2UsXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgIH0pXG4gICAgICApLFxuICAgIHBhcmVudE1hdGNoZXMsXG4gICAgZGF0YVJvdXRlclN0YXRlQ29udGV4dCB8fCB1bmRlZmluZWRcbiAgKTtcblxuICAvLyBXaGVuIGEgdXNlciBwYXNzZXMgaW4gYSBgbG9jYXRpb25BcmdgLCB0aGUgYXNzb2NpYXRlZCByb3V0ZXMgbmVlZCB0b1xuICAvLyBiZSB3cmFwcGVkIGluIGEgbmV3IGBMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXJgIGluIG9yZGVyIGZvciBgdXNlTG9jYXRpb25gXG4gIC8vIHRvIHVzZSB0aGUgc2NvcGVkIGxvY2F0aW9uIGluc3RlYWQgb2YgdGhlIGdsb2JhbCBsb2NhdGlvbi5cbiAgaWYgKGxvY2F0aW9uQXJnICYmIHJlbmRlcmVkTWF0Y2hlcykge1xuICAgIHJldHVybiAoXG4gICAgICA8TG9jYXRpb25Db250ZXh0LlByb3ZpZGVyXG4gICAgICAgIHZhbHVlPXt7XG4gICAgICAgICAgbG9jYXRpb246IHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiBcIi9cIixcbiAgICAgICAgICAgIHNlYXJjaDogXCJcIixcbiAgICAgICAgICAgIGhhc2g6IFwiXCIsXG4gICAgICAgICAgICBzdGF0ZTogbnVsbCxcbiAgICAgICAgICAgIGtleTogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICAuLi5sb2NhdGlvbixcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hdmlnYXRpb25UeXBlOiBOYXZpZ2F0aW9uVHlwZS5Qb3AsXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHtyZW5kZXJlZE1hdGNoZXN9XG4gICAgICA8L0xvY2F0aW9uQ29udGV4dC5Qcm92aWRlcj5cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHJlbmRlcmVkTWF0Y2hlcztcbn1cblxuZnVuY3Rpb24gRGVmYXVsdEVycm9yRWxlbWVudCgpIHtcbiAgbGV0IGVycm9yID0gdXNlUm91dGVFcnJvcigpO1xuICBsZXQgbWVzc2FnZSA9IGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKVxuICAgID8gYCR7ZXJyb3Iuc3RhdHVzfSAke2Vycm9yLnN0YXR1c1RleHR9YFxuICAgIDogZXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICAgID8gZXJyb3IubWVzc2FnZVxuICAgIDogSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xuICBsZXQgc3RhY2sgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiBudWxsO1xuICBsZXQgbGlnaHRncmV5ID0gXCJyZ2JhKDIwMCwyMDAsMjAwLCAwLjUpXCI7XG4gIGxldCBwcmVTdHlsZXMgPSB7IHBhZGRpbmc6IFwiMC41cmVtXCIsIGJhY2tncm91bmRDb2xvcjogbGlnaHRncmV5IH07XG4gIGxldCBjb2RlU3R5bGVzID0geyBwYWRkaW5nOiBcIjJweCA0cHhcIiwgYmFja2dyb3VuZENvbG9yOiBsaWdodGdyZXkgfTtcblxuICBsZXQgZGV2SW5mbyA9IG51bGw7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgZGV2SW5mbyA9IChcbiAgICAgIDw+XG4gICAgICAgIDxwPvCfkr8gSGV5IGRldmVsb3BlciDwn5GLPC9wPlxuICAgICAgICA8cD5cbiAgICAgICAgICBZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyB3aGVuIHlvdXIgYXBwIHRocm93cyBlcnJvcnNcbiAgICAgICAgICBieSBwcm92aWRpbmcgeW91ciBvd24mbmJzcDtcbiAgICAgICAgICA8Y29kZSBzdHlsZT17Y29kZVN0eWxlc30+ZXJyb3JFbGVtZW50PC9jb2RlPiBwcm9wcyBvbiZuYnNwO1xuICAgICAgICAgIDxjb2RlIHN0eWxlPXtjb2RlU3R5bGVzfT4mbHQ7Um91dGUmZ3Q7PC9jb2RlPlxuICAgICAgICA8L3A+XG4gICAgICA8Lz5cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGgyPlVuZXhwZWN0ZWQgQXBwbGljYXRpb24gRXJyb3IhPC9oMj5cbiAgICAgIDxoMyBzdHlsZT17eyBmb250U3R5bGU6IFwiaXRhbGljXCIgfX0+e21lc3NhZ2V9PC9oMz5cbiAgICAgIHtzdGFjayA/IDxwcmUgc3R5bGU9e3ByZVN0eWxlc30+e3N0YWNrfTwvcHJlPiA6IG51bGx9XG4gICAgICB7ZGV2SW5mb31cbiAgICA8Lz5cbiAgKTtcbn1cblxudHlwZSBSZW5kZXJFcnJvckJvdW5kYXJ5UHJvcHMgPSBSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjx7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbiAgZXJyb3I6IGFueTtcbiAgY29tcG9uZW50OiBSZWFjdC5SZWFjdE5vZGU7XG4gIHJvdXRlQ29udGV4dDogUm91dGVDb250ZXh0T2JqZWN0O1xufT47XG5cbnR5cGUgUmVuZGVyRXJyb3JCb3VuZGFyeVN0YXRlID0ge1xuICBsb2NhdGlvbjogTG9jYXRpb247XG4gIGVycm9yOiBhbnk7XG59O1xuXG5leHBvcnQgY2xhc3MgUmVuZGVyRXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxcbiAgUmVuZGVyRXJyb3JCb3VuZGFyeVByb3BzLFxuICBSZW5kZXJFcnJvckJvdW5kYXJ5U3RhdGVcbj4ge1xuICBjb25zdHJ1Y3Rvcihwcm9wczogUmVuZGVyRXJyb3JCb3VuZGFyeVByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBsb2NhdGlvbjogcHJvcHMubG9jYXRpb24sXG4gICAgICBlcnJvcjogcHJvcHMuZXJyb3IsXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3I6IGFueSkge1xuICAgIHJldHVybiB7IGVycm9yOiBlcnJvciB9O1xuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICBwcm9wczogUmVuZGVyRXJyb3JCb3VuZGFyeVByb3BzLFxuICAgIHN0YXRlOiBSZW5kZXJFcnJvckJvdW5kYXJ5U3RhdGVcbiAgKSB7XG4gICAgLy8gV2hlbiB3ZSBnZXQgaW50byBhbiBlcnJvciBzdGF0ZSwgdGhlIHVzZXIgd2lsbCBsaWtlbHkgY2xpY2sgXCJiYWNrXCIgdG8gdGhlXG4gICAgLy8gcHJldmlvdXMgcGFnZSB0aGF0IGRpZG4ndCBoYXZlIGFuIGVycm9yLiBCZWNhdXNlIHRoaXMgd3JhcHMgdGhlIGVudGlyZVxuICAgIC8vIGFwcGxpY2F0aW9uLCB0aGF0IHdpbGwgaGF2ZSBubyBlZmZlY3QtLXRoZSBlcnJvciBwYWdlIGNvbnRpbnVlcyB0byBkaXNwbGF5LlxuICAgIC8vIFRoaXMgZ2l2ZXMgdXMgYSBtZWNoYW5pc20gdG8gcmVjb3ZlciBmcm9tIHRoZSBlcnJvciB3aGVuIHRoZSBsb2NhdGlvbiBjaGFuZ2VzLlxuICAgIC8vXG4gICAgLy8gV2hldGhlciB3ZSdyZSBpbiBhbiBlcnJvciBzdGF0ZSBvciBub3QsIHdlIHVwZGF0ZSB0aGUgbG9jYXRpb24gaW4gc3RhdGVcbiAgICAvLyBzbyB0aGF0IHdoZW4gd2UgYXJlIGluIGFuIGVycm9yIHN0YXRlLCBpdCBnZXRzIHJlc2V0IHdoZW4gYSBuZXcgbG9jYXRpb25cbiAgICAvLyBjb21lcyBpbiBhbmQgdGhlIHVzZXIgcmVjb3ZlcnMgZnJvbSB0aGUgZXJyb3IuXG4gICAgaWYgKHN0YXRlLmxvY2F0aW9uICE9PSBwcm9wcy5sb2NhdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IHByb3BzLmVycm9yLFxuICAgICAgICBsb2NhdGlvbjogcHJvcHMubG9jYXRpb24sXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIG5vdCBjaGFuZ2luZyBsb2NhdGlvbnMsIHByZXNlcnZlIHRoZSBsb2NhdGlvbiBidXQgc3RpbGwgc3VyZmFjZVxuICAgIC8vIGFueSBuZXcgZXJyb3JzIHRoYXQgbWF5IGNvbWUgdGhyb3VnaC4gV2UgcmV0YWluIHRoZSBleGlzdGluZyBlcnJvciwgd2UgZG9cbiAgICAvLyB0aGlzIGJlY2F1c2UgdGhlIGVycm9yIHByb3ZpZGVkIGZyb20gdGhlIGFwcCBzdGF0ZSBtYXkgYmUgY2xlYXJlZCB3aXRob3V0XG4gICAgLy8gdGhlIGxvY2F0aW9uIGNoYW5naW5nLlxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogcHJvcHMuZXJyb3IgfHwgc3RhdGUuZXJyb3IsXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZENhdGNoKGVycm9yOiBhbnksIGVycm9ySW5mbzogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwiUmVhY3QgUm91dGVyIGNhdWdodCB0aGUgZm9sbG93aW5nIGVycm9yIGR1cmluZyByZW5kZXJcIixcbiAgICAgIGVycm9yLFxuICAgICAgZXJyb3JJbmZvXG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5lcnJvciA/IChcbiAgICAgIDxSb3V0ZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3RoaXMucHJvcHMucm91dGVDb250ZXh0fT5cbiAgICAgICAgPFJvdXRlRXJyb3JDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgICAgdmFsdWU9e3RoaXMuc3RhdGUuZXJyb3J9XG4gICAgICAgICAgY2hpbGRyZW49e3RoaXMucHJvcHMuY29tcG9uZW50fVxuICAgICAgICAvPlxuICAgICAgPC9Sb3V0ZUNvbnRleHQuUHJvdmlkZXI+XG4gICAgKSA6IChcbiAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICApO1xuICB9XG59XG5cbmludGVyZmFjZSBSZW5kZXJlZFJvdXRlUHJvcHMge1xuICByb3V0ZUNvbnRleHQ6IFJvdXRlQ29udGV4dE9iamVjdDtcbiAgbWF0Y2g6IFJvdXRlTWF0Y2g8c3RyaW5nLCBSb3V0ZU9iamVjdD47XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xufVxuXG5mdW5jdGlvbiBSZW5kZXJlZFJvdXRlKHsgcm91dGVDb250ZXh0LCBtYXRjaCwgY2hpbGRyZW4gfTogUmVuZGVyZWRSb3V0ZVByb3BzKSB7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuXG4gIC8vIFRyYWNrIGhvdyBkZWVwIHdlIGdvdCBpbiBvdXIgcmVuZGVyIHBhc3MgdG8gZW11bGF0ZSBTU1IgY29tcG9uZW50RGlkQ2F0Y2hcbiAgLy8gaW4gYSBEYXRhU3RhdGljUm91dGVyXG4gIGlmIChcbiAgICBkYXRhUm91dGVyQ29udGV4dCAmJlxuICAgIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpYyAmJlxuICAgIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY0NvbnRleHQgJiZcbiAgICBtYXRjaC5yb3V0ZS5lcnJvckVsZW1lbnRcbiAgKSB7XG4gICAgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljQ29udGV4dC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtyb3V0ZUNvbnRleHR9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvUm91dGVDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3JlbmRlck1hdGNoZXMoXG4gIG1hdGNoZXM6IFJvdXRlTWF0Y2hbXSB8IG51bGwsXG4gIHBhcmVudE1hdGNoZXM6IFJvdXRlTWF0Y2hbXSA9IFtdLFxuICBkYXRhUm91dGVyU3RhdGU/OiBSZW1peFJvdXRlcltcInN0YXRlXCJdXG4pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaWYgKG1hdGNoZXMgPT0gbnVsbCkge1xuICAgIGlmIChkYXRhUm91dGVyU3RhdGU/LmVycm9ycykge1xuICAgICAgLy8gRG9uJ3QgYmFpbCBpZiB3ZSBoYXZlIGRhdGEgcm91dGVyIGVycm9ycyBzbyB3ZSBjYW4gcmVuZGVyIHRoZW0gaW4gdGhlXG4gICAgICAvLyBib3VuZGFyeS4gIFVzZSB0aGUgcHJlLW1hdGNoZWQgKG9yIHNoaW1tZWQpIG1hdGNoZXNcbiAgICAgIG1hdGNoZXMgPSBkYXRhUm91dGVyU3RhdGUubWF0Y2hlcyBhcyBEYXRhUm91dGVNYXRjaFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBsZXQgcmVuZGVyZWRNYXRjaGVzID0gbWF0Y2hlcztcblxuICAvLyBJZiB3ZSBoYXZlIGRhdGEgZXJyb3JzLCB0cmltIG1hdGNoZXMgdG8gdGhlIGhpZ2hlc3QgZXJyb3IgYm91bmRhcnlcbiAgbGV0IGVycm9ycyA9IGRhdGFSb3V0ZXJTdGF0ZT8uZXJyb3JzO1xuICBpZiAoZXJyb3JzICE9IG51bGwpIHtcbiAgICBsZXQgZXJyb3JJbmRleCA9IHJlbmRlcmVkTWF0Y2hlcy5maW5kSW5kZXgoXG4gICAgICAobSkgPT4gbS5yb3V0ZS5pZCAmJiBlcnJvcnM/LlttLnJvdXRlLmlkXVxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgZXJyb3JJbmRleCA+PSAwLFxuICAgICAgYENvdWxkIG5vdCBmaW5kIGEgbWF0Y2hpbmcgcm91dGUgZm9yIHRoZSBjdXJyZW50IGVycm9yczogJHtlcnJvcnN9YFxuICAgICk7XG4gICAgcmVuZGVyZWRNYXRjaGVzID0gcmVuZGVyZWRNYXRjaGVzLnNsaWNlKFxuICAgICAgMCxcbiAgICAgIE1hdGgubWluKHJlbmRlcmVkTWF0Y2hlcy5sZW5ndGgsIGVycm9ySW5kZXggKyAxKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcmVuZGVyZWRNYXRjaGVzLnJlZHVjZVJpZ2h0KChvdXRsZXQsIG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGxldCBlcnJvciA9IG1hdGNoLnJvdXRlLmlkID8gZXJyb3JzPy5bbWF0Y2gucm91dGUuaWRdIDogbnVsbDtcbiAgICAvLyBPbmx5IGRhdGEgcm91dGVycyBoYW5kbGUgZXJyb3JzXG4gICAgbGV0IGVycm9yRWxlbWVudCA9IGRhdGFSb3V0ZXJTdGF0ZVxuICAgICAgPyBtYXRjaC5yb3V0ZS5lcnJvckVsZW1lbnQgfHwgPERlZmF1bHRFcnJvckVsZW1lbnQgLz5cbiAgICAgIDogbnVsbDtcbiAgICBsZXQgbWF0Y2hlcyA9IHBhcmVudE1hdGNoZXMuY29uY2F0KHJlbmRlcmVkTWF0Y2hlcy5zbGljZSgwLCBpbmRleCArIDEpKTtcbiAgICBsZXQgZ2V0Q2hpbGRyZW4gPSAoKSA9PiAoXG4gICAgICA8UmVuZGVyZWRSb3V0ZSBtYXRjaD17bWF0Y2h9IHJvdXRlQ29udGV4dD17eyBvdXRsZXQsIG1hdGNoZXMgfX0+XG4gICAgICAgIHtlcnJvclxuICAgICAgICAgID8gZXJyb3JFbGVtZW50XG4gICAgICAgICAgOiBtYXRjaC5yb3V0ZS5lbGVtZW50ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IG1hdGNoLnJvdXRlLmVsZW1lbnRcbiAgICAgICAgICA6IG91dGxldH1cbiAgICAgIDwvUmVuZGVyZWRSb3V0ZT5cbiAgICApO1xuICAgIC8vIE9ubHkgd3JhcCBpbiBhbiBlcnJvciBib3VuZGFyeSB3aXRoaW4gZGF0YSByb3V0ZXIgdXNhZ2VzIHdoZW4gd2UgaGF2ZSBhblxuICAgIC8vIGVycm9yRWxlbWVudCBvbiB0aGlzIHJvdXRlLiAgT3RoZXJ3aXNlIGxldCBpdCBidWJibGUgdXAgdG8gYW4gYW5jZXN0b3JcbiAgICAvLyBlcnJvckVsZW1lbnRcbiAgICByZXR1cm4gZGF0YVJvdXRlclN0YXRlICYmIChtYXRjaC5yb3V0ZS5lcnJvckVsZW1lbnQgfHwgaW5kZXggPT09IDApID8gKFxuICAgICAgPFJlbmRlckVycm9yQm91bmRhcnlcbiAgICAgICAgbG9jYXRpb249e2RhdGFSb3V0ZXJTdGF0ZS5sb2NhdGlvbn1cbiAgICAgICAgY29tcG9uZW50PXtlcnJvckVsZW1lbnR9XG4gICAgICAgIGVycm9yPXtlcnJvcn1cbiAgICAgICAgY2hpbGRyZW49e2dldENoaWxkcmVuKCl9XG4gICAgICAgIHJvdXRlQ29udGV4dD17eyBvdXRsZXQ6IG51bGwsIG1hdGNoZXMgfX1cbiAgICAgIC8+XG4gICAgKSA6IChcbiAgICAgIGdldENoaWxkcmVuKClcbiAgICApO1xuICB9LCBudWxsIGFzIFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwpO1xufVxuXG5lbnVtIERhdGFSb3V0ZXJIb29rIHtcbiAgVXNlQmxvY2tlciA9IFwidXNlQmxvY2tlclwiLFxuICBVc2VSZXZhbGlkYXRvciA9IFwidXNlUmV2YWxpZGF0b3JcIixcbn1cblxuZW51bSBEYXRhUm91dGVyU3RhdGVIb29rIHtcbiAgVXNlTG9hZGVyRGF0YSA9IFwidXNlTG9hZGVyRGF0YVwiLFxuICBVc2VBY3Rpb25EYXRhID0gXCJ1c2VBY3Rpb25EYXRhXCIsXG4gIFVzZVJvdXRlRXJyb3IgPSBcInVzZVJvdXRlRXJyb3JcIixcbiAgVXNlTmF2aWdhdGlvbiA9IFwidXNlTmF2aWdhdGlvblwiLFxuICBVc2VSb3V0ZUxvYWRlckRhdGEgPSBcInVzZVJvdXRlTG9hZGVyRGF0YVwiLFxuICBVc2VNYXRjaGVzID0gXCJ1c2VNYXRjaGVzXCIsXG4gIFVzZVJldmFsaWRhdG9yID0gXCJ1c2VSZXZhbGlkYXRvclwiLFxufVxuXG5mdW5jdGlvbiBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKFxuICBob29rTmFtZTogRGF0YVJvdXRlckhvb2sgfCBEYXRhUm91dGVyU3RhdGVIb29rXG4pIHtcbiAgcmV0dXJuIGAke2hvb2tOYW1lfSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgZGF0YSByb3V0ZXIuICBTZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vcm91dGVycy9waWNraW5nLWEtcm91dGVyLmA7XG59XG5cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJDb250ZXh0KGhvb2tOYW1lOiBEYXRhUm91dGVySG9vaykge1xuICBsZXQgY3R4ID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XG4gIGludmFyaWFudChjdHgsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKTtcbiAgcmV0dXJuIGN0eDtcbn1cblxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlclN0YXRlKGhvb2tOYW1lOiBEYXRhUm91dGVyU3RhdGVIb29rKSB7XG4gIGxldCBzdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gIGludmFyaWFudChzdGF0ZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpO1xuICByZXR1cm4gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIHVzZVJvdXRlQ29udGV4dChob29rTmFtZTogRGF0YVJvdXRlclN0YXRlSG9vaykge1xuICBsZXQgcm91dGUgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGludmFyaWFudChyb3V0ZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpO1xuICByZXR1cm4gcm91dGU7XG59XG5cbmZ1bmN0aW9uIHVzZUN1cnJlbnRSb3V0ZUlkKGhvb2tOYW1lOiBEYXRhUm91dGVyU3RhdGVIb29rKSB7XG4gIGxldCByb3V0ZSA9IHVzZVJvdXRlQ29udGV4dChob29rTmFtZSk7XG4gIGxldCB0aGlzUm91dGUgPSByb3V0ZS5tYXRjaGVzW3JvdXRlLm1hdGNoZXMubGVuZ3RoIC0gMV07XG4gIGludmFyaWFudChcbiAgICB0aGlzUm91dGUucm91dGUuaWQsXG4gICAgYCR7aG9va05hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcImlkXCJgXG4gICk7XG4gIHJldHVybiB0aGlzUm91dGUucm91dGUuaWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBuYXZpZ2F0aW9uLCBkZWZhdWx0aW5nIHRvIGFuIFwiaWRsZVwiIG5hdmlnYXRpb24gd2hlblxuICogbm8gbmF2aWdhdGlvbiBpcyBpbiBwcm9ncmVzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTmF2aWdhdGlvbigpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTmF2aWdhdGlvbik7XG4gIHJldHVybiBzdGF0ZS5uYXZpZ2F0aW9uO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByZXZhbGlkYXRlIGZ1bmN0aW9uIGZvciBtYW51YWxseSB0cmlnZ2VyaW5nIHJldmFsaWRhdGlvbiwgYXMgd2VsbFxuICogYXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgYW55IG1hbnVhbCByZXZhbGlkYXRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZXZhbGlkYXRvcigpIHtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlUmV2YWxpZGF0b3IpO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSZXZhbGlkYXRvcik7XG4gIHJldHVybiB7XG4gICAgcmV2YWxpZGF0ZTogZGF0YVJvdXRlckNvbnRleHQucm91dGVyLnJldmFsaWRhdGUsXG4gICAgc3RhdGU6IHN0YXRlLnJldmFsaWRhdGlvbixcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhY3RpdmUgcm91dGUgbWF0Y2hlcywgdXNlZnVsIGZvciBhY2Nlc3NpbmcgbG9hZGVyRGF0YSBmb3JcbiAqIHBhcmVudC9jaGlsZCByb3V0ZXMgb3IgdGhlIHJvdXRlIFwiaGFuZGxlXCIgcHJvcGVydHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hdGNoZXMoKSB7XG4gIGxldCB7IG1hdGNoZXMsIGxvYWRlckRhdGEgfSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcbiAgICBEYXRhUm91dGVyU3RhdGVIb29rLlVzZU1hdGNoZXNcbiAgKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT5cbiAgICAgIG1hdGNoZXMubWFwKChtYXRjaCkgPT4ge1xuICAgICAgICBsZXQgeyBwYXRobmFtZSwgcGFyYW1zIH0gPSBtYXRjaDtcbiAgICAgICAgLy8gTm90ZTogVGhpcyBzdHJ1Y3R1cmUgbWF0Y2hlcyB0aGF0IGNyZWF0ZWQgYnkgY3JlYXRlVXNlTWF0Y2hlc01hdGNoXG4gICAgICAgIC8vIGluIHRoZSBAcmVtaXgtcnVuL3JvdXRlciAsIHNvIGlmIHlvdSBjaGFuZ2UgdGhpcyBwbGVhc2UgYWxzbyBjaGFuZ2VcbiAgICAgICAgLy8gdGhhdCA6KSAgRXZlbnR1YWxseSB3ZSdsbCBEUlkgdGhpcyB1cFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBtYXRjaC5yb3V0ZS5pZCxcbiAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgZGF0YTogbG9hZGVyRGF0YVttYXRjaC5yb3V0ZS5pZF0gYXMgdW5rbm93bixcbiAgICAgICAgICBoYW5kbGU6IG1hdGNoLnJvdXRlLmhhbmRsZSBhcyB1bmtub3duLFxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgW21hdGNoZXMsIGxvYWRlckRhdGFdXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbG9hZGVyIGRhdGEgZm9yIHRoZSBuZWFyZXN0IGFuY2VzdG9yIFJvdXRlIGxvYWRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9hZGVyRGF0YSgpOiB1bmtub3duIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTG9hZGVyRGF0YSk7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VMb2FkZXJEYXRhKTtcblxuICBpZiAoc3RhdGUuZXJyb3JzICYmIHN0YXRlLmVycm9yc1tyb3V0ZUlkXSAhPSBudWxsKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGBZb3UgY2Fubm90IFxcYHVzZUxvYWRlckRhdGFcXGAgaW4gYW4gZXJyb3JFbGVtZW50IChyb3V0ZUlkOiAke3JvdXRlSWR9KWBcbiAgICApO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxvYWRlckRhdGFbcm91dGVJZF07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbG9hZGVyRGF0YSBmb3IgdGhlIGdpdmVuIHJvdXRlSWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdXRlTG9hZGVyRGF0YShyb3V0ZUlkOiBzdHJpbmcpOiB1bmtub3duIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVMb2FkZXJEYXRhKTtcbiAgcmV0dXJuIHN0YXRlLmxvYWRlckRhdGFbcm91dGVJZF07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYWN0aW9uIGRhdGEgZm9yIHRoZSBuZWFyZXN0IGFuY2VzdG9yIFJvdXRlIGFjdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQWN0aW9uRGF0YSgpOiB1bmtub3duIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlQWN0aW9uRGF0YSk7XG5cbiAgbGV0IHJvdXRlID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQocm91dGUsIGB1c2VBY3Rpb25EYXRhIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBSb3V0ZUNvbnRleHRgKTtcblxuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhzdGF0ZT8uYWN0aW9uRGF0YSB8fCB7fSlbMF07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmVhcmVzdCBhbmNlc3RvciBSb3V0ZSBlcnJvciwgd2hpY2ggY291bGQgYmUgYSBsb2FkZXIvYWN0aW9uXG4gKiBlcnJvciBvciBhIHJlbmRlciBlcnJvci4gIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgY2FsbGVkIGZyb20geW91clxuICogZXJyb3JFbGVtZW50IHRvIGRpc3BsYXkgYSBwcm9wZXIgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdXRlRXJyb3IoKTogdW5rbm93biB7XG4gIGxldCBlcnJvciA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVFcnJvckNvbnRleHQpO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSb3V0ZUVycm9yKTtcbiAgbGV0IHJvdXRlSWQgPSB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJvdXRlRXJyb3IpO1xuXG4gIC8vIElmIHRoaXMgd2FzIGEgcmVuZGVyIGVycm9yLCB3ZSBwdXQgaXQgaW4gYSBSb3V0ZUVycm9yIGNvbnRleHQgaW5zaWRlXG4gIC8vIG9mIFJlbmRlckVycm9yQm91bmRhcnlcbiAgaWYgKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlIGxvb2sgZm9yIGVycm9ycyBmcm9tIG91ciBkYXRhIHJvdXRlciBzdGF0ZVxuICByZXR1cm4gc3RhdGUuZXJyb3JzPy5bcm91dGVJZF07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaGFwcHktcGF0aCBkYXRhIGZyb20gdGhlIG5lYXJlc3QgYW5jZXN0b3IgPEF3YWl0IC8+IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VBc3luY1ZhbHVlKCk6IHVua25vd24ge1xuICBsZXQgdmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KEF3YWl0Q29udGV4dCk7XG4gIHJldHVybiB2YWx1ZT8uX2RhdGE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXJyb3IgZnJvbSB0aGUgbmVhcmVzdCBhbmNlc3RvciA8QXdhaXQgLz4gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFzeW5jRXJyb3IoKTogdW5rbm93biB7XG4gIGxldCB2YWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoQXdhaXRDb250ZXh0KTtcbiAgcmV0dXJuIHZhbHVlPy5fZXJyb3I7XG59XG5cbmxldCBibG9ja2VySWQgPSAwO1xuXG4vKipcbiAqIEFsbG93IHRoZSBhcHBsaWNhdGlvbiB0byBibG9jayBuYXZpZ2F0aW9ucyB3aXRoaW4gdGhlIFNQQSBhbmQgcHJlc2VudCB0aGVcbiAqIHVzZXIgYSBjb25maXJtYXRpb24gZGlhbG9nIHRvIGNvbmZpcm0gdGhlIG5hdmlnYXRpb24uICBNb3N0bHkgdXNlZCB0byBhdm9pZFxuICogdXNpbmcgaGFsZi1maWxsZWQgZm9ybSBkYXRhLiAgVGhpcyBkb2VzIG5vdCBoYW5kbGUgaGFyZC1yZWxvYWRzIG9yXG4gKiBjcm9zcy1vcmlnaW4gbmF2aWdhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VCbG9ja2VyKHNob3VsZEJsb2NrOiBib29sZWFuIHwgQmxvY2tlckZ1bmN0aW9uKTogQmxvY2tlciB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlQmxvY2tlcik7XG4gIGxldCBbYmxvY2tlcktleV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBTdHJpbmcoKytibG9ja2VySWQpKTtcblxuICBsZXQgYmxvY2tlckZ1bmN0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2s8QmxvY2tlckZ1bmN0aW9uPihcbiAgICAoYXJncykgPT4ge1xuICAgICAgcmV0dXJuIHR5cGVvZiBzaG91bGRCbG9jayA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gISFzaG91bGRCbG9jayhhcmdzKVxuICAgICAgICA6ICEhc2hvdWxkQmxvY2s7XG4gICAgfSxcbiAgICBbc2hvdWxkQmxvY2tdXG4gICk7XG5cbiAgbGV0IGJsb2NrZXIgPSByb3V0ZXIuZ2V0QmxvY2tlcihibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb24pO1xuXG4gIC8vIENsZWFudXAgb24gdW5tb3VudFxuICBSZWFjdC51c2VFZmZlY3QoXG4gICAgKCkgPT4gKCkgPT4gcm91dGVyLmRlbGV0ZUJsb2NrZXIoYmxvY2tlcktleSksXG4gICAgW3JvdXRlciwgYmxvY2tlcktleV1cbiAgKTtcblxuICByZXR1cm4gYmxvY2tlcjtcbn1cblxuY29uc3QgYWxyZWFkeVdhcm5lZDogUmVjb3JkPHN0cmluZywgYm9vbGVhbj4gPSB7fTtcblxuZnVuY3Rpb24gd2FybmluZ09uY2Uoa2V5OiBzdHJpbmcsIGNvbmQ6IGJvb2xlYW4sIG1lc3NhZ2U6IHN0cmluZykge1xuICBpZiAoIWNvbmQgJiYgIWFscmVhZHlXYXJuZWRba2V5XSkge1xuICAgIGFscmVhZHlXYXJuZWRba2V5XSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgbWVzc2FnZSk7XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUge1xuICBUcmFja2VkUHJvbWlzZSxcbiAgSW5pdGlhbEVudHJ5LFxuICBMb2NhdGlvbixcbiAgTWVtb3J5SGlzdG9yeSxcbiAgUm91dGVyIGFzIFJlbWl4Um91dGVyLFxuICBSb3V0ZXJTdGF0ZSxcbiAgVG8sXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuaW1wb3J0IHtcbiAgQWN0aW9uIGFzIE5hdmlnYXRpb25UeXBlLFxuICBBYm9ydGVkRGVmZXJyZWRFcnJvcixcbiAgY3JlYXRlTWVtb3J5SGlzdG9yeSxcbiAgaW52YXJpYW50LFxuICBwYXJzZVBhdGgsXG4gIHN0cmlwQmFzZW5hbWUsXG4gIHdhcm5pbmcsXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgYXMgdXNlU3luY0V4dGVybmFsU3RvcmVTaGltIH0gZnJvbSBcIi4vdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbVwiO1xuXG5pbXBvcnQgdHlwZSB7XG4gIERhdGFSb3V0ZU9iamVjdCxcbiAgSW5kZXhSb3V0ZU9iamVjdCxcbiAgUm91dGVNYXRjaCxcbiAgUm91dGVPYmplY3QsXG4gIE5hdmlnYXRvcixcbiAgTm9uSW5kZXhSb3V0ZU9iamVjdCxcbiAgUmVsYXRpdmVSb3V0aW5nVHlwZSxcbn0gZnJvbSBcIi4vY29udGV4dFwiO1xuaW1wb3J0IHtcbiAgTG9jYXRpb25Db250ZXh0LFxuICBOYXZpZ2F0aW9uQ29udGV4dCxcbiAgRGF0YVJvdXRlckNvbnRleHQsXG4gIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsXG4gIEF3YWl0Q29udGV4dCxcbn0gZnJvbSBcIi4vY29udGV4dFwiO1xuaW1wb3J0IHtcbiAgdXNlQXN5bmNWYWx1ZSxcbiAgdXNlSW5Sb3V0ZXJDb250ZXh0LFxuICB1c2VOYXZpZ2F0ZSxcbiAgdXNlT3V0bGV0LFxuICB1c2VSb3V0ZXMsXG4gIF9yZW5kZXJNYXRjaGVzLFxufSBmcm9tIFwiLi9ob29rc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlclByb3ZpZGVyUHJvcHMge1xuICBmYWxsYmFja0VsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIHJvdXRlcjogUmVtaXhSb3V0ZXI7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZW1peCBSb3V0ZXIgaW5zdGFuY2UsIHJlbmRlciB0aGUgYXBwcm9wcmlhdGUgVUlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlclByb3ZpZGVyKHtcbiAgZmFsbGJhY2tFbGVtZW50LFxuICByb3V0ZXIsXG59OiBSb3V0ZXJQcm92aWRlclByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgLy8gU3luYyByb3V0ZXIgc3RhdGUgdG8gb3VyIGNvbXBvbmVudCBzdGF0ZSB0byBmb3JjZSByZS1yZW5kZXJzXG4gIGxldCBzdGF0ZTogUm91dGVyU3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW0oXG4gICAgcm91dGVyLnN1YnNjcmliZSxcbiAgICAoKSA9PiByb3V0ZXIuc3RhdGUsXG4gICAgLy8gV2UgaGF2ZSB0byBwcm92aWRlIHRoaXMgc28gUmVhY3RAMTggZG9lc24ndCBjb21wbGFpbiBkdXJpbmcgaHlkcmF0aW9uLFxuICAgIC8vIGJ1dCB3ZSBwYXNzIG91ciBzZXJpYWxpemVkIGh5ZHJhdGlvbiBkYXRhIGludG8gdGhlIHJvdXRlciBzbyBzdGF0ZSBoZXJlXG4gICAgLy8gaXMgYWxyZWFkeSBzeW5jZWQgd2l0aCB3aGF0IHRoZSBzZXJ2ZXIgc2F3XG4gICAgKCkgPT4gcm91dGVyLnN0YXRlXG4gICk7XG5cbiAgbGV0IG5hdmlnYXRvciA9IFJlYWN0LnVzZU1lbW8oKCk6IE5hdmlnYXRvciA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZUhyZWY6IHJvdXRlci5jcmVhdGVIcmVmLFxuICAgICAgZW5jb2RlTG9jYXRpb246IHJvdXRlci5lbmNvZGVMb2NhdGlvbixcbiAgICAgIGdvOiAobikgPT4gcm91dGVyLm5hdmlnYXRlKG4pLFxuICAgICAgcHVzaDogKHRvLCBzdGF0ZSwgb3B0cykgPT5cbiAgICAgICAgcm91dGVyLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzPy5wcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIH0pLFxuICAgICAgcmVwbGFjZTogKHRvLCBzdGF0ZSwgb3B0cykgPT5cbiAgICAgICAgcm91dGVyLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHM/LnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgfSksXG4gICAgfTtcbiAgfSwgW3JvdXRlcl0pO1xuXG4gIGxldCBiYXNlbmFtZSA9IHJvdXRlci5iYXNlbmFtZSB8fCBcIi9cIjtcblxuICAvLyBUaGUgZnJhZ21lbnQgYW5kIHtudWxsfSBoZXJlIGFyZSBpbXBvcnRhbnQhICBXZSBuZWVkIHRoZW0gdG8ga2VlcCBSZWFjdCAxOCdzXG4gIC8vIHVzZUlkIGhhcHB5IHdoZW4gd2UgYXJlIHNlcnZlci1yZW5kZXJpbmcgc2luY2Ugd2UgbWF5IGhhdmUgYSA8c2NyaXB0PiBoZXJlXG4gIC8vIGNvbnRhaW5pbmcgdGhlIGh5ZHJhdGVkIHNlcnZlci1zaWRlIHN0YXRpY0NvbnRleHQgKGZyb20gU3RhdGljUm91dGVyUHJvdmlkZXIpLlxuICAvLyB1c2VJZCByZWxpZXMgb24gdGhlIGNvbXBvbmVudCB0cmVlIHN0cnVjdHVyZSB0byBnZW5lcmF0ZSBkZXRlcm1pbmlzdGljIGlkJ3NcbiAgLy8gc28gd2UgbmVlZCB0byBlbnN1cmUgaXQgcmVtYWlucyB0aGUgc2FtZSBvbiB0aGUgY2xpZW50IGV2ZW4gdGhvdWdoXG4gIC8vIHdlIGRvbid0IG5lZWQgdGhlIDxzY3JpcHQ+IHRhZ1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8RGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgdmFsdWU9e3tcbiAgICAgICAgICByb3V0ZXIsXG4gICAgICAgICAgbmF2aWdhdG9yLFxuICAgICAgICAgIHN0YXRpYzogZmFsc2UsXG4gICAgICAgICAgLy8gRG8gd2UgbmVlZCB0aGlzP1xuICAgICAgICAgIGJhc2VuYW1lLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICA8RGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17c3RhdGV9PlxuICAgICAgICAgIDxSb3V0ZXJcbiAgICAgICAgICAgIGJhc2VuYW1lPXtyb3V0ZXIuYmFzZW5hbWV9XG4gICAgICAgICAgICBsb2NhdGlvbj17cm91dGVyLnN0YXRlLmxvY2F0aW9ufVxuICAgICAgICAgICAgbmF2aWdhdGlvblR5cGU9e3JvdXRlci5zdGF0ZS5oaXN0b3J5QWN0aW9ufVxuICAgICAgICAgICAgbmF2aWdhdG9yPXtuYXZpZ2F0b3J9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge3JvdXRlci5zdGF0ZS5pbml0aWFsaXplZCA/IDxSb3V0ZXMgLz4gOiBmYWxsYmFja0VsZW1lbnR9XG4gICAgICAgICAgPC9Sb3V0ZXI+XG4gICAgICAgIDwvRGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgIDwvRGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgICB7bnVsbH1cbiAgICA8Lz5cbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZW1vcnlSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgaW5pdGlhbEVudHJpZXM/OiBJbml0aWFsRW50cnlbXTtcbiAgaW5pdGlhbEluZGV4PzogbnVtYmVyO1xufVxuXG4vKipcbiAqIEEgPFJvdXRlcj4gdGhhdCBzdG9yZXMgYWxsIGVudHJpZXMgaW4gbWVtb3J5LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vcm91dGVyLWNvbXBvbmVudHMvbWVtb3J5LXJvdXRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gTWVtb3J5Um91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICBpbml0aWFsRW50cmllcyxcbiAgaW5pdGlhbEluZGV4LFxufTogTWVtb3J5Um91dGVyUHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZjxNZW1vcnlIaXN0b3J5PigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5KHtcbiAgICAgIGluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEluZGV4LFxuICAgICAgdjVDb21wYXQ6IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sXG4gIH0pO1xuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgIC8+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVQcm9wcyB7XG4gIHRvOiBUbztcbiAgcmVwbGFjZT86IGJvb2xlYW47XG4gIHN0YXRlPzogYW55O1xuICByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGU7XG59XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBOb3RlOiBUaGlzIEFQSSBpcyBtb3N0bHkgdXNlZnVsIGluIFJlYWN0LkNvbXBvbmVudCBzdWJjbGFzc2VzIHRoYXQgYXJlIG5vdFxuICogYWJsZSB0byB1c2UgaG9va3MuIEluIGZ1bmN0aW9uYWwgY29tcG9uZW50cywgd2UgcmVjb21tZW5kIHlvdSB1c2UgdGhlXG4gKiBgdXNlTmF2aWdhdGVgIGhvb2sgaW5zdGVhZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvbmF2aWdhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE5hdmlnYXRlKHtcbiAgdG8sXG4gIHJlcGxhY2UsXG4gIHN0YXRlLFxuICByZWxhdGl2ZSxcbn06IE5hdmlnYXRlUHJvcHMpOiBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mXG4gICAgLy8gdGhlIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgPE5hdmlnYXRlPiBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICB3YXJuaW5nKFxuICAgICFSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KS5zdGF0aWMsXG4gICAgYDxOYXZpZ2F0ZT4gbXVzdCBub3QgYmUgdXNlZCBvbiB0aGUgaW5pdGlhbCByZW5kZXIgaW4gYSA8U3RhdGljUm91dGVyPi4gYCArXG4gICAgICBgVGhpcyBpcyBhIG5vLW9wLCBidXQgeW91IHNob3VsZCBtb2RpZnkgeW91ciBjb2RlIHNvIHRoZSA8TmF2aWdhdGU+IGlzIGAgK1xuICAgICAgYG9ubHkgZXZlciByZW5kZXJlZCBpbiByZXNwb25zZSB0byBzb21lIHVzZXIgaW50ZXJhY3Rpb24gb3Igc3RhdGUgY2hhbmdlLmBcbiAgKTtcblxuICBsZXQgZGF0YVJvdXRlclN0YXRlID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIEF2b2lkIGtpY2tpbmcgb2ZmIG11bHRpcGxlIG5hdmlnYXRpb25zIGlmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYVxuICAgIC8vIGRhdGEtcm91dGVyIG5hdmlnYXRpb24sIHNpbmNlIGNvbXBvbmVudHMgZ2V0IHJlLXJlbmRlcmVkIHdoZW4gd2UgZW50ZXJcbiAgICAvLyBhIHN1Ym1pdHRpbmcvbG9hZGluZyBzdGF0ZVxuICAgIGlmIChkYXRhUm91dGVyU3RhdGUgJiYgZGF0YVJvdXRlclN0YXRlLm5hdmlnYXRpb24uc3RhdGUgIT09IFwiaWRsZVwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG5hdmlnYXRlKHRvLCB7IHJlcGxhY2UsIHN0YXRlLCByZWxhdGl2ZSB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3V0bGV0UHJvcHMge1xuICBjb250ZXh0PzogdW5rbm93bjtcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBjaGlsZCByb3V0ZSdzIGVsZW1lbnQsIGlmIHRoZXJlIGlzIG9uZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvb3V0bGV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBPdXRsZXQocHJvcHM6IE91dGxldFByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIHJldHVybiB1c2VPdXRsZXQocHJvcHMuY29udGV4dCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aFJvdXRlUHJvcHMge1xuICBjYXNlU2Vuc2l0aXZlPzogTm9uSW5kZXhSb3V0ZU9iamVjdFtcImNhc2VTZW5zaXRpdmVcIl07XG4gIHBhdGg/OiBOb25JbmRleFJvdXRlT2JqZWN0W1wicGF0aFwiXTtcbiAgaWQ/OiBOb25JbmRleFJvdXRlT2JqZWN0W1wiaWRcIl07XG4gIGxvYWRlcj86IE5vbkluZGV4Um91dGVPYmplY3RbXCJsb2FkZXJcIl07XG4gIGFjdGlvbj86IE5vbkluZGV4Um91dGVPYmplY3RbXCJhY3Rpb25cIl07XG4gIGhhc0Vycm9yQm91bmRhcnk/OiBOb25JbmRleFJvdXRlT2JqZWN0W1wiaGFzRXJyb3JCb3VuZGFyeVwiXTtcbiAgc2hvdWxkUmV2YWxpZGF0ZT86IE5vbkluZGV4Um91dGVPYmplY3RbXCJzaG91bGRSZXZhbGlkYXRlXCJdO1xuICBoYW5kbGU/OiBOb25JbmRleFJvdXRlT2JqZWN0W1wiaGFuZGxlXCJdO1xuICBpbmRleD86IGZhbHNlO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG4gIGVycm9yRWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGF5b3V0Um91dGVQcm9wcyBleHRlbmRzIFBhdGhSb3V0ZVByb3BzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5kZXhSb3V0ZVByb3BzIHtcbiAgY2FzZVNlbnNpdGl2ZT86IEluZGV4Um91dGVPYmplY3RbXCJjYXNlU2Vuc2l0aXZlXCJdO1xuICBwYXRoPzogSW5kZXhSb3V0ZU9iamVjdFtcInBhdGhcIl07XG4gIGlkPzogSW5kZXhSb3V0ZU9iamVjdFtcImlkXCJdO1xuICBsb2FkZXI/OiBJbmRleFJvdXRlT2JqZWN0W1wibG9hZGVyXCJdO1xuICBhY3Rpb24/OiBJbmRleFJvdXRlT2JqZWN0W1wiYWN0aW9uXCJdO1xuICBoYXNFcnJvckJvdW5kYXJ5PzogSW5kZXhSb3V0ZU9iamVjdFtcImhhc0Vycm9yQm91bmRhcnlcIl07XG4gIHNob3VsZFJldmFsaWRhdGU/OiBJbmRleFJvdXRlT2JqZWN0W1wic2hvdWxkUmV2YWxpZGF0ZVwiXTtcbiAgaGFuZGxlPzogSW5kZXhSb3V0ZU9iamVjdFtcImhhbmRsZVwiXTtcbiAgaW5kZXg6IHRydWU7XG4gIGNoaWxkcmVuPzogdW5kZWZpbmVkO1xuICBlbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbiAgZXJyb3JFbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbn1cblxuZXhwb3J0IHR5cGUgUm91dGVQcm9wcyA9IFBhdGhSb3V0ZVByb3BzIHwgTGF5b3V0Um91dGVQcm9wcyB8IEluZGV4Um91dGVQcm9wcztcblxuLyoqXG4gKiBEZWNsYXJlcyBhbiBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkIGF0IGEgY2VydGFpbiBVUkwgcGF0aC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvcm91dGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlKF9wcm9wczogUm91dGVQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBpbnZhcmlhbnQoXG4gICAgZmFsc2UsXG4gICAgYEEgPFJvdXRlPiBpcyBvbmx5IGV2ZXIgdG8gYmUgdXNlZCBhcyB0aGUgY2hpbGQgb2YgPFJvdXRlcz4gZWxlbWVudCwgYCArXG4gICAgICBgbmV2ZXIgcmVuZGVyZWQgZGlyZWN0bHkuIFBsZWFzZSB3cmFwIHlvdXIgPFJvdXRlPiBpbiBhIDxSb3V0ZXM+LmBcbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgbG9jYXRpb246IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nO1xuICBuYXZpZ2F0aW9uVHlwZT86IE5hdmlnYXRpb25UeXBlO1xuICBuYXZpZ2F0b3I6IE5hdmlnYXRvcjtcbiAgc3RhdGljPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBsb2NhdGlvbiBjb250ZXh0IGZvciB0aGUgcmVzdCBvZiB0aGUgYXBwLlxuICpcbiAqIE5vdGU6IFlvdSB1c3VhbGx5IHdvbid0IHJlbmRlciBhIDxSb3V0ZXI+IGRpcmVjdGx5LiBJbnN0ZWFkLCB5b3UnbGwgcmVuZGVyIGFcbiAqIHJvdXRlciB0aGF0IGlzIG1vcmUgc3BlY2lmaWMgdG8geW91ciBlbnZpcm9ubWVudCBzdWNoIGFzIGEgPEJyb3dzZXJSb3V0ZXI+XG4gKiBpbiB3ZWIgYnJvd3NlcnMgb3IgYSA8U3RhdGljUm91dGVyPiBmb3Igc2VydmVyIHJlbmRlcmluZy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlci1jb21wb25lbnRzL3JvdXRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gUm91dGVyKHtcbiAgYmFzZW5hbWU6IGJhc2VuYW1lUHJvcCA9IFwiL1wiLFxuICBjaGlsZHJlbiA9IG51bGwsXG4gIGxvY2F0aW9uOiBsb2NhdGlvblByb3AsXG4gIG5hdmlnYXRpb25UeXBlID0gTmF2aWdhdGlvblR5cGUuUG9wLFxuICBuYXZpZ2F0b3IsXG4gIHN0YXRpYzogc3RhdGljUHJvcCA9IGZhbHNlLFxufTogUm91dGVyUHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgICF1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICBgWW91IGNhbm5vdCByZW5kZXIgYSA8Um91dGVyPiBpbnNpZGUgYW5vdGhlciA8Um91dGVyPi5gICtcbiAgICAgIGAgWW91IHNob3VsZCBuZXZlciBoYXZlIG1vcmUgdGhhbiBvbmUgaW4geW91ciBhcHAuYFxuICApO1xuXG4gIC8vIFByZXNlcnZlIHRyYWlsaW5nIHNsYXNoZXMgb24gYmFzZW5hbWUsIHNvIHdlIGNhbiBsZXQgdGhlIHVzZXIgY29udHJvbFxuICAvLyB0aGUgZW5mb3JjZW1lbnQgb2YgdHJhaWxpbmcgc2xhc2hlcyB0aHJvdWdob3V0IHRoZSBhcHBcbiAgbGV0IGJhc2VuYW1lID0gYmFzZW5hbWVQcm9wLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpO1xuICBsZXQgbmF2aWdhdGlvbkNvbnRleHQgPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+ICh7IGJhc2VuYW1lLCBuYXZpZ2F0b3IsIHN0YXRpYzogc3RhdGljUHJvcCB9KSxcbiAgICBbYmFzZW5hbWUsIG5hdmlnYXRvciwgc3RhdGljUHJvcF1cbiAgKTtcblxuICBpZiAodHlwZW9mIGxvY2F0aW9uUHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxvY2F0aW9uUHJvcCA9IHBhcnNlUGF0aChsb2NhdGlvblByb3ApO1xuICB9XG5cbiAgbGV0IHtcbiAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCIsXG4gICAgc3RhdGUgPSBudWxsLFxuICAgIGtleSA9IFwiZGVmYXVsdFwiLFxuICB9ID0gbG9jYXRpb25Qcm9wO1xuXG4gIGxldCBsb2NhdGlvbiA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCB0cmFpbGluZ1BhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShwYXRobmFtZSwgYmFzZW5hbWUpO1xuXG4gICAgaWYgKHRyYWlsaW5nUGF0aG5hbWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGhuYW1lOiB0cmFpbGluZ1BhdGhuYW1lLFxuICAgICAgc2VhcmNoLFxuICAgICAgaGFzaCxcbiAgICAgIHN0YXRlLFxuICAgICAga2V5LFxuICAgIH07XG4gIH0sIFtiYXNlbmFtZSwgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCwgc3RhdGUsIGtleV0pO1xuXG4gIHdhcm5pbmcoXG4gICAgbG9jYXRpb24gIT0gbnVsbCxcbiAgICBgPFJvdXRlciBiYXNlbmFtZT1cIiR7YmFzZW5hbWV9XCI+IGlzIG5vdCBhYmxlIHRvIG1hdGNoIHRoZSBVUkwgYCArXG4gICAgICBgXCIke3BhdGhuYW1lfSR7c2VhcmNofSR7aGFzaH1cIiBiZWNhdXNlIGl0IGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIGAgK1xuICAgICAgYGJhc2VuYW1lLCBzbyB0aGUgPFJvdXRlcj4gd29uJ3QgcmVuZGVyIGFueXRoaW5nLmBcbiAgKTtcblxuICBpZiAobG9jYXRpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8TmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e25hdmlnYXRpb25Db250ZXh0fT5cbiAgICAgIDxMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgICB2YWx1ZT17eyBsb2NhdGlvbiwgbmF2aWdhdGlvblR5cGUgfX1cbiAgICAgIC8+XG4gICAgPC9OYXZpZ2F0aW9uQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXNQcm9wcyB7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBsb2NhdGlvbj86IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciBhIG5lc3RlZCB0cmVlIG9mIDxSb3V0ZT4gZWxlbWVudHMgdGhhdCByZW5kZXJzIHRoZSBicmFuY2hcbiAqIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vY29tcG9uZW50cy9yb3V0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlcyh7XG4gIGNoaWxkcmVuLFxuICBsb2NhdGlvbixcbn06IFJvdXRlc1Byb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICAvLyBXaGVuIGluIGEgRGF0YVJvdXRlckNvbnRleHQgX3dpdGhvdXRfIGNoaWxkcmVuLCB3ZSB1c2UgdGhlIHJvdXRlciByb3V0ZXNcbiAgLy8gZGlyZWN0bHkuICBJZiB3ZSBoYXZlIGNoaWxkcmVuLCB0aGVuIHdlJ3JlIGluIGEgZGVzY2VuZGFudCB0cmVlIGFuZCB3ZVxuICAvLyBuZWVkIHRvIHVzZSBjaGlsZCByb3V0ZXMuXG4gIGxldCByb3V0ZXMgPVxuICAgIGRhdGFSb3V0ZXJDb250ZXh0ICYmICFjaGlsZHJlblxuICAgICAgPyAoZGF0YVJvdXRlckNvbnRleHQucm91dGVyLnJvdXRlcyBhcyBEYXRhUm91dGVPYmplY3RbXSlcbiAgICAgIDogY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgcmV0dXJuIHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBd2FpdFJlc29sdmVSZW5kZXJGdW5jdGlvbiB7XG4gIChkYXRhOiBBd2FpdGVkPGFueT4pOiBSZWFjdC5SZWFjdE5vZGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXdhaXRQcm9wcyB7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfCBBd2FpdFJlc29sdmVSZW5kZXJGdW5jdGlvbjtcbiAgZXJyb3JFbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlO1xuICByZXNvbHZlOiBUcmFja2VkUHJvbWlzZSB8IGFueTtcbn1cblxuLyoqXG4gKiBDb21wb25lbnQgdG8gdXNlIGZvciByZW5kZXJpbmcgbGF6aWx5IGxvYWRlZCBkYXRhIGZyb20gcmV0dXJuaW5nIGRlZmVyKClcbiAqIGluIGEgbG9hZGVyIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBBd2FpdCh7IGNoaWxkcmVuLCBlcnJvckVsZW1lbnQsIHJlc29sdmUgfTogQXdhaXRQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxBd2FpdEVycm9yQm91bmRhcnkgcmVzb2x2ZT17cmVzb2x2ZX0gZXJyb3JFbGVtZW50PXtlcnJvckVsZW1lbnR9PlxuICAgICAgPFJlc29sdmVBd2FpdD57Y2hpbGRyZW59PC9SZXNvbHZlQXdhaXQ+XG4gICAgPC9Bd2FpdEVycm9yQm91bmRhcnk+XG4gICk7XG59XG5cbnR5cGUgQXdhaXRFcnJvckJvdW5kYXJ5UHJvcHMgPSBSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjx7XG4gIGVycm9yRWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgcmVzb2x2ZTogVHJhY2tlZFByb21pc2UgfCBhbnk7XG59PjtcblxudHlwZSBBd2FpdEVycm9yQm91bmRhcnlTdGF0ZSA9IHtcbiAgZXJyb3I6IGFueTtcbn07XG5cbmVudW0gQXdhaXRSZW5kZXJTdGF0dXMge1xuICBwZW5kaW5nLFxuICBzdWNjZXNzLFxuICBlcnJvcixcbn1cblxuY29uc3QgbmV2ZXJTZXR0bGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKCgpID0+IHt9KTtcblxuY2xhc3MgQXdhaXRFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFxuICBBd2FpdEVycm9yQm91bmRhcnlQcm9wcyxcbiAgQXdhaXRFcnJvckJvdW5kYXJ5U3RhdGVcbj4ge1xuICBjb25zdHJ1Y3Rvcihwcm9wczogQXdhaXRFcnJvckJvdW5kYXJ5UHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHsgZXJyb3I6IG51bGwgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3I6IGFueSkge1xuICAgIHJldHVybiB7IGVycm9yIH07XG4gIH1cblxuICBjb21wb25lbnREaWRDYXRjaChlcnJvcjogYW55LCBlcnJvckluZm86IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIjxBd2FpdD4gY2F1Z2h0IHRoZSBmb2xsb3dpbmcgZXJyb3IgZHVyaW5nIHJlbmRlclwiLFxuICAgICAgZXJyb3IsXG4gICAgICBlcnJvckluZm9cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IGNoaWxkcmVuLCBlcnJvckVsZW1lbnQsIHJlc29sdmUgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBsZXQgcHJvbWlzZTogVHJhY2tlZFByb21pc2UgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgc3RhdHVzOiBBd2FpdFJlbmRlclN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLnBlbmRpbmc7XG5cbiAgICBpZiAoIShyZXNvbHZlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgIC8vIERpZG4ndCBnZXQgYSBwcm9taXNlIC0gcHJvdmlkZSBhcyBhIHJlc29sdmVkIHByb21pc2VcbiAgICAgIHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLnN1Y2Nlc3M7XG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7IGdldDogKCkgPT4gdHJ1ZSB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9kYXRhXCIsIHsgZ2V0OiAoKSA9PiByZXNvbHZlIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgLy8gQ2F1Z2h0IGEgcmVuZGVyIGVycm9yLCBwcm92aWRlIGl0IGFzIGEgcmVqZWN0ZWQgcHJvbWlzZVxuICAgICAgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3I7XG4gICAgICBsZXQgcmVuZGVyRXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KCkuY2F0Y2goKCkgPT4ge30pOyAvLyBBdm9pZCB1bmhhbmRsZWQgcmVqZWN0aW9uIHdhcm5pbmdzXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7IGdldDogKCkgPT4gdHJ1ZSB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7IGdldDogKCkgPT4gcmVuZGVyRXJyb3IgfSk7XG4gICAgfSBlbHNlIGlmICgocmVzb2x2ZSBhcyBUcmFja2VkUHJvbWlzZSkuX3RyYWNrZWQpIHtcbiAgICAgIC8vIEFscmVhZHkgdHJhY2tlZCBwcm9taXNlIC0gY2hlY2sgY29udGVudHNcbiAgICAgIHByb21pc2UgPSByZXNvbHZlO1xuICAgICAgc3RhdHVzID1cbiAgICAgICAgcHJvbWlzZS5fZXJyb3IgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3JcbiAgICAgICAgICA6IHByb21pc2UuX2RhdGEgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gQXdhaXRSZW5kZXJTdGF0dXMuc3VjY2Vzc1xuICAgICAgICAgIDogQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmF3ICh1bnRyYWNrZWQpIHByb21pc2UgLSB0cmFjayBpdFxuICAgICAgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl90cmFja2VkXCIsIHsgZ2V0OiAoKSA9PiB0cnVlIH0pO1xuICAgICAgcHJvbWlzZSA9IHJlc29sdmUudGhlbihcbiAgICAgICAgKGRhdGE6IGFueSkgPT5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfZGF0YVwiLCB7IGdldDogKCkgPT4gZGF0YSB9KSxcbiAgICAgICAgKGVycm9yOiBhbnkpID0+XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX2Vycm9yXCIsIHsgZ2V0OiAoKSA9PiBlcnJvciB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBzdGF0dXMgPT09IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yICYmXG4gICAgICBwcm9taXNlLl9lcnJvciBpbnN0YW5jZW9mIEFib3J0ZWREZWZlcnJlZEVycm9yXG4gICAgKSB7XG4gICAgICAvLyBGcmVlemUgdGhlIFVJIGJ5IHRocm93aW5nIGEgbmV2ZXIgcmVzb2x2ZWQgcHJvbWlzZVxuICAgICAgdGhyb3cgbmV2ZXJTZXR0bGVkUHJvbWlzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvciAmJiAhZXJyb3JFbGVtZW50KSB7XG4gICAgICAvLyBObyBlcnJvckVsZW1lbnQsIHRocm93IHRvIHRoZSBuZWFyZXN0IHJvdXRlLWxldmVsIGVycm9yIGJvdW5kYXJ5XG4gICAgICB0aHJvdyBwcm9taXNlLl9lcnJvcjtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvcikge1xuICAgICAgLy8gUmVuZGVyIHZpYSBvdXIgZXJyb3JFbGVtZW50XG4gICAgICByZXR1cm4gPEF3YWl0Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17cHJvbWlzZX0gY2hpbGRyZW49e2Vycm9yRWxlbWVudH0gLz47XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuc3VjY2Vzcykge1xuICAgICAgLy8gUmVuZGVyIGNoaWxkcmVuIHdpdGggcmVzb2x2ZWQgdmFsdWVcbiAgICAgIHJldHVybiA8QXdhaXRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtwcm9taXNlfSBjaGlsZHJlbj17Y2hpbGRyZW59IC8+O1xuICAgIH1cblxuICAgIC8vIFRocm93IHRvIHRoZSBzdXNwZW5zZSBib3VuZGFyeVxuICAgIHRocm93IHByb21pc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogSW5kaXJlY3Rpb24gdG8gbGV2ZXJhZ2UgdXNlQXN5bmNWYWx1ZSBmb3IgYSByZW5kZXItcHJvcCBBUEkgb24gPEF3YWl0PlxuICovXG5mdW5jdGlvbiBSZXNvbHZlQXdhaXQoe1xuICBjaGlsZHJlbixcbn06IHtcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB8IEF3YWl0UmVzb2x2ZVJlbmRlckZ1bmN0aW9uO1xufSkge1xuICBsZXQgZGF0YSA9IHVzZUFzeW5jVmFsdWUoKTtcbiAgbGV0IHRvUmVuZGVyID0gdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbihkYXRhKSA6IGNoaWxkcmVuO1xuICByZXR1cm4gPD57dG9SZW5kZXJ9PC8+O1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBVVElMU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENyZWF0ZXMgYSByb3V0ZSBjb25maWcgZnJvbSBhIFJlYWN0IFwiY2hpbGRyZW5cIiBvYmplY3QsIHdoaWNoIGlzIHVzdWFsbHlcbiAqIGVpdGhlciBhIGA8Um91dGU+YCBlbGVtZW50IG9yIGFuIGFycmF5IG9mIHRoZW0uIFVzZWQgaW50ZXJuYWxseSBieVxuICogYDxSb3V0ZXM+YCB0byBjcmVhdGUgYSByb3V0ZSBjb25maWcgZnJvbSBpdHMgY2hpbGRyZW4uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9jcmVhdGUtcm91dGVzLWZyb20tY2hpbGRyZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSxcbiAgcGFyZW50UGF0aDogbnVtYmVyW10gPSBbXVxuKTogUm91dGVPYmplY3RbXSB7XG4gIGxldCByb3V0ZXM6IFJvdXRlT2JqZWN0W10gPSBbXTtcblxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAvLyBJZ25vcmUgbm9uLWVsZW1lbnRzLiBUaGlzIGFsbG93cyBwZW9wbGUgdG8gbW9yZSBlYXNpbHkgaW5saW5lXG4gICAgICAvLyBjb25kaXRpb25hbHMgaW4gdGhlaXIgcm91dGUgY29uZmlnLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJlYWN0LkZyYWdtZW50KSB7XG4gICAgICAvLyBUcmFuc3BhcmVudGx5IHN1cHBvcnQgUmVhY3QuRnJhZ21lbnQgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgIHJvdXRlcy5wdXNoLmFwcGx5KFxuICAgICAgICByb3V0ZXMsXG4gICAgICAgIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihlbGVtZW50LnByb3BzLmNoaWxkcmVuLCBwYXJlbnRQYXRoKVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnZhcmlhbnQoXG4gICAgICBlbGVtZW50LnR5cGUgPT09IFJvdXRlLFxuICAgICAgYFske1xuICAgICAgICB0eXBlb2YgZWxlbWVudC50eXBlID09PSBcInN0cmluZ1wiID8gZWxlbWVudC50eXBlIDogZWxlbWVudC50eXBlLm5hbWVcbiAgICAgIH1dIGlzIG5vdCBhIDxSb3V0ZT4gY29tcG9uZW50LiBBbGwgY29tcG9uZW50IGNoaWxkcmVuIG9mIDxSb3V0ZXM+IG11c3QgYmUgYSA8Um91dGU+IG9yIDxSZWFjdC5GcmFnbWVudD5gXG4gICAgKTtcblxuICAgIGludmFyaWFudChcbiAgICAgICFlbGVtZW50LnByb3BzLmluZGV4IHx8ICFlbGVtZW50LnByb3BzLmNoaWxkcmVuLFxuICAgICAgXCJBbiBpbmRleCByb3V0ZSBjYW5ub3QgaGF2ZSBjaGlsZCByb3V0ZXMuXCJcbiAgICApO1xuXG4gICAgbGV0IHRyZWVQYXRoID0gWy4uLnBhcmVudFBhdGgsIGluZGV4XTtcbiAgICBsZXQgcm91dGU6IFJvdXRlT2JqZWN0ID0ge1xuICAgICAgaWQ6IGVsZW1lbnQucHJvcHMuaWQgfHwgdHJlZVBhdGguam9pbihcIi1cIiksXG4gICAgICBjYXNlU2Vuc2l0aXZlOiBlbGVtZW50LnByb3BzLmNhc2VTZW5zaXRpdmUsXG4gICAgICBlbGVtZW50OiBlbGVtZW50LnByb3BzLmVsZW1lbnQsXG4gICAgICBpbmRleDogZWxlbWVudC5wcm9wcy5pbmRleCxcbiAgICAgIHBhdGg6IGVsZW1lbnQucHJvcHMucGF0aCxcbiAgICAgIGxvYWRlcjogZWxlbWVudC5wcm9wcy5sb2FkZXIsXG4gICAgICBhY3Rpb246IGVsZW1lbnQucHJvcHMuYWN0aW9uLFxuICAgICAgZXJyb3JFbGVtZW50OiBlbGVtZW50LnByb3BzLmVycm9yRWxlbWVudCxcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGVsZW1lbnQucHJvcHMuZXJyb3JFbGVtZW50ICE9IG51bGwsXG4gICAgICBzaG91bGRSZXZhbGlkYXRlOiBlbGVtZW50LnByb3BzLnNob3VsZFJldmFsaWRhdGUsXG4gICAgICBoYW5kbGU6IGVsZW1lbnQucHJvcHMuaGFuZGxlLFxuICAgIH07XG5cbiAgICBpZiAoZWxlbWVudC5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgcm91dGUuY2hpbGRyZW4gPSBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oXG4gICAgICAgIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIHRyZWVQYXRoXG4gICAgICApO1xuICAgIH1cblxuICAgIHJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJvdXRlcztcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSByZXN1bHQgb2YgYG1hdGNoUm91dGVzKClgIGludG8gYSBSZWFjdCBlbGVtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTWF0Y2hlcyhcbiAgbWF0Y2hlczogUm91dGVNYXRjaFtdIHwgbnVsbFxuKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIHJldHVybiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogV2FsayB0aGUgcm91dGUgdHJlZSBhbmQgYWRkIGhhc0Vycm9yQm91bmRhcnkgaWYgaXQncyBub3QgcHJvdmlkZWQsIHNvIHRoYXRcbiAqIHVzZXJzIHByb3ZpZGluZyBtYW51YWwgcm91dGUgYXJyYXlzIGNhbiBqdXN0IHNwZWNpZnkgZXJyb3JFbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmhhbmNlTWFudWFsUm91dGVPYmplY3RzKFxuICByb3V0ZXM6IFJvdXRlT2JqZWN0W11cbik6IFJvdXRlT2JqZWN0W10ge1xuICByZXR1cm4gcm91dGVzLm1hcCgocm91dGUpID0+IHtcbiAgICBsZXQgcm91dGVDbG9uZSA9IHsgLi4ucm91dGUgfTtcbiAgICBpZiAocm91dGVDbG9uZS5oYXNFcnJvckJvdW5kYXJ5ID09IG51bGwpIHtcbiAgICAgIHJvdXRlQ2xvbmUuaGFzRXJyb3JCb3VuZGFyeSA9IHJvdXRlQ2xvbmUuZXJyb3JFbGVtZW50ICE9IG51bGw7XG4gICAgfVxuICAgIGlmIChyb3V0ZUNsb25lLmNoaWxkcmVuKSB7XG4gICAgICByb3V0ZUNsb25lLmNoaWxkcmVuID0gZW5oYW5jZU1hbnVhbFJvdXRlT2JqZWN0cyhyb3V0ZUNsb25lLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvdXRlQ2xvbmU7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHR5cGUge1xuICBBY3Rpb25GdW5jdGlvbixcbiAgQWN0aW9uRnVuY3Rpb25BcmdzLFxuICBCbG9ja2VyLFxuICBCbG9ja2VyRnVuY3Rpb24sXG4gIEZldGNoZXIsXG4gIEh5ZHJhdGlvblN0YXRlLFxuICBKc29uRnVuY3Rpb24sXG4gIExvYWRlckZ1bmN0aW9uLFxuICBMb2FkZXJGdW5jdGlvbkFyZ3MsXG4gIExvY2F0aW9uLFxuICBOYXZpZ2F0aW9uLFxuICBQYXJhbXMsXG4gIFBhcmFtUGFyc2VLZXksXG4gIFBhdGgsXG4gIFBhdGhNYXRjaCxcbiAgUGF0aFBhdHRlcm4sXG4gIFJlZGlyZWN0RnVuY3Rpb24sXG4gIFJvdXRlciBhcyBSZW1peFJvdXRlcixcbiAgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uLFxuICBUbyxcbiAgSW5pdGlhbEVudHJ5LFxufSBmcm9tIFwiQHJlbWl4LXJ1bi9yb3V0ZXJcIjtcbmltcG9ydCB7XG4gIEFib3J0ZWREZWZlcnJlZEVycm9yLFxuICBBY3Rpb24gYXMgTmF2aWdhdGlvblR5cGUsXG4gIGNyZWF0ZU1lbW9yeUhpc3RvcnksXG4gIGNyZWF0ZVBhdGgsXG4gIGNyZWF0ZVJvdXRlcixcbiAgZGVmZXIsXG4gIGdlbmVyYXRlUGF0aCxcbiAgaXNSb3V0ZUVycm9yUmVzcG9uc2UsXG4gIGpzb24sXG4gIG1hdGNoUGF0aCxcbiAgbWF0Y2hSb3V0ZXMsXG4gIHBhcnNlUGF0aCxcbiAgcmVkaXJlY3QsXG4gIHJlc29sdmVQYXRoLFxufSBmcm9tIFwiQHJlbWl4LXJ1bi9yb3V0ZXJcIjtcblxuaW1wb3J0IHR5cGUge1xuICBBd2FpdFByb3BzLFxuICBNZW1vcnlSb3V0ZXJQcm9wcyxcbiAgTmF2aWdhdGVQcm9wcyxcbiAgT3V0bGV0UHJvcHMsXG4gIFJvdXRlUHJvcHMsXG4gIFBhdGhSb3V0ZVByb3BzLFxuICBMYXlvdXRSb3V0ZVByb3BzLFxuICBJbmRleFJvdXRlUHJvcHMsXG4gIFJvdXRlclByb3BzLFxuICBSb3V0ZXNQcm9wcyxcbiAgUm91dGVyUHJvdmlkZXJQcm9wcyxcbn0gZnJvbSBcIi4vbGliL2NvbXBvbmVudHNcIjtcbmltcG9ydCB7XG4gIGVuaGFuY2VNYW51YWxSb3V0ZU9iamVjdHMsXG4gIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbixcbiAgcmVuZGVyTWF0Y2hlcyxcbiAgQXdhaXQsXG4gIE1lbW9yeVJvdXRlcixcbiAgTmF2aWdhdGUsXG4gIE91dGxldCxcbiAgUm91dGUsXG4gIFJvdXRlcixcbiAgUm91dGVyUHJvdmlkZXIsXG4gIFJvdXRlcyxcbn0gZnJvbSBcIi4vbGliL2NvbXBvbmVudHNcIjtcbmltcG9ydCB0eXBlIHtcbiAgRGF0YVJvdXRlTWF0Y2gsXG4gIERhdGFSb3V0ZU9iamVjdCxcbiAgSW5kZXhSb3V0ZU9iamVjdCxcbiAgTmF2aWdhdG9yLFxuICBOYXZpZ2F0ZU9wdGlvbnMsXG4gIE5vbkluZGV4Um91dGVPYmplY3QsXG4gIFJvdXRlTWF0Y2gsXG4gIFJvdXRlT2JqZWN0LFxuICBSZWxhdGl2ZVJvdXRpbmdUeXBlLFxufSBmcm9tIFwiLi9saWIvY29udGV4dFwiO1xuaW1wb3J0IHtcbiAgRGF0YVJvdXRlckNvbnRleHQsXG4gIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsXG4gIExvY2F0aW9uQ29udGV4dCxcbiAgTmF2aWdhdGlvbkNvbnRleHQsXG4gIFJvdXRlQ29udGV4dCxcbn0gZnJvbSBcIi4vbGliL2NvbnRleHRcIjtcbmltcG9ydCB0eXBlIHsgTmF2aWdhdGVGdW5jdGlvbiB9IGZyb20gXCIuL2xpYi9ob29rc1wiO1xuaW1wb3J0IHtcbiAgdXNlQmxvY2tlcixcbiAgdXNlSHJlZixcbiAgdXNlSW5Sb3V0ZXJDb250ZXh0LFxuICB1c2VMb2NhdGlvbixcbiAgdXNlTWF0Y2gsXG4gIHVzZU5hdmlnYXRpb25UeXBlLFxuICB1c2VOYXZpZ2F0ZSxcbiAgdXNlT3V0bGV0LFxuICB1c2VPdXRsZXRDb250ZXh0LFxuICB1c2VQYXJhbXMsXG4gIHVzZVJlc29sdmVkUGF0aCxcbiAgdXNlUm91dGVzLFxuICB1c2VBY3Rpb25EYXRhLFxuICB1c2VBc3luY0Vycm9yLFxuICB1c2VBc3luY1ZhbHVlLFxuICB1c2VMb2FkZXJEYXRhLFxuICB1c2VNYXRjaGVzLFxuICB1c2VOYXZpZ2F0aW9uLFxuICB1c2VSZXZhbGlkYXRvcixcbiAgdXNlUm91dGVFcnJvcixcbiAgdXNlUm91dGVMb2FkZXJEYXRhLFxufSBmcm9tIFwiLi9saWIvaG9va3NcIjtcblxuLy8gRXhwb3J0ZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBidXQgbm90IGJlaW5nIHVzZWQgaW50ZXJuYWxseSBhbnltb3JlXG50eXBlIEhhc2ggPSBzdHJpbmc7XG50eXBlIFBhdGhuYW1lID0gc3RyaW5nO1xudHlwZSBTZWFyY2ggPSBzdHJpbmc7XG5cbi8vIEV4cG9zZSByZWFjdC1yb3V0ZXIgcHVibGljIEFQSVxuZXhwb3J0IHR5cGUge1xuICBBY3Rpb25GdW5jdGlvbixcbiAgQWN0aW9uRnVuY3Rpb25BcmdzLFxuICBBd2FpdFByb3BzLFxuICBCbG9ja2VyIGFzIHVuc3RhYmxlX0Jsb2NrZXIsXG4gIEJsb2NrZXJGdW5jdGlvbiBhcyB1bnN0YWJsZV9CbG9ja2VyRnVuY3Rpb24sXG4gIERhdGFSb3V0ZU1hdGNoLFxuICBEYXRhUm91dGVPYmplY3QsXG4gIEZldGNoZXIsXG4gIEhhc2gsXG4gIEluZGV4Um91dGVPYmplY3QsXG4gIEluZGV4Um91dGVQcm9wcyxcbiAgSnNvbkZ1bmN0aW9uLFxuICBMYXlvdXRSb3V0ZVByb3BzLFxuICBMb2FkZXJGdW5jdGlvbixcbiAgTG9hZGVyRnVuY3Rpb25BcmdzLFxuICBMb2NhdGlvbixcbiAgTWVtb3J5Um91dGVyUHJvcHMsXG4gIE5hdmlnYXRlRnVuY3Rpb24sXG4gIE5hdmlnYXRlT3B0aW9ucyxcbiAgTmF2aWdhdGVQcm9wcyxcbiAgTmF2aWdhdGlvbixcbiAgTmF2aWdhdG9yLFxuICBOb25JbmRleFJvdXRlT2JqZWN0LFxuICBPdXRsZXRQcm9wcyxcbiAgUGFyYW1zLFxuICBQYXJhbVBhcnNlS2V5LFxuICBQYXRoLFxuICBQYXRoTWF0Y2gsXG4gIFBhdGhuYW1lLFxuICBQYXRoUGF0dGVybixcbiAgUGF0aFJvdXRlUHJvcHMsXG4gIFJlZGlyZWN0RnVuY3Rpb24sXG4gIFJlbGF0aXZlUm91dGluZ1R5cGUsXG4gIFJvdXRlTWF0Y2gsXG4gIFJvdXRlT2JqZWN0LFxuICBSb3V0ZVByb3BzLFxuICBSb3V0ZXJQcm9wcyxcbiAgUm91dGVyUHJvdmlkZXJQcm9wcyxcbiAgUm91dGVzUHJvcHMsXG4gIFNlYXJjaCxcbiAgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uLFxuICBUbyxcbn07XG5leHBvcnQge1xuICBBYm9ydGVkRGVmZXJyZWRFcnJvcixcbiAgQXdhaXQsXG4gIE1lbW9yeVJvdXRlcixcbiAgTmF2aWdhdGUsXG4gIE5hdmlnYXRpb25UeXBlLFxuICBPdXRsZXQsXG4gIFJvdXRlLFxuICBSb3V0ZXIsXG4gIFJvdXRlclByb3ZpZGVyLFxuICBSb3V0ZXMsXG4gIGNyZWF0ZVBhdGgsXG4gIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbixcbiAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIGFzIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cyxcbiAgZGVmZXIsXG4gIGlzUm91dGVFcnJvclJlc3BvbnNlLFxuICBnZW5lcmF0ZVBhdGgsXG4gIGpzb24sXG4gIG1hdGNoUGF0aCxcbiAgbWF0Y2hSb3V0ZXMsXG4gIHBhcnNlUGF0aCxcbiAgcmVkaXJlY3QsXG4gIHJlbmRlck1hdGNoZXMsXG4gIHJlc29sdmVQYXRoLFxuICB1c2VBY3Rpb25EYXRhLFxuICB1c2VBc3luY0Vycm9yLFxuICB1c2VBc3luY1ZhbHVlLFxuICB1c2VCbG9ja2VyIGFzIHVuc3RhYmxlX3VzZUJsb2NrZXIsXG4gIHVzZUhyZWYsXG4gIHVzZUluUm91dGVyQ29udGV4dCxcbiAgdXNlTG9hZGVyRGF0YSxcbiAgdXNlTG9jYXRpb24sXG4gIHVzZU1hdGNoLFxuICB1c2VNYXRjaGVzLFxuICB1c2VOYXZpZ2F0ZSxcbiAgdXNlTmF2aWdhdGlvbixcbiAgdXNlTmF2aWdhdGlvblR5cGUsXG4gIHVzZU91dGxldCxcbiAgdXNlT3V0bGV0Q29udGV4dCxcbiAgdXNlUGFyYW1zLFxuICB1c2VSZXNvbHZlZFBhdGgsXG4gIHVzZVJldmFsaWRhdG9yLFxuICB1c2VSb3V0ZUVycm9yLFxuICB1c2VSb3V0ZUxvYWRlckRhdGEsXG4gIHVzZVJvdXRlcyxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNZW1vcnlSb3V0ZXIoXG4gIHJvdXRlczogUm91dGVPYmplY3RbXSxcbiAgb3B0cz86IHtcbiAgICBiYXNlbmFtZT86IHN0cmluZztcbiAgICBoeWRyYXRpb25EYXRhPzogSHlkcmF0aW9uU3RhdGU7XG4gICAgaW5pdGlhbEVudHJpZXM/OiBJbml0aWFsRW50cnlbXTtcbiAgICBpbml0aWFsSW5kZXg/OiBudW1iZXI7XG4gIH1cbik6IFJlbWl4Um91dGVyIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIGhpc3Rvcnk6IGNyZWF0ZU1lbW9yeUhpc3Rvcnkoe1xuICAgICAgaW5pdGlhbEVudHJpZXM6IG9wdHM/LmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEluZGV4OiBvcHRzPy5pbml0aWFsSW5kZXgsXG4gICAgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogb3B0cz8uaHlkcmF0aW9uRGF0YSxcbiAgICByb3V0ZXM6IGVuaGFuY2VNYW51YWxSb3V0ZU9iamVjdHMocm91dGVzKSxcbiAgfSkuaW5pdGlhbGl6ZSgpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBEQU5HRVIhIFBMRUFTRSBSRUFEIE1FIVxuLy8gV2UgcHJvdmlkZSB0aGVzZSBleHBvcnRzIGFzIGFuIGVzY2FwZSBoYXRjaCBpbiB0aGUgZXZlbnQgdGhhdCB5b3UgbmVlZCBhbnlcbi8vIHJvdXRpbmcgZGF0YSB0aGF0IHdlIGRvbid0IHByb3ZpZGUgYW4gZXhwbGljaXQgQVBJIGZvci4gV2l0aCB0aGF0IHNhaWQsIHdlXG4vLyB3YW50IHRvIGNvdmVyIHlvdXIgdXNlIGNhc2UgaWYgd2UgY2FuLCBzbyBpZiB5b3UgZmVlbCB0aGUgbmVlZCB0byB1c2UgdGhlc2Vcbi8vIHdlIHdhbnQgdG8gaGVhciBmcm9tIHlvdS4gTGV0IHVzIGtub3cgd2hhdCB5b3UncmUgYnVpbGRpbmcgYW5kIHdlJ2xsIGRvIG91clxuLy8gYmVzdCB0byBtYWtlIHN1cmUgd2UgY2FuIHN1cHBvcnQgeW91IVxuLy9cbi8vIFdlIGNvbnNpZGVyIHRoZXNlIGV4cG9ydHMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIGFuZCBkbyBub3QgZ3VhcmFudGVlXG4vLyBhZ2FpbnN0IGFueSBicmVha2luZyBjaGFuZ2VzLCByZWdhcmRsZXNzIG9mIHRoZSBzZW12ZXIgcmVsZWFzZS4gVXNlIHdpdGhcbi8vIGV4dHJlbWUgY2F1dGlvbiBhbmQgb25seSBpZiB5b3UgdW5kZXJzdGFuZCB0aGUgY29uc2VxdWVuY2VzLiBHb2RzcGVlZC5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IHtcbiAgTmF2aWdhdGlvbkNvbnRleHQgYXMgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LFxuICBMb2NhdGlvbkNvbnRleHQgYXMgVU5TQUZFX0xvY2F0aW9uQ29udGV4dCxcbiAgUm91dGVDb250ZXh0IGFzIFVOU0FGRV9Sb3V0ZUNvbnRleHQsXG4gIERhdGFSb3V0ZXJDb250ZXh0IGFzIFVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCxcbiAgRGF0YVJvdXRlclN0YXRlQ29udGV4dCBhcyBVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCxcbiAgZW5oYW5jZU1hbnVhbFJvdXRlT2JqZWN0cyBhcyBVTlNBRkVfZW5oYW5jZU1hbnVhbFJvdXRlT2JqZWN0cyxcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxuXG52YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRTtcblxue1xuICBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QubW9kdWxlLnJlZmVyZW5jZScpO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICggIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcbi8vIGV2ZW4gd2l0aCB0aGUgcHJvZCB0cmFuc2Zvcm0uIFRoaXMgbWVhbnMgdGhhdCBqc3hERVYgaXMgcHVyZWx5XG4vLyBvcHQtaW4gYmVoYXZpb3IgZm9yIGJldHRlciBtZXNzYWdlcyBidXQgdGhhdCB3ZSB3b24ndCBzdG9wXG4vLyBnaXZpbmcgeW91IHdhcm5pbmdzIGlmIHlvdSB1c2UgcHJvZHVjdGlvbiBhcGlzLlxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvblN0YXRpYyh0eXBlLCBwcm9wcywga2V5KSB7XG4gIHtcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyh0eXBlLCBwcm9wcywga2V5KSB7XG4gIHtcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgZmFsc2UpO1xuICB9XG59XG5cbnZhciBqc3ggPSAganN4V2l0aFZhbGlkYXRpb25EeW5hbWljIDsgLy8gd2UgbWF5IHdhbnQgdG8gc3BlY2lhbCBjYXNlIGpzeHMgaW50ZXJuYWxseSB0byB0YWtlIGFkdmFudGFnZSBvZiBzdGF0aWMgY2hpbGRyZW4uXG4vLyBmb3Igbm93IHdlIGNhbiBzaGlwIGlkZW50aWNhbCBwcm9kIGZ1bmN0aW9uc1xuXG52YXIganN4cyA9ICBqc3hXaXRoVmFsaWRhdGlvblN0YXRpYyA7XG5cbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5qc3ggPSBqc3g7XG5leHBvcnRzLmpzeHMgPSBqc3hzO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCBkZWZhdWx0IHtcIkhlYWRlclwiOlwiWVlNcmFSc21fajFkVWl5dkVMazNcIixcIkhlYWRlclRpdGxlXCI6XCJsMW1UU2w1QnpPSTdrekZtVVFPYVwifTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCBkZWZhdWx0IHtcIkhlYWRlckxpbmtcIjpcIkNJQTFaTHZrSFRENnBYWjNYSGJjXCJ9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IGRlZmF1bHQge1wiVG9kb0xpc3RcIjpcImJ1a3dYWTdZWF82YU5sd2c4cXlrXCJ9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsImltcG9ydCB7IGpzeCBhcyBfanN4LCBGcmFnbWVudCBhcyBfRnJhZ21lbnQsIGpzeHMgYXMgX2pzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCBcIi4vc3R5bGVzL19iYXNlLnNjc3NcIjtcbmltcG9ydCBIZWFkZXIgZnJvbSBcIi4vX3BhcnRpYWxzL0hlYWRlci9IZWFkZXJcIjtcbmltcG9ydCB7IEFwcFN0YXRlUHJvdmlkZXIgfSBmcm9tIFwiLi9ob2MvdXNlQXBwU3RhdGVcIjtcbmltcG9ydCB7IFJvdXRlLCBSb3V0ZXMgfSBmcm9tIFwicmVhY3Qtcm91dGVyLWRvbVwiO1xuaW1wb3J0IHsgd2l0aFN1c3BlbnNlIH0gZnJvbSBcIi4vaG9jL3dpdGhTdXNwZW5zZVwiO1xuaW1wb3J0IHsgUGFnZUxheW91dCB9IGZyb20gXCIuL2NvbXBvbmVudHMvUGFnZUxheW91dC9QYWdlTGF5b3V0XCI7XG52YXIgQXN5bmNUb2RvQ29udGFpbmVyID0gd2l0aFN1c3BlbnNlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGltcG9ydChcIi4vY29udGFpbmVycy9Ub2RvQ29udGFpbmVyXCIpOyB9KTtcbnZhciBBc3luY0VkaXRUb2RvSXRlbSA9IHdpdGhTdXNwZW5zZShmdW5jdGlvbiAoKSB7IHJldHVybiBpbXBvcnQoXCIuL2NvbnRhaW5lcnMvVG9kb0NvbnRhaW5lci9FZGl0VG9kb0l0ZW1cIik7IH0pO1xudmFyIEFzeW5jU3RhdHNDb250YWluZXIgPSB3aXRoU3VzcGVuc2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gaW1wb3J0KFwiLi9jb250YWluZXJzL1N0YXRzQ29udGFpbmVyXCIpOyB9KTtcbnZhciBBc3luY0Fib3V0Q29udGFpbmVyID0gd2l0aFN1c3BlbnNlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGltcG9ydChcIi4vY29udGFpbmVycy9BYm91dENvbnRhaW5lclwiKTsgfSk7XG5mdW5jdGlvbiBBcHAoKSB7XG4gICAgcmV0dXJuIChfanN4KF9GcmFnbWVudCwgeyBjaGlsZHJlbjogX2pzeHMoQXBwU3RhdGVQcm92aWRlciwgeyBjaGlsZHJlbjogW19qc3goSGVhZGVyLCB7fSksIF9qc3goUGFnZUxheW91dCwgeyBjaGlsZHJlbjogX2pzeHMoUm91dGVzLCB7IGNoaWxkcmVuOiBbX2pzeChSb3V0ZSwgeyBwYXRoOiBcIi9cIiwgZWxlbWVudDogX2pzeHMoX0ZyYWdtZW50LCB7IGNoaWxkcmVuOiBbQXN5bmNUb2RvQ29udGFpbmVyLCBBc3luY0VkaXRUb2RvSXRlbV0gfSkgfSksIF9qc3goUm91dGUsIHsgcGF0aDogXCIvc3RhdHNcIiwgZWxlbWVudDogQXN5bmNTdGF0c0NvbnRhaW5lciB9KSwgX2pzeChSb3V0ZSwgeyBwYXRoOiBcIi9hYm91dFwiLCBlbGVtZW50OiBBc3luY0Fib3V0Q29udGFpbmVyIH0pXSB9KSB9KV0gfSkgfSkpO1xufVxuZXhwb3J0IGRlZmF1bHQgQXBwO1xuIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmltcG9ydCB7IGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgY2xhc3NlcyBmcm9tIFwiLi9IZWFkZXIubW9kdWxlLnNjc3NcIjtcbmltcG9ydCBIZWFkZXJMaW5rIGZyb20gXCIuL0hlYWRlckxpbmsvSGVhZGVyTGlua1wiO1xudmFyIEhlYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKF9qc3hzKFwiaGVhZGVyXCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc2VzLkhlYWRlciB9LCB7IGNoaWxkcmVuOiBbX2pzeChcImgxXCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc2VzLkhlYWRlclRpdGxlIH0sIHsgY2hpbGRyZW46IFwiVG9kbyBQcm8gTWF4IEFwcFwiIH0pKSwgX2pzeHMoXCJuYXZcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IFwibS1hdXRvXCIgfSwgeyBjaGlsZHJlbjogW19qc3goSGVhZGVyTGluaywgX19hc3NpZ24oeyB1cmw6IFwiL1wiIH0sIHsgY2hpbGRyZW46IFwiSG9tZVwiIH0pKSwgX2pzeChIZWFkZXJMaW5rLCBfX2Fzc2lnbih7IHVybDogXCIvc3RhdHNcIiB9LCB7IGNoaWxkcmVuOiBcIlN0YXRzXCIgfSkpLCBfanN4KEhlYWRlckxpbmssIF9fYXNzaWduKHsgdXJsOiBcIi9hYm91dFwiIH0sIHsgY2hpbGRyZW46IFwiQWJvdXRcIiB9KSldIH0pKV0gfSkpKTtcbn07XG5leHBvcnQgZGVmYXVsdCBIZWFkZXI7XG4iLCJ2YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IExpbmsgfSBmcm9tIFwicmVhY3Qtcm91dGVyLWRvbVwiO1xuaW1wb3J0IGNsYXNzZXMgZnJvbSBcIi4vSGVhZGVyTGluay5tb2R1bGUuc2Nzc1wiO1xudmFyIEhlYWRlckxpbmsgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgdXJsID0gX2EudXJsLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xuICAgIHJldHVybiAoX2pzeChMaW5rLCBfX2Fzc2lnbih7IHRvOiBcIlwiLmNvbmNhdCh1cmwpLCBjbGFzc05hbWU6IGNsYXNzZXMuSGVhZGVyTGluayArIFwiIG1yLTIgbXItMlwiIH0sIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pKSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgSGVhZGVyTGluaztcbiIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5pbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IGNsYXNzZXMgZnJvbSBcIi4vUGFnZUxheW91dC5tb2R1bGUuc2Nzc1wiO1xuZXhwb3J0IHZhciBQYWdlTGF5b3V0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XG4gICAgcmV0dXJuIChfanN4KFwiZGl2XCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc2VzLlRvZG9MaXN0ICsgXCIgbXItYXV0byBtbC1hdXRvXCIgfSwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSkpKTtcbn07XG4iLCJ2YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VDb250ZXh0LCB9IGZyb20gXCJyZWFjdFwiO1xuZXhwb3J0IHZhciBBcHBTYXRlID0gY3JlYXRlQ29udGV4dCh7XG4gICAgYXBwU3RhdGU6IHsgZWRpdFRvZG9JZDogLTEsIGlzRHJhd2VyT3BlbjogZmFsc2UgfSxcbiAgICBzZXRBcHBTdGF0ZTogZnVuY3Rpb24gKCkgeyB9LFxufSk7XG5leHBvcnQgdmFyIHVzZUFwcFN0YXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdXNlQ29udGV4dChBcHBTYXRlKTsgfTtcbmV4cG9ydCB2YXIgQXBwU3RhdGVQcm92aWRlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xuICAgIHZhciBfYiA9IHVzZVN0YXRlKHtcbiAgICAgICAgZWRpdFRvZG9JZDogLTEsXG4gICAgICAgIGlzRHJhd2VyT3BlbjogZmFsc2UsXG4gICAgfSksIGFwcFN0YXRlID0gX2JbMF0sIHNldEFwcFN0YXRlID0gX2JbMV07XG4gICAgcmV0dXJuIChfanN4KEFwcFNhdGUuUHJvdmlkZXIsIF9fYXNzaWduKHsgdmFsdWU6IHsgYXBwU3RhdGU6IGFwcFN0YXRlLCBzZXRBcHBTdGF0ZTogc2V0QXBwU3RhdGUgfSB9LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSkpO1xufTtcbiIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5pbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IFJlYWN0LCB7IFN1c3BlbnNlIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgTG9hZGluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9qc3goXCJkaXZcIiwgeyBjaGlsZHJlbjogXCJMb2FkaW5nLi4uXCIgfSk7IH07XG5leHBvcnQgdmFyIHdpdGhTdXNwZW5zZSA9IGZ1bmN0aW9uIChDb21wb25lbnRJbXBvcnRDYWxsYmFjaykge1xuICAgIHZhciBBc3luY0NvbXBvbmVudCA9IFJlYWN0LmxhenkoQ29tcG9uZW50SW1wb3J0Q2FsbGJhY2spO1xuICAgIHJldHVybiAoX2pzeChTdXNwZW5zZSwgX19hc3NpZ24oeyBmYWxsYmFjazogX2pzeChMb2FkaW5nLCB7fSkgfSwgeyBjaGlsZHJlbjogX2pzeChBc3luY0NvbXBvbmVudCwge30pIH0pKSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVhY3RcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwib3NcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicGF0aFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwcm9jZXNzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInR0eVwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1cmxcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXRpbFwiKTsiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbl9fd2VicGFja19yZXF1aXJlX18ubSA9IF9fd2VicGFja19tb2R1bGVzX187XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5mID0ge307XG4vLyBUaGlzIGZpbGUgY29udGFpbnMgb25seSB0aGUgZW50cnkgY2h1bmsuXG4vLyBUaGUgY2h1bmsgbG9hZGluZyBmdW5jdGlvbiBmb3IgYWRkaXRpb25hbCBjaHVua3Ncbl9fd2VicGFja19yZXF1aXJlX18uZSA9IChjaHVua0lkKSA9PiB7XG5cdHJldHVybiBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLmYpLnJlZHVjZSgocHJvbWlzZXMsIGtleSkgPT4ge1xuXHRcdF9fd2VicGFja19yZXF1aXJlX18uZltrZXldKGNodW5rSWQsIHByb21pc2VzKTtcblx0XHRyZXR1cm4gcHJvbWlzZXM7XG5cdH0sIFtdKSk7XG59OyIsIi8vIFRoaXMgZnVuY3Rpb24gYWxsb3cgdG8gcmVmZXJlbmNlIGFzeW5jIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy51ID0gKGNodW5rSWQpID0+IHtcblx0Ly8gcmV0dXJuIHVybCBmb3IgZmlsZW5hbWVzIGJhc2VkIG9uIHRlbXBsYXRlXG5cdHJldHVybiBcIlwiICsgY2h1bmtJZCArIFwiLmpzXCI7XG59OyIsIi8vIFRoaXMgZnVuY3Rpb24gYWxsb3cgdG8gcmVmZXJlbmNlIGFzeW5jIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5taW5pQ3NzRiA9IChjaHVua0lkKSA9PiB7XG5cdC8vIHJldHVybiB1cmwgZm9yIGZpbGVuYW1lcyBiYXNlZCBvbiB0ZW1wbGF0ZVxuXHRyZXR1cm4gXCJcIiArIGNodW5rSWQgKyBcIi5jc3NcIjtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL1wiOyIsImlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcbnZhciBjcmVhdGVTdHlsZXNoZWV0ID0gKGNodW5rSWQsIGZ1bGxocmVmLCBvbGRUYWcsIHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHR2YXIgbGlua1RhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGxpbmtUYWcucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cdGxpbmtUYWcudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0dmFyIG9uTGlua0NvbXBsZXRlID0gKGV2ZW50KSA9PiB7XG5cdFx0Ly8gYXZvaWQgbWVtIGxlYWtzLlxuXHRcdGxpbmtUYWcub25lcnJvciA9IGxpbmtUYWcub25sb2FkID0gbnVsbDtcblx0XHRpZiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnKSB7XG5cdFx0XHRyZXNvbHZlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBlcnJvclR5cGUgPSBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnID8gJ21pc3NpbmcnIDogZXZlbnQudHlwZSk7XG5cdFx0XHR2YXIgcmVhbEhyZWYgPSBldmVudCAmJiBldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0LmhyZWYgfHwgZnVsbGhyZWY7XG5cdFx0XHR2YXIgZXJyID0gbmV3IEVycm9yKFwiTG9hZGluZyBDU1MgY2h1bmsgXCIgKyBjaHVua0lkICsgXCIgZmFpbGVkLlxcbihcIiArIHJlYWxIcmVmICsgXCIpXCIpO1xuXHRcdFx0ZXJyLmNvZGUgPSBcIkNTU19DSFVOS19MT0FEX0ZBSUxFRFwiO1xuXHRcdFx0ZXJyLnR5cGUgPSBlcnJvclR5cGU7XG5cdFx0XHRlcnIucmVxdWVzdCA9IHJlYWxIcmVmO1xuXHRcdFx0bGlua1RhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpbmtUYWcpXG5cdFx0XHRyZWplY3QoZXJyKTtcblx0XHR9XG5cdH1cblx0bGlua1RhZy5vbmVycm9yID0gbGlua1RhZy5vbmxvYWQgPSBvbkxpbmtDb21wbGV0ZTtcblx0bGlua1RhZy5ocmVmID0gZnVsbGhyZWY7XG5cblx0aWYgKG9sZFRhZykge1xuXHRcdG9sZFRhZy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShsaW5rVGFnLCBvbGRUYWcubmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGlua1RhZyk7XG5cdH1cblx0cmV0dXJuIGxpbmtUYWc7XG59O1xudmFyIGZpbmRTdHlsZXNoZWV0ID0gKGhyZWYsIGZ1bGxocmVmKSA9PiB7XG5cdHZhciBleGlzdGluZ0xpbmtUYWdzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsaW5rXCIpO1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgZXhpc3RpbmdMaW5rVGFncy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciB0YWcgPSBleGlzdGluZ0xpbmtUYWdzW2ldO1xuXHRcdHZhciBkYXRhSHJlZiA9IHRhZy5nZXRBdHRyaWJ1dGUoXCJkYXRhLWhyZWZcIikgfHwgdGFnLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG5cdFx0aWYodGFnLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIgJiYgKGRhdGFIcmVmID09PSBocmVmIHx8IGRhdGFIcmVmID09PSBmdWxsaHJlZikpIHJldHVybiB0YWc7XG5cdH1cblx0dmFyIGV4aXN0aW5nU3R5bGVUYWdzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdHlsZVwiKTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IGV4aXN0aW5nU3R5bGVUYWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHRhZyA9IGV4aXN0aW5nU3R5bGVUYWdzW2ldO1xuXHRcdHZhciBkYXRhSHJlZiA9IHRhZy5nZXRBdHRyaWJ1dGUoXCJkYXRhLWhyZWZcIik7XG5cdFx0aWYoZGF0YUhyZWYgPT09IGhyZWYgfHwgZGF0YUhyZWYgPT09IGZ1bGxocmVmKSByZXR1cm4gdGFnO1xuXHR9XG59O1xudmFyIGxvYWRTdHlsZXNoZWV0ID0gKGNodW5rSWQpID0+IHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHR2YXIgaHJlZiA9IF9fd2VicGFja19yZXF1aXJlX18ubWluaUNzc0YoY2h1bmtJZCk7XG5cdFx0dmFyIGZ1bGxocmVmID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgaHJlZjtcblx0XHRpZihmaW5kU3R5bGVzaGVldChocmVmLCBmdWxsaHJlZikpIHJldHVybiByZXNvbHZlKCk7XG5cdFx0Y3JlYXRlU3R5bGVzaGVldChjaHVua0lkLCBmdWxsaHJlZiwgbnVsbCwgcmVzb2x2ZSwgcmVqZWN0KTtcblx0fSk7XG59XG4vLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIENTUyBjaHVua3NcbnZhciBpbnN0YWxsZWRDc3NDaHVua3MgPSB7XG5cdFwibWFpblwiOiAwXG59O1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmYubWluaUNzcyA9IChjaHVua0lkLCBwcm9taXNlcykgPT4ge1xuXHR2YXIgY3NzQ2h1bmtzID0ge1wic3JjX2NvbnRhaW5lcnNfVG9kb0NvbnRhaW5lcl9pbmRleF90c3hcIjoxLFwic3JjX2NvbnRhaW5lcnNfVG9kb0NvbnRhaW5lcl9FZGl0VG9kb0l0ZW1faW5kZXhfdHN4XCI6MSxcInNyY19jb250YWluZXJzX1N0YXRzQ29udGFpbmVyX2luZGV4X3RzeFwiOjF9O1xuXHRpZihpbnN0YWxsZWRDc3NDaHVua3NbY2h1bmtJZF0pIHByb21pc2VzLnB1c2goaW5zdGFsbGVkQ3NzQ2h1bmtzW2NodW5rSWRdKTtcblx0ZWxzZSBpZihpbnN0YWxsZWRDc3NDaHVua3NbY2h1bmtJZF0gIT09IDAgJiYgY3NzQ2h1bmtzW2NodW5rSWRdKSB7XG5cdFx0cHJvbWlzZXMucHVzaChpbnN0YWxsZWRDc3NDaHVua3NbY2h1bmtJZF0gPSBsb2FkU3R5bGVzaGVldChjaHVua0lkKS50aGVuKCgpID0+IHtcblx0XHRcdGluc3RhbGxlZENzc0NodW5rc1tjaHVua0lkXSA9IDA7XG5cdFx0fSwgKGUpID0+IHtcblx0XHRcdGRlbGV0ZSBpbnN0YWxsZWRDc3NDaHVua3NbY2h1bmtJZF07XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH0pKTtcblx0fVxufTtcblxuLy8gbm8gaG1yIiwiLy8gbm8gYmFzZVVSSVxuXG4vLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGNodW5rc1xuLy8gXCIxXCIgbWVhbnMgXCJsb2FkZWRcIiwgb3RoZXJ3aXNlIG5vdCBsb2FkZWQgeWV0XG52YXIgaW5zdGFsbGVkQ2h1bmtzID0ge1xuXHRcIm1haW5cIjogMVxufTtcblxuLy8gbm8gb24gY2h1bmtzIGxvYWRlZFxuXG52YXIgaW5zdGFsbENodW5rID0gKGNodW5rKSA9PiB7XG5cdHZhciBtb3JlTW9kdWxlcyA9IGNodW5rLm1vZHVsZXMsIGNodW5rSWRzID0gY2h1bmsuaWRzLCBydW50aW1lID0gY2h1bmsucnVudGltZTtcblx0Zm9yKHZhciBtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG5cdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm1bbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xuXHRcdH1cblx0fVxuXHRpZihydW50aW1lKSBydW50aW1lKF9fd2VicGFja19yZXF1aXJlX18pO1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgY2h1bmtJZHMubGVuZ3RoOyBpKyspXG5cdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRzW2ldXSA9IDE7XG5cbn07XG5cbi8vIHJlcXVpcmUoKSBjaHVuayBsb2FkaW5nIGZvciBqYXZhc2NyaXB0XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmYucmVxdWlyZSA9IChjaHVua0lkLCBwcm9taXNlcykgPT4ge1xuXHQvLyBcIjFcIiBpcyB0aGUgc2lnbmFsIGZvciBcImFscmVhZHkgbG9hZGVkXCJcblx0aWYoIWluc3RhbGxlZENodW5rc1tjaHVua0lkXSkge1xuXHRcdGlmKHRydWUpIHsgLy8gYWxsIGNodW5rcyBoYXZlIEpTXG5cdFx0XHRpbnN0YWxsQ2h1bmsocmVxdWlyZShcIi4vXCIgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLnUoY2h1bmtJZCkpKTtcblx0XHR9IGVsc2UgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMTtcblx0fVxufTtcblxuLy8gbm8gZXh0ZXJuYWwgaW5zdGFsbCBjaHVua1xuXG4vLyBubyBITVJcblxuLy8gbm8gSE1SIG1hbmlmZXN0IiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgQXBwIGZyb20gXCIuLi9BcHBcIjtcbmltcG9ydCB7IFN0YXRpY1JvdXRlciB9IGZyb20gXCJyZWFjdC1yb3V0ZXItZG9tL3NlcnZlclwiO1xuZXhwb3J0IHZhciBTc3JBcHAgPSBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICByZXR1cm4gKF9qc3goU3RhdGljUm91dGVyLCBfX2Fzc2lnbih7IGxvY2F0aW9uOiBwYXRobmFtZSB9LCB7IGNoaWxkcmVuOiBfanN4KEFwcCwge30pIH0pKSk7XG59O1xuIl0sIm5hbWVzIjpbIkFjdGlvbiIsIlBvcFN0YXRlRXZlbnRUeXBlIiwiY3JlYXRlTWVtb3J5SGlzdG9yeSIsIm9wdGlvbnMiLCJpbml0aWFsRW50cmllcyIsImluaXRpYWxJbmRleCIsInY1Q29tcGF0IiwiZW50cmllcyIsIm1hcCIsImVudHJ5IiwiaW5kZXgiLCJjcmVhdGVNZW1vcnlMb2NhdGlvbiIsInN0YXRlIiwidW5kZWZpbmVkIiwiY2xhbXBJbmRleCIsImxlbmd0aCIsImFjdGlvbiIsIlBvcCIsImxpc3RlbmVyIiwibiIsIk1hdGgiLCJtaW4iLCJtYXgiLCJnZXRDdXJyZW50TG9jYXRpb24iLCJ0byIsImtleSIsImxvY2F0aW9uIiwiY3JlYXRlTG9jYXRpb24iLCJwYXRobmFtZSIsIndhcm5pbmckMSIsImNoYXJBdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJjcmVhdGVIcmVmIiwiY3JlYXRlUGF0aCIsImhpc3RvcnkiLCJjcmVhdGVVUkwiLCJVUkwiLCJlbmNvZGVMb2NhdGlvbiIsInBhdGgiLCJwYXJzZVBhdGgiLCJzZWFyY2giLCJoYXNoIiwicHVzaCIsIlB1c2giLCJuZXh0TG9jYXRpb24iLCJzcGxpY2UiLCJkZWx0YSIsInJlcGxhY2UiLCJSZXBsYWNlIiwiZ28iLCJuZXh0SW5kZXgiLCJsaXN0ZW4iLCJmbiIsImNyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiY3JlYXRlQnJvd3NlckxvY2F0aW9uIiwid2luZG93IiwiZ2xvYmFsSGlzdG9yeSIsInVzciIsImNyZWF0ZUJyb3dzZXJIcmVmIiwiZ2V0VXJsQmFzZWRIaXN0b3J5IiwiY3JlYXRlSGFzaEhpc3RvcnkiLCJjcmVhdGVIYXNoTG9jYXRpb24iLCJzdWJzdHIiLCJjcmVhdGVIYXNoSHJlZiIsImJhc2UiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJocmVmIiwiZ2V0QXR0cmlidXRlIiwidXJsIiwiaGFzaEluZGV4IiwiaW5kZXhPZiIsInNsaWNlIiwidmFsaWRhdGVIYXNoTG9jYXRpb24iLCJpbnZhcmlhbnQiLCJ2YWx1ZSIsIm1lc3NhZ2UiLCJFcnJvciIsIndhcm5pbmciLCJjb25kIiwiY29uc29sZSIsIndhcm4iLCJlIiwiY3JlYXRlS2V5IiwicmFuZG9tIiwidG9TdHJpbmciLCJnZXRIaXN0b3J5U3RhdGUiLCJpZHgiLCJjdXJyZW50IiwiX2V4dGVuZHMiLCJfcmVmIiwicGFyc2VkUGF0aCIsInNlYXJjaEluZGV4IiwiZ2V0TG9jYXRpb24iLCJ2YWxpZGF0ZUxvY2F0aW9uIiwiZGVmYXVsdFZpZXciLCJnZXRJbmRleCIsInJlcGxhY2VTdGF0ZSIsImhhbmRsZVBvcCIsImhpc3RvcnlTdGF0ZSIsInB1c2hTdGF0ZSIsImVycm9yIiwiYXNzaWduIiwib3JpZ2luIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJSZXN1bHRUeXBlIiwiaXNJbmRleFJvdXRlIiwicm91dGUiLCJjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzIiwicm91dGVzIiwicGFyZW50UGF0aCIsImFsbElkcyIsIlNldCIsInRyZWVQYXRoIiwiaWQiLCJqb2luIiwiY2hpbGRyZW4iLCJoYXMiLCJhZGQiLCJpbmRleFJvdXRlIiwicGF0aE9yTGF5b3V0Um91dGUiLCJtYXRjaFJvdXRlcyIsImxvY2F0aW9uQXJnIiwiYmFzZW5hbWUiLCJzdHJpcEJhc2VuYW1lIiwiYnJhbmNoZXMiLCJmbGF0dGVuUm91dGVzIiwicmFua1JvdXRlQnJhbmNoZXMiLCJtYXRjaGVzIiwiaSIsIm1hdGNoUm91dGVCcmFuY2giLCJzYWZlbHlEZWNvZGVVUkkiLCJwYXJlbnRzTWV0YSIsImZsYXR0ZW5Sb3V0ZSIsInJlbGF0aXZlUGF0aCIsIm1ldGEiLCJjYXNlU2Vuc2l0aXZlIiwiY2hpbGRyZW5JbmRleCIsInN0YXJ0c1dpdGgiLCJqb2luUGF0aHMiLCJyb3V0ZXNNZXRhIiwiY29uY2F0Iiwic2NvcmUiLCJjb21wdXRlU2NvcmUiLCJmb3JFYWNoIiwiX3JvdXRlJHBhdGgiLCJpbmNsdWRlcyIsImV4cGxvZGVkIiwiZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMiLCJzZWdtZW50cyIsInNwbGl0IiwiZmlyc3QiLCJyZXN0IiwiaXNPcHRpb25hbCIsImVuZHNXaXRoIiwicmVxdWlyZWQiLCJyZXN0RXhwbG9kZWQiLCJyZXN1bHQiLCJzdWJwYXRoIiwic29ydCIsImEiLCJiIiwiY29tcGFyZUluZGV4ZXMiLCJwYXJhbVJlIiwiZHluYW1pY1NlZ21lbnRWYWx1ZSIsImluZGV4Um91dGVWYWx1ZSIsImVtcHR5U2VnbWVudFZhbHVlIiwic3RhdGljU2VnbWVudFZhbHVlIiwic3BsYXRQZW5hbHR5IiwiaXNTcGxhdCIsInMiLCJpbml0aWFsU2NvcmUiLCJzb21lIiwiZmlsdGVyIiwicmVkdWNlIiwic2VnbWVudCIsInRlc3QiLCJzaWJsaW5ncyIsImV2ZXJ5IiwiYnJhbmNoIiwibWF0Y2hlZFBhcmFtcyIsIm1hdGNoZWRQYXRobmFtZSIsImVuZCIsInJlbWFpbmluZ1BhdGhuYW1lIiwibWF0Y2giLCJtYXRjaFBhdGgiLCJPYmplY3QiLCJwYXJhbXMiLCJwYXRobmFtZUJhc2UiLCJub3JtYWxpemVQYXRobmFtZSIsImdlbmVyYXRlUGF0aCIsIm9yaWdpbmFsUGF0aCIsIl8iLCJvcHRpb25hbCIsInBhcmFtIiwicHJlZml4IiwiX18iLCJzdHIiLCJzdGFyIiwicGF0dGVybiIsIm1hdGNoZXIiLCJwYXJhbU5hbWVzIiwiY29tcGlsZVBhdGgiLCJjYXB0dXJlR3JvdXBzIiwibWVtbyIsInBhcmFtTmFtZSIsInNwbGF0VmFsdWUiLCJzYWZlbHlEZWNvZGVVUklDb21wb25lbnQiLCJyZWdleHBTb3VyY2UiLCJSZWdFeHAiLCJkZWNvZGVVUkkiLCJkZWNvZGVVUklDb21wb25lbnQiLCJ0b0xvd2VyQ2FzZSIsInN0YXJ0SW5kZXgiLCJuZXh0Q2hhciIsInJlc29sdmVQYXRoIiwiZnJvbVBhdGhuYW1lIiwidG9QYXRobmFtZSIsInJlc29sdmVQYXRobmFtZSIsIm5vcm1hbGl6ZVNlYXJjaCIsIm5vcm1hbGl6ZUhhc2giLCJyZWxhdGl2ZVNlZ21lbnRzIiwicG9wIiwiZ2V0SW52YWxpZFBhdGhFcnJvciIsImNoYXIiLCJmaWVsZCIsImRlc3QiLCJnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyIsInJlc29sdmVUbyIsInRvQXJnIiwicm91dGVQYXRobmFtZXMiLCJsb2NhdGlvblBhdGhuYW1lIiwiaXNQYXRoUmVsYXRpdmUiLCJpc0VtcHR5UGF0aCIsImZyb20iLCJyb3V0ZVBhdGhuYW1lSW5kZXgiLCJ0b1NlZ21lbnRzIiwic2hpZnQiLCJoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2giLCJoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCIsImdldFRvUGF0aG5hbWUiLCJwYXRocyIsImpzb24iLCJkYXRhIiwiaW5pdCIsInJlc3BvbnNlSW5pdCIsInN0YXR1cyIsImhlYWRlcnMiLCJIZWFkZXJzIiwic2V0IiwiUmVzcG9uc2UiLCJBYm9ydGVkRGVmZXJyZWRFcnJvciIsIkRlZmVycmVkRGF0YSIsImNvbnN0cnVjdG9yIiwicGVuZGluZ0tleXNTZXQiLCJzdWJzY3JpYmVycyIsImRlZmVycmVkS2V5cyIsIkFycmF5IiwiaXNBcnJheSIsInJlamVjdCIsImFib3J0UHJvbWlzZSIsIlByb21pc2UiLCJyIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsIm9uQWJvcnQiLCJ1bmxpc3RlbkFib3J0U2lnbmFsIiwic2lnbmFsIiwiYWNjIiwidHJhY2tQcm9taXNlIiwiZG9uZSIsInByb21pc2UiLCJyYWNlIiwidGhlbiIsIm9uU2V0dGxlIiwiY2F0Y2giLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImFib3J0ZWQiLCJkZWxldGUiLCJlbWl0Iiwic2V0dGxlZEtleSIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJjYW5jZWwiLCJhYm9ydCIsInYiLCJrIiwicmVzb2x2ZURhdGEiLCJyZXNvbHZlIiwic2l6ZSIsInVud3JhcHBlZERhdGEiLCJfcmVmMiIsInVud3JhcFRyYWNrZWRQcm9taXNlIiwicGVuZGluZ0tleXMiLCJpc1RyYWNrZWRQcm9taXNlIiwiX3RyYWNrZWQiLCJfZXJyb3IiLCJfZGF0YSIsImRlZmVyIiwicmVkaXJlY3QiLCJFcnJvclJlc3BvbnNlIiwic3RhdHVzVGV4dCIsImludGVybmFsIiwiaXNSb3V0ZUVycm9yUmVzcG9uc2UiLCJ2YWxpZE11dGF0aW9uTWV0aG9kc0FyciIsInZhbGlkTXV0YXRpb25NZXRob2RzIiwidmFsaWRSZXF1ZXN0TWV0aG9kc0FyciIsInZhbGlkUmVxdWVzdE1ldGhvZHMiLCJyZWRpcmVjdFN0YXR1c0NvZGVzIiwicmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzIiwiSURMRV9OQVZJR0FUSU9OIiwiZm9ybU1ldGhvZCIsImZvcm1BY3Rpb24iLCJmb3JtRW5jVHlwZSIsImZvcm1EYXRhIiwiSURMRV9GRVRDSEVSIiwiSURMRV9CTE9DS0VSIiwicHJvY2VlZCIsInJlc2V0IiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwiaXNCcm93c2VyIiwiY3JlYXRlRWxlbWVudCIsImlzU2VydmVyIiwiY3JlYXRlUm91dGVyIiwiZGF0YVJvdXRlcyIsInVubGlzdGVuSGlzdG9yeSIsInNhdmVkU2Nyb2xsUG9zaXRpb25zIiwiZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkiLCJnZXRTY3JvbGxQb3NpdGlvbiIsImluaXRpYWxTY3JvbGxSZXN0b3JlZCIsImh5ZHJhdGlvbkRhdGEiLCJpbml0aWFsTWF0Y2hlcyIsImluaXRpYWxFcnJvcnMiLCJnZXRJbnRlcm5hbFJvdXRlckVycm9yIiwiZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyIsImluaXRpYWxpemVkIiwibSIsImxvYWRlciIsInJvdXRlciIsImhpc3RvcnlBY3Rpb24iLCJuYXZpZ2F0aW9uIiwicmVzdG9yZVNjcm9sbFBvc2l0aW9uIiwicHJldmVudFNjcm9sbFJlc2V0IiwicmV2YWxpZGF0aW9uIiwibG9hZGVyRGF0YSIsImFjdGlvbkRhdGEiLCJlcnJvcnMiLCJmZXRjaGVycyIsIk1hcCIsImJsb2NrZXJzIiwicGVuZGluZ0FjdGlvbiIsInBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQiLCJwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIiLCJpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24iLCJpc1JldmFsaWRhdGlvblJlcXVpcmVkIiwiY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMiLCJjYW5jZWxsZWRGZXRjaGVyTG9hZHMiLCJmZXRjaENvbnRyb2xsZXJzIiwiaW5jcmVtZW50aW5nTG9hZElkIiwicGVuZGluZ05hdmlnYXRpb25Mb2FkSWQiLCJmZXRjaFJlbG9hZElkcyIsImZldGNoUmVkaXJlY3RJZHMiLCJmZXRjaExvYWRNYXRjaGVzIiwiYWN0aXZlRGVmZXJyZWRzIiwiYmxvY2tlckZ1bmN0aW9ucyIsImlnbm9yZU5leHRIaXN0b3J5VXBkYXRlIiwiaW5pdGlhbGl6ZSIsImJsb2NrZXJLZXkiLCJzaG91bGRCbG9ja05hdmlnYXRpb24iLCJjdXJyZW50TG9jYXRpb24iLCJ1cGRhdGVCbG9ja2VyIiwiZGVsZXRlQmxvY2tlciIsInVwZGF0ZVN0YXRlIiwic3RhcnROYXZpZ2F0aW9uIiwiZGlzcG9zZSIsImNsZWFyIiwiZGVsZXRlRmV0Y2hlciIsIm5ld1N0YXRlIiwiY29tcGxldGVOYXZpZ2F0aW9uIiwiX2xvY2F0aW9uJHN0YXRlIiwiX2xvY2F0aW9uJHN0YXRlMiIsImlzQWN0aW9uUmVsb2FkIiwiaXNNdXRhdGlvbk1ldGhvZCIsIl9pc1JlZGlyZWN0Iiwia2V5cyIsIm1lcmdlTG9hZGVyRGF0YSIsImdldFNhdmVkU2Nyb2xsUG9zaXRpb24iLCJuYXZpZ2F0ZSIsIm9wdHMiLCJzdWJtaXNzaW9uIiwibm9ybWFsaXplTmF2aWdhdGVPcHRpb25zIiwidXNlclJlcGxhY2UiLCJwZW5kaW5nRXJyb3IiLCJyZXZhbGlkYXRlIiwiaW50ZXJydXB0QWN0aXZlTG9hZHMiLCJzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24iLCJvdmVycmlkZU5hdmlnYXRpb24iLCJzYXZlU2Nyb2xsUG9zaXRpb24iLCJsb2FkaW5nTmF2aWdhdGlvbiIsIm5vdEZvdW5kTWF0Y2hlcyIsImNhbmNlbEFjdGl2ZURlZmVycmVkcyIsImlzSGFzaENoYW5nZU9ubHkiLCJyZXF1ZXN0IiwiY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QiLCJwZW5kaW5nQWN0aW9uRGF0YSIsImZpbmROZWFyZXN0Qm91bmRhcnkiLCJhY3Rpb25PdXRwdXQiLCJoYW5kbGVBY3Rpb24iLCJzaG9ydENpcmN1aXRlZCIsInBlbmRpbmdBY3Rpb25FcnJvciIsIlJlcXVlc3QiLCJoYW5kbGVMb2FkZXJzIiwiYWN0aW9uTWF0Y2giLCJnZXRUYXJnZXRNYXRjaCIsInR5cGUiLCJtZXRob2QiLCJyb3V0ZUlkIiwiY2FsbExvYWRlck9yQWN0aW9uIiwiaXNSZWRpcmVjdFJlc3VsdCIsInN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uIiwiaXNFcnJvclJlc3VsdCIsImJvdW5kYXJ5TWF0Y2giLCJpc0RlZmVycmVkUmVzdWx0IiwiYWN0aXZlU3VibWlzc2lvbiIsIm1hdGNoZXNUb0xvYWQiLCJyZXZhbGlkYXRpbmdGZXRjaGVycyIsImdldE1hdGNoZXNUb0xvYWQiLCJyZiIsImZldGNoZXIiLCJyZXZhbGlkYXRpbmdGZXRjaGVyIiwicmVzdWx0cyIsImxvYWRlclJlc3VsdHMiLCJmZXRjaGVyUmVzdWx0cyIsImNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YSIsImZpbmRSZWRpcmVjdCIsInByb2Nlc3NMb2FkZXJEYXRhIiwiZGVmZXJyZWREYXRhIiwibWFya0ZldGNoUmVkaXJlY3RzRG9uZSIsImRpZEFib3J0RmV0Y2hMb2FkcyIsImFib3J0U3RhbGVGZXRjaExvYWRzIiwiZ2V0RmV0Y2hlciIsImZldGNoIiwiYWJvcnRGZXRjaGVyIiwic2V0RmV0Y2hlckVycm9yIiwiaGFuZGxlRmV0Y2hlckFjdGlvbiIsImhhbmRsZUZldGNoZXJMb2FkZXIiLCJyZXF1ZXN0TWF0Y2hlcyIsImV4aXN0aW5nRmV0Y2hlciIsImFib3J0Q29udHJvbGxlciIsImZldGNoUmVxdWVzdCIsImFjdGlvblJlc3VsdCIsImxvYWRpbmdGZXRjaGVyIiwiaXNGZXRjaEFjdGlvblJlZGlyZWN0IiwicmV2YWxpZGF0aW9uUmVxdWVzdCIsImxvYWRJZCIsImxvYWRGZXRjaGVyIiwic3RhbGVLZXkiLCJkb25lRmV0Y2hlciIsInJlc29sdmVEZWZlcnJlZERhdGEiLCJfdGVtcCIsIl93aW5kb3ciLCJyZWRpcmVjdExvY2F0aW9uIiwiX2lzRmV0Y2hBY3Rpb25SZWRpcmVjdCIsIm5ld09yaWdpbiIsInJlZGlyZWN0SGlzdG9yeUFjdGlvbiIsImN1cnJlbnRNYXRjaGVzIiwiZmV0Y2hlcnNUb0xvYWQiLCJhbGwiLCJmIiwicmVzb2x2ZURlZmVycmVkUmVzdWx0cyIsIm1hcmtGZXRjaGVyc0RvbmUiLCJkb25lS2V5cyIsImxhbmRlZElkIiwieWVldGVkS2V5cyIsImdldEJsb2NrZXIiLCJibG9ja2VyIiwibmV3QmxvY2tlciIsImJsb2NrZXJGdW5jdGlvbiIsInByZWRpY2F0ZSIsImNhbmNlbGxlZFJvdXRlSWRzIiwiZGZkIiwiZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24iLCJwb3NpdGlvbnMiLCJnZXRQb3NpdGlvbiIsImdldEtleSIsInkiLCJ1c2VyTWF0Y2hlcyIsImNyZWF0ZVVzZU1hdGNoZXNNYXRjaCIsIl9pbnRlcm5hbEZldGNoQ29udHJvbGxlcnMiLCJfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHMiLCJVTlNBRkVfREVGRVJSRURfU1lNQk9MIiwiU3ltYm9sIiwiY3JlYXRlU3RhdGljSGFuZGxlciIsInF1ZXJ5IiwiX3RlbXAyIiwicmVxdWVzdENvbnRleHQiLCJpc1ZhbGlkTWV0aG9kIiwibWV0aG9kTm90QWxsb3dlZE1hdGNoZXMiLCJzdGF0dXNDb2RlIiwibG9hZGVySGVhZGVycyIsImFjdGlvbkhlYWRlcnMiLCJxdWVyeUltcGwiLCJpc1Jlc3BvbnNlIiwicXVlcnlSb3V0ZSIsIl90ZW1wMyIsImZpbmQiLCJ2YWx1ZXMiLCJfcmVzdWx0JGFjdGl2ZURlZmVycmUiLCJyb3V0ZU1hdGNoIiwic3VibWl0IiwibG9hZFJvdXRlRGF0YSIsImlzUXVlcnlSb3V0ZVJlc3BvbnNlIiwiaXNSZWRpcmVjdFJlc3BvbnNlIiwicmVzcG9uc2UiLCJpc1JvdXRlUmVxdWVzdCIsIkxvY2F0aW9uIiwiY29udGV4dCIsImxvYWRlclJlcXVlc3QiLCJnZXRMb2FkZXJNYXRjaGVzVW50aWxCb3VuZGFyeSIsInByb2Nlc3NSb3V0ZUxvYWRlckRhdGEiLCJleGVjdXRlZExvYWRlcnMiLCJmcm9tRW50cmllcyIsImdldFN0YXRpY0NvbnRleHRGcm9tRXJyb3IiLCJuZXdDb250ZXh0IiwiX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQiLCJpc1N1Ym1pc3Npb25OYXZpZ2F0aW9uIiwiaXNGZXRjaGVyIiwic3RyaXBIYXNoRnJvbVBhdGgiLCJzZWFyY2hQYXJhbXMiLCJjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyIsImhhc05ha2VkSW5kZXhRdWVyeSIsImFwcGVuZCIsImJvdW5kYXJ5SWQiLCJib3VuZGFyeU1hdGNoZXMiLCJmaW5kSW5kZXgiLCJjdXJyZW50VXJsIiwibmV4dFVybCIsImRlZmF1bHRTaG91bGRSZXZhbGlkYXRlIiwibmF2aWdhdGlvbk1hdGNoZXMiLCJpc05ld0xvYWRlciIsImN1cnJlbnRSb3V0ZU1hdGNoIiwibmV4dFJvdXRlTWF0Y2giLCJzaG91bGRSZXZhbGlkYXRlTG9hZGVyIiwiY3VycmVudFBhcmFtcyIsIm5leHRQYXJhbXMiLCJpc05ld1JvdXRlSW5zdGFuY2UiLCJzaG91bGRSZXZhbGlkYXRlIiwiY3VycmVudExvYWRlckRhdGEiLCJjdXJyZW50TWF0Y2giLCJpc05ldyIsImlzTWlzc2luZ0RhdGEiLCJjdXJyZW50UGF0aCIsImxvYWRlck1hdGNoIiwiYXJnIiwicm91dGVDaG9pY2UiLCJpc1N0YXRpY1JlcXVlc3QiLCJyZXN1bHRUeXBlIiwib25SZWplY3QiLCJoYW5kbGVyIiwiYWN0aXZlTWF0Y2hlcyIsInJlc29sdmVkTG9jYXRpb24iLCJwcm90b2NvbCIsImNvbnRlbnRUeXBlIiwidGV4dCIsImRlZmVycmVkIiwidG9VcHBlckNhc2UiLCJib2R5IiwiVVJMU2VhcmNoUGFyYW1zIiwiRmlsZSIsIm5hbWUiLCJmb3VuZEVycm9yIiwibmV3TG9hZGVyRGF0YSIsIm1lcmdlZExvYWRlckRhdGEiLCJoYXNPd25Qcm9wZXJ0eSIsImVsaWdpYmxlTWF0Y2hlcyIsInJldmVyc2UiLCJoYXNFcnJvckJvdW5kYXJ5IiwiX3RlbXA0IiwiZXJyb3JNZXNzYWdlIiwib2JqIiwiaXNSZXZhbGlkYXRpbmdMb2FkZXIiLCJ1bndyYXAiLCJnZXRBbGwiLCJoYW5kbGUiLCJwYXRoTWF0Y2hlcyIsImRlZmF1bHRNZXRob2QiLCJkZWZhdWx0RW5jVHlwZSIsImlzSHRtbEVsZW1lbnQiLCJvYmplY3QiLCJ0YWdOYW1lIiwiaXNCdXR0b25FbGVtZW50IiwiaXNGb3JtRWxlbWVudCIsImlzSW5wdXRFbGVtZW50IiwiaXNNb2RpZmllZEV2ZW50IiwiZXZlbnQiLCJtZXRhS2V5IiwiYWx0S2V5IiwiY3RybEtleSIsInNoaWZ0S2V5Iiwic2hvdWxkUHJvY2Vzc0xpbmtDbGljayIsInRhcmdldCIsImJ1dHRvbiIsImNyZWF0ZVNlYXJjaFBhcmFtcyIsImdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uIiwibG9jYXRpb25TZWFyY2giLCJkZWZhdWx0U2VhcmNoUGFyYW1zIiwiZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvIiwiZGVmYXVsdEFjdGlvbiIsImVuY1R5cGUiLCJzdWJtaXNzaW9uVHJpZ2dlciIsIkZvcm1EYXRhIiwiZm9ybSIsImhvc3QiLCJjcmVhdGVCcm93c2VyUm91dGVyIiwicGFyc2VIeWRyYXRpb25EYXRhIiwiVU5TQUZFX2VuaGFuY2VNYW51YWxSb3V0ZU9iamVjdHMiLCJjcmVhdGVIYXNoUm91dGVyIiwiX19zdGF0aWNSb3V0ZXJIeWRyYXRpb25EYXRhIiwiZGVzZXJpYWxpemVFcnJvcnMiLCJzZXJpYWxpemVkIiwidmFsIiwiX190eXBlIiwic3RhY2siLCJCcm93c2VyUm91dGVyIiwiaGlzdG9yeVJlZiIsIlJlYWN0IiwidXNlUmVmIiwic2V0U3RhdGUiLCJ1c2VTdGF0ZSIsInVzZUxheW91dEVmZmVjdCIsIlJvdXRlciIsIm5hdmlnYXRpb25UeXBlIiwibmF2aWdhdG9yIiwiSGFzaFJvdXRlciIsIkhpc3RvcnlSb3V0ZXIiLCJfcmVmMyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRpc3BsYXlOYW1lIiwiTGluayIsImZvcndhcmRSZWYiLCJMaW5rV2l0aFJlZiIsIl9yZWY0IiwicmVmIiwib25DbGljayIsInJlbGF0aXZlIiwicmVsb2FkRG9jdW1lbnQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsIl9leGNsdWRlZCIsImFic29sdXRlSHJlZiIsImlzRXh0ZXJuYWwiLCJ0YXJnZXRVcmwiLCJ1c2VIcmVmIiwiaW50ZXJuYWxPbkNsaWNrIiwidXNlTGlua0NsaWNrSGFuZGxlciIsImhhbmRsZUNsaWNrIiwiZGVmYXVsdFByZXZlbnRlZCIsIk5hdkxpbmsiLCJOYXZMaW5rV2l0aFJlZiIsIl9yZWY1IiwiYXJpYUN1cnJlbnRQcm9wIiwiY2xhc3NOYW1lIiwiY2xhc3NOYW1lUHJvcCIsInN0eWxlIiwic3R5bGVQcm9wIiwiX2V4Y2x1ZGVkMiIsInVzZVJlc29sdmVkUGF0aCIsInVzZUxvY2F0aW9uIiwicm91dGVyU3RhdGUiLCJ1c2VDb250ZXh0IiwiVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQiLCJVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQiLCJuZXh0TG9jYXRpb25QYXRobmFtZSIsImlzQWN0aXZlIiwiaXNQZW5kaW5nIiwiYXJpYUN1cnJlbnQiLCJCb29sZWFuIiwiRm9ybSIsInByb3BzIiwiRm9ybUltcGwiLCJfcmVmNiIsImZvcndhcmRlZFJlZiIsIm9uU3VibWl0IiwiZmV0Y2hlcktleSIsIl9leGNsdWRlZDMiLCJ1c2VTdWJtaXRJbXBsIiwidXNlRm9ybUFjdGlvbiIsInN1Ym1pdEhhbmRsZXIiLCJwcmV2ZW50RGVmYXVsdCIsInN1Ym1pdHRlciIsIm5hdGl2ZUV2ZW50Iiwic3VibWl0TWV0aG9kIiwiY3VycmVudFRhcmdldCIsIlNjcm9sbFJlc3RvcmF0aW9uIiwiX3JlZjciLCJzdG9yYWdlS2V5IiwidXNlU2Nyb2xsUmVzdG9yYXRpb24iLCJEYXRhUm91dGVySG9vayIsIkRhdGFSb3V0ZXJTdGF0ZUhvb2siLCJnZXREYXRhUm91dGVyQ29uc29sZUVycm9yIiwiaG9va05hbWUiLCJ1c2VEYXRhUm91dGVyQ29udGV4dCIsImN0eCIsIlVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCIsInVzZURhdGFSb3V0ZXJTdGF0ZSIsInJlcGxhY2VQcm9wIiwidXNlTmF2aWdhdGUiLCJ1c2VDYWxsYmFjayIsInVzZVNlYXJjaFBhcmFtcyIsImRlZmF1bHRJbml0IiwiZGVmYXVsdFNlYXJjaFBhcmFtc1JlZiIsImhhc1NldFNlYXJjaFBhcmFtc1JlZiIsInVzZU1lbW8iLCJzZXRTZWFyY2hQYXJhbXMiLCJuZXh0SW5pdCIsIm5hdmlnYXRlT3B0aW9ucyIsIm5ld1NlYXJjaFBhcmFtcyIsInVzZVN1Ym1pdCIsIlVzZVN1Ym1pdEltcGwiLCJyb3V0ZUNvbnRleHQiLCJVTlNBRkVfUm91dGVDb250ZXh0IiwiY3JlYXRlRmV0Y2hlckZvcm0iLCJGZXRjaGVyRm9ybSIsImZldGNoZXJJZCIsInVzZUZldGNoZXIiLCJfcm91dGUkbWF0Y2hlcyIsIlVzZUZldGNoZXIiLCJTdHJpbmciLCJsb2FkIiwiZmV0Y2hlcldpdGhDb21wb25lbnRzIiwidXNlRWZmZWN0IiwidXNlRmV0Y2hlcnMiLCJVc2VGZXRjaGVycyIsIlNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSIsIlVzZVNjcm9sbFJlc3RvcmF0aW9uIiwidXNlTWF0Y2hlcyIsInVzZU5hdmlnYXRpb24iLCJzY3JvbGxSZXN0b3JhdGlvbiIsInVzZVBhZ2VIaWRlIiwic2Nyb2xsWSIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInNlc3Npb25Qb3NpdGlvbnMiLCJnZXRJdGVtIiwicGFyc2UiLCJkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24iLCJzY3JvbGxUbyIsImVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJzY3JvbGxJbnRvVmlldyIsInVzZUJlZm9yZVVubG9hZCIsImNhbGxiYWNrIiwiY2FwdHVyZSIsInVzZVByb21wdCIsIl9yZWY4Iiwid2hlbiIsInVuc3RhYmxlX3VzZUJsb2NrZXIiLCJjb25maXJtIiwic2V0VGltZW91dCIsImV4cG9ydHMiLCJyZXF1aXJlIiwicmVhY3RSb3V0ZXJEb20iLCJfaW50ZXJvcE5hbWVzcGFjZSIsIl9fZXNNb2R1bGUiLCJjcmVhdGUiLCJkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImZyZWV6ZSIsIlJlYWN0X19uYW1lc3BhY2UiLCJTdGF0aWNSb3V0ZXIiLCJsb2NhdGlvblByb3AiLCJzdGF0aWNOYXZpZ2F0b3IiLCJnZXRTdGF0ZWxlc3NOYXZpZ2F0b3IiLCJzdGF0aWMiLCJTdGF0aWNSb3V0ZXJQcm92aWRlciIsInJvdXRlciQxIiwiaHlkcmF0ZSIsIm5vbmNlIiwiZGF0YVJvdXRlckNvbnRleHQiLCJzdGF0aWNDb250ZXh0IiwiaHlkcmF0ZVNjcmlwdCIsInNlcmlhbGl6ZUVycm9ycyIsIkZyYWdtZW50IiwiUHJvdmlkZXIiLCJSb3V0ZXMiLCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmciLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsImJhY2siLCJmb3J3YXJkIiwiZ2VuZXJhdGVNYW5pZmVzdCIsIm1hbmlmZXN0IiwiYXJndW1lbnRzIiwiY3JlYXRlU3RhdGljUm91dGVyIiwiVU5TQUZFX2NvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMiLCJtc2ciLCJpc1BvbHlmaWxsIiwieCIsImlzIiwidXNlRGVidWdWYWx1ZSIsImRpZFdhcm5PbGQxOEFscGhhIiwiZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSQyIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJnZXRTbmFwc2hvdCIsImdldFNlcnZlclNuYXBzaG90IiwiY2FjaGVkVmFsdWUiLCJpbnN0IiwiZm9yY2VVcGRhdGUiLCJjaGVja0lmU25hcHNob3RDaGFuZ2VkIiwiaGFuZGxlU3RvcmVDaGFuZ2UiLCJsYXRlc3RHZXRTbmFwc2hvdCIsInByZXZWYWx1ZSIsIm5leHRWYWx1ZSIsInVzZVN5bmNFeHRlcm5hbFN0b3JlJDEiLCJjYW5Vc2VET00iLCJpc1NlcnZlckVudmlyb25tZW50Iiwic2hpbSIsIm1vZHVsZSIsIkRhdGFSb3V0ZXJDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsIkRhdGFSb3V0ZXJTdGF0ZUNvbnRleHQiLCJBd2FpdENvbnRleHQiLCJOYXZpZ2F0aW9uQ29udGV4dCIsIkxvY2F0aW9uQ29udGV4dCIsIlJvdXRlQ29udGV4dCIsIm91dGxldCIsIlJvdXRlRXJyb3JDb250ZXh0IiwidXNlSW5Sb3V0ZXJDb250ZXh0Iiwiam9pbmVkUGF0aG5hbWUiLCJ1c2VOYXZpZ2F0aW9uVHlwZSIsInVzZU1hdGNoIiwicm91dGVQYXRobmFtZXNKc29uIiwiVU5TQUZFX2dldFBhdGhDb250cmlidXRpbmdNYXRjaGVzIiwiYWN0aXZlUmVmIiwiT3V0bGV0Q29udGV4dCIsInVzZU91dGxldENvbnRleHQiLCJ1c2VPdXRsZXQiLCJ1c2VQYXJhbXMiLCJ1c2VSb3V0ZXMiLCJkYXRhUm91dGVyU3RhdGVDb250ZXh0IiwicGFyZW50TWF0Y2hlcyIsInBhcmVudFBhcmFtcyIsInBhcmVudFBhdGhuYW1lIiwicGFyZW50UGF0aG5hbWVCYXNlIiwicGFyZW50Um91dGUiLCJ3YXJuaW5nT25jZSIsImxvY2F0aW9uRnJvbUNvbnRleHQiLCJfcGFyc2VkTG9jYXRpb25BcmckcGEiLCJwYXJzZWRMb2NhdGlvbkFyZyIsImVsZW1lbnQiLCJyZW5kZXJlZE1hdGNoZXMiLCJfcmVuZGVyTWF0Y2hlcyIsIkRlZmF1bHRFcnJvckVsZW1lbnQiLCJ1c2VSb3V0ZUVycm9yIiwibGlnaHRncmV5IiwicHJlU3R5bGVzIiwicGFkZGluZyIsImJhY2tncm91bmRDb2xvciIsImNvZGVTdHlsZXMiLCJkZXZJbmZvIiwiZm9udFN0eWxlIiwiUmVuZGVyRXJyb3JCb3VuZGFyeSIsIkNvbXBvbmVudCIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImNvbXBvbmVudERpZENhdGNoIiwiZXJyb3JJbmZvIiwicmVuZGVyIiwiY29tcG9uZW50IiwiUmVuZGVyZWRSb3V0ZSIsImVycm9yRWxlbWVudCIsImRhdGFSb3V0ZXJTdGF0ZSIsImVycm9ySW5kZXgiLCJyZWR1Y2VSaWdodCIsImdldENoaWxkcmVuIiwidXNlUm91dGVDb250ZXh0IiwidXNlQ3VycmVudFJvdXRlSWQiLCJ0aGlzUm91dGUiLCJVc2VOYXZpZ2F0aW9uIiwidXNlUmV2YWxpZGF0b3IiLCJVc2VSZXZhbGlkYXRvciIsIlVzZU1hdGNoZXMiLCJ1c2VMb2FkZXJEYXRhIiwiVXNlTG9hZGVyRGF0YSIsInVzZVJvdXRlTG9hZGVyRGF0YSIsIlVzZVJvdXRlTG9hZGVyRGF0YSIsInVzZUFjdGlvbkRhdGEiLCJVc2VBY3Rpb25EYXRhIiwiX3N0YXRlJGVycm9ycyIsIlVzZVJvdXRlRXJyb3IiLCJ1c2VBc3luY1ZhbHVlIiwidXNlQXN5bmNFcnJvciIsImJsb2NrZXJJZCIsInVzZUJsb2NrZXIiLCJzaG91bGRCbG9jayIsIlVzZUJsb2NrZXIiLCJhcmdzIiwiYWxyZWFkeVdhcm5lZCIsIlJvdXRlclByb3ZpZGVyIiwiZmFsbGJhY2tFbGVtZW50IiwiTWVtb3J5Um91dGVyIiwiTmF2aWdhdGUiLCJPdXRsZXQiLCJSb3V0ZSIsIl9wcm9wcyIsImJhc2VuYW1lUHJvcCIsInN0YXRpY1Byb3AiLCJuYXZpZ2F0aW9uQ29udGV4dCIsInRyYWlsaW5nUGF0aG5hbWUiLCJjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4iLCJBd2FpdCIsIkF3YWl0RXJyb3JCb3VuZGFyeSIsIlJlc29sdmVBd2FpdCIsIkF3YWl0UmVuZGVyU3RhdHVzIiwibmV2ZXJTZXR0bGVkUHJvbWlzZSIsInBlbmRpbmciLCJzdWNjZXNzIiwicmVuZGVyRXJyb3IiLCJ0b1JlbmRlciIsIkNoaWxkcmVuIiwiaXNWYWxpZEVsZW1lbnQiLCJhcHBseSIsInJlbmRlck1hdGNoZXMiLCJlbmhhbmNlTWFudWFsUm91dGVPYmplY3RzIiwicm91dGVDbG9uZSIsImNyZWF0ZU1lbW9yeVJvdXRlciIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsImZvciIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiUmVhY3RTaGFyZWRJbnRlcm5hbHMiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsImZvcm1hdCIsIl9sZW4yIiwiX2tleTIiLCJwcmludFdhcm5pbmciLCJsZXZlbCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJnZXRTdGFja0FkZGVuZHVtIiwiYXJnc1dpdGhGb3JtYXQiLCJpdGVtIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiY2FsbCIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJmdW5jdGlvbk5hbWUiLCJnZXRDb250ZXh0TmFtZSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsInByb3ZpZGVyIiwiX2NvbnRleHQiLCJvdXRlck5hbWUiLCJsYXp5Q29tcG9uZW50IiwicGF5bG9hZCIsIl9wYXlsb2FkIiwiX2luaXQiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsImdyb3VwIiwiZ3JvdXBDb2xsYXBzZWQiLCJncm91cEVuZCIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJ0cmltIiwicmVlbnRyeSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJQb3NzaWJseVdlYWtNYXAiLCJXZWFrTWFwIiwiZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSIsImNvbnN0cnVjdCIsImZyYW1lIiwiY29udHJvbCIsInByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInByZXZpb3VzRGlzcGF0Y2hlciIsIkZha2UiLCJSZWZsZWN0Iiwic2FtcGxlIiwic2FtcGxlTGluZXMiLCJjb250cm9sTGluZXMiLCJjIiwiX2ZyYW1lIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJvd25lciIsIl9vd25lciIsIl9zb3VyY2UiLCJzZXRFeHRyYVN0YWNrRnJhbWUiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsImNvbXBvbmVudE5hbWUiLCJiaW5kIiwidHlwZVNwZWNOYW1lIiwiZXJyb3IkMSIsImVyciIsImV4IiwiaXNBcnJheUltcGwiLCJ0eXBlTmFtZSIsImhhc1RvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImNoZWNrS2V5U3RyaW5nQ29lcmNpb24iLCJSZWFjdEN1cnJlbnRPd25lciIsIlJFU0VSVkVEX1BST1BTIiwiX19zZWxmIiwiX19zb3VyY2UiLCJzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biIsInNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duIiwiZGlkV2FybkFib3V0U3RyaW5nUmVmcyIsImhhc1ZhbGlkUmVmIiwiY29uZmlnIiwiZ2V0dGVyIiwiaXNSZWFjdFdhcm5pbmciLCJoYXNWYWxpZEtleSIsIndhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZCIsInNlbGYiLCJzdGF0ZU5vZGUiLCJkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ0tleSIsImRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nUmVmIiwiUmVhY3RFbGVtZW50IiwiX3N0b3JlIiwianN4REVWIiwibWF5YmVLZXkiLCJwcm9wTmFtZSIsImRlZmF1bHRQcm9wcyIsIlJlYWN0Q3VycmVudE93bmVyJDEiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwicHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24iLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsImdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJwYXJlbnRUeXBlIiwicGFyZW50TmFtZSIsInZhbGlkYXRlRXhwbGljaXRLZXkiLCJ2YWxpZGF0ZWQiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY2hpbGRPd25lciIsInZhbGlkYXRlQ2hpbGRLZXlzIiwibm9kZSIsImNoaWxkIiwiaXRlcmF0b3JGbiIsInN0ZXAiLCJuZXh0IiwidmFsaWRhdGVQcm9wVHlwZXMiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJfbmFtZSIsImdldERlZmF1bHRQcm9wcyIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwidmFsaWRhdGVGcmFnbWVudFByb3BzIiwiZnJhZ21lbnQiLCJqc3hXaXRoVmFsaWRhdGlvbiIsImlzU3RhdGljQ2hpbGRyZW4iLCJ2YWxpZFR5cGUiLCJzb3VyY2VJbmZvIiwidHlwZVN0cmluZyIsImpzeFdpdGhWYWxpZGF0aW9uU3RhdGljIiwianN4V2l0aFZhbGlkYXRpb25EeW5hbWljIiwianN4IiwianN4cyJdLCJzb3VyY2VSb290IjoiIn0=